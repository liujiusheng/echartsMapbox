/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 126);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(279);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(27);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__constants__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer__ = __webpack_require__(43);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__composite_layer__ = __webpack_require__(187);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__composite_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__attribute_manager__ = __webpack_require__(75);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_4__attribute_manager__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layer_manager__ = __webpack_require__(190);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_5__layer_manager__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_get__ = __webpack_require__(44);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_6__utils_get__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Set up deck.gl global state




// Export core objects





// Ability to extract data from ES6 containers (Maps, Immutable.maps etc)

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvaW5kZXguanMiXSwibmFtZXMiOlsiQ09PUkRJTkFURV9TWVNURU0iLCJkZWZhdWx0IiwiTGF5ZXIiLCJDb21wb3NpdGVMYXllciIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJMYXllck1hbmFnZXIiLCJnZXQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxRQUFQOztBQUVBLFNBQVFBLGlCQUFSLFFBQWdDLGFBQWhDOztBQUVBO0FBQ0EsU0FBUUMsV0FBV0MsS0FBbkIsUUFBK0IsU0FBL0I7QUFDQSxTQUFRRCxXQUFXRSxjQUFuQixRQUF3QyxtQkFBeEM7QUFDQSxTQUFRRixXQUFXRyxnQkFBbkIsUUFBMEMscUJBQTFDO0FBQ0EsU0FBUUgsV0FBV0ksWUFBbkIsUUFBc0MsaUJBQXRDOztBQUVBO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixhQUFsQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBTZXQgdXAgZGVjay5nbCBnbG9iYWwgc3RhdGVcbmltcG9ydCAnLi9pbml0JztcblxuZXhwb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vLyBFeHBvcnQgY29yZSBvYmplY3RzXG5leHBvcnQge2RlZmF1bHQgYXMgTGF5ZXJ9IGZyb20gJy4vbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIENvbXBvc2l0ZUxheWVyfSBmcm9tICcuL2NvbXBvc2l0ZS1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgQXR0cmlidXRlTWFuYWdlcn0gZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgTGF5ZXJNYW5hZ2VyfSBmcm9tICcuL2xheWVyLW1hbmFnZXInO1xuXG4vLyBBYmlsaXR5IHRvIGV4dHJhY3QgZGF0YSBmcm9tIEVTNiBjb250YWluZXJzIChNYXBzLCBJbW11dGFibGUubWFwcyBldGMpXG5leHBvcnQge2dldH0gZnJvbSAnLi91dGlscy9nZXQnO1xuIl19

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isWebGLContext;
/* harmony export (immutable) */ __webpack_exports__["b"] = isWebGL2Context;
/* harmony export (immutable) */ __webpack_exports__["c"] = assertWebGLContext;
/* harmony export (immutable) */ __webpack_exports__["d"] = assertWebGL2Context;
/* harmony export (immutable) */ __webpack_exports__["e"] = setContextDefaults;
/* harmony export (immutable) */ __webpack_exports__["f"] = createGLContext;
/* harmony export (immutable) */ __webpack_exports__["g"] = glContextWithState;
/* harmony export (immutable) */ __webpack_exports__["h"] = getGLContextInfo;
/* harmony export (immutable) */ __webpack_exports__["i"] = pollContext;
/* harmony export (immutable) */ __webpack_exports__["j"] = withParameters;
/* harmony export (immutable) */ __webpack_exports__["k"] = glGetDebugInfo;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context_debug__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_query_manager__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__init__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_assert__);
// WebGLRenderingContext related methods

/* global document */









var GL_UNMASKED_VENDOR_WEBGL = 0x9245; // vendor string of the graphics driver.
var GL_UNMASKED_RENDERER_WEBGL = 0x9246; // renderer string of the graphics driver.

// Heuristic testing of contexts (to indentify debug wrappers around gl contexts)
var GL_ARRAY_BUFFER = 0x8892;
var GL_TEXTURE_BINDING_3D = 0x806A;

var ERR_CONTEXT = 'Invalid WebGLRenderingContext';

var ERR_WEBGL2 = 'Requires WebGL2';

var ERR_WEBGL_MISSING_BROWSER = 'WebGL API is missing. Check your if your browser supports WebGL or\ninstall a recent version of a major browser.';

var ERR_WEBGL_MISSING_NODE = 'WebGL API is missing. To run luma.gl under Node.js, please "npm install gl"\nand import \'luma.gl/headless\' before importing \'luma.gl\'.';

var ERR_HEADLESSGL_NOT_AVAILABLE = 'Cannot create headless WebGL context, headlessGL not available';

var ERR_HEADLESSGL_FAILED = 'headlessGL failed to create headless WebGL context';

function isWebGLContext(gl) {
  return gl && (gl instanceof __WEBPACK_IMPORTED_MODULE_0__api__["h" /* WebGLRenderingContext */] || gl.ARRAY_BUFFER === GL_ARRAY_BUFFER);
}

function isWebGL2Context(gl) {
  return gl && (gl instanceof __WEBPACK_IMPORTED_MODULE_0__api__["c" /* WebGL2RenderingContext */] || gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D);
}

function assertWebGLContext(gl) {
  // Need to handle debug context
  __WEBPACK_IMPORTED_MODULE_5_assert___default()(isWebGLContext(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  // Need to handle debug context
  __WEBPACK_IMPORTED_MODULE_5_assert___default()(isWebGL2Context(gl), ERR_WEBGL2);
}

var defaultWidth = null;
var defaultHeight = null;

function setContextDefaults(_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === undefined ? 1 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? 1 : _ref$height;

  defaultWidth = width;
  defaultHeight = height;
}

// Checks if WebGL is enabled and creates a context for using WebGL.
/* eslint-disable complexity, max-statements */
function createGLContext() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // BROWSER CONTEXT PARAMATERS: canvas is only used when in browser
  var canvas = opts.canvas;
  var _opts$width = opts.width,
      width = _opts$width === undefined ? defaultWidth || 800 : _opts$width,
      _opts$height = opts.height,
      height = _opts$height === undefined ? defaultHeight || 600 : _opts$height,
      _opts$webgl = opts.webgl2,
      webgl2 = _opts$webgl === undefined ? false : _opts$webgl,
      _opts$debug = opts.debug,
      debug = _opts$debug === undefined ? false : _opts$debug;


  var gl = void 0;

  if (!__WEBPACK_IMPORTED_MODULE_3__utils__["isBrowser"]) {
    gl = _createHeadlessContext(width, height, opts);
  } else {
    // Create browser gl context
    if (!__WEBPACK_IMPORTED_MODULE_0__api__["i" /* webGLTypesAvailable */]) {
      throw new Error(ERR_WEBGL_MISSING_BROWSER);
    }
    // Make sure we have a canvas
    canvas = canvas;
    if (typeof canvas === 'string') {
      if (!__WEBPACK_IMPORTED_MODULE_3__utils__["isPageLoaded"]) {
        throw new Error('createGLContext called on canvas \'' + canvas + '\' before page was loaded');
      }
      canvas = document.getElementById(canvas);
    }
    if (!canvas) {
      canvas = _createCanvas({ width: width, height: height });
    }

    canvas.addEventListener('webglcontextcreationerror', function (e) {
      __WEBPACK_IMPORTED_MODULE_3__utils__["log"].log(0, e.statusMessage || 'Unknown error');
    }, false);

    // Prefer webgl2 over webgl1, prefer conformant over experimental
    if (webgl2) {
      gl = gl || canvas.getContext('webgl2', opts);
      gl = gl || canvas.getContext('experimental-webgl2', opts);
    } else {
      gl = gl || canvas.getContext('webgl', opts);
      gl = gl || canvas.getContext('experimental-webgl', opts);
    }

    __WEBPACK_IMPORTED_MODULE_5_assert___default()(gl, 'Failed to create WebGLRenderingContext');
  }

  if (__WEBPACK_IMPORTED_MODULE_3__utils__["isBrowser"] && debug) {
    gl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context_debug__["a" /* makeDebugContext */])(gl);
    // Debug forces log level to at least 1
    __WEBPACK_IMPORTED_MODULE_3__utils__["log"].priority = Math.max(__WEBPACK_IMPORTED_MODULE_3__utils__["log"].priority, 1);
    // Log some debug info
    logInfo(gl);
  }

  return gl;
}

// Create a canvas set to 100%
// TODO - remove
function _createCanvas(_ref2) {
  var width = _ref2.width,
      height = _ref2.height;

  var canvas = document.createElement('canvas');
  canvas.id = 'lumagl-canvas';
  canvas.style.width = Number.isFinite(width) ? width + 'px' : '100%';
  canvas.style.height = Number.isFinite(height) ? height + 'px' : '100%';
  // adds the canvas to the body element
  __WEBPACK_IMPORTED_MODULE_3__utils__["pageLoadPromise"].then(function (document) {
    var body = document.body;
    body.insertBefore(canvas, body.firstChild);
  });
  return canvas;
}

function _createHeadlessContext(width, height, opts) {
  // Create headless gl context
  if (!__WEBPACK_IMPORTED_MODULE_0__api__["i" /* webGLTypesAvailable */]) {
    throw new Error(ERR_WEBGL_MISSING_NODE);
  }
  if (!__WEBPACK_IMPORTED_MODULE_4__init__["default"].globals.headlessGL) {
    throw new Error(ERR_HEADLESSGL_NOT_AVAILABLE);
  }
  var gl = __WEBPACK_IMPORTED_MODULE_4__init__["default"].globals.headlessGL(width, height, opts);
  if (!gl) {
    throw new Error(ERR_HEADLESSGL_FAILED);
  }
  return gl;
}

// VERY LIMITED / BASIC GL STATE MANAGEMENT

// Executes a function with gl states temporarily set, exception safe
// Currently support scissor test and framebuffer binding
function glContextWithState(gl, _ref3, func) {
  var scissorTest = _ref3.scissorTest,
      framebuffer = _ref3.framebuffer;

  // assertWebGLContext(gl);

  var scissorTestWasEnabled = void 0;
  if (scissorTest) {
    scissorTestWasEnabled = gl.isEnabled(gl.SCISSOR_TEST);
    var x = scissorTest.x,
        y = scissorTest.y,
        w = scissorTest.w,
        h = scissorTest.h;

    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, w, h);
  }

  if (framebuffer) {
    // TODO - was there any previously set frame buffer we need to remember?
    framebuffer.bind();
  }

  var value = void 0;
  try {
    value = func(gl);
  } finally {
    if (!scissorTestWasEnabled) {
      gl.disable(gl.SCISSOR_TEST);
    }
    if (framebuffer) {
      // TODO - was there any previously set frame buffer?
      // TODO - delegate "unbind" to Framebuffer object?
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
  }

  return value;
}

function getGLContextInfo(gl) {
  var vendorMasked = gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VENDOR);
  var rendererMasked = gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RENDERER);
  var info = gl.getExtension('WEBGL_debug_renderer_info');
  var vendorUnmasked = info && gl.getParameter(GL_UNMASKED_VENDOR_WEBGL);
  var rendererUnmasked = info && gl.getParameter(GL_UNMASKED_RENDERER_WEBGL);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked: vendorMasked,
    rendererMasked: rendererMasked,
    version: gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERSION),
    shadingLanguageVersion: gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SHADING_LANGUAGE_VERSION)
  };
}

// POLLING FOR PENDING QUERIES
// Calling this function checks all pending queries for completion
function pollContext(gl) {
  __WEBPACK_IMPORTED_MODULE_2__helpers_query_manager__["a" /* default */].poll(gl);
}

function withParameters() {
  return glContextWithState.apply(undefined, arguments);
}

// DEBUG INFO

/**
 * Provides strings identifying the GPU vendor and driver.
 * https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
 * @param {WebGLRenderingContext} gl - context
 * @return {Object} - 'vendor' and 'renderer' string fields.
 */
function glGetDebugInfo(gl) {
  return getGLContextInfo(gl);
  // const info = gl.getExtension('WEBGL_debug_renderer_info');
  // // We can't determine if 'WEBGL_debug_renderer_info' is supported by
  // // checking whether info is null here. Firefox doesn't follow the
  // // specs by returning null for unsupported extension. Instead,
  // // it returns an object without GL_UNMASKED_VENDOR_WEBGL and GL_UNMASKED_RENDERER_WEBGL.
  // return {
  //   vendor: (info && info.UNMASKED_VENDOR_WEBGL) ?
  //     gl.getParameter(info.UNMASKED_VENDOR_WEBGL) : 'unknown',
  //   renderer: (info && info.UNMASKED_RENDERER_WEBGL) ?
  //     gl.getParameter(info.UNMASKED_RENDERER_WEBGL) : 'unknown'
  // };
}

function logInfo(gl) {
  var webGL = isWebGL2Context(gl) ? 'WebGL2' : 'WebGL1';
  var info = glGetDebugInfo(gl);
  var driver = info ? '(' + info.vendor + ' ' + info.renderer + ')' : '';
  var debug = gl.debug ? 'debug' : '';
  __WEBPACK_IMPORTED_MODULE_3__utils__["log"].log(0, 'luma.gl: Created ' + webGL + ' ' + debug + ' context ' + driver, gl);

  // const extensions = gl.getSupportedExtensions();
  // log.log(0, `Supported extensions: [${extensions.join(', ')}]`);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9jb250ZXh0LmpzIl0sIm5hbWVzIjpbIkdMIiwiV2ViR0xSZW5kZXJpbmdDb250ZXh0IiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsIndlYkdMVHlwZXNBdmFpbGFibGUiLCJtYWtlRGVidWdDb250ZXh0IiwicXVlcnlNYW5hZ2VyIiwibG9nIiwiaXNCcm93c2VyIiwiaXNQYWdlTG9hZGVkIiwicGFnZUxvYWRQcm9taXNlIiwibHVtYSIsImFzc2VydCIsIkdMX1VOTUFTS0VEX1ZFTkRPUl9XRUJHTCIsIkdMX1VOTUFTS0VEX1JFTkRFUkVSX1dFQkdMIiwiR0xfQVJSQVlfQlVGRkVSIiwiR0xfVEVYVFVSRV9CSU5ESU5HXzNEIiwiRVJSX0NPTlRFWFQiLCJFUlJfV0VCR0wyIiwiRVJSX1dFQkdMX01JU1NJTkdfQlJPV1NFUiIsIkVSUl9XRUJHTF9NSVNTSU5HX05PREUiLCJFUlJfSEVBRExFU1NHTF9OT1RfQVZBSUxBQkxFIiwiRVJSX0hFQURMRVNTR0xfRkFJTEVEIiwiaXNXZWJHTENvbnRleHQiLCJnbCIsIkFSUkFZX0JVRkZFUiIsImlzV2ViR0wyQ29udGV4dCIsIlRFWFRVUkVfQklORElOR18zRCIsImFzc2VydFdlYkdMQ29udGV4dCIsImFzc2VydFdlYkdMMkNvbnRleHQiLCJkZWZhdWx0V2lkdGgiLCJkZWZhdWx0SGVpZ2h0Iiwic2V0Q29udGV4dERlZmF1bHRzIiwid2lkdGgiLCJoZWlnaHQiLCJjcmVhdGVHTENvbnRleHQiLCJvcHRzIiwiY2FudmFzIiwid2ViZ2wyIiwiZGVidWciLCJfY3JlYXRlSGVhZGxlc3NDb250ZXh0IiwiRXJyb3IiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiX2NyZWF0ZUNhbnZhcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwic3RhdHVzTWVzc2FnZSIsImdldENvbnRleHQiLCJwcmlvcml0eSIsIk1hdGgiLCJtYXgiLCJsb2dJbmZvIiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRoZW4iLCJib2R5IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsImdsb2JhbHMiLCJoZWFkbGVzc0dMIiwiZ2xDb250ZXh0V2l0aFN0YXRlIiwiZnVuYyIsInNjaXNzb3JUZXN0IiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdFdhc0VuYWJsZWQiLCJpc0VuYWJsZWQiLCJTQ0lTU09SX1RFU1QiLCJ4IiwieSIsInciLCJoIiwiZW5hYmxlIiwic2Npc3NvciIsImJpbmQiLCJ2YWx1ZSIsImRpc2FibGUiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImdldEdMQ29udGV4dEluZm8iLCJ2ZW5kb3JNYXNrZWQiLCJnZXRQYXJhbWV0ZXIiLCJWRU5ET1IiLCJyZW5kZXJlck1hc2tlZCIsIlJFTkRFUkVSIiwiaW5mbyIsImdldEV4dGVuc2lvbiIsInZlbmRvclVubWFza2VkIiwicmVuZGVyZXJVbm1hc2tlZCIsInZlbmRvciIsInJlbmRlcmVyIiwidmVyc2lvbiIsIlZFUlNJT04iLCJzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uIiwiU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OIiwicG9sbENvbnRleHQiLCJwb2xsIiwid2l0aFBhcmFtZXRlcnMiLCJnbEdldERlYnVnSW5mbyIsIndlYkdMIiwiZHJpdmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLE9BQU9BLEVBQVAsTUFBZSxPQUFmO0FBQ0EsU0FBUUMscUJBQVIsRUFBK0JDLHNCQUEvQixFQUF1REMsbUJBQXZELFFBQWlGLE9BQWpGO0FBQ0EsU0FBUUMsZ0JBQVIsUUFBK0IsaUJBQS9COztBQUVBLE9BQU9DLFlBQVAsTUFBeUIseUJBQXpCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxTQUFiLEVBQXdCQyxZQUF4QixFQUFzQ0MsZUFBdEMsUUFBNEQsVUFBNUQ7QUFDQSxPQUFPQyxJQUFQLE1BQWlCLFNBQWpCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQSxJQUFNQywyQkFB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LGFBQVN0RSxHQUFHNEQsWUFBSCxDQUFnQm5GLEdBQUc4RixPQUFuQixDQUxKO0FBTUxDLDRCQUF3QnhFLEdBQUc0RCxZQUFILENBQWdCbkYsR0FBR2dHLHdCQUFuQjtBQU5uQixHQUFQO0FBUUQ7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sU0FBU0MsV0FBVCxDQUFxQjFFLEVBQXJCLEVBQXlCO0FBQzlCbEIsZUFBYTZGLElBQWIsQ0FBa0IzRSxFQUFsQjtBQUNEOztBQUVELE9BQU8sU0FBUzRFLGNBQVQsR0FBaUM7QUFDdEMsU0FBT3BDLDhDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BLE9BQU8sU0FBU3FDLGNBQVQsQ0FBd0I3RSxFQUF4QixFQUE0QjtBQUNqQyxTQUFPMEQsaUJBQWlCMUQsRUFBakIsQ0FBUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxTQUFTNEIsT0FBVCxDQUFpQjVCLEVBQWpCLEVBQXFCO0FBQ25CLE1BQU04RSxRQUFRNUUsZ0JBQWdCRixFQUFoQixJQUFzQixRQUF0QixHQUFpQyxRQUEvQztBQUNBLE1BQU1nRSxPQUFPYSxlQUFlN0UsRUFBZixDQUFiO0FBQ0EsTUFBTStFLFNBQVNmLGFBQVdBLEtBQUtJLE1BQWhCLFNBQTBCSixLQUFLSyxRQUEvQixTQUE2QyxFQUE1RDtBQUNBLE1BQU10RCxRQUFRZixHQUFHZSxLQUFILEdBQVcsT0FBWCxHQUFxQixFQUFuQztBQUNBaEMsTUFBSUEsR0FBSixDQUFRLENBQVIsd0JBQStCK0YsS0FBL0IsU0FBd0MvRCxLQUF4QyxpQkFBeURnRSxNQUF6RCxFQUFtRS9FLEVBQW5FOztBQUVBO0FBQ0E7QUFDRCIsImZpbGUiOiJjb250ZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV2ViR0xSZW5kZXJpbmdDb250ZXh0IHJlbGF0ZWQgbWV0aG9kc1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmltcG9ydCBHTCBmcm9tICcuL2FwaSc7XG5pbXBvcnQge1dlYkdMUmVuZGVyaW5nQ29udGV4dCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgd2ViR0xUeXBlc0F2YWlsYWJsZX0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHttYWtlRGVidWdDb250ZXh0fSBmcm9tICcuL2NvbnRleHQtZGVidWcnO1xuXG5pbXBvcnQgcXVlcnlNYW5hZ2VyIGZyb20gJy4vaGVscGVycy9xdWVyeS1tYW5hZ2VyJztcbmltcG9ydCB7bG9nLCBpc0Jyb3dzZXIsIGlzUGFnZUxvYWRlZCwgcGFnZUxvYWRQcm9taXNlfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgbHVtYSBmcm9tICcuLi9pbml0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgR0xfVU5NQVNLRURfVkVORE9SX1dFQkdMID0gMHg5MjQ1OyAvLyB2ZW5kb3Igc3RyaW5nIG9mIHRoZSBncmFwaGljcyBkcml2ZXIuXG5jb25zdCBHTF9VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCA9IDB4OTI0NjsgLy8gcmVuZGVyZXIgc3RyaW5nIG9mIHRoZSBncmFwaGljcyBkcml2ZXIuXG5cbi8vIEhldXJpc3RpYyB0ZXN0aW5nIG9mIGNvbnRleHRzICh0byBpbmRlbnRpZnkgZGVidWcgd3JhcHBlcnMgYXJvdW5kIGdsIGNvbnRleHRzKVxuY29uc3QgR0xfQVJSQVlfQlVGRkVSID0gMHg4ODkyO1xuY29uc3QgR0xfVEVYVFVSRV9CSU5ESU5HXzNEID0gMHg4MDZBO1xuXG5jb25zdCBFUlJfQ09OVEVYVCA9ICdJbnZhbGlkIFdlYkdMUmVuZGVyaW5nQ29udGV4dCc7XG5cbmNvbnN0IEVSUl9XRUJHTDIgPSAnUmVxdWlyZXMgV2ViR0wyJztcblxuY29uc3QgRVJSX1dFQkdMX01JU1NJTkdfQlJPV1NFUiA9IGBcXFxuV2ViR0wgQVBJIGlzIG1pc3NpbmcuIENoZWNrIHlvdXIgaWYgeW91ciBicm93c2VyIHN1cHBvcnRzIFdlYkdMIG9yXG5pbnN0YWxsIGEgcmVjZW50IHZlcnNpb24gb2YgYSBtYWpvciBicm93c2VyLmA7XG5cbmNvbnN0IEVSUl9XRUJHTF9NSVNTSU5HX05PREUgPSBgXFxcbldlYkdMIEFQSSBpcyBtaXNzaW5nLiBUbyBydW4gbHVtYS5nbCB1bmRlciBOb2RlLmpzLCBwbGVhc2UgXCJucG0gaW5zdGFsbCBnbFwiXG5hbmQgaW1wb3J0ICdsdW1hLmdsL2hlYWRsZXNzJyBiZWZvcmUgaW1wb3J0aW5nICdsdW1hLmdsJy5gO1xuXG5jb25zdCBFUlJfSEVBRExFU1NHTF9OT1RfQVZBSUxBQkxFID1cbidDYW5ub3QgY3JlYXRlIGhlYWRsZXNzIFdlYkdMIGNvbnRleHQsIGhlYWRsZXNzR0wgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IEVSUl9IRUFETEVTU0dMX0ZBSUxFRCA9ICdoZWFkbGVzc0dMIGZhaWxlZCB0byBjcmVhdGUgaGVhZGxlc3MgV2ViR0wgY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdMQ29udGV4dChnbCkge1xuICByZXR1cm4gZ2wgJiYgKGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHx8XG4gICAgZ2wuQVJSQVlfQlVGRkVSID09PSBHTF9BUlJBWV9CVUZGRVIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJHTDJDb250ZXh0KGdsKSB7XG4gIHJldHVybiBnbCAmJiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHx8XG4gICAgZ2wuVEVYVFVSRV9CSU5ESU5HXzNEID09PSBHTF9URVhUVVJFX0JJTkRJTkdfM0QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0V2ViR0xDb250ZXh0KGdsKSB7XG4gIC8vIE5lZWQgdG8gaGFuZGxlIGRlYnVnIGNvbnRleHRcbiAgYXNzZXJ0KGlzV2ViR0xDb250ZXh0KGdsKSwgRVJSX0NPTlRFWFQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0V2ViR0wyQ29udGV4dChnbCkge1xuICAvLyBOZWVkIHRvIGhhbmRsZSBkZWJ1ZyBjb250ZXh0XG4gIGFzc2VydChpc1dlYkdMMkNvbnRleHQoZ2wpLCBFUlJfV0VCR0wyKTtcbn1cblxubGV0IGRlZmF1bHRXaWR0aCA9IG51bGw7XG5sZXQgZGVmYXVsdEhlaWdodCA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0RGVmYXVsdHMoe3dpZHRoID0gMSwgaGVpZ2h0ID0gMX0pIHtcbiAgZGVmYXVsdFdpZHRoID0gd2lkdGg7XG4gIGRlZmF1bHRIZWlnaHQgPSBoZWlnaHQ7XG59XG5cbi8vIENoZWNrcyBpZiBXZWJHTCBpcyBlbmFibGVkIGFuZCBjcmVhdGVzIGEgY29udGV4dCBmb3IgdXNpbmcgV2ViR0wuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdMQ29udGV4dChvcHRzID0ge30pIHtcbiAgLy8gQlJPV1NFUiBDT05URVhUIFBBUkFNQVRFUlM6IGNhbnZhcyBpcyBvbmx5IHVzZWQgd2hlbiBpbiBicm93c2VyXG4gIGxldCB7Y2FudmFzfSA9IG9wdHM7XG5cbiAgY29uc3Qge1xuICAgIC8vIEhFQURMRVNTIENPTlRFWFQgUEFSQU1FVEVSUzogd2lkdGggYXJlIGhlaWdodCBhcmUgb25seSB1c2VkIGJ5IGhlYWRsZXNzIGdsXG4gICAgd2lkdGggPSBkZWZhdWx0V2lkdGggfHwgODAwLFxuICAgIGhlaWdodCA9IGRlZmF1bHRIZWlnaHQgfHwgNjAwLFxuICAgIC8vIENPTU1PTiBDT05URVhUIFBBUkFNRVRFUlNcbiAgICAvLyBBdHRlbXB0IHRvIGFsbG9jYXRlIFdlYkdMMiBjb250ZXh0XG4gICAgd2ViZ2wyID0gZmFsc2UsXG4gICAgLy8gSW5zdHJ1bWVudCBjb250ZXh0IChhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZSlcbiAgICAvLyBOb3RlOiBjdXJyZW50bHkgZGVmYXVsdHMgdG8gdHJ1ZSBhbmQgbmVlZHMgdG8gYmUgZXhwbGljaXRseSB0dXJuZWQgb2ZmXG4gICAgZGVidWcgPSBmYWxzZVxuICAgIC8vIE90aGVyIG9wdGlvbnMgYXJlIHBhc3NlZCB0aHJvdWdoIHRvIGNvbnRleHQgY3JlYXRvclxuICB9ID0gb3B0cztcblxuICBsZXQgZ2w7XG5cbiAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICBnbCA9IF9jcmVhdGVIZWFkbGVzc0NvbnRleHQod2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRlIGJyb3dzZXIgZ2wgY29udGV4dFxuICAgIGlmICghd2ViR0xUeXBlc0F2YWlsYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9XRUJHTF9NSVNTSU5HX0JST1dTRVIpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNhbnZhc1xuICAgIGNhbnZhcyA9IGNhbnZhcztcbiAgICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghaXNQYWdlTG9hZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgY3JlYXRlR0xDb250ZXh0IGNhbGxlZCBvbiBjYW52YXMgJyR7Y2FudmFzfScgYmVmb3JlIHBhZ2Ugd2FzIGxvYWRlZGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjYW52YXMgPSBfY3JlYXRlQ2FudmFzKHt3aWR0aCwgaGVpZ2h0fSk7XG4gICAgfVxuXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGNyZWF0aW9uZXJyb3InLCBlID0+IHtcbiAgICAgIGxvZy5sb2coMCwgZS5zdGF0dXNNZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gUHJlZmVyIHdlYmdsMiBvdmVyIHdlYmdsMSwgcHJlZmVyIGNvbmZvcm1hbnQgb3ZlciBleHBlcmltZW50YWxcbiAgICBpZiAod2ViZ2wyKSB7XG4gICAgICBnbCA9IGdsIHx8IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBvcHRzKTtcbiAgICAgIGdsID0gZ2wgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbDInLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wgPSBnbCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRzKTtcbiAgICAgIGdsID0gZ2wgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdHMpO1xuICAgIH1cblxuICAgIGFzc2VydChnbCwgJ0ZhaWxlZCB0byBjcmVhdGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0Jyk7XG4gIH1cblxuICBpZiAoaXNCcm93c2VyICYmIGRlYnVnKSB7XG4gICAgZ2wgPSBtYWtlRGVidWdDb250ZXh0KGdsKTtcbiAgICAvLyBEZWJ1ZyBmb3JjZXMgbG9nIGxldmVsIHRvIGF0IGxlYXN0IDFcbiAgICBsb2cucHJpb3JpdHkgPSBNYXRoLm1heChsb2cucHJpb3JpdHksIDEpO1xuICAgIC8vIExvZyBzb21lIGRlYnVnIGluZm9cbiAgICBsb2dJbmZvKGdsKTtcbiAgfVxuXG4gIHJldHVybiBnbDtcbn1cblxuLy8gQ3JlYXRlIGEgY2FudmFzIHNldCB0byAxMDAlXG4vLyBUT0RPIC0gcmVtb3ZlXG5mdW5jdGlvbiBfY3JlYXRlQ2FudmFzKHt3aWR0aCwgaGVpZ2h0fSkge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLmlkID0gJ2x1bWFnbC1jYW52YXMnO1xuICBjYW52YXMuc3R5bGUud2lkdGggPSBOdW1iZXIuaXNGaW5pdGUod2lkdGgpID8gYCR7d2lkdGh9cHhgIDogJzEwMCUnO1xuICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKGhlaWdodCkgPyBgJHtoZWlnaHR9cHhgIDogJzEwMCUnO1xuICAvLyBhZGRzIHRoZSBjYW52YXMgdG8gdGhlIGJvZHkgZWxlbWVudFxuICBwYWdlTG9hZFByb21pc2UudGhlbihkb2N1bWVudCA9PiB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgYm9keS5pbnNlcnRCZWZvcmUoY2FudmFzLCBib2R5LmZpcnN0Q2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUhlYWRsZXNzQ29udGV4dCh3aWR0aCwgaGVpZ2h0LCBvcHRzKSB7XG4gIC8vIENyZWF0ZSBoZWFkbGVzcyBnbCBjb250ZXh0XG4gIGlmICghd2ViR0xUeXBlc0F2YWlsYWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfV0VCR0xfTUlTU0lOR19OT0RFKTtcbiAgfVxuICBpZiAoIWx1bWEuZ2xvYmFscy5oZWFkbGVzc0dMKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9IRUFETEVTU0dMX05PVF9BVkFJTEFCTEUpO1xuICB9XG4gIGNvbnN0IGdsID0gbHVtYS5nbG9iYWxzLmhlYWRsZXNzR0wod2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gIGlmICghZ2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0hFQURMRVNTR0xfRkFJTEVEKTtcbiAgfVxuICByZXR1cm4gZ2w7XG59XG5cbi8vIFZFUlkgTElNSVRFRCAvIEJBU0lDIEdMIFNUQVRFIE1BTkFHRU1FTlRcblxuLy8gRXhlY3V0ZXMgYSBmdW5jdGlvbiB3aXRoIGdsIHN0YXRlcyB0ZW1wb3JhcmlseSBzZXQsIGV4Y2VwdGlvbiBzYWZlXG4vLyBDdXJyZW50bHkgc3VwcG9ydCBzY2lzc29yIHRlc3QgYW5kIGZyYW1lYnVmZmVyIGJpbmRpbmdcbmV4cG9ydCBmdW5jdGlvbiBnbENvbnRleHRXaXRoU3RhdGUoZ2wsIHtzY2lzc29yVGVzdCwgZnJhbWVidWZmZXJ9LCBmdW5jKSB7XG4gIC8vIGFzc2VydFdlYkdMQ29udGV4dChnbCk7XG5cbiAgbGV0IHNjaXNzb3JUZXN0V2FzRW5hYmxlZDtcbiAgaWYgKHNjaXNzb3JUZXN0KSB7XG4gICAgc2Npc3NvclRlc3RXYXNFbmFibGVkID0gZ2wuaXNFbmFibGVkKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgY29uc3Qge3gsIHksIHcsIGh9ID0gc2Npc3NvclRlc3Q7XG4gICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgZ2wuc2Npc3Nvcih4LCB5LCB3LCBoKTtcbiAgfVxuXG4gIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgIC8vIFRPRE8gLSB3YXMgdGhlcmUgYW55IHByZXZpb3VzbHkgc2V0IGZyYW1lIGJ1ZmZlciB3ZSBuZWVkIHRvIHJlbWVtYmVyP1xuICAgIGZyYW1lYnVmZmVyLmJpbmQoKTtcbiAgfVxuXG4gIGxldCB2YWx1ZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IGZ1bmMoZ2wpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICghc2Npc3NvclRlc3RXYXNFbmFibGVkKSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgLy8gVE9ETyAtIHdhcyB0aGVyZSBhbnkgcHJldmlvdXNseSBzZXQgZnJhbWUgYnVmZmVyP1xuICAgICAgLy8gVE9ETyAtIGRlbGVnYXRlIFwidW5iaW5kXCIgdG8gRnJhbWVidWZmZXIgb2JqZWN0P1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHTENvbnRleHRJbmZvKGdsKSB7XG4gIGNvbnN0IHZlbmRvck1hc2tlZCA9IGdsLmdldFBhcmFtZXRlcihHTC5WRU5ET1IpO1xuICBjb25zdCByZW5kZXJlck1hc2tlZCA9IGdsLmdldFBhcmFtZXRlcihHTC5SRU5ERVJFUik7XG4gIGNvbnN0IGluZm8gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nKTtcbiAgY29uc3QgdmVuZG9yVW5tYXNrZWQgPSBpbmZvICYmIGdsLmdldFBhcmFtZXRlcihHTF9VTk1BU0tFRF9WRU5ET1JfV0VCR0wpO1xuICBjb25zdCByZW5kZXJlclVubWFza2VkID0gaW5mbyAmJiBnbC5nZXRQYXJhbWV0ZXIoR0xfVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpO1xuICByZXR1cm4ge1xuICAgIHZlbmRvcjogdmVuZG9yVW5tYXNrZWQgfHwgdmVuZG9yTWFza2VkLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlclVubWFza2VkIHx8IHJlbmRlcmVyTWFza2VkLFxuICAgIHZlbmRvck1hc2tlZCxcbiAgICByZW5kZXJlck1hc2tlZCxcbiAgICB2ZXJzaW9uOiBnbC5nZXRQYXJhbWV0ZXIoR0wuVkVSU0lPTiksXG4gICAgc2hhZGluZ0xhbmd1YWdlVmVyc2lvbjogZ2wuZ2V0UGFyYW1ldGVyKEdMLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTilcbiAgfTtcbn1cblxuLy8gUE9MTElORyBGT1IgUEVORElORyBRVUVSSUVTXG4vLyBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGFsbCBwZW5kaW5nIHF1ZXJpZXMgZm9yIGNvbXBsZXRpb25cbmV4cG9ydCBmdW5jdGlvbiBwb2xsQ29udGV4dChnbCkge1xuICBxdWVyeU1hbmFnZXIucG9sbChnbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUGFyYW1ldGVycyguLi5hcmdzKSB7XG4gIHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUoLi4uYXJncyk7XG59XG5cbi8vIERFQlVHIElORk9cblxuLyoqXG4gKiBQcm92aWRlcyBzdHJpbmdzIGlkZW50aWZ5aW5nIHRoZSBHUFUgdmVuZG9yIGFuZCBkcml2ZXIuXG4gKiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8vXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBjb250ZXh0XG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gJ3ZlbmRvcicgYW5kICdyZW5kZXJlcicgc3RyaW5nIGZpZWxkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsR2V0RGVidWdJbmZvKGdsKSB7XG4gIHJldHVybiBnZXRHTENvbnRleHRJbmZvKGdsKTtcbiAgLy8gY29uc3QgaW5mbyA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbycpO1xuICAvLyAvLyBXZSBjYW4ndCBkZXRlcm1pbmUgaWYgJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nIGlzIHN1cHBvcnRlZCBieVxuICAvLyAvLyBjaGVja2luZyB3aGV0aGVyIGluZm8gaXMgbnVsbCBoZXJlLiBGaXJlZm94IGRvZXNuJ3QgZm9sbG93IHRoZVxuICAvLyAvLyBzcGVjcyBieSByZXR1cm5pbmcgbnVsbCBmb3IgdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uLiBJbnN0ZWFkLFxuICAvLyAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCB3aXRob3V0IEdMX1VOTUFTS0VEX1ZFTkRPUl9XRUJHTCBhbmQgR0xfVU5NQVNLRURfUkVOREVSRVJfV0VCR0wuXG4gIC8vIHJldHVybiB7XG4gIC8vICAgdmVuZG9yOiAoaW5mbyAmJiBpbmZvLlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCkgP1xuICAvLyAgICAgZ2wuZ2V0UGFyYW1ldGVyKGluZm8uVU5NQVNLRURfVkVORE9SX1dFQkdMKSA6ICd1bmtub3duJyxcbiAgLy8gICByZW5kZXJlcjogKGluZm8gJiYgaW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCkgP1xuICAvLyAgICAgZ2wuZ2V0UGFyYW1ldGVyKGluZm8uVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpIDogJ3Vua25vd24nXG4gIC8vIH07XG59XG5cbmZ1bmN0aW9uIGxvZ0luZm8oZ2wpIHtcbiAgY29uc3Qgd2ViR0wgPSBpc1dlYkdMMkNvbnRleHQoZ2wpID8gJ1dlYkdMMicgOiAnV2ViR0wxJztcbiAgY29uc3QgaW5mbyA9IGdsR2V0RGVidWdJbmZvKGdsKTtcbiAgY29uc3QgZHJpdmVyID0gaW5mbyA/IGAoJHtpbmZvLnZlbmRvcn0gJHtpbmZvLnJlbmRlcmVyfSlgIDogJyc7XG4gIGNvbnN0IGRlYnVnID0gZ2wuZGVidWcgPyAnZGVidWcnIDogJyc7XG4gIGxvZy5sb2coMCwgYGx1bWEuZ2w6IENyZWF0ZWQgJHt3ZWJHTH0gJHtkZWJ1Z30gY29udGV4dCAke2RyaXZlcn1gLCBnbCk7XG5cbiAgLy8gY29uc3QgZXh0ZW5zaW9ucyA9IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcbiAgLy8gbG9nLmxvZygwLCBgU3VwcG9ydGVkIGV4dGVuc2lvbnM6IFske2V4dGVuc2lvbnMuam9pbignLCAnKX1dYCk7XG59XG4iXX0=

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__is_browser__ = __webpack_require__(56);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "isNode", function() { return __WEBPACK_IMPORTED_MODULE_0__is_browser__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return __WEBPACK_IMPORTED_MODULE_0__is_browser__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__browser_utils__ = __webpack_require__(250);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "isPageLoaded", function() { return __WEBPACK_IMPORTED_MODULE_1__browser_utils__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pageLoadPromise", function() { return __WEBPACK_IMPORTED_MODULE_1__browser_utils__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__promise_utils__ = __webpack_require__(251);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "promisify", function() { return __WEBPACK_IMPORTED_MODULE_2__promise_utils__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(252);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "splat", function() { return __WEBPACK_IMPORTED_MODULE_3__utils__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return __WEBPACK_IMPORTED_MODULE_3__utils__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return __WEBPACK_IMPORTED_MODULE_3__utils__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return __WEBPACK_IMPORTED_MODULE_3__utils__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__log__ = __webpack_require__(57);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return __WEBPACK_IMPORTED_MODULE_4__log__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return __WEBPACK_IMPORTED_MODULE_4__log__["b"]; });






//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0IiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQSxjQUFjLGNBQWQ7QUFDQSxjQUFjLGlCQUFkO0FBQ0EsY0FBYyxpQkFBZDtBQUNBLGNBQWMsU0FBZDtBQUNBLGNBQWMsT0FBZDtBQUNBLFNBQVFBLFdBQVdDLEdBQW5CLFFBQTZCLE9BQTdCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9pcy1icm93c2VyJztcbmV4cG9ydCAqIGZyb20gJy4vYnJvd3Nlci11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL3Byb21pc2UtdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xvZyc7XG5leHBvcnQge2RlZmF1bHQgYXMgbG9nfSBmcm9tICcuL2xvZyc7XG4iXX0=

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return experimental; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webgl_gl_constants__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__webgl_gl_constants__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl_context__ = __webpack_require__(2);
/* unused harmony reexport isWebGLContext */
/* unused harmony reexport isWebGL2Context */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_1__webgl_context__["f"]; });
/* unused harmony reexport getGLExtension */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_1__webgl_context__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_1__webgl_context__["k"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_context_state__ = __webpack_require__(254);
/* unused harmony reexport getGLParameter */
/* unused harmony reexport setGLParameter */
/* unused harmony reexport withGLState */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__webgl_context_limits__ = __webpack_require__(109);
/* unused harmony reexport getGLContextInfo */
/* unused harmony reexport getContextLimits */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__webgl_context_debug__ = __webpack_require__(108);
/* unused harmony reexport makeDebugContext */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__webgl_debug_parameters__ = __webpack_require__(110);
/* unused harmony reexport installParameterDefinitions */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__webgl_buffer__ = __webpack_require__(28);
/* unused harmony reexport Buffer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__webgl_shader__ = __webpack_require__(60);
/* unused harmony reexport Shader */
/* unused harmony reexport VertexShader */
/* unused harmony reexport FragmentShader */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__webgl_program__ = __webpack_require__(59);
/* unused harmony reexport Program */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__webgl_framebuffer__ = __webpack_require__(35);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_9__webgl_framebuffer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__webgl_renderbuffer__ = __webpack_require__(36);
/* unused harmony reexport Renderbuffer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__webgl_texture_2d__ = __webpack_require__(61);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_11__webgl_texture_2d__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__webgl_texture_cube__ = __webpack_require__(115);
/* unused harmony reexport TextureCube */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__webgl_draw__ = __webpack_require__(111);
/* unused harmony reexport draw */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__webgl_functions__ = __webpack_require__(113);
/* unused harmony reexport clear */
/* unused harmony reexport readPixels */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__webgl_fence_sync__ = __webpack_require__(112);
/* unused harmony reexport FenceSync */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__webgl_query__ = __webpack_require__(255);
/* unused harmony reexport Query */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__webgl_sampler__ = __webpack_require__(114);
/* unused harmony reexport Sampler */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__webgl_texture_3d__ = __webpack_require__(257);
/* unused harmony reexport Texture3D */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__webgl_texture_2d_array__ = __webpack_require__(256);
/* unused harmony reexport Texture2DArray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__webgl_transform_feedback__ = __webpack_require__(258);
/* unused harmony reexport TransformFeedback */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__webgl_vertex_array_object__ = __webpack_require__(116);
/* unused harmony reexport VertexArrayObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__webgl_uniform_buffer_layout__ = __webpack_require__(259);
/* unused harmony reexport UniformBufferLayout */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__core_model__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_23__core_model__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__core_animation_loop__ = __webpack_require__(91);
/* unused harmony reexport AnimationLoop */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__packages_events__ = __webpack_require__(248);
/* unused harmony reexport addEvents */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__geometry_geometry__ = __webpack_require__(19);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_26__geometry_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__geometry_cone_geometry__ = __webpack_require__(97);
/* unused harmony reexport ConeGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__geometry_cube_geometry__ = __webpack_require__(98);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_28__geometry_cube_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__geometry_cylinder_geometry__ = __webpack_require__(99);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_29__geometry_cylinder_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__geometry_ico_sphere_geometry__ = __webpack_require__(100);
/* unused harmony reexport IcoSphereGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__geometry_plane_geometry__ = __webpack_require__(101);
/* unused harmony reexport PlaneGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__geometry_sphere_geometry__ = __webpack_require__(102);
/* unused harmony reexport SphereGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__geometry_truncated_cone_geometry__ = __webpack_require__(32);
/* unused harmony reexport TruncatedConeGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__models_cone__ = __webpack_require__(240);
/* unused harmony reexport Cone */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__models_cube__ = __webpack_require__(241);
/* unused harmony reexport Cube */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__models_cylinder__ = __webpack_require__(242);
/* unused harmony reexport Cylinder */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__models_ico_sphere__ = __webpack_require__(243);
/* unused harmony reexport IcoSphere */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__models_plane__ = __webpack_require__(244);
/* unused harmony reexport Plane */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__models_sphere__ = __webpack_require__(245);
/* unused harmony reexport Sphere */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__models_truncated_cone__ = __webpack_require__(246);
/* unused harmony reexport TruncatedCone */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__models_clip_space_quad__ = __webpack_require__(239);
/* unused harmony reexport ClipSpaceQuad */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__packages_math_src_common__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__packages_math_src_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_42__packages_math_src_common__);
/* unused harmony reexport radians */
/* unused harmony reexport degrees */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__packages_math_src_vector2__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__packages_math_src_vector2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_43__packages_math_src_vector2__);
/* unused harmony reexport Vector2 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__packages_math_src_vector3__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__packages_math_src_vector3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_44__packages_math_src_vector3__);
/* unused harmony reexport Vector3 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__packages_math_src_vector4__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__packages_math_src_vector4___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_45__packages_math_src_vector4__);
/* unused harmony reexport Vector4 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__packages_math_src_matrix4__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__packages_math_src_matrix4___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_46__packages_math_src_matrix4__);
/* unused harmony reexport Matrix4 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__packages_math_src_quaternion__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__packages_math_src_quaternion___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_47__packages_math_src_quaternion__);
/* unused harmony reexport Quaternion */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__packages_math_src_euler__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__packages_math_src_euler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_48__packages_math_src_euler__);
/* unused harmony reexport Euler */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__io__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__io___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_49__io__);
/* unused harmony reexport setPathPrefix */
/* unused harmony reexport loadFile */
/* unused harmony reexport loadImage */
/* unused harmony reexport loadFiles */
/* unused harmony reexport loadImages */
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_49__io__, "loadTextures")) __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_49__io__["loadTextures"]; });
/* unused harmony reexport loadProgram */
/* unused harmony reexport loadModel */
/* unused harmony reexport parseModel */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__experimental_shader_tools__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__experimental_shader_modules__ = __webpack_require__(227);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_9__webgl_framebuffer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__deprecated_scenegraph__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__deprecated_scenegraph___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_52__deprecated_scenegraph__);
/* unused harmony reexport Object3D */
/* unused harmony reexport Group */
/* unused harmony reexport Scene */
/* unused harmony reexport pickModels */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__deprecated_shaderlib__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__deprecated_shaderlib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_53__deprecated_shaderlib__);
/* unused harmony reexport Shaders */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__deprecated_fx__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__deprecated_fx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_54__deprecated_fx__);
/* unused harmony reexport Fx */
// Export core modules for luma.gl

// Initialize any global state
__webpack_require__(33);

// WebGL




















// WebGL2 & Extensions









// Core Classes



// Addons


// Geometry









// Models










// Math








// IO


// EXPERIMENTAL MODULES

// Shader Tools


// Register Shader Modules


var experimental = {
  registerShaderModules: __WEBPACK_IMPORTED_MODULE_50__experimental_shader_tools__["a" /* registerShaderModules */],
  assembleShaders: __WEBPACK_IMPORTED_MODULE_50__experimental_shader_tools__["b" /* assembleShaders */],
  ShaderCache: __WEBPACK_IMPORTED_MODULE_50__experimental_shader_tools__["c" /* ShaderCache */]
};

// Alias for FramebufferObject (deprecated in v3). Framebuffer API is fairly similar


// DEPRECATED IN V3.0



//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiZGVmYXVsdCIsIkdMIiwiaXNXZWJHTENvbnRleHQiLCJpc1dlYkdMMkNvbnRleHQiLCJjcmVhdGVHTENvbnRleHQiLCJnZXRHTEV4dGVuc2lvbiIsImdsQ29udGV4dFdpdGhTdGF0ZSIsImdsR2V0RGVidWdJbmZvIiwiZ2V0R0xQYXJhbWV0ZXIiLCJzZXRHTFBhcmFtZXRlciIsIndpdGhHTFN0YXRlIiwiZ2V0R0xDb250ZXh0SW5mbyIsImdldENvbnRleHRMaW1pdHMiLCJtYWtlRGVidWdDb250ZXh0IiwiaW5zdGFsbFBhcmFtZXRlckRlZmluaXRpb25zIiwiQnVmZmVyIiwiU2hhZGVyIiwiVmVydGV4U2hhZGVyIiwiRnJhZ21lbnRTaGFkZXIiLCJQcm9ncmFtIiwiRnJhbWVidWZmZXIiLCJSZW5kZXJidWZmZXIiLCJUZXh0dXJlMkQiLCJUZXh0dXJlQ3ViZSIsImRyYXciLCJjbGVhciIsInJlYWRQaXhlbHMiLCJGZW5jZVN5bmMiLCJRdWVyeSIsIlNhbXBsZXIiLCJUZXh0dXJlM0QiLCJUZXh0dXJlMkRBcnJheSIsIlRyYW5zZm9ybUZlZWRiYWNrIiwiVmVydGV4QXJyYXlPYmplY3QiLCJVbmlmb3JtQnVmZmVyTGF5b3V0IiwiTW9kZWwiLCJBbmltYXRpb25Mb29wIiwiYWRkRXZlbnRzIiwiR2VvbWV0cnkiLCJDb25lR2VvbWV0cnkiLCJDdWJlR2VvbWV0cnkiLCJDeWxpbmRlckdlb21ldHJ5IiwiSWNvU3BoZXJlR2VvbWV0cnkiLCJQbGFuZUdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJUcnVuY2F0ZWRDb25lR2VvbWV0cnkiLCJDb25lIiwiQ3ViZSIsIkN5bGluZGVyIiwiSWNvU3BoZXJlIiwiUGxhbmUiLCJTcGhlcmUiLCJUcnVuY2F0ZWRDb25lIiwiQ2xpcFNwYWNlUXVhZCIsInJhZGlhbnMiLCJkZWdyZWVzIiwiVmVjdG9yMiIsIlZlY3RvcjMiLCJWZWN0b3I0IiwiTWF0cml4NCIsIlF1YXRlcm5pb24iLCJFdWxlciIsInNldFBhdGhQcmVmaXgiLCJsb2FkRmlsZSIsImxvYWRJbWFnZSIsImxvYWRGaWxlcyIsImxvYWRJbWFnZXMiLCJsb2FkVGV4dHVyZXMiLCJsb2FkUHJvZ3JhbSIsImxvYWRNb2RlbCIsInBhcnNlTW9kZWwiLCJyZWdpc3RlclNoYWRlck1vZHVsZXMiLCJhc3NlbWJsZVNoYWRlcnMiLCJTaGFkZXJDYWNoZSIsImV4cGVyaW1lbnRhbCIsIkZyYW1lYnVmZmVyT2JqZWN0IiwiT2JqZWN0M0QiLCJHcm91cCIsIlNjZW5lIiwicGlja01vZGVscyIsIlNoYWRlcnMiLCJGeCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQUEsUUFBUSxRQUFSOztBQUVBO0FBQ0EsU0FBUUMsV0FBV0MsRUFBbkIsUUFBNEIsc0JBQTVCO0FBQ0EsU0FDRUMsY0FERixFQUVFQyxlQUZGLFFBRXdCLGlCQUZ4Qjs7QUFJQSxTQUNFQyxlQURGLEVBRUVDLGNBRkYsRUFHRUMsa0JBSEYsRUFJRUMsY0FKRixRQUl1QixpQkFKdkI7QUFLQSxTQUNFQyxjQURGLEVBRUVDLGNBRkYsRUFHRUMsV0FIRixRQUdvQix1QkFIcEI7QUFJQSxTQUNFQyxnQkFERixFQUVFQyxnQkFGRixRQUV5Qix3QkFGekI7QUFHQSxTQUNFQyxnQkFERixRQUN5Qix1QkFEekI7QUFFQSxTQUNFQywyQkFERixRQUNvQywwQkFEcEM7O0FBR0EsU0FBUWQsV0FBV2UsTUFBbkIsUUFBZ0MsZ0JBQWhDO0FBQ0EsU0FBUWYsV0FBV2dCLE1BQW5CLEVBQTJCQyxZQUEzQixFQUF5Q0MsY0FBekMsUUFBOEQsZ0JBQTlEO0FBQ0EsU0FBUWxCLFdBQVdtQixPQUFuQixRQUFpQyxpQkFBakM7QUFDQSxTQUFRbkIsV0FBV29CLFdBQW5CLFFBQXFDLHFCQUFyQztBQUNBLFNBQVFwQixXQUFXcUIsWUFBbkIsUUFBc0Msc0JBQXRDO0FBQ0EsU0FBUXJCLFdBQVdzQixTQUFuQixRQUFtQyxvQkFBbkM7QUFDQSxTQUFRdEIsV0FBV3VCLFdB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QUFDQSxTQUFRL0UsV0FBV2dGLE9BQW5CLFFBQWlDLHdCQUFqQztBQUNBLFNBQVFoRixXQUFXaUYsRUFBbkIsUUFBNEIsaUJBQTVCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0IGNvcmUgbW9kdWxlcyBmb3IgbHVtYS5nbFxuXG4vLyBJbml0aWFsaXplIGFueSBnbG9iYWwgc3RhdGVcbnJlcXVpcmUoJy4vaW5pdCcpO1xuXG4vLyBXZWJHTFxuZXhwb3J0IHtkZWZhdWx0IGFzIEdMfSBmcm9tICcuL3dlYmdsL2dsLWNvbnN0YW50cyc7XG5leHBvcnQge1xuICBpc1dlYkdMQ29udGV4dCxcbiAgaXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL3dlYmdsL2NvbnRleHQnO1xuXG5leHBvcnQge1xuICBjcmVhdGVHTENvbnRleHQsXG4gIGdldEdMRXh0ZW5zaW9uLFxuICBnbENvbnRleHRXaXRoU3RhdGUsXG4gIGdsR2V0RGVidWdJbmZvfSBmcm9tICcuL3dlYmdsL2NvbnRleHQnO1xuZXhwb3J0IHtcbiAgZ2V0R0xQYXJhbWV0ZXIsXG4gIHNldEdMUGFyYW1ldGVyLFxuICB3aXRoR0xTdGF0ZX0gZnJvbSAnLi93ZWJnbC9jb250ZXh0LXN0YXRlJztcbmV4cG9ydCB7XG4gIGdldEdMQ29udGV4dEluZm8sXG4gIGdldENvbnRleHRMaW1pdHN9IGZyb20gJy4vd2ViZ2wvY29udGV4dC1saW1pdHMnO1xuZXhwb3J0IHtcbiAgbWFrZURlYnVnQ29udGV4dH0gZnJvbSAnLi93ZWJnbC9jb250ZXh0LWRlYnVnJztcbmV4cG9ydCB7XG4gIGluc3RhbGxQYXJhbWV0ZXJEZWZpbml0aW9uc30gZnJvbSAnLi93ZWJnbC9kZWJ1Zy1wYXJhbWV0ZXJzJztcblxuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1ZmZlcn0gZnJvbSAnLi93ZWJnbC9idWZmZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNoYWRlciwgVmVydGV4U2hhZGVyLCBGcmFnbWVudFNoYWRlcn0gZnJvbSAnLi93ZWJnbC9zaGFkZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFByb2dyYW19IGZyb20gJy4vd2ViZ2wvcHJvZ3JhbSc7XG5leHBvcnQge2RlZmF1bHQgYXMgRnJhbWVidWZmZXJ9IGZyb20gJy4vd2ViZ2wvZnJhbWVidWZmZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFJlbmRlcmJ1ZmZlcn0gZnJvbSAnLi93ZWJnbC9yZW5kZXJidWZmZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRleHR1cmUyRH0gZnJvbSAnLi93ZWJnbC90ZXh0dXJlLTJkJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUZXh0dXJlQ3ViZX0gZnJvbSAnLi93ZWJnbC90ZXh0dXJlLWN1YmUnO1xuXG5leHBvcnQge1xuICBkcmF3fSBmcm9tICcuL3dlYmdsL2RyYXcnO1xuZXhwb3J0IHtcbiAgY2xlYXIsXG4gIHJlYWRQaXhlbHN9IGZyb20gJy4vd2ViZ2wvZnVuY3Rpb25zJztcblxuLy8gV2ViR0wyICYgRXh0ZW5zaW9uc1xuZXhwb3J0IHtkZWZhdWx0IGFzIEZlbmNlU3luY30gZnJvbSAnLi93ZWJnbC9mZW5jZS1zeW5jJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBRdWVyeX0gZnJvbSAnLi93ZWJnbC9xdWVyeSc7XG5leHBvcnQge2RlZmF1bHQgYXMgU2FtcGxlcn0gZnJvbSAnLi93ZWJnbC9zYW1wbGVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUZXh0dXJlM0R9IGZyb20gJy4vd2ViZ2wvdGV4dHVyZS0zZCc7XG5leHBvcnQge2RlZmF1bHQgYXMgVGV4dHVyZTJEQXJyYXl9IGZyb20gJy4vd2ViZ2wvdGV4dHVyZS0yZC1hcnJheSc7XG5leHBvcnQge2RlZmF1bHQgYXMgVHJhbnNmb3JtRmVlZGJhY2t9IGZyb20gJy4vd2ViZ2wvdHJhbnNmb3JtLWZlZWRiYWNrJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWZXJ0ZXhBcnJheU9iamVjdH0gZnJvbSAnLi93ZWJnbC92ZXJ0ZXgtYXJyYXktb2JqZWN0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBVbmlmb3JtQnVmZmVyTGF5b3V0fSBmcm9tICcuL3dlYmdsL3VuaWZvcm0tYnVmZmVyLWxheW91dCc7XG5cbi8vIENvcmUgQ2xhc3Nlc1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1vZGVsfSBmcm9tICcuL2NvcmUvbW9kZWwnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEFuaW1hdGlvbkxvb3B9IGZyb20gJy4vY29yZS9hbmltYXRpb24tbG9vcCc7XG5cbi8vIEFkZG9uc1xuZXhwb3J0IHthZGRFdmVudHN9IGZyb20gJy4vcGFja2FnZXMvZXZlbnRzJztcblxuLy8gR2VvbWV0cnlcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeS9nZW9tZXRyeSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQ29uZUdlb21ldHJ5fSBmcm9tICcuL2dlb21ldHJ5L2NvbmUtZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEN1YmVHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeS9jdWJlLWdlb21ldHJ5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBDeWxpbmRlckdlb21ldHJ5fSBmcm9tICcuL2dlb21ldHJ5L2N5bGluZGVyLWdlb21ldHJ5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJY29TcGhlcmVHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeS9pY28tc3BoZXJlLWdlb21ldHJ5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQbGFuZUdlb21ldHJ5fSBmcm9tICcuL2dlb21ldHJ5L3BsYW5lLWdlb21ldHJ5JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTcGhlcmVHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeS9zcGhlcmUtZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRydW5jYXRlZENvbmVHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeS90cnVuY2F0ZWQtY29uZS1nZW9tZXRyeSc7XG5cbi8vIE1vZGVsc1xuZXhwb3J0IHtkZWZhdWx0IGFzIENvbmV9IGZyb20gJy4vbW9kZWxzL2NvbmUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEN1YmV9IGZyb20gJy4vbW9kZWxzL2N1YmUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEN5bGluZGVyfSBmcm9tICcuL21vZGVscy9jeWxpbmRlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgSWNvU3BoZXJlfSBmcm9tICcuL21vZGVscy9pY28tc3BoZXJlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQbGFuZX0gZnJvbSAnLi9tb2RlbHMvcGxhbmUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNwaGVyZX0gZnJvbSAnLi9tb2RlbHMvc3BoZXJlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUcnVuY2F0ZWRDb25lfSBmcm9tICcuL21vZGVscy90cnVuY2F0ZWQtY29uZSc7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBDbGlwU3BhY2VRdWFkfSBmcm9tICcuL21vZGVscy9jbGlwLXNwYWNlLXF1YWQnO1xuXG4vLyBNYXRoXG5leHBvcnQge1xuICByYWRpYW5zLFxuICBkZWdyZWVzfSBmcm9tICcuL3BhY2thZ2VzL21hdGgvc3JjL2NvbW1vbic7XG5leHBvcnQge2RlZmF1bHQgYXMgVmVjdG9yMn0gZnJvbSAnLi9wYWNrYWdlcy9tYXRoL3NyYy92ZWN0b3IyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWZWN0b3IzfSBmcm9tICcuL3BhY2thZ2VzL21hdGgvc3JjL3ZlY3RvcjMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFZlY3RvcjR9IGZyb20gJy4vcGFja2FnZXMvbWF0aC9zcmMvdmVjdG9yNCc7XG5leHBvcnQge2RlZmF1bHQgYXMgTWF0cml4NH0gZnJvbSAnLi9wYWNrYWdlcy9tYXRoL3NyYy9tYXRyaXg0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBRdWF0ZXJuaW9ufSBmcm9tICcuL3BhY2thZ2VzL21hdGgvc3JjL3F1YXRlcm5pb24nO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEV1bGVyfSBmcm9tICcuL3BhY2thZ2VzL21hdGgvc3JjL2V1bGVyJztcblxuLy8gSU9cbmV4cG9ydCB7XG4gIHNldFBhdGhQcmVmaXgsXG4gIGxvYWRGaWxlLFxuICBsb2FkSW1hZ2UsXG4gIGxvYWRGaWxlcyxcbiAgbG9hZEltYWdlcyxcbiAgbG9hZFRleHR1cmVzLFxuICBsb2FkUHJvZ3JhbSxcbiAgbG9hZE1vZGVsLFxuICBwYXJzZU1vZGVsXG59IGZyb20gJy4vaW8nO1xuXG4vLyBFWFBFUklNRU5UQUwgTU9EVUxFU1xuXG4vLyBTaGFkZXIgVG9vbHNcbmltcG9ydCB7XG4gIHJlZ2lzdGVyU2hhZGVyTW9kdWxlcyxcbiAgYXNzZW1ibGVTaGFkZXJzLFxuICBTaGFkZXJDYWNoZVxufSBmcm9tICcuL2V4cGVyaW1lbnRhbC9zaGFkZXItdG9vbHMnO1xuXG4vLyBSZWdpc3RlciBTaGFkZXIgTW9kdWxlc1xuaW1wb3J0ICcuL2V4cGVyaW1lbnRhbC9zaGFkZXItbW9kdWxlcyc7XG5cbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWwgPSB7XG4gIHJlZ2lzdGVyU2hhZGVyTW9kdWxlcyxcbiAgYXNzZW1ibGVTaGFkZXJzLFxuICBTaGFkZXJDYWNoZVxufTtcblxuLy8gQWxpYXMgZm9yIEZyYW1lYnVmZmVyT2JqZWN0IChkZXByZWNhdGVkIGluIHYzKS4gRnJhbWVidWZmZXIgQVBJIGlzIGZhaXJseSBzaW1pbGFyXG5leHBvcnQge2RlZmF1bHQgYXMgRnJhbWVidWZmZXJPYmplY3R9IGZyb20gJy4vd2ViZ2wvZnJhbWVidWZmZXInO1xuXG4vLyBERVBSRUNBVEVEIElOIFYzLjBcbmV4cG9ydCB7T2JqZWN0M0QsIEdyb3VwLCBTY2VuZSwgcGlja01vZGVsc30gZnJvbSAnLi9kZXByZWNhdGVkL3NjZW5lZ3JhcGgnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNoYWRlcnN9IGZyb20gJy4vZGVwcmVjYXRlZC9zaGFkZXJsaWInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEZ4fSBmcm9tICcuL2RlcHJlY2F0ZWQvZngnO1xuIl19

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webgl_types__ = __webpack_require__(107);
/* unused harmony reexport Image */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_0__webgl_types__["b"]; });
/* unused harmony reexport WebGLProgram */
/* unused harmony reexport WebGLShader */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__webgl_types__["e"]; });
/* unused harmony reexport WebGLFramebuffer */
/* unused harmony reexport WebGLRenderbuffer */
/* unused harmony reexport WebGLTexture */
/* unused harmony reexport WebGLUniformLocation */
/* unused harmony reexport WebGLActiveInfo */
/* unused harmony reexport WebGLShaderPrecisionFormat */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__webgl_types__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_0__webgl_types__["m"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl_format_shader_error__ = __webpack_require__(253);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_1__webgl_format_shader_error__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_1__webgl_format_shader_error__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_constants__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_constants__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_constants__["c"]; });
/* unused harmony reexport glKey */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_constants__["a"]; });
// Exports WebGL API constants and types, plus some basic type checks




// TODO - avoid importing GL as it is a big file


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy93ZWJnbC9hcGkvaW5kZXguanMiXSwibmFtZXMiOlsiSW1hZ2UiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJXZWJHTFByb2dyYW0iLCJXZWJHTFNoYWRlciIsIldlYkdMQnVmZmVyIiwiV2ViR0xGcmFtZWJ1ZmZlciIsIldlYkdMUmVuZGVyYnVmZmVyIiwiV2ViR0xUZXh0dXJlIiwiV2ViR0xVbmlmb3JtTG9jYXRpb24iLCJXZWJHTEFjdGl2ZUluZm8iLCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdCIsIldlYkdMMlJlbmRlcmluZ0NvbnRleHQiLCJ3ZWJHTFR5cGVzQXZhaWxhYmxlIiwiZm9ybWF0R0xTTENvbXBpbGVyRXJyb3IiLCJnZXRTaGFkZXJOYW1lIiwiR0wiLCJnbEdldCIsImdsS2V5IiwiZGVmYXVsdCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxTQUNFQSxLQURGLEVBRUVDLHFCQUZGLEVBR0VDLFlBSEYsRUFJRUMsV0FKRixFQUtFQyxXQUxGLEVBTUVDLGdCQU5GLEVBT0VDLGlCQVBGLEVBUUVDLFlBUkYsRUFTRUMsb0JBVEYsRUFVRUMsZUFWRixFQVdFQywwQkFYRixFQVlFQyxzQkFaRixFQWNFQyxtQkFkRixRQWVPLGVBZlA7O0FBaUJBLFNBQ0VDLHVCQURGLEVBRUVDLGFBRkYsUUFHTyw2QkFIUDs7QUFLQTtBQUNBLFNBQVFDLEVBQVIsRUFBWUMsS0FBWixFQUFtQkMsS0FBbkIsUUFBK0IsaUJBQS9CO0FBQ0EsU0FBUUMsT0FBUixRQUFpQyxpQkFBakMiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHBvcnRzIFdlYkdMIEFQSSBjb25zdGFudHMgYW5kIHR5cGVzLCBwbHVzIHNvbWUgYmFzaWMgdHlwZSBjaGVja3NcbmV4cG9ydCB7XG4gIEltYWdlLFxuICBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFdlYkdMUHJvZ3JhbSxcbiAgV2ViR0xTaGFkZXIsXG4gIFdlYkdMQnVmZmVyLFxuICBXZWJHTEZyYW1lYnVmZmVyLFxuICBXZWJHTFJlbmRlcmJ1ZmZlcixcbiAgV2ViR0xUZXh0dXJlLFxuICBXZWJHTFVuaWZvcm1Mb2NhdGlvbixcbiAgV2ViR0xBY3RpdmVJbmZvLFxuICBXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdCxcbiAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcblxuICB3ZWJHTFR5cGVzQXZhaWxhYmxlXG59IGZyb20gJy4vd2ViZ2wtdHlwZXMnO1xuXG5leHBvcnQge1xuICBmb3JtYXRHTFNMQ29tcGlsZXJFcnJvcixcbiAgZ2V0U2hhZGVyTmFtZVxufSBmcm9tICcuL3dlYmdsLWZvcm1hdC1zaGFkZXItZXJyb3InO1xuXG4vLyBUT0RPIC0gYXZvaWQgaW1wb3J0aW5nIEdMIGFzIGl0IGlzIGEgYmlnIGZpbGVcbmV4cG9ydCB7R0wsIGdsR2V0LCBnbEtleX0gZnJvbSAnLi4vZ2wtY29uc3RhbnRzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZWZhdWx0fSBmcm9tICcuLi9nbC1jb25zdGFudHMnO1xuIl19

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__log__ = __webpack_require__(46);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__log__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatten__ = __webpack_require__(195);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compare_objects__ = __webpack_require__(194);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_2__compare_objects__["a"]; });
/* unused harmony reexport areEqualShallow */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compare_arrays__ = __webpack_require__(193);
/* unused harmony reexport compareArrays */
/* unused harmony reexport checkArray */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__fp64__ = __webpack_require__(10);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_4__fp64__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__color__ = __webpack_require__(192);
/* unused harmony reexport parseColor */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__blend__ = __webpack_require__(191);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_6__blend__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_6__blend__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__get__ = __webpack_require__(44);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_7__get__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__count__ = __webpack_require__(76);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_8__count__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Log


// Object and array support




// FP64 and Color support




// ES6 Container and Immutable support


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvaW5kZXguanMiXSwibmFtZXMiOlsiZGVmYXVsdCIsImxvZyIsImZsYXR0ZW4iLCJmbGF0dGVuVmVydGljZXMiLCJmaWxsQXJyYXkiLCJjb21wYXJlUHJvcHMiLCJhcmVFcXVhbFNoYWxsb3ciLCJjb21wYXJlQXJyYXlzIiwiY2hlY2tBcnJheSIsImZwNjRpZnkiLCJwYXJzZUNvbG9yIiwiZ2V0QmxlbmRNb2RlIiwic2V0QmxlbmRNb2RlIiwiZ2V0IiwiY291bnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUUEsV0FBV0MsR0FBbkIsUUFBNkIsT0FBN0I7O0FBRUE7QUFDQSxTQUFRQyxPQUFSLEVBQWlCQyxlQUFqQixFQUFrQ0MsU0FBbEMsUUFBa0QsV0FBbEQ7QUFDQSxTQUFRQyxZQUFSLEVBQXNCQyxlQUF0QixRQUE0QyxtQkFBNUM7QUFDQSxTQUFRQyxhQUFSLEVBQXVCQyxVQUF2QixRQUF3QyxrQkFBeEM7O0FBRUE7QUFDQSxTQUFRQyxPQUFSLFFBQXNCLFFBQXRCO0FBQ0EsU0FBUUMsVUFBUixRQUF5QixTQUF6QjtBQUNBLFNBQVFDLFlBQVIsRUFBc0JDLFlBQXRCLFFBQXlDLFNBQXpDOztBQUVBO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixPQUFsQjtBQUNBLFNBQVFDLEtBQVIsUUFBb0IsU0FBcEIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gTG9nXG5leHBvcnQge2RlZmF1bHQgYXMgbG9nfSBmcm9tICcuL2xvZyc7XG5cbi8vIE9iamVjdCBhbmQgYXJyYXkgc3VwcG9ydFxuZXhwb3J0IHtmbGF0dGVuLCBmbGF0dGVuVmVydGljZXMsIGZpbGxBcnJheX0gZnJvbSAnLi9mbGF0dGVuJztcbmV4cG9ydCB7Y29tcGFyZVByb3BzLCBhcmVFcXVhbFNoYWxsb3d9IGZyb20gJy4vY29tcGFyZS1vYmplY3RzJztcbmV4cG9ydCB7Y29tcGFyZUFycmF5cywgY2hlY2tBcnJheX0gZnJvbSAnLi9jb21wYXJlLWFycmF5cyc7XG5cbi8vIEZQNjQgYW5kIENvbG9yIHN1cHBvcnRcbmV4cG9ydCB7ZnA2NGlmeX0gZnJvbSAnLi9mcDY0JztcbmV4cG9ydCB7cGFyc2VDb2xvcn0gZnJvbSAnLi9jb2xvcic7XG5leHBvcnQge2dldEJsZW5kTW9kZSwgc2V0QmxlbmRNb2RlfSBmcm9tICcuL2JsZW5kJztcblxuLy8gRVM2IENvbnRhaW5lciBhbmQgSW1tdXRhYmxlIHN1cHBvcnRcbmV4cG9ydCB7Z2V0fSBmcm9tICcuL2dldCc7XG5leHBvcnQge2NvdW50fSBmcm9tICcuL2NvdW50JztcbiJdfQ==

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__ = __webpack_require__(198);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(82);
/* unused harmony namespace reexport */
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxvQkFBZDtBQUNBLGNBQWMsaUJBQWQiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0ICogZnJvbSAnLi9hc3NlbWJsZS1zaGFkZXJzJztcbmV4cG9ydCAqIGZyb20gJy4vc2hhZGVyLWNodW5rcyc7XG4iXX0=

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = __webpack_require__(15);
exports.mat2 = __webpack_require__(212);
exports.mat2d = __webpack_require__(213);
exports.mat3 = __webpack_require__(86);
exports.mat4 = __webpack_require__(214);
exports.quat = __webpack_require__(215);
exports.vec2 = __webpack_require__(216);
exports.vec3 = __webpack_require__(87);
exports.vec4 = __webpack_require__(88);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = fp64ify;
/* harmony export (immutable) */ __webpack_exports__["b"] = enable64bitSupport;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__log__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(27);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// TODO - move to shaderlib utilities



function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

function enable64bitSupport(props) {
  if (props.fp64) {
    if (props.projectionMode === __WEBPACK_IMPORTED_MODULE_1__constants__["a" /* COORDINATE_SYSTEM */].LNGLAT) {
      return true;
    }
    __WEBPACK_IMPORTED_MODULE_0__log__["a" /* default */].once(0, '64-bit mode only works with projectionMode set to\n      COORDINATE_SYSTEM.LNGLAT. Rendering in 32-bit mode instead');
  }

  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZnA2NC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJDT09SRElOQVRFX1NZU1RFTSIsImZwNjRpZnkiLCJhIiwiaGlQYXJ0IiwiTWF0aCIsImZyb3VuZCIsImxvUGFydCIsImVuYWJsZTY0Yml0U3VwcG9ydCIsInByb3BzIiwiZnA2NCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwib25jZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPQSxHQUFQLE1BQWdCLE9BQWhCO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0MsY0FBaEM7O0FBRUEsT0FBTyxTQUFTQyxPQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUN6QixNQUFNQyxTQUFTQyxLQUFLQyxNQUFMLENBQVlILENBQVosQ0FBZjtBQUNBLE1BQU1JLFNBQVNKLElBQUlFLEtBQUtDLE1BQUwsQ0FBWUgsQ0FBWixDQUFuQjtBQUNBLFNBQU8sQ0FBQ0MsTUFBRCxFQUFTRyxNQUFULENBQVA7QUFDRDs7QUFFRCxPQUFPLFNBQVNDLGtCQUFULENBQTRCQyxLQUE1QixFQUFtQztBQUN4QyxNQUFJQSxNQUFNQyxJQUFWLEVBQWdCO0FBQ2QsUUFBSUQsTUFBTUUsY0FBTixLQUF5QlYsa0JBQWtCVyxNQUEvQyxFQUF1RDtBQUNyRCxhQUFPLElBQVA7QUFDRDtBQUNEWixRQUFJYSxJQUFKLENBQVMsQ0FBVDtBQUVEOztBQUVELFNBQU8sS0FBUDtBQUNEIiwiZmlsZSI6ImZwNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gVE9ETyAtIG1vdmUgdG8gc2hhZGVybGliIHV0aWxpdGllc1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gTWF0aC5mcm91bmQoYSk7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlNjRiaXRTdXBwb3J0KHByb3BzKSB7XG4gIGlmIChwcm9wcy5mcDY0KSB7XG4gICAgaWYgKHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2cub25jZSgwLCBgNjQtYml0IG1vZGUgb25seSB3b3JrcyB3aXRoIHByb2plY3Rpb25Nb2RlIHNldCB0b1xuICAgICAgQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULiBSZW5kZXJpbmcgaW4gMzItYml0IG1vZGUgaW5zdGVhZGApO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl19

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(30);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GL; });
/* harmony export (immutable) */ __webpack_exports__["c"] = glGet;
/* harmony export (immutable) */ __webpack_exports__["d"] = glKey;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
// WEBGL BUILT-IN TYPES


var GL = {};
/* harmony default export */ __webpack_exports__["a"] = (GL);

// Resolve a WebGL enumeration name (returns itself if already a number)
function glGet(name) {
  // If not a string, return (assume number)
  if (typeof name !== 'string') {
    return name;
  }

  // If string converts to number, return number
  var number = Number(name);
  if (!isNaN(number)) {
    return number;
  }

  // Look up string, after removing any 'GL.' or 'gl.' prefix
  name = name.replace(/^.*\./, '');
  var value = GL[name];
  __WEBPACK_IMPORTED_MODULE_0_assert___default()(value !== undefined, 'Accessing undefined constant GL.' + name);
  return value;
}

function glKey(value) {
  value = Number(value);
  for (var key in GL) {
    if (GL[key] === value) {
      return 'GL.' + key;
    }
  }
  return String(value);
}

// GL constants, copied from Mozilla documentation
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants

// Standard WebGL 1 constants
// These constants are defined on the WebGLRenderingContext interface.

/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */
Object.assign(GL, {
  // Clearing buffers
  // Constants passed to clear() to clear buffer masks.

  DEPTH_BUFFER_BIT: 0x00000100, // Passed to clear to clear the current depth buffer.
  STENCIL_BUFFER_BIT: 0x00000400, // Passed to clear to clear the current stencil buffer.
  COLOR_BUFFER_BIT: 0x00004000, // Passed to clear to clear the current color buffer.

  // Rendering primitives
  // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.

  POINTS: 0x0000, // Passed to drawElements or drawArrays to draw single points.
  LINES: 0x0001, // Passed to drawElements or drawArrays to draw lines. Each vertex connects to the one after it.
  LINE_LOOP: 0x0002, // Passed to drawElements or drawArrays to draw lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 0x0003, // Passed to drawElements or drawArrays to draw a connected group of line segments from the first vertex to the last.
  TRIANGLES: 0x0004, // Passed to drawElements or drawArrays to draw triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 0x0005, // Passed to drawElements or drawArrays to draw a connected group of triangles.
  TRIANGLE_FAN: 0x0006, // Passed to drawElements or drawArrays to draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan.

  // Blending modes
  // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).

  ZERO: 0, // Passed to blendFunc or blendFuncSeparate to turn off a component.
  ONE: 1, // Passed to blendFunc or blendFuncSeparate to turn on a component.
  SRC_COLOR: 0x0300, // Passed to blendFunc or blendFuncSeparate to multiply a component by the source elements color.
  ONE_MINUS_SRC_COLOR: 0x0301, // Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source elements color.
  SRC_ALPHA: 0x0302, // Passed to blendFunc or blendFuncSeparate to multiply a component by the source's alpha.
  ONE_MINUS_SRC_ALPHA: 0x0303, // Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source's alpha.
  DST_ALPHA: 0x0304, // Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's alpha.
  ONE_MINUS_DST_ALPHA: 0x0305, // Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's alpha.
  DST_COLOR: 0x0306, // Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's color.
  ONE_MINUS_DST_COLOR: 0x0307, // Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's color.
  SRC_ALPHA_SATURATE: 0x0308, // Passed to blendFunc or blendFuncSeparate to multiply a component by the minimum of source's alpha or one minus the destination's alpha.
  CONSTANT_COLOR: 0x8001, // Passed to blendFunc or blendFuncSeparate to specify a constant color blend function.
  ONE_MINUS_CONSTANT_COLOR: 0x8002, // Passed to blendFunc or blendFuncSeparate to specify one minus a constant color blend function.
  CONSTANT_ALPHA: 0x8003, // Passed to blendFunc or blendFuncSeparate to specify a constant alpha blend function.
  ONE_MINUS_CONSTANT_ALPHA: 0x8004, // Passed to blendFunc or blendFuncSeparate to specify one minus a constant alpha blend function.

  // Blending equations
  // Constants passed to blendEquation() or blendEquationSeparate() to control
  // how the blending is calculated (for both, RBG and alpha, or separately).

  FUNC_ADD: 0x8006, // Passed to blendEquation or blendEquationSeparate to set an addition blend function.
  FUNC_SUBSTRACT: 0x800A, // Passed to blendEquation or blendEquationSeparate to specify a subtraction blend function (source - destination).
  FUNC_REVERSE_SUBTRACT: 0x800B, // Passed to blendEquation or blendEquationSeparate to specify a reverse subtraction blend function (destination - source).

  // Getting GL parameter information
  // Constants passed to getParameter() to specify what information to return.

  BLEND_EQUATION: 0x8009, // Passed to getParameter to get the current RGB blend function.
  BLEND_EQUATION_RGB: 0x8009, // Passed to getParameter to get the current RGB blend function. Same as BLEND_EQUATION
  BLEND_EQUATION_ALPHA: 0x883D, // Passed to getParameter to get the current alpha blend function. Same as BLEND_EQUATION
  BLEND_DST_RGB: 0x80C8, // Passed to getParameter to get the current destination RGB blend function.
  BLEND_SRC_RGB: 0x80C9, // Passed to getParameter to get the current destination RGB blend function.
  BLEND_DST_ALPHA: 0x80CA, // Passed to getParameter to get the current destination alpha blend function.
  BLEND_SRC_ALPHA: 0x80CB, // Passed to getParameter to get the current source alpha blend function.
  BLEND_COLOR: 0x8005, // Passed to getParameter to return a the current blend color.
  ARRAY_BUFFER_BINDING: 0x8894, // Passed to getParameter to get the array buffer binding.
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895, // Passed to getParameter to get the current element array buffer.
  LINE_WIDTH: 0x0B21, // Passed to getParameter to get the current lineWidth (set by the lineWidth method).
  ALIASED_POINT_SIZE_RANGE: 0x846D, // Passed to getParameter to get the current size of a point drawn with gl.POINTS
  ALIASED_LINE_WIDTH_RANGE: 0x846E, // Passed to getParameter to get the range of available widths for a line. Returns a length-2 array with the lo value at 0, and hight at 1.
  CULL_FACE_MODE: 0x0B45, // Passed to getParameter to get the current value of cullFace. Should return FRONT, BACK, or FRONT_AND_BACK
  FRONT_FACE: 0x0B46, // Passed to getParameter to determine the current value of frontFace. Should return CW or CCW.
  DEPTH_RANGE: 0x0B70, // Passed to getParameter to return a length-2 array of floats giving the current depth range.
  DEPTH_WRITEMASK: 0x0B72, // Passed to getParameter to determine if the depth write mask is enabled.
  DEPTH_CLEAR_VALUE: 0x0B73, // Passed to getParameter to determine the current depth clear value.
  DEPTH_FUNC: 0x0B74, // Passed to getParameter to get the current depth function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL.
  STENCIL_CLEAR_VALUE: 0x0B91, // Passed to getParameter to get the value the stencil will be cleared to.
  STENCIL_FUNC: 0x0B92, // Passed to getParameter to get the current stencil function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL.
  STENCIL_FAIL: 0x0B94, // Passed to getParameter to get the current stencil fail function. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
  STENCIL_PASS_DEPTH_FAIL: 0x0B95, // Passed to getParameter to get the current stencil fail function should the depth buffer test fail. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
  STENCIL_PASS_DEPTH_PASS: 0x0B96, // Passed to getParameter to get the current stencil fail function should the depth buffer test pass. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
  STENCIL_REF: 0x0B97, // Passed to getParameter to get the reference value used for stencil tests.
  STENCIL_VALUE_MASK: 0x0B93,
  STENCIL_WRITEMASK: 0x0B98,
  STENCIL_BACK_FUNC: 0x8800,
  STENCIL_BACK_FAIL: 0x8801,
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
  STENCIL_BACK_REF: 0x8CA3,
  STENCIL_BACK_VALUE_MASK: 0x8CA4,
  STENCIL_BACK_WRITEMASK: 0x8CA5,
  VIEWPORT: 0x0BA2, // Returns an Int32Array with four elements for the current viewport dimensions.
  SCISSOR_BOX: 0x0C10, // Returns an Int32Array with four elements for the current scissor box dimensions.
  COLOR_CLEAR_VALUE: 0x0C22,
  COLOR_WRITEMASK: 0x0C23,
  UNPACK_ALIGNMENT: 0x0CF5,
  PACK_ALIGNMENT: 0x0D05,
  MAX_TEXTURE_SIZE: 0x0D33,
  MAX_VIEWPORT_DIMS: 0x0D3A,
  SUBPIXEL_BITS: 0x0D50,
  RED_BITS: 0x0D52,
  GREEN_BITS: 0x0D53,
  BLUE_BITS: 0x0D54,
  ALPHA_BITS: 0x0D55,
  DEPTH_BITS: 0x0D56,
  STENCIL_BITS: 0x0D57,
  POLYGON_OFFSET_UNITS: 0x2A00,
  POLYGON_OFFSET_FACTOR: 0x8038,
  TEXTURE_BINDING_2D: 0x8069,
  SAMPLE_BUFFERS: 0x80A8,
  SAMPLES: 0x80A9,
  SAMPLE_COVERAGE_VALUE: 0x80AA,
  SAMPLE_COVERAGE_INVERT: 0x80AB,
  COMPRESSED_TEXTURE_FORMATS: 0x86A3,
  VENDOR: 0x1F00,
  RENDERER: 0x1F01,
  VERSION: 0x1F02,
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,
  BROWSER_DEFAULT_WEBGL: 0x9244,

  // Buffers
  // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
  // getBufferParameter().

  STATIC_DRAW: 0x88E4, // Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and not change often.
  STREAM_DRAW: 0x88E0, // Passed to bufferData as a hint about whether the contents of the buffer are likely to not be used often.
  DYNAMIC_DRAW: 0x88E8, // Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and change often.
  ARRAY_BUFFER: 0x8892, // Passed to bindBuffer or bufferData to specify the type of buffer being used.
  ELEMENT_ARRAY_BUFFER: 0x8893, // Passed to bindBuffer or bufferData to specify the type of buffer being used.
  BUFFER_SIZE: 0x8764, // Passed to getBufferParameter to get a buffer's size.
  BUFFER_USAGE: 0x8765, // Passed to getBufferParameter to get the hint for the buffer passed in when it was created.

  // Vertex attributes
  // Constants passed to getVertexAttrib().

  CURRENT_VERTEX_ATTRIB: 0x8626, // Passed to getVertexAttrib to read back the current vertex attribute.
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,

  // Culling
  // Constants passed to cullFace().

  CULL_FACE: 0x0B44, // Passed to enable/disable to turn on/off culling. Can also be used with getParameter to find the current culling method.
  FRONT: 0x0404, // Passed to cullFace to specify that only front faces should be drawn.
  BACK: 0x0405, // Passed to cullFace to specify that only back faces should be drawn.
  FRONT_AND_BACK: 0x0408, // Passed to cullFace to specify that front and back faces should be drawn.

  // Enabling and disabling
  // Constants passed to enable() or disable().

  BLEND: 0x0BE2, // Passed to enable/disable to turn on/off blending. Can also be used with getParameter to find the current blending method.
  DEPTH_TEST: 0x0B71, // Passed to enable/disable to turn on/off the depth test. Can also be used with getParameter to query the depth test.
  DITHER: 0x0BD0, // Passed to enable/disable to turn on/off dithering. Can also be used with getParameter to find the current dithering method.
  POLYGON_OFFSET_FILL: 0x8037, // Passed to enable/disable to turn on/off the polygon offset. Useful for rendering hidden-line images, decals, and or solids with highlighted edges. Can also be used with getParameter to query the scissor test.
  SAMPLE_ALPHA_TO_COVERAGE: 0x809E, // Passed to enable/disable to turn on/off the alpha to coverage. Used in multi-sampling alpha channels.
  SAMPLE_COVERAGE: 0x80A0, // Passed to enable/disable to turn on/off the sample coverage. Used in multi-sampling.
  SCISSOR_TEST: 0x0C11, // Passed to enable/disable to turn on/off the scissor test. Can also be used with getParameter to query the scissor test.
  STENCIL_TEST: 0x0B90, // Passed to enable/disable to turn on/off the stencil test. Can also be used with getParameter to query the stencil test.

  // Errors
  // Constants returned from getError().

  NO_ERROR: 0, // Returned from getError.
  INVALID_ENUM: 0x0500, //  Returned from getError.
  INVALID_VALUE: 0x0501, //  Returned from getError.
  INVALID_OPERATION: 0x0502, //  Returned from getError.
  OUT_OF_MEMORY: 0x0505, //  Returned from getError.
  CONTEXT_LOST_WEBGL: 0x9242, //  Returned from getError.

  // Front face directions
  // Constants passed to frontFace().

  CW: 0x0900, //  Passed to frontFace to specify the front face of a polygon is drawn in the clockwise direction
  CCW: 0x0901, // Passed to frontFace to specify the front face of a polygon is drawn in the counter clockwise direction

  // Hints
  // Constants passed to hint()

  DONT_CARE: 0x1100, // There is no preference for this behavior.
  FASTEST: 0x1101, // The most efficient behavior should be used.
  NICEST: 0x1102, // The most correct or the highest quality option should be used.
  GENERATE_MIPMAP_HINT: 0x8192, // Hint for the quality of filtering when generating mipmap images with generateMipmap().

  // Data types

  BYTE: 0x1400,
  UNSIGNED_BYTE: 0x1401,
  SHORT: 0x1402,
  UNSIGNED_SHORT: 0x1403,
  INT: 0x1404,
  UNSIGNED_INT: 0x1405,
  FLOAT: 0x1406,

  // Pixel formats

  DEPTH_COMPONENT: 0x1902,
  ALPHA: 0x1906,
  RGB: 0x1907,
  RGBA: 0x1908,
  LUMINANCE: 0x1909,
  LUMINANCE_ALPHA: 0x190A,

  // Pixel types

  // UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT_4_4_4_4: 0x8033,
  UNSIGNED_SHORT_5_5_5_1: 0x8034,
  UNSIGNED_SHORT_5_6_5: 0x8363,

  // Shaders
  // Constants passed to createShader() or getShaderParameter()

  FRAGMENT_SHADER: 0x8B30, // Passed to createShader to define a fragment shader.
  VERTEX_SHADER: 0x8B31, // Passed to createShader to define a vertex shader
  COMPILE_STATUS: 0x8B81, // Passed to getShaderParamter to get the status of the compilation. Returns false if the shader was not compiled. You can then query getShaderInfoLog to find the exact error
  DELETE_STATUS: 0x8B80, // Passed to getShaderParamter to determine if a shader was deleted via deleteShader. Returns true if it was, false otherwise.
  LINK_STATUS: 0x8B82, // Passed to getProgramParameter after calling linkProgram to determine if a program was linked correctly. Returns false if there were errors. Use getProgramInfoLog to find the exact error.
  VALIDATE_STATUS: 0x8B83, // Passed to getProgramParameter after calling validateProgram to determine if it is valid. Returns false if errors were found.
  ATTACHED_SHADERS: 0x8B85, // Passed to getProgramParameter after calling attachShader to determine if the shader was attached correctly. Returns false if errors occurred.
  ACTIVE_ATTRIBUTES: 0x8B89, // Passed to getProgramParameter to get the number of attributes active in a program.
  ACTIVE_UNIFORMS: 0x8B86, // Passed to getProgramParamter to get the number of uniforms active in a program.
  MAX_VERTEX_ATTRIBS: 0x8869,
  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
  MAX_VARYING_VECTORS: 0x8DFC,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
  MAX_TEXTURE_IMAGE_UNITS: 0x8872, // Implementation dependent number of maximum texture units. At least 8.
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
  SHADER_TYPE: 0x8B4F,
  SHADING_LANGUAGE_VERSION: 0x8B8C,
  CURRENT_PROGRAM: 0x8B8D,

  // Depth or stencil tests
  // Constants passed to depthFunc() or stencilFunc().

  NEVER: 0x0200, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn.
  ALWAYS: 0x0207, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn.
  LESS: 0x0201, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value.
  EQUAL: 0x0202, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value.
  LEQUAL: 0x0203, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value.
  GREATER: 0x0204, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value.
  GEQUAL: 0x0206, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value.
  NOTEQUAL: 0x0205, //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value.

  // Stencil actions
  // Constants passed to stencilOp().

  KEEP: 0x1E00,
  REPLACE: 0x1E01,
  INCR: 0x1E02,
  DECR: 0x1E03,
  INVERT: 0x150A,
  INCR_WRAP: 0x8507,
  DECR_WRAP: 0x8508,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  TEXTURE_2D: 0x0DE1,
  TEXTURE: 0x1702,
  TEXTURE_CUBE_MAP: 0x8513,
  TEXTURE_BINDING_CUBE_MAP: 0x8514,
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
  // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
  TEXTURE0: 0x84C0, // A texture unit.
  ACTIVE_TEXTURE: 0x84E0, // The current active texture unit.
  REPEAT: 0x2901,
  CLAMP_TO_EDGE: 0x812F,
  MIRRORED_REPEAT: 0x8370,

  // Emulation
  TEXTURE_WIDTH: 0x1000,
  TEXTURE_HEIGHT: 0x1001,

  // Uniform types

  FLOAT_VEC2: 0x8B50,
  FLOAT_VEC3: 0x8B51,
  FLOAT_VEC4: 0x8B52,
  INT_VEC2: 0x8B53,
  INT_VEC3: 0x8B54,
  INT_VEC4: 0x8B55,
  BOOL: 0x8B56,
  BOOL_VEC2: 0x8B57,
  BOOL_VEC3: 0x8B58,
  BOOL_VEC4: 0x8B59,
  FLOAT_MAT2: 0x8B5A,
  FLOAT_MAT3: 0x8B5B,
  FLOAT_MAT4: 0x8B5C,
  SAMPLER_2D: 0x8B5E,
  SAMPLER_CUBE: 0x8B60,

  // Shader precision-specified types

  LOW_FLOAT: 0x8DF0,
  MEDIUM_FLOAT: 0x8DF1,
  HIGH_FLOAT: 0x8DF2,
  LOW_INT: 0x8DF3,
  MEDIUM_INT: 0x8DF4,
  HIGH_INT: 0x8DF5,

  // Framebuffers and renderbuffers

  FRAMEBUFFER: 0x8D40,
  RENDERBUFFER: 0x8D41,
  RGBA4: 0x8056,
  RGB5_A1: 0x8057,
  RGB565: 0x8D62,
  DEPTH_COMPONENT16: 0x81A5,
  STENCIL_INDEX: 0x1901,
  STENCIL_INDEX8: 0x8D48,
  DEPTH_STENCIL: 0x84F9,
  RENDERBUFFER_WIDTH: 0x8D42,
  RENDERBUFFER_HEIGHT: 0x8D43,
  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
  RENDERBUFFER_RED_SIZE: 0x8D50,
  RENDERBUFFER_GREEN_SIZE: 0x8D51,
  RENDERBUFFER_BLUE_SIZE: 0x8D52,
  RENDERBUFFER_ALPHA_SIZE: 0x8D53,
  RENDERBUFFER_DEPTH_SIZE: 0x8D54,
  RENDERBUFFER_STENCIL_SIZE: 0x8D55,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
  COLOR_ATTACHMENT0: 0x8CE0,
  DEPTH_ATTACHMENT: 0x8D00,
  STENCIL_ATTACHMENT: 0x8D20,
  DEPTH_STENCIL_ATTACHMENT: 0x821A,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 0x8CD5,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
  FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
  FRAMEBUFFER_BINDING: 0x8CA6,
  RENDERBUFFER_BINDING: 0x8CA7,
  MAX_RENDERBUFFER_SIZE: 0x84E8,
  INVALID_FRAMEBUFFER_OPERATION: 0x0506,

  // Pixel storage modes
  // Constants passed to pixelStorei().

  UNPACK_FLIP_Y_WEBGL: 0x9240,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243
});

// Additional constants defined WebGL 2
// These constants are defined on the WebGL2RenderingContext interface.
// All WebGL 1 constants are also available in a WebGL 2 context.

Object.assign(GL, {
  // Getting GL parameter information
  // Constants passed to getParameter()
  // to specify what information to return.

  READ_BUFFER: 0x0C02,
  UNPACK_ROW_LENGTH: 0x0CF2,
  UNPACK_SKIP_ROWS: 0x0CF3,
  UNPACK_SKIP_PIXELS: 0x0CF4,
  PACK_ROW_LENGTH: 0x0D02,
  PACK_SKIP_ROWS: 0x0D03,
  PACK_SKIP_PIXELS: 0x0D04,
  TEXTURE_BINDING_3D: 0x806A,
  UNPACK_SKIP_IMAGES: 0x806D,
  UNPACK_IMAGE_HEIGHT: 0x806E,
  MAX_3D_TEXTURE_SIZE: 0x8073,
  MAX_ELEMENTS_VERTICES: 0x80E8,
  MAX_ELEMENTS_INDICES: 0x80E9,
  MAX_TEXTURE_LOD_BIAS: 0x84FD,
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49,
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A,
  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF,
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
  MAX_VARYING_COMPONENTS: 0x8B4B,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
  RASTERIZER_DISCARD: 0x8C89,
  VERTEX_ARRAY_BINDING: 0x85B5,
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
  MAX_ELEMENT_INDEX: 0x8D6B,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  RED: 0x1903,
  RGB8: 0x8051,
  RGBA8: 0x8058,
  RGB10_A2: 0x8059,
  TEXTURE_3D: 0x806F,
  TEXTURE_WRAP_R: 0x8072,
  TEXTURE_MIN_LOD: 0x813A,
  TEXTURE_MAX_LOD: 0x813B,
  TEXTURE_BASE_LEVEL: 0x813C,
  TEXTURE_MAX_LEVEL: 0x813D,
  TEXTURE_COMPARE_MODE: 0x884C,
  TEXTURE_COMPARE_FUNC: 0x884D,
  SRGB: 0x8C40,
  SRGB8: 0x8C41,
  SRGB8_ALPHA8: 0x8C43,
  COMPARE_REF_TO_TEXTURE: 0x884E,
  RGBA32F: 0x8814,
  RGB32F: 0x8815,
  RGBA16F: 0x881A,
  RGB16F: 0x881B,
  TEXTURE_2D_ARRAY: 0x8C1A,
  TEXTURE_BINDING_2D_ARRAY: 0x8C1D,
  R11F_G11F_B10F: 0x8C3A,
  RGB9_E5: 0x8C3D,
  RGBA32UI: 0x8D70,
  RGB32UI: 0x8D71,
  RGBA16UI: 0x8D76,
  RGB16UI: 0x8D77,
  RGBA8UI: 0x8D7C,
  RGB8UI: 0x8D7D,
  RGBA32I: 0x8D82,
  RGB32I: 0x8D83,
  RGBA16I: 0x8D88,
  RGB16I: 0x8D89,
  RGBA8I: 0x8D8E,
  RGB8I: 0x8D8F,
  RED_INTEGER: 0x8D94,
  RGB_INTEGER: 0x8D98,
  RGBA_INTEGER: 0x8D99,
  R8: 0x8229,
  RG8: 0x822B,
  R16F: 0x822D,
  R32F: 0x822E,
  RG16F: 0x822F,
  RG32F: 0x8230,
  R8I: 0x8231,
  R8UI: 0x8232,
  R16I: 0x8233,
  R16UI: 0x8234,
  R32I: 0x8235,
  R32UI: 0x8236,
  RG8I: 0x8237,
  RG8UI: 0x8238,
  RG16I: 0x8239,
  RG16UI: 0x823A,
  RG32I: 0x823B,
  RG32UI: 0x823C,
  R8_SNORM: 0x8F94,
  RG8_SNORM: 0x8F95,
  RGB8_SNORM: 0x8F96,
  RGBA8_SNORM: 0x8F97,
  RGB10_A2UI: 0x906F,

  /* covered by extension
  COMPRESSED_R11_EAC : 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC : 0x9273,
  COMPRESSED_RGB8_ETC2 : 0x9274,
  COMPRESSED_SRGB8_ETC2: 0x9275,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 : 0x9276,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC : 0x9277,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : 0x9279,
  */
  TEXTURE_IMMUTABLE_FORMAT: 0x912F,
  TEXTURE_IMMUTABLE_LEVELS: 0x82DF,

  // Pixel types

  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B,
  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E,
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD,
  UNSIGNED_INT_24_8: 0x84FA,
  HALF_FLOAT: 0x140B,
  RG: 0x8227,
  RG_INTEGER: 0x8228,
  INT_2_10_10_10_REV: 0x8D9F,

  // Queries

  CURRENT_QUERY: 0x8865,
  QUERY_RESULT: 0x8866,
  QUERY_RESULT_AVAILABLE: 0x8867,
  ANY_SAMPLES_PASSED: 0x8C2F,
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A,

  // Draw buffers

  MAX_DRAW_BUFFERS: 0x8824,
  DRAW_BUFFER0: 0x8825,
  DRAW_BUFFER1: 0x8826,
  DRAW_BUFFER2: 0x8827,
  DRAW_BUFFER3: 0x8828,
  DRAW_BUFFER4: 0x8829,
  DRAW_BUFFER5: 0x882A,
  DRAW_BUFFER6: 0x882B,
  DRAW_BUFFER7: 0x882C,
  DRAW_BUFFER8: 0x882D,
  DRAW_BUFFER9: 0x882E,
  DRAW_BUFFER10: 0x882F,
  DRAW_BUFFER11: 0x8830,
  DRAW_BUFFER12: 0x8831,
  DRAW_BUFFER13: 0x8832,
  DRAW_BUFFER14: 0x8833,
  DRAW_BUFFER15: 0x8834,
  MAX_COLOR_ATTACHMENTS: 0x8CDF,
  COLOR_ATTACHMENT1: 0x8CE1,
  COLOR_ATTACHMENT2: 0x8CE2,
  COLOR_ATTACHMENT3: 0x8CE3,
  COLOR_ATTACHMENT4: 0x8CE4,
  COLOR_ATTACHMENT5: 0x8CE5,
  COLOR_ATTACHMENT6: 0x8CE6,
  COLOR_ATTACHMENT7: 0x8CE7,
  COLOR_ATTACHMENT8: 0x8CE8,
  COLOR_ATTACHMENT9: 0x8CE9,
  COLOR_ATTACHMENT10: 0x8CEA,
  COLOR_ATTACHMENT11: 0x8CEB,
  COLOR_ATTACHMENT12: 0x8CEC,
  COLOR_ATTACHMENT13: 0x8CED,
  COLOR_ATTACHMENT14: 0x8CEE,
  COLOR_ATTACHMENT15: 0x8CEF,

  // Samplers

  SAMPLER_3D: 0x8B5F,
  SAMPLER_2D_SHADOW: 0x8B62,
  SAMPLER_2D_ARRAY: 0x8DC1,
  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4,
  SAMPLER_CUBE_SHADOW: 0x8DC5,
  INT_SAMPLER_2D: 0x8DCA,
  INT_SAMPLER_3D: 0x8DCB,
  INT_SAMPLER_CUBE: 0x8DCC,
  INT_SAMPLER_2D_ARRAY: 0x8DCF,
  UNSIGNED_INT_SAMPLER_2D: 0x8DD2,
  UNSIGNED_INT_SAMPLER_3D: 0x8DD3,
  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4,
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,
  MAX_SAMPLES: 0x8D57,
  SAMPLER_BINDING: 0x8919,

  // Buffers

  PIXEL_PACK_BUFFER: 0x88EB,
  PIXEL_UNPACK_BUFFER: 0x88EC,
  PIXEL_PACK_BUFFER_BINDING: 0x88ED,
  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF,
  COPY_READ_BUFFER: 0x8F36,
  COPY_WRITE_BUFFER: 0x8F37,
  COPY_READ_BUFFER_BINDING: 0x8F36,
  COPY_WRITE_BUFFER_BINDING: 0x8F37,

  // Data types

  FLOAT_MAT2x3: 0x8B65,
  FLOAT_MAT2x4: 0x8B66,
  FLOAT_MAT3x2: 0x8B67,
  FLOAT_MAT3x4: 0x8B68,
  FLOAT_MAT4x2: 0x8B69,
  FLOAT_MAT4x3: 0x8B6A,
  UNSIGNED_INT_VEC2: 0x8DC6,
  UNSIGNED_INT_VEC3: 0x8DC7,
  UNSIGNED_INT_VEC4: 0x8DC8,
  UNSIGNED_NORMALIZED: 0x8C17,
  SIGNED_NORMALIZED: 0x8F9C,

  // Vertex attributes

  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD,
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE,

  // Transform feedback

  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80,
  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83,
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,
  INTERLEAVED_ATTRIBS: 0x8C8C,
  SEPARATE_ATTRIBS: 0x8C8D,
  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,
  TRANSFORM_FEEDBACK: 0x8E22,
  TRANSFORM_FEEDBACK_PAUSED: 0x8E23,
  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24,
  TRANSFORM_FEEDBACK_BINDING: 0x8E25,

  // Framebuffers and renderbuffers

  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
  FRAMEBUFFER_DEFAULT: 0x8218,
  DEPTH_STENCIL_ATTACHMENT: 0x821A,
  DEPTH_STENCIL: 0x84F9,
  DEPTH24_STENCIL8: 0x88F0,
  DRAW_FRAMEBUFFER_BINDING: 0x8CA6,
  READ_FRAMEBUFFER: 0x8CA8,
  DRAW_FRAMEBUFFER: 0x8CA9,
  READ_FRAMEBUFFER_BINDING: 0x8CAA,
  RENDERBUFFER_SAMPLES: 0x8CAB,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56,

  // Uniforms

  UNIFORM_BUFFER: 0x8A11,
  UNIFORM_BUFFER_BINDING: 0x8A28,
  UNIFORM_BUFFER_START: 0x8A29,
  UNIFORM_BUFFER_SIZE: 0x8A2A,
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B,
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D,
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E,
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F,
  MAX_UNIFORM_BLOCK_SIZE: 0x8A30,
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31,
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33,
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34,
  ACTIVE_UNIFORM_BLOCKS: 0x8A36,
  UNIFORM_TYPE: 0x8A37,
  UNIFORM_SIZE: 0x8A38,
  UNIFORM_BLOCK_INDEX: 0x8A3A,
  UNIFORM_OFFSET: 0x8A3B,
  UNIFORM_ARRAY_STRIDE: 0x8A3C,
  UNIFORM_MATRIX_STRIDE: 0x8A3D,
  UNIFORM_IS_ROW_MAJOR: 0x8A3E,
  UNIFORM_BLOCK_BINDING: 0x8A3F,
  UNIFORM_BLOCK_DATA_SIZE: 0x8A40,
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,

  // Sync objects

  OBJECT_TYPE: 0x9112,
  SYNC_CONDITION: 0x9113,
  SYNC_STATUS: 0x9114,
  SYNC_FLAGS: 0x9115,
  SYNC_FENCE: 0x9116,
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
  UNSIGNALED: 0x9118,
  SIGNALED: 0x9119,
  ALREADY_SIGNALED: 0x911A,
  TIMEOUT_EXPIRED: 0x911B,
  CONDITION_SATISFIED: 0x911C,
  WAIT_FAILED: 0x911D,
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,

  // Miscellaneous constants

  COLOR: 0x1800,
  DEPTH: 0x1801,
  STENCIL: 0x1802,
  MIN: 0x8007,
  MAX: 0x8008,
  DEPTH_COMPONENT24: 0x81A6,
  STREAM_READ: 0x88E1,
  STREAM_COPY: 0x88E2,
  STATIC_READ: 0x88E5,
  STATIC_COPY: 0x88E6,
  DYNAMIC_READ: 0x88E9,
  DYNAMIC_COPY: 0x88EA,
  DEPTH_COMPONENT32F: 0x8CAC,
  DEPTH32F_STENCIL8: 0x8CAD,
  INVALID_INDEX: 0xFFFFFFFF,
  TIMEOUT_IGNORED: -1,
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,

  // Constants defined in WebGL extensions

  // ANGLE_instanced_arrays

  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE, // Describes the frequency divisor used for instanced rendering.

  // WEBGL_debug_renderer_info

  UNMASKED_VENDOR_WEBGL: 0x9245, // Passed to getParameter to get the vendor string of the graphics driver.
  UNMASKED_RENDERER_WEBGL: 0x9246, // Passed to getParameter to get the renderer string of the graphics driver.

  // EXT_texture_filter_anisotropic

  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF, // Returns the maximum available anisotropy.
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE, // Passed to texParameter to set the desired maximum anisotropy for a texture.

  // WEBGL_compressed_texture_s3tc

  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0, // A DXT1-compressed image in an RGB image format.
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1, // A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2, // A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3, // A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done.

  // WEBGL_compressed_texture_es3

  COMPRESSED_R11_EAC: 0x9270, // One-channel (red) unsigned format compression.
  COMPRESSED_SIGNED_R11_EAC: 0x9271, // One-channel (red) signed format compression.
  COMPRESSED_RG11_EAC: 0x9272, // Two-channel (red and green) unsigned format compression.
  COMPRESSED_SIGNED_RG11_EAC: 0x9273, // Two-channel (red and green) signed format compression.
  COMPRESSED_RGB8_ETC2: 0x9274, // Compresses RBG8 data with no alpha channel.
  COMPRESSED_RGBA8_ETC2_EAC: 0x9275, // Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately.
  COMPRESSED_SRGB8_ETC2: 0x9276, // Compresses sRBG8 data with no alpha channel.
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277, // Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately.
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278, // Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279, // Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.

  // WEBGL_compressed_texture_pvrtc

  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00, // RGB compression in 4-bit mode. One block for each 44 pixels.
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02, // RGBA compression in 4-bit mode. One block for each 44 pixels.
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01, // RGB compression in 2-bit mode. One block for each 84 pixels.
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03, // RGBA compression in 2-bit mode. One block for each 84 pixe

  // WEBGL_compressed_texture_etc1

  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64, // Compresses 24-bit RGB data with no alpha channel.

  // WEBGL_compressed_texture_atc

  COMPRESSED_RGB_ATC_WEBGL: 0x8C92, //  Compresses RGB textures with no alpha channel.
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8C92, // Compresses RGBA textures using explicit alpha encoding (useful when alpha transitions are sharp).
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87EE, // Compresses RGBA textures using interpolated alpha encoding (useful when alpha transitions are gradient).

  // WEBGL_depth_texture

  UNSIGNED_INT_24_8_WEBGL: 0x84FA, // Unsigned integer type for 24-bit depth texture data.

  // OES_texture_half_float

  HALF_FLOAT_OES: 0x8D61, // Half floating-point type (16-bit).

  // WEBGL_color_buffer_float

  RGBA32F_EXT: 0x8814, // RGBA 32-bit floating-point color-renderable format.
  RGB32F_EXT: 0x8815, // RGB 32-bit floating-point color-renderable format.
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
  UNSIGNED_NORMALIZED_EXT: 0x8C17,

  // EXT_blend_minmax

  MIN_EXT: 0x8007, // Produces the minimum color components of the source and destination colors.
  MAX_EXT: 0x8008, // Produces the maximum color components of the source and destination colors.

  // EXT_sRGB

  SRGB_EXT: 0x8C40, // Unsized sRGB format that leaves the precision up to the driver.
  SRGB_ALPHA_EXT: 0x8C42, // Unsized sRGB format with unsized alpha component.
  SRGB8_ALPHA8_EXT: 0x8C43, // Sized (8-bit) sRGB and alpha formats.
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210, // Returns the framebuffer color encoding.

  // OES_standard_derivatives

  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B, // Indicates the accuracy of the derivative calculation for the GLSL built-in functions: dFdx, dFdy, and fwidth.

  // WEBGL_draw_buffers

  COLOR_ATTACHMENT0_WEBGL: 0x8CE0, // Framebuffer color attachment point
  COLOR_ATTACHMENT1_WEBGL: 0x8CE1, // Framebuffer color attachment point
  COLOR_ATTACHMENT2_WEBGL: 0x8CE2, // Framebuffer color attachment point
  COLOR_ATTACHMENT3_WEBGL: 0x8CE3, // Framebuffer color attachment point
  COLOR_ATTACHMENT4_WEBGL: 0x8CE4, // Framebuffer color attachment point
  COLOR_ATTACHMENT5_WEBGL: 0x8CE5, // Framebuffer color attachment point
  COLOR_ATTACHMENT6_WEBGL: 0x8CE6, // Framebuffer color attachment point
  COLOR_ATTACHMENT7_WEBGL: 0x8CE7, // Framebuffer color attachment point
  COLOR_ATTACHMENT8_WEBGL: 0x8CE8, // Framebuffer color attachment point
  COLOR_ATTACHMENT9_WEBGL: 0x8CE9, // Framebuffer color attachment point
  COLOR_ATTACHMENT10_WEBGL: 0x8CEA, // Framebuffer color attachment point
  COLOR_ATTACHMENT11_WEBGL: 0x8CEB, // Framebuffer color attachment point
  COLOR_ATTACHMENT12_WEBGL: 0x8CEC, // Framebuffer color attachment point
  COLOR_ATTACHMENT13_WEBGL: 0x8CED, // Framebuffer color attachment point
  COLOR_ATTACHMENT14_WEBGL: 0x8CEE, // Framebuffer color attachment point
  COLOR_ATTACHMENT15_WEBGL: 0x8CEF, // Framebuffer color attachment point
  DRAW_BUFFER0_WEBGL: 0x8825, // Draw buffer
  DRAW_BUFFER1_WEBGL: 0x8826, // Draw buffer
  DRAW_BUFFER2_WEBGL: 0x8827, // Draw buffer
  DRAW_BUFFER3_WEBGL: 0x8828, // Draw buffer
  DRAW_BUFFER4_WEBGL: 0x8829, // Draw buffer
  DRAW_BUFFER5_WEBGL: 0x882A, // Draw buffer
  DRAW_BUFFER6_WEBGL: 0x882B, // Draw buffer
  DRAW_BUFFER7_WEBGL: 0x882C, // Draw buffer
  DRAW_BUFFER8_WEBGL: 0x882D, // Draw buffer
  DRAW_BUFFER9_WEBGL: 0x882E, // Draw buffer
  DRAW_BUFFER10_WEBGL: 0x882F, // Draw buffer
  DRAW_BUFFER11_WEBGL: 0x8830, // Draw buffer
  DRAW_BUFFER12_WEBGL: 0x8831, // Draw buffer
  DRAW_BUFFER13_WEBGL: 0x8832, // Draw buffer
  DRAW_BUFFER14_WEBGL: 0x8833, // Draw buffer
  DRAW_BUFFER15_WEBGL: 0x8834, // Draw buffer
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF, // Maximum number of framebuffer color attachment points
  MAX_DRAW_BUFFERS_WEBGL: 0x8824, // Maximum number of draw buffers

  // OES_vertex_array_object

  VERTEX_ARRAY_BINDING_OES: 0x85B5, // The bound vertex array object (VAO).

  // EXT_disjoint_timer_query

  QUERY_COUNTER_BITS_EXT: 0x8864, // The number of bits used to hold the query result for the given target.
  CURRENT_QUERY_EXT: 0x8865, // The currently active query.
  QUERY_RESULT_EXT: 0x8866, // The query result.
  QUERY_RESULT_AVAILABLE_EXT: 0x8867, // A Boolean indicating whether or not a query result is available.
  TIME_ELAPSED_EXT: 0x88BF, // Elapsed time (in nanoseconds).
  TIMESTAMP_EXT: 0x8E28, // The current time.
  GPU_DISJOINT_EXT: 0x8FBB // A Boolean indicating whether or not the GPU performed any disjoint operation.
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9nbC1jb25zdGFudHMuanMiXSwibmFtZXMiOlsiYXNzZXJ0IiwiR0wiLCJnbEdldCIsIm5hbWUiLCJudW1iZXIiLCJOdW1iZXIiLCJpc05hTiIsInJlcGxhY2UiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImdsS2V5Iiwia2V5IiwiU3RyaW5nIiwiT2JqZWN0IiwiYXNzaWduIiwiREVQVEhfQlVGRkVSX0JJVCIsIlNURU5DSUxfQlVGRkVSX0JJVCIsIkNPTE9SX0JVRkZFUl9CSVQiLCJQT0lOVFMiLCJMSU5FUyIsIkxJTkVfTE9PUCIsIkxJTkVfU1RSSVAiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsIlpFUk8iLCJPTkUiLCJTUkNfQ09MT1IiLCJPTkVfTUlOVVNfU1JDX0NPTE9SIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsIkRTVF9BTFBIQSIsIk9ORV9NSU5VU19EU1RfQUxQSEEiLCJEU1RfQ09MT1IiLCJPTkVfTUlOVVNfRFNUX0NPTE9SIiwiU1JDX0FMUEhBX1NBVFVSQVRFIiwiQ09OU1RBTlRfQ09MT1IiLCJPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IiLCJDT05TVEFOVF9BTFBIQSIsIk9ORV9NSU5VU19DT05TVEFOVF9BTFBIQSIsIkZVTkNfQUREIiwiRlVOQ19TVUJTVFJBQ1QiLCJGVU5DX1JFVkVSU0VfU1VCVFJBQ1QiLCJCTEVORF9FUVVBVElPTiIsIkJMRU5EX0VRVUFUSU9OX1JHQiIsIkJMRU5EX0VRVUFUSU9OX0FMUEhBIiwiQkxFTkRfRFNUX1JHQiIsIkJMRU5EX1NSQ19SR0IiLCJCTEVORF9EU1RfQUxQSEEiLCJCTEVORF9TUkNfQUxQSEEiLCJCTEVORF9DT0xPUiIsIkFSUkFZX0JVRkZFUl9CSU5ESU5HIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORyIsIkxJTkVfV0lEVEgiLCJBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UiLCJBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UiLCJDVUxMX0ZBQ0VfTU9ERSIsIkZST05UX0ZBQ0UiLCJERVBUSF9SQU5HRSIsIkRFUFRIX1dSSVRFTUFTSyIsIkRFUFRIX0NMRUFSX1ZBTFVFIiwiREVQVEhfRlVOQyIsIlNURU5DSUxfQ0xFQVJfVkFMVUUiLCJTVEVOQ0lMX0ZVTkMiLCJTVEVOQ0lMX0ZBSUwiLCJTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCIsIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9SRUYiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX1dSSVRFTUFTSyIsIlNURU5DSUxfQkFDS19GVU5DIiwiU1RFTkNJTF9CQUNLX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMIiwiU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUyIsIlNURU5DSUxfQkFDS19SRUYiLCJTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSyIsIlNURU5DSUxfQkFDS19XUklURU1BU0siLCJWSUVXUE9SVCIsIlNDSVNTT1JfQk9YIiwiQ09MT1JfQ0xFQVJfVkFMVUUiLCJDT0xPUl9XUklURU1BU0siLCJVTlBBQ0tfQUxJR05NRU5UIiwiUEFDS19BTElHTk1FTlQiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTUFYX1ZJRVdQT1JUX0RJTVMiLCJTVUJQSVhFTF9CSVRTIiwiUkVEX0JJVFMiLCJHUkVFTl9CSVRTIiwiQkxVRV9CSVRTIiwiQUxQSEFfQklUUyIsIkRFUFRIX0JJVFMiLCJTVEVOQ0lMX0JJVFMiLCJQT0xZR09OX09GRlNFVF9VTklUUyIsIlBPTFlHT05fT0ZGU0VUX0ZBQ1RPUiIsIlRFWFRVUkVfQklORElOR18yRCIsIlNBTVBMRV9CVUZGRVJTIiwiU0FNUExFUyIsIlNBTVBMRV9DT1ZFUkFHRV9WQUxVRSIsIlNBTVBMRV9DT1ZFUkFHRV9JTlZFUlQiLCJDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyIsIlZFTkRPUiIsIlJFTkRFUkVSIiwiVkVSU0lPTiIsIklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSIsIklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUIiwiQlJPV1NFUl9ERUZBVUxUX1dFQkdMIiwiU1RBVElDX0RSQVciLCJTVFJFQU1fRFJBVyIsIkRZTkFNSUNfRFJBVyIsIkFSUkFZX0JVRkZFUiIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiQlVGRkVSX1NJWkUiLCJCVUZGRVJfVVNBR0UiLCJDVVJSRU5UX1ZFUlRFWF9BVFRSSUIiLCJWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQiLCJWRVJURVhfQVRUUklCX0FSUkFZX1NJWkUiLCJWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkciLCJDVUxMX0ZBQ0UiLCJGUk9OVCIsIkJBQ0siLCJGUk9OVF9BTkRfQkFDSyIsIkJMRU5EIiwiREVQVEhfVEVTVCIsIkRJVEhFUiIsIlBPTFlHT05fT0ZGU0VUX0ZJTEwiLCJTQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UiLCJTQU1QTEVfQ09WRVJBR0UiLCJTQ0lTU09SX1RFU1QiLCJTVEVOQ0lMX1RFU1QiLCJOT19FUlJPUiIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfVkFMVUUiLCJJTlZBTElEX09QRVJBVElPTiIsIk9VVF9PRl9NRU1PUlkiLCJDT05URVhUX0xPU1RfV0VCR0wiLCJDVyIsIkNDVyIsIkRPTlRfQ0FSRSIsIkZBU1RFU1QiLCJOSUNFU1QiLCJHRU5FUkFURV9NSVBNQVBfSElOVCIsIkJZVEUiLCJVTlNJR05FRF9CWVRFIiwiU0hPUlQiLCJVTlNJR05FRF9TSE9SVCIsIklOVCIsIlVOU0lHTkVEX0lOVCIsIkZMT0FUIiwiREVQVEhfQ09NUE9ORU5UIiwiQUxQSEEiLCJSR0IiLCJSR0JBIiwiTFVNSU5BTkNFIiwiTFVNSU5BTkNFX0FMUEhBIiwiVU5TSUdORURfU0hPUlRfNF80XzRfNCIsIlVOU0lHTkVEX1NIT1JUXzVfNV81XzEiLCJVTlNJR05FRF9TSE9SVF81XzZfNSIsIkZSQUdNRU5UX1NIQURFUiIsIlZFUlRFWF9TSEFERVIiLCJDT01QSUxFX1NUQVRVUyIsIkRFTEVURV9TVEFUVVMiLCJMSU5LX1NUQVRVUyIsIlZBTElEQVRFX1NUQVRVUyIsIkFUVEFDSEVEX1NIQURFUlMiLCJBQ1RJVkVfQVRUUklCVVRFUyIsIkFDVElWRV9VTklGT1JNUyIsIk1BWF9WRVJURVhfQVRUUklCUyIsIk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTIiwiTUFYX1ZBUllJTkdfVkVDVE9SUyIsIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTIiwiU0hBREVSX1RZUEUiLCJTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04iLCJDVVJSRU5UX1BST0dSQU0iLCJORVZFUiIsIkFMV0FZUyIsIkxFU1MiLCJFUVVBTCIsIkxFUVVBTCIsIkdSRUFURVIiLCJHRVFVQUwiLCJOT1RFUVVBTCIsIktFRVAiLCJSRVBMQUNFIiwiSU5DUiIsIkRFQ1IiLCJJTlZFUlQiLCJJTkNSX1dSQVAiLCJERUNSX1dSQVAiLCJORUFSRVNUIiwiTElORUFSIiwiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsIk5FQVJFU1RfTUlQTUFQX0xJTkVBUiIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJURVhUVVJFX1dSQVBfVCIsIlRFWFRVUkVfMkQiLCJURVhUVVJFIiwiVEVYVFVSRV9DVUJFX01BUCIsIlRFWFRVUkVfQklORElOR19DVUJFX01BUCIsIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCIsIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCIsIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSIsIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSIsIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiIsIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiIsIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUiLCJURVhUVVJFMCIsIkFDVElWRV9URVhUVVJFIiwiUkVQRUFUIiwiQ0xBTVBfVE9fRURHRSIsIk1JUlJPUkVEX1JFUEVBVCIsIlRFWFRVUkVfV0lEVEgiLCJURVhUVVJFX0hFSUdIVCIsIkZMT0FUX1ZFQzIiLCJGTE9BVF9WRUMzIiwiRkxPQVRfVkVDNCIsIklOVF9WRUMyIiwiSU5UX1ZFQzMiLCJJTlRfVkVDNCIsIkJPT0wiLCJCT09MX1ZFQzIiLCJCT09MX1ZFQzMiLCJCT09MX1ZFQzQiLCJGTE9BVF9NQVQyIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJTQU1QTEVSXzJEIiwiU0FNUExFUl9DVUJFIiwiTE9XX0ZMT0FUIiwiTUVESVVNX0ZMT0FUIiwiSElHSF9GTE9BVCIsIkxPV19JTlQiLCJNRURJVU1fSU5UIiwiSElHSF9JTlQiLCJGUkFNRUJVRkZFUiIsIlJFTkRFUkJVRkZFUiIsIlJHQkE0IiwiUkdCNV9BMSIsIlJHQjU2NSIsIkRFUFRIX0NPTVBPTkVOVDE2IiwiU1RFTkNJTF9JTkRFWCIsIlNURU5DSUxfSU5ERVg4IiwiREVQVEhfU1RFTkNJTCIsIlJFTkRFUkJVRkZFUl9XSURUSCIsIlJFTkRFUkJVRkZFUl9IRUlHSFQiLCJSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUIiwiUkVOREVSQlVGRkVSX1JFRF9TSVpFIiwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkUiLCJSRU5ERVJCVUZGRVJfQkxVRV9TSVpFIiwiUkVOREVSQlVGRkVSX0FMUEhBX1NJWkUiLCJSRU5ERVJCVUZGRVJfREVQVEhfU0laRSIsIlJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJERVBUSF9BVFRBQ0hNRU5UIiwiU1RFTkNJTF9BVFRBQ0hNRU5UIiwiREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIiwiTk9ORSIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCIsIkZSQU1FQlVGRkVSX0JJTkRJTkciLCJSRU5ERVJCVUZGRVJfQklORElORyIsIk1BWF9SRU5ERVJCVUZGRVJfU0laRSIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiVU5QQUNLX0ZMSVBfWV9XRUJHTCIsIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCIsIlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wiLCJSRUFEX0JVRkZFUiIsIlVOUEFDS19ST1dfTEVOR1RIIiwiVU5QQUNLX1NLSVBfUk9XUyIsIlVOUEFDS19TS0lQX1BJWEVMUyIsIlBBQ0tfUk9XX0xFTkdUSCIsIlBBQ0tfU0tJUF9ST1dTIiwiUEFDS19TS0lQX1BJWEVMUyIsIlRFWFRVUkVfQklORElOR18zRCIsIlVOUEFDS19TS0lQX0lNQUdFUyIsIlVOUEFDS19JTUFHRV9IRUlHSFQiLCJNQVhfM0RfVEVYVFVSRV9TSVpFIiwiTUFYX0VMRU1FTlRTX1ZFUlRJQ0VTIiwiTUFYX0VMRU1FTlRTX0lORElDRVMiLCJNQVhfVEVYVFVSRV9MT0RfQklBUyIsIk1BWF9GUkFHTUVOVF9VTklGT1JNX0NPTVBPTkVOVFMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UUyIsIk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyIsIk1JTl9QUk9HUkFNX1RFWEVMX09GRlNFVCIsIk1BWF9QUk9HUkFNX1RFWEVMX09GRlNFVCIsIk1BWF9WQVJZSU5HX0NPTVBPTkVOVFMiLCJGUkFHTUVOVF9TSEFERVJfREVSSVZBVElWRV9ISU5UIiwiUkFTVEVSSVpFUl9ESVNDQVJEIiwiVkVSVEVYX0FSUkFZX0JJTkRJTkciLCJNQVhfVkVSVEVYX09VVFBVVF9DT01QT05FTlRTIiwiTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFMiLCJNQVhfU0VSVkVSX1dBSVRfVElNRU9VVCIsIk1BWF9FTEVNRU5UX0lOREVYIiwiUkVEIiwiUkdCOCIsIlJHQkE4IiwiUkdCMTBfQTIiLCJURVhUVVJFXzNEIiwiVEVYVFVSRV9XUkFQX1IiLCJURVhUVVJFX01JTl9MT0QiLCJURVhUVVJFX01BWF9MT0QiLCJURVhUVVJFX0JBU0VfTEVWRUwiLCJURVhUVVJFX01BWF9MRVZFTCIsIlRFWFRVUkVfQ09NUEFSRV9NT0RFIiwiVEVYVFVSRV9DT01QQVJFX0ZVTkMiLCJTUkdCIiwiU1JHQjgiLCJTUkdCOF9BTFBIQTgiLCJDT01QQVJFX1JFRl9UT19URVhUVVJFIiwiUkdCQTMyRiIsIlJHQjMyRiIsIlJHQkExNkYiLCJSR0IxNkYiLCJURVhUVVJFXzJEX0FSUkFZIiwiVEVYVFVSRV9CSU5ESU5HXzJEX0FSUkFZIiwiUjExRl9HMTFGX0IxMEYiLCJSR0I5X0U1IiwiUkdCQTMyVUkiLCJSR0IzMlVJIiwiUkdCQTE2VUkiLCJSR0IxNlVJIiwiUkdCQThVSSIsIlJHQjhVSSIsIlJHQkEzMkkiLCJSR0IzMkkiLCJSR0JBMTZJIiwiUkdCMTZJIiwiUkdCQThJIiwiUkdCOEkiLCJSRURfSU5URUdFUiIsIlJHQl9JTlRFR0VSIiwiUkdCQV9JTlRFR0VSIiwiUjgiLCJSRzgiLCJSMTZGIiwiUjMyRiIsIlJHMTZGIiwiUkczMkYiLCJSOEkiLCJSOFVJIiwiUjE2SSIsIlIxNlVJIiwiUjMySSIsIlIzMlVJIiwiUkc4SSIsIlJHOFVJIiwiUkcxNkkiLCJSRzE2VUkiLCJSRzMySSIsIlJHMzJVSSIsIlI4X1NOT1JNIiwiUkc4X1NOT1JNIiwiUkdCOF9TTk9STSIsIlJHQkE4X1NOT1JNIiwiUkdCMTBfQTJVSSIsIlRFWFRVUkVfSU1NVVRBQkxFX0ZPUk1BVCIsIlRFWFRVUkVfSU1NVVRBQkxFX0xFVkVMUyIsIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViIsIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYiLCJVTlNJR05FRF9JTlRfNV85XzlfOV9SRVYiLCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYiLCJVTlNJR05FRF9JTlRfMjRfOCIsIkhBTEZfRkxPQVQiLCJSRyIsIlJHX0lOVEVHRVIiLCJJTlRfMl8xMF8xMF8xMF9SRVYiLCJDVVJSRU5UX1FVRVJZIiwiUVVFUllfUkVTVUxUIiwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRSIsIkFOWV9TQU1QTEVTX1BBU1NFRCIsIkFOWV9TQU1QTEVTX1BBU1NFRF9DT05TRVJWQVRJVkUiLCJNQVhfRFJBV19CVUZGRVJTIiwiRFJBV19CVUZGRVIwIiwiRFJBV19CVUZGRVIxIiwiRFJBV19CVUZGRVIyIiwiRFJBV19CVUZGRVIzIiwiRFJBV19CVUZGRVI0IiwiRFJBV19CVUZGRVI1IiwiRFJBV19CVUZGRVI2IiwiRFJBV19CVUZGRVI3IiwiRFJBV19CVUZGRVI4IiwiRFJBV19CVUZGRVI5IiwiRFJBV19CVUZGRVIxMCIsIkRSQVdfQlVGRkVSMTEiLCJEUkFXX0JVRkZFUjEyIiwiRFJBV19CVUZGRVIxMyIsIkRSQVdfQlVGRkVSMTQiLCJEUkFXX0JVRkZFUjE1IiwiTUFYX0NPTE9SX0FUVEFDSE1FTlRTIiwiQ09MT1JfQVRUQUNITUVOVDEiLCJDT0xPUl9BVFRBQ0hNRU5UMiIsIkNPTE9SX0FUVEFDSE1FTlQzIiwiQ09MT1JfQVRUQUNITUVOVDQiLCJDT0xPUl9BVFRBQ0hNRU5UNSIsIkNPTE9SX0FUVEFDSE1FTlQ2IiwiQ09MT1JfQVRUQUNITUVOVDciLCJDT0xPUl9BVFRBQ0hNRU5UOCIsIkNPTE9SX0FUVEFDSE1FTlQ5IiwiQ09MT1JfQVRUQUNITUVOVDEwIiwiQ09MT1JfQVRUQUNITUVOVDExIiwiQ09MT1JfQVRUQUNITUVOVDEyIiwiQ09MT1JfQVRUQUNITUVOVDEzIiwiQ09MT1JfQVRUQUNITUVOVDE0IiwiQ09MT1JfQVRUQUNITUVOVDE1IiwiU0FNUExFUl8zRCIsIlNBTVBMRVJfMkRfU0hBRE9XIiwiU0FNUExFUl8yRF9BUlJBWSIsIlNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XIiwiU0FNUExFUl9DVUJFX1NIQURPVyIsIklOVF9TQU1QTEVSXzJEIiwiSU5UX1NBTVBMRVJfM0QiLCJJTlRfU0FNUExFUl9DVUJFIiwiSU5UX1NBTVBMRVJfMkRfQVJSQVkiLCJVTlNJR05FRF9JTlRfU0FNUExFUl8yRCIsIlVOU0lHTkVEX0lOVF9TQU1QTEVSXzNEIiwiVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRSIsIlVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZIiwiTUFYX1NBTVBMRVMiLCJTQU1QTEVSX0JJTkRJTkciLCJQSVhFTF9QQUNLX0JVRkZFUiIsIlBJWEVMX1VOUEFDS19CVUZGRVIiLCJQSVhFTF9QQUNLX0JVRkZFUl9CSU5ESU5HIiwiUElYRUxfVU5QQUNLX0JVRkZFUl9CSU5ESU5HIiwiQ09QWV9SRUFEX0JVRkZFUiIsIkNPUFlfV1JJVEVfQlVGRkVSIiwiQ09QWV9SRUFEX0JVRkZFUl9CSU5ESU5HIiwiQ09QWV9XUklURV9CVUZGRVJfQklORElORyIsIkZMT0FUX01BVDJ4MyIsIkZMT0FUX01BVDJ4NCIsIkZMT0FUX01BVDN4MiIsIkZMT0FUX01BVDN4NCIsIkZMT0FUX01BVDR4MiIsIkZMT0FUX01BVDR4MyIsIlVOU0lHTkVEX0lOVF9WRUMyIiwiVU5TSUdORURfSU5UX1ZFQzMiLCJVTlNJR05FRF9JTlRfVkVDNCIsIlVOU0lHTkVEX05PUk1BTElaRUQiLCJTSUdORURfTk9STUFMSVpFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfSU5URUdFUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUiIsIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfTU9ERSIsIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfU0VQQVJBVEVfQ09NUE9ORU5UUyIsIlRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyIsIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU1RBUlQiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX1NJWkUiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19JTlRFUkxFQVZFRF9DT01QT05FTlRTIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTIiwiSU5URVJMRUFWRURfQVRUUklCUyIsIlNFUEFSQVRFX0FUVFJJQlMiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIiwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9CSU5ESU5HIiwiVFJBTlNGT1JNX0ZFRURCQUNLIiwiVFJBTlNGT1JNX0ZFRURCQUNLX1BBVVNFRCIsIlRSQU5TRk9STV9GRUVEQkFDS19BQ1RJVkUiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQklORElORyIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkciLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9SRURfU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfR1JFRU5fU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9BTFBIQV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9ERVBUSF9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkUiLCJGUkFNRUJVRkZFUl9ERUZBVUxUIiwiREVQVEgyNF9TVEVOQ0lMOCIsIkRSQVdfRlJBTUVCVUZGRVJfQklORElORyIsIlJFQURfRlJBTUVCVUZGRVIiLCJEUkFXX0ZSQU1FQlVGRkVSIiwiUkVBRF9GUkFNRUJVRkZFUl9CSU5ESU5HIiwiUkVOREVSQlVGRkVSX1NBTVBMRVMiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEFZRVIiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFIiwiVU5JRk9STV9CVUZGRVIiLCJVTklGT1JNX0JVRkZFUl9CSU5ESU5HIiwiVU5JRk9STV9CVUZGRVJfU1RBUlQiLCJVTklGT1JNX0JVRkZFUl9TSVpFIiwiTUFYX1ZFUlRFWF9VTklGT1JNX0JMT0NLUyIsIk1BWF9GUkFHTUVOVF9VTklGT1JNX0JMT0NLUyIsIk1BWF9DT01CSU5FRF9VTklGT1JNX0JMT0NLUyIsIk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyIsIk1BWF9VTklGT1JNX0JMT0NLX1NJWkUiLCJNQVhfQ09NQklORURfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UUyIsIk1BWF9DT01CSU5FRF9GUkFHTUVOVF9VTklGT1JNX0NPTVBPTkVOVFMiLCJVTklGT1JNX0JVRkZFUl9PRkZTRVRfQUxJR05NRU5UIiwiQUNUSVZFX1VOSUZPUk1fQkxPQ0tTIiwiVU5JRk9STV9UWVBFIiwiVU5JRk9STV9TSVpFIiwiVU5JRk9STV9CTE9DS19JTkRFWCIsIlVOSUZPUk1fT0ZGU0VUIiwiVU5JRk9STV9BUlJBWV9TVFJJREUiLCJVTklGT1JNX01BVFJJWF9TVFJJREUiLCJVTklGT1JNX0lTX1JPV19NQUpPUiIsIlVOSUZPUk1fQkxPQ0tfQklORElORyIsIlVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFIiwiVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STVMiLCJVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVMiLCJVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfVkVSVEVYX1NIQURFUiIsIlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVIiLCJPQkpFQ1RfVFlQRSIsIlNZTkNfQ09ORElUSU9OIiwiU1lOQ19TVEFUVVMiLCJTWU5DX0ZMQUdTIiwiU1lOQ19GRU5DRSIsIlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFIiwiVU5TSUdOQUxFRCIsIlNJR05BTEVEIiwiQUxSRUFEWV9TSUdOQUxFRCIsIlRJTUVPVVRfRVhQSVJFRCIsIkNPTkRJVElPTl9TQVRJU0ZJRUQiLCJXQUlUX0ZBSUxFRCIsIlNZTkNfRkxVU0hfQ09NTUFORFNfQklUIiwiQ09MT1IiLCJERVBUSCIsIlNURU5DSUwiLCJNSU4iLCJNQVgiLCJERVBUSF9DT01QT05FTlQyNCIsIlNUUkVBTV9SRUFEIiwiU1RSRUFNX0NPUFkiLCJTVEFUSUNfUkVBRCIsIlNUQVRJQ19DT1BZIiwiRFlOQU1JQ19SRUFEIiwiRFlOQU1JQ19DT1BZIiwiREVQVEhfQ09NUE9ORU5UMzJGIiwiREVQVEgzMkZfU1RFTkNJTDgiLCJJTlZBTElEX0lOREVYIiwiVElNRU9VVF9JR05PUkVEIiwiTUFYX0NMSUVOVF9XQUlUX1RJTUVPVVRfV0VCR0wiLCJWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JfQU5HTEUiLCJVTk1BU0tFRF9WRU5ET1JfV0VCR0wiLCJVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCIsIk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCIsIlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwiQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCIsIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUIiwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQiLCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCIsIkNPTVBSRVNTRURfUjExX0VBQyIsIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMiLCJDT01QUkVTU0VEX1JHMTFfRUFDIiwiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUMiLCJDT01QUkVTU0VEX1JHQjhfRVRDMiIsIkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUMiLCJDT01QUkVTU0VEX1NSR0I4X0VUQzIiLCJDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyIsIkNPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIiLCJDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMiIsIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUciLCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyIsIkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUciLCJDT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRyIsIkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wiLCJDT01QUkVTU0VEX1JHQl9BVENfV0VCR0wiLCJDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMIiwiQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0wiLCJVTlNJR05FRF9JTlRfMjRfOF9XRUJHTCIsIkhBTEZfRkxPQVRfT0VTIiwiUkdCQTMyRl9FWFQiLCJSR0IzMkZfRVhUIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT01QT05FTlRfVFlQRV9FWFQiLCJVTlNJR05FRF9OT1JNQUxJWkVEX0VYVCIsIk1JTl9FWFQiLCJNQVhfRVhUIiwiU1JHQl9FWFQiLCJTUkdCX0FMUEhBX0VYVCIsIlNSR0I4X0FMUEhBOF9FWFQiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTE9SX0VOQ09ESU5HX0VYVCIsIkZSQUdNRU5UX1NIQURFUl9ERVJJVkFUSVZFX0hJTlRfT0VTIiwiQ09MT1JfQVRUQUNITUVOVDBfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMV9XRUJHTCIsIkNPTE9SX0FUVEFDSE1FTlQyX1dFQkdMIiwiQ09MT1JfQVRUQUNITUVOVDNfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UNF9XRUJHTCIsIkNPTE9SX0FUVEFDSE1FTlQ1X1dFQkdMIiwiQ09MT1JfQVRUQUNITUVOVDZfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UN19XRUJHTCIsIkNPTE9SX0FUVEFDSE1FTlQ4X1dFQkdMIiwiQ09MT1JfQVRUQUNITUVOVDlfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTBfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTFfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTJfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTNfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTRfV0VCR0wiLCJDT0xPUl9BVFRBQ0hNRU5UMTVfV0VCR0wiLCJEUkFXX0JVRkZFUjBfV0VCR0wiLCJEUkFXX0JVRkZFUjFfV0VCR0wiLCJEUkFXX0JVRkZFUjJfV0VCR0wiLCJEUkFXX0JVRkZFUjNfV0VCR0wiLCJEUkFXX0JVRkZFUjRfV0VCR0wiLCJEUkFXX0JVRkZFUjVfV0VCR0wiLCJEUkFXX0JVRkZFUjZfV0VCR0wiLCJEUkFXX0JVRkZFUjdfV0VCR0wiLCJEUkFXX0JVRkZFUjhfV0VCR0wiLCJEUkFXX0JVRkZFUjlfV0VCR0wiLCJEUkFXX0JVRkZFUjEwX1dFQkdMIiwiRFJBV19CVUZGRVIxMV9XRUJHTCIsIkRSQVdfQlVGRkVSMTJfV0VCR0wiLCJEUkFXX0JVRkZFUjEzX1dFQkdMIiwiRFJBV19CVUZGRVIxNF9XRUJHTCIsIkRSQVdfQlVGRkVSMTVfV0VCR0wiLCJNQVhfQ09MT1JfQVRUQUNITUVOVFNfV0VCR0wiLCJNQVhfRFJBV19CVUZGRVJTX1dFQkdMIiwiVkVSVEVYX0FSUkFZX0JJTkRJTkdfT0VTIiwiUVVFUllfQ09VTlRFUl9CSVRTX0VYVCIsIkNVUlJFTlRfUVVFUllfRVhUIiwiUVVFUllfUkVTVUxUX0VYVCIsIlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUIiwiVElNRV9FTEFQU0VEX0VYVCIsIlRJTUVTVEFNUF9FWFQiLCJHUFVfRElTSk9JTlRfRVhUIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkI7O0FB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LHVCQUFxQixNQXZiTCxFQXViYTtBQUM3QkMsdUJBQXFCLE1BeGJMLEVBd2JhO0FBQzdCQyx1QkFBcUIsTUF6YkwsRUF5YmE7QUFDN0JDLHVCQUFxQixNQTFiTCxFQTBiYTtBQUM3QkMsK0JBQTZCLE1BM2JiLEVBMmJxQjtBQUNyQ0MsMEJBQXlCLE1BNWJULEVBNGJpQjs7QUFFakM7O0FBRUFDLDRCQUEyQixNQWhjWCxFQWdjbUI7O0FBRW5DOztBQUVBQywwQkFBeUIsTUFwY1QsRUFvY2lCO0FBQ2pDQyxxQkFBbUIsTUFyY0gsRUFxY1c7QUFDM0JDLG9CQUFtQixNQXRjSCxFQXNjVztBQUMzQkMsOEJBQTZCLE1BdmNiLEVBdWNxQjtBQUNyQ0Msb0JBQW1CLE1BeGNILEVBd2NXO0FBQzNCQyxpQkFBZSxNQXpjQyxFQXljTztBQUN2QkMsb0JBQW1CLE1BMWNILENBMGNVO0FBMWNWLENBQWxCIiwiZmlsZSI6ImdsLWNvbnN0YW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdFQkdMIEJVSUxULUlOIFRZUEVTXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmV4cG9ydCBjb25zdCBHTCA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgR0w7XG5cbi8vIFJlc29sdmUgYSBXZWJHTCBlbnVtZXJhdGlvbiBuYW1lIChyZXR1cm5zIGl0c2VsZiBpZiBhbHJlYWR5IGEgbnVtYmVyKVxuZXhwb3J0IGZ1bmN0aW9uIGdsR2V0KG5hbWUpIHtcbiAgLy8gSWYgbm90IGEgc3RyaW5nLCByZXR1cm4gKGFzc3VtZSBudW1iZXIpXG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8vIElmIHN0cmluZyBjb252ZXJ0cyB0byBudW1iZXIsIHJldHVybiBudW1iZXJcbiAgY29uc3QgbnVtYmVyID0gTnVtYmVyKG5hbWUpO1xuICBpZiAoIWlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgLy8gTG9vayB1cCBzdHJpbmcsIGFmdGVyIHJlbW92aW5nIGFueSAnR0wuJyBvciAnZ2wuJyBwcmVmaXhcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXi4qXFwuLywgJycpO1xuICBjb25zdCB2YWx1ZSA9IEdMW25hbWVdO1xuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgYEFjY2Vzc2luZyB1bmRlZmluZWQgY29uc3RhbnQgR0wuJHtuYW1lfWApO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnbEtleSh2YWx1ZSkge1xuICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGZvciAoY29uc3Qga2V5IGluIEdMKSB7XG4gICAgaWYgKEdMW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gYEdMLiR7a2V5fWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG4vLyBHTCBjb25zdGFudHMsIGNvcGllZCBmcm9tIE1vemlsbGEgZG9jdW1lbnRhdGlvblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9Db25zdGFudHNcblxuLy8gU3RhbmRhcmQgV2ViR0wgMSBjb25zdGFudHNcbi8vIFRoZXNlIGNvbnN0YW50cyBhcmUgZGVmaW5lZCBvbiB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGludGVyZmFjZS5cblxuLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcsIG1heC1sZW4sIG5vLWlubGluZS1jb21tZW50cywgY2FtZWxjYXNlICovXG5PYmplY3QuYXNzaWduKEdMLCB7XG4gIC8vIENsZWFyaW5nIGJ1ZmZlcnNcbiAgLy8gQ29uc3RhbnRzIHBhc3NlZCB0byBjbGVhcigpIHRvIGNsZWFyIGJ1ZmZlciBtYXNrcy5cblxuICBERVBUSF9CVUZGRVJfQklUOiAgMHgwMDAwMDEwMCwgLy8gUGFzc2VkIHRvIGNsZWFyIHRvIGNsZWFyIHRoZSBjdXJyZW50IGRlcHRoIGJ1ZmZlci5cbiAgU1RFTkNJTF9CVUZGRVJfQklUOiAgMHgwMDAwMDQwMCwgLy8gUGFzc2VkIHRvIGNsZWFyIHRvIGNsZWFyIHRoZSBjdXJyZW50IHN0ZW5jaWwgYnVmZmVyLlxuICBDT0xPUl9CVUZGRVJfQklUOiAgMHgwMDAwNDAwMCwgLy8gUGFzc2VkIHRvIGNsZWFyIHRvIGNsZWFyIHRoZSBjdXJyZW50IGNvbG9yIGJ1ZmZlci5cblxuICAvLyBSZW5kZXJpbmcgcHJpbWl0aXZlc1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGRyYXdFbGVtZW50cygpIG9yIGRyYXdBcnJheXMoKSB0byBzcGVjaWZ5IHdoYXQga2luZCBvZiBwcmltaXRpdmUgdG8gcmVuZGVyLlxuXG4gIFBPSU5UUzogIDB4MDAwMCwgLy8gUGFzc2VkIHRvIGRyYXdFbGVtZW50cyBvciBkcmF3QXJyYXlzIHRvIGRyYXcgc2luZ2xlIHBvaW50cy5cbiAgTElORVM6IDB4MDAwMSwgLy8gUGFzc2VkIHRvIGRyYXdFbGVtZW50cyBvciBkcmF3QXJyYXlzIHRvIGRyYXcgbGluZXMuIEVhY2ggdmVydGV4IGNvbm5lY3RzIHRvIHRoZSBvbmUgYWZ0ZXIgaXQuXG4gIExJTkVfTE9PUDogMHgwMDAyLCAvLyBQYXNzZWQgdG8gZHJhd0VsZW1lbnRzIG9yIGRyYXdBcnJheXMgdG8gZHJhdyBsaW5lcy4gRWFjaCBzZXQgb2YgdHdvIHZlcnRpY2VzIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0ZSBsaW5lIHNlZ21lbnQuXG4gIExJTkVfU1RSSVA6ICAweDAwMDMsIC8vIFBhc3NlZCB0byBkcmF3RWxlbWVudHMgb3IgZHJhd0FycmF5cyB0byBkcmF3IGEgY29ubmVjdGVkIGdyb3VwIG9mIGxpbmUgc2VnbWVudHMgZnJvbSB0aGUgZmlyc3QgdmVydGV4IHRvIHRoZSBsYXN0LlxuICBUUklBTkdMRVM6IDB4MDAwNCwgLy8gUGFzc2VkIHRvIGRyYXdFbGVtZW50cyBvciBkcmF3QXJyYXlzIHRvIGRyYXcgdHJpYW5nbGVzLiBFYWNoIHNldCBvZiB0aHJlZSB2ZXJ0aWNlcyBjcmVhdGVzIGEgc2VwYXJhdGUgdHJpYW5nbGUuXG4gIFRSSUFOR0xFX1NUUklQOiAgMHgwMDA1LCAvLyBQYXNzZWQgdG8gZHJhd0VsZW1lbnRzIG9yIGRyYXdBcnJheXMgdG8gZHJhdyBhIGNvbm5lY3RlZCBncm91cCBvZiB0cmlhbmdsZXMuXG4gIFRSSUFOR0xFX0ZBTjogIDB4MDAwNiwgLy8gUGFzc2VkIHRvIGRyYXdFbGVtZW50cyBvciBkcmF3QXJyYXlzIHRvIGRyYXcgYSBjb25uZWN0ZWQgZ3JvdXAgb2YgdHJpYW5nbGVzLiBFYWNoIHZlcnRleCBjb25uZWN0cyB0byB0aGUgcHJldmlvdXMgYW5kIHRoZSBmaXJzdCB2ZXJ0ZXggaW4gdGhlIGZhbi5cblxuICAvLyBCbGVuZGluZyBtb2Rlc1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGJsZW5kRnVuYygpIG9yIGJsZW5kRnVuY1NlcGFyYXRlKCkgdG8gc3BlY2lmeSB0aGUgYmxlbmRpbmcgbW9kZSAoZm9yIGJvdGgsIFJCRyBhbmQgYWxwaGEsIG9yIHNlcGFyYXRlbHkpLlxuXG4gIFpFUk86ICAwLCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIHR1cm4gb2ZmIGEgY29tcG9uZW50LlxuICBPTkU6IDEsIC8vIFBhc3NlZCB0byBibGVuZEZ1bmMgb3IgYmxlbmRGdW5jU2VwYXJhdGUgdG8gdHVybiBvbiBhIGNvbXBvbmVudC5cbiAgU1JDX0NPTE9SOiAweDAzMDAsIC8vIFBhc3NlZCB0byBibGVuZEZ1bmMgb3IgYmxlbmRGdW5jU2VwYXJhdGUgdG8gbXVsdGlwbHkgYSBjb21wb25lbnQgYnkgdGhlIHNvdXJjZSBlbGVtZW50cyBjb2xvci5cbiAgT05FX01JTlVTX1NSQ19DT0xPUjogMHgwMzAxLCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIG11bHRpcGx5IGEgY29tcG9uZW50IGJ5IG9uZSBtaW51cyB0aGUgc291cmNlIGVsZW1lbnRzIGNvbG9yLlxuICBTUkNfQUxQSEE6IDB4MDMwMiwgLy8gUGFzc2VkIHRvIGJsZW5kRnVuYyBvciBibGVuZEZ1bmNTZXBhcmF0ZSB0byBtdWx0aXBseSBhIGNvbXBvbmVudCBieSB0aGUgc291cmNlJ3MgYWxwaGEuXG4gIE9ORV9NSU5VU19TUkNfQUxQSEE6IDB4MDMwMywgLy8gUGFzc2VkIHRvIGJsZW5kRnVuYyBvciBibGVuZEZ1bmNTZXBhcmF0ZSB0byBtdWx0aXBseSBhIGNvbXBvbmVudCBieSBvbmUgbWludXMgdGhlIHNvdXJjZSdzIGFscGhhLlxuICBEU1RfQUxQSEE6IDB4MDMwNCwgLy8gUGFzc2VkIHRvIGJsZW5kRnVuYyBvciBibGVuZEZ1bmNTZXBhcmF0ZSB0byBtdWx0aXBseSBhIGNvbXBvbmVudCBieSB0aGUgZGVzdGluYXRpb24ncyBhbHBoYS5cbiAgT05FX01JTlVTX0RTVF9BTFBIQTogMHgwMzA1LCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIG11bHRpcGx5IGEgY29tcG9uZW50IGJ5IG9uZSBtaW51cyB0aGUgZGVzdGluYXRpb24ncyBhbHBoYS5cbiAgRFNUX0NPTE9SOiAweDAzMDYsIC8vIFBhc3NlZCB0byBibGVuZEZ1bmMgb3IgYmxlbmRGdW5jU2VwYXJhdGUgdG8gbXVsdGlwbHkgYSBjb21wb25lbnQgYnkgdGhlIGRlc3RpbmF0aW9uJ3MgY29sb3IuXG4gIE9ORV9NSU5VU19EU1RfQ09MT1I6IDB4MDMwNywgLy8gUGFzc2VkIHRvIGJsZW5kRnVuYyBvciBibGVuZEZ1bmNTZXBhcmF0ZSB0byBtdWx0aXBseSBhIGNvbXBvbmVudCBieSBvbmUgbWludXMgdGhlIGRlc3RpbmF0aW9uJ3MgY29sb3IuXG4gIFNSQ19BTFBIQV9TQVRVUkFURTogIDB4MDMwOCwgLy8gUGFzc2VkIHRvIGJsZW5kRnVuYyBvciBibGVuZEZ1bmNTZXBhcmF0ZSB0byBtdWx0aXBseSBhIGNvbXBvbmVudCBieSB0aGUgbWluaW11bSBvZiBzb3VyY2UncyBhbHBoYSBvciBvbmUgbWludXMgdGhlIGRlc3RpbmF0aW9uJ3MgYWxwaGEuXG4gIENPTlNUQU5UX0NPTE9SOiAgMHg4MDAxLCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIHNwZWNpZnkgYSBjb25zdGFudCBjb2xvciBibGVuZCBmdW5jdGlvbi5cbiAgT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SOiAgMHg4MDAyLCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIHNwZWNpZnkgb25lIG1pbnVzIGEgY29uc3RhbnQgY29sb3IgYmxlbmQgZnVuY3Rpb24uXG4gIENPTlNUQU5UX0FMUEhBOiAgMHg4MDAzLCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIHNwZWNpZnkgYSBjb25zdGFudCBhbHBoYSBibGVuZCBmdW5jdGlvbi5cbiAgT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBOiAgMHg4MDA0LCAvLyBQYXNzZWQgdG8gYmxlbmRGdW5jIG9yIGJsZW5kRnVuY1NlcGFyYXRlIHRvIHNwZWNpZnkgb25lIG1pbnVzIGEgY29uc3RhbnQgYWxwaGEgYmxlbmQgZnVuY3Rpb24uXG5cbiAgLy8gQmxlbmRpbmcgZXF1YXRpb25zXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gYmxlbmRFcXVhdGlvbigpIG9yIGJsZW5kRXF1YXRpb25TZXBhcmF0ZSgpIHRvIGNvbnRyb2xcbiAgLy8gaG93IHRoZSBibGVuZGluZyBpcyBjYWxjdWxhdGVkIChmb3IgYm90aCwgUkJHIGFuZCBhbHBoYSwgb3Igc2VwYXJhdGVseSkuXG5cbiAgRlVOQ19BREQ6ICAweDgwMDYsIC8vIFBhc3NlZCB0byBibGVuZEVxdWF0aW9uIG9yIGJsZW5kRXF1YXRpb25TZXBhcmF0ZSB0byBzZXQgYW4gYWRkaXRpb24gYmxlbmQgZnVuY3Rpb24uXG4gIEZVTkNfU1VCU1RSQUNUOiAgMHg4MDBBLCAvLyBQYXNzZWQgdG8gYmxlbmRFcXVhdGlvbiBvciBibGVuZEVxdWF0aW9uU2VwYXJhdGUgdG8gc3BlY2lmeSBhIHN1YnRyYWN0aW9uIGJsZW5kIGZ1bmN0aW9uIChzb3VyY2UgLSBkZXN0aW5hdGlvbikuXG4gIEZVTkNfUkVWRVJTRV9TVUJUUkFDVDogMHg4MDBCLCAvLyBQYXNzZWQgdG8gYmxlbmRFcXVhdGlvbiBvciBibGVuZEVxdWF0aW9uU2VwYXJhdGUgdG8gc3BlY2lmeSBhIHJldmVyc2Ugc3VidHJhY3Rpb24gYmxlbmQgZnVuY3Rpb24gKGRlc3RpbmF0aW9uIC0gc291cmNlKS5cblxuICAvLyBHZXR0aW5nIEdMIHBhcmFtZXRlciBpbmZvcm1hdGlvblxuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGdldFBhcmFtZXRlcigpIHRvIHNwZWNpZnkgd2hhdCBpbmZvcm1hdGlvbiB0byByZXR1cm4uXG5cbiAgQkxFTkRfRVFVQVRJT046ICAweDgwMDksIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IFJHQiBibGVuZCBmdW5jdGlvbi5cbiAgQkxFTkRfRVFVQVRJT05fUkdCOiAgMHg4MDA5LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgY3VycmVudCBSR0IgYmxlbmQgZnVuY3Rpb24uIFNhbWUgYXMgQkxFTkRfRVFVQVRJT05cbiAgQkxFTkRfRVFVQVRJT05fQUxQSEE6ICAweDg4M0QsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IGFscGhhIGJsZW5kIGZ1bmN0aW9uLiBTYW1lIGFzIEJMRU5EX0VRVUFUSU9OXG4gIEJMRU5EX0RTVF9SR0I6IDB4ODBDOCwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGN1cnJlbnQgZGVzdGluYXRpb24gUkdCIGJsZW5kIGZ1bmN0aW9uLlxuICBCTEVORF9TUkNfUkdCOiAweDgwQzksIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IGRlc3RpbmF0aW9uIFJHQiBibGVuZCBmdW5jdGlvbi5cbiAgQkxFTkRfRFNUX0FMUEhBOiAweDgwQ0EsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IGRlc3RpbmF0aW9uIGFscGhhIGJsZW5kIGZ1bmN0aW9uLlxuICBCTEVORF9TUkNfQUxQSEE6IDB4ODBDQiwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGN1cnJlbnQgc291cmNlIGFscGhhIGJsZW5kIGZ1bmN0aW9uLlxuICBCTEVORF9DT0xPUjogMHg4MDA1LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIHJldHVybiBhIHRoZSBjdXJyZW50IGJsZW5kIGNvbG9yLlxuICBBUlJBWV9CVUZGRVJfQklORElORzogIDB4ODg5NCwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGFycmF5IGJ1ZmZlciBiaW5kaW5nLlxuICBFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HOiAgMHg4ODk1LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgY3VycmVudCBlbGVtZW50IGFycmF5IGJ1ZmZlci5cbiAgTElORV9XSURUSDogIDB4MEIyMSwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGN1cnJlbnQgbGluZVdpZHRoIChzZXQgYnkgdGhlIGxpbmVXaWR0aCBtZXRob2QpLlxuICBBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0U6ICAweDg0NkQsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IHNpemUgb2YgYSBwb2ludCBkcmF3biB3aXRoIGdsLlBPSU5UU1xuICBBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0U6ICAweDg0NkUsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSByYW5nZSBvZiBhdmFpbGFibGUgd2lkdGhzIGZvciBhIGxpbmUuIFJldHVybnMgYSBsZW5ndGgtMiBhcnJheSB3aXRoIHRoZSBsbyB2YWx1ZSBhdCAwLCBhbmQgaGlnaHQgYXQgMS5cbiAgQ1VMTF9GQUNFX01PREU6ICAweDBCNDUsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGN1bGxGYWNlLiBTaG91bGQgcmV0dXJuIEZST05ULCBCQUNLLCBvciBGUk9OVF9BTkRfQkFDS1xuICBGUk9OVF9GQUNFOiAgMHgwQjQ2LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGRldGVybWluZSB0aGUgY3VycmVudCB2YWx1ZSBvZiBmcm9udEZhY2UuIFNob3VsZCByZXR1cm4gQ1cgb3IgQ0NXLlxuICBERVBUSF9SQU5HRTogMHgwQjcwLCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIHJldHVybiBhIGxlbmd0aC0yIGFycmF5IG9mIGZsb2F0cyBnaXZpbmcgdGhlIGN1cnJlbnQgZGVwdGggcmFuZ2UuXG4gIERFUFRIX1dSSVRFTUFTSzogMHgwQjcyLCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGRldGVybWluZSBpZiB0aGUgZGVwdGggd3JpdGUgbWFzayBpcyBlbmFibGVkLlxuICBERVBUSF9DTEVBUl9WQUxVRTogMHgwQjczLCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGRldGVybWluZSB0aGUgY3VycmVudCBkZXB0aCBjbGVhciB2YWx1ZS5cbiAgREVQVEhfRlVOQzogIDB4MEI3NCwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGN1cnJlbnQgZGVwdGggZnVuY3Rpb24uIFJldHVybnMgTkVWRVIsIEFMV0FZUywgTEVTUywgRVFVQUwsIExFUVVBTCwgR1JFQVRFUiwgR0VRVUFMLCBvciBOT1RFUVVBTC5cbiAgU1RFTkNJTF9DTEVBUl9WQUxVRTogMHgwQjkxLCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgdmFsdWUgdGhlIHN0ZW5jaWwgd2lsbCBiZSBjbGVhcmVkIHRvLlxuICBTVEVOQ0lMX0ZVTkM6ICAweDBCOTIsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSBjdXJyZW50IHN0ZW5jaWwgZnVuY3Rpb24uIFJldHVybnMgTkVWRVIsIEFMV0FZUywgTEVTUywgRVFVQUwsIExFUVVBTCwgR1JFQVRFUiwgR0VRVUFMLCBvciBOT1RFUVVBTC5cbiAgU1RFTkNJTF9GQUlMOiAgMHgwQjk0LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgY3VycmVudCBzdGVuY2lsIGZhaWwgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gS0VFUCwgUkVQTEFDRSwgSU5DUiwgREVDUiwgSU5WRVJULCBJTkNSX1dSQVAsIG9yIERFQ1JfV1JBUC5cbiAgU1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUw6IDB4MEI5NSwgLy8gUGFzc2VkIHRvIGdldFBhcmFtZXRlciB0byBnZXQgdGhlIGN1cnJlbnQgc3RlbmNpbCBmYWlsIGZ1bmN0aW9uIHNob3VsZCB0aGUgZGVwdGggYnVmZmVyIHRlc3QgZmFpbC4gU2hvdWxkIHJldHVybiBLRUVQLCBSRVBMQUNFLCBJTkNSLCBERUNSLCBJTlZFUlQsIElOQ1JfV1JBUCwgb3IgREVDUl9XUkFQLlxuICBTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUzogMHgwQjk2LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgY3VycmVudCBzdGVuY2lsIGZhaWwgZnVuY3Rpb24gc2hvdWxkIHRoZSBkZXB0aCBidWZmZXIgdGVzdCBwYXNzLiBTaG91bGQgcmV0dXJuIEtFRVAsIFJFUExBQ0UsIElOQ1IsIERFQ1IsIElOVkVSVCwgSU5DUl9XUkFQLCBvciBERUNSX1dSQVAuXG4gIFNURU5DSUxfUkVGOiAweDBCOTcsIC8vIFBhc3NlZCB0byBnZXRQYXJhbWV0ZXIgdG8gZ2V0IHRoZSByZWZlcmVuY2UgdmFsdWUgdXNlZCBmb3Igc3RlbmNpbCB0ZXN0cy5cbiAgU1RFTkNJTF9WQUxVRV9NQVNLOiAgMHgwQjkzLFxuICBTVEVOQ0lMX1dSSVRFTUFTSzogMHgwQjk4LFxuICBTVEVOQ0lMX0JBQ0tfRlVOQzogMHg4ODAwLFxuICBTVEVOQ0lMX0JBQ0tfRkFJTDogMHg4ODAxLFxuICBTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMOiAgMHg4ODAyLFxuICBTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTOiAgMHg4ODAzLFxuICBTVEVOQ0lMX0JBQ0tfUkVGOiAgMHg4Q0EzLFxuICBTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSzogMHg4Q0E0LFxuICBTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLOiAgMHg4Q0E1LFxuICBWSUVXUE9SVDogIDB4MEJBMiwgLy8gUmV0dXJucyBhbiBJbnQzMkFycmF5IHdpdGggZm91ciBlbGVtZW50cyBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAgU0NJU1NPUl9CT1g6IDB4MEMxMCwgLy8gUmV0dXJucyBhbiBJbnQzMkFycmF5IHdpdGggZm91ciBlbGVtZW50cyBmb3IgdGhlIGN1cnJlbnQgc2Npc3NvciBib3ggZGltZW5zaW9ucy5cbiAgQ09MT1JfQ0xFQVJfVkFMVUU6IDB4MEMyMixcbiAgQ09MT1JfV1JJVEVNQVNLOiAweDBDMjMsXG4gIFVOUEFDS19BTElHTk1FTlQ6ICAweDBDRjUsXG4gIFBBQ0tfQUxJR05NRU5UOiAgMHgwRDA1LFxuICBNQVhfVEVYVFVSRV9TSVpFOiAgMHgwRDMzLFxuICBNQVhfVklFV1BPUlRfRElNUzogMHgwRDNBLFxuICBTVUJQSVhFTF9CSVRTOiAweDBENTAsXG4gIFJFRF9CSVRTOiAgMHgwRDUyLFxuICBHUkVFTl9CSVRTOiAgMHgwRDUzLFxuICBCTFVFX0JJVFM6IDB4MEQ1NCxcbiAgQUxQSEFfQklUUzogIDB4MEQ1NSxcbiAgREVQVEhfQklUUzogIDB4MEQ1NixcbiAgU1RFTkNJTF9CSVRTOiAgMHgwRDU3LFxuICBQT0xZR09OX09GRlNFVF9VTklUUzogIDB4MkEwMCxcbiAgUE9MWUdPTl9PRkZTRVRfRkFDVE9SOiAweDgwMzgsXG4gIFRFWFRVUkVfQklORElOR18yRDogIDB4ODA2OSxcbiAgU0FNUExFX0JVRkZFUlM6ICAweDgwQTgsXG4gIFNBTVBMRVM6IDB4ODBBOSxcbiAgU0FNUExFX0NPVkVSQUdFX1ZBTFVFOiAweDgwQUEsXG4gIFNBTVBMRV9DT1ZFUkFHRV9JTlZFUlQ6ICAweDgwQUIsXG4gIENPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAgMHg4NkEzLFxuICBWRU5ET1I6ICAweDFGMDAsXG4gIFJFTkRFUkVSOiAgMHgxRjAxLFxuICBWRVJTSU9OOiAweDFGMDIsXG4gIElNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRTogIDB4OEI5QSxcbiAgSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQ6ICAweDhCOUIsXG4gIEJST1dTRVJfREVGQVVMVF9XRUJHTDogMHg5MjQ0LFxuXG4gIC8vIEJ1ZmZlcnNcbiAgLy8gQ29uc3RhbnRzIHBhc3NlZCB0byBidWZmZXJEYXRhKCksIGJ1ZmZlclN1YkRhdGEoKSwgYmluZEJ1ZmZlcigpLCBvclxuICAvLyBnZXRCdWZmZXJQYXJhbWV0ZXIoKS5cblxuICBTVEFUSUNfRFJBVzogMHg4OEU0LCAvLyBQYXNzZWQgdG8gYnVmZmVyRGF0YSBhcyBhIGhpbnQgYWJvdXQgd2hldGhlciB0aGUgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgb2Z0ZW4gYW5kIG5vdCBjaGFuZ2Ugb2Z0ZW4uXG4gIFNUUkVBTV9EUkFXOiAweDg4RTAsIC8vIFBhc3NlZCB0byBidWZmZXJEYXRhIGFzIGEgaGludCBhYm91dCB3aGV0aGVyIHRoZSBjb250ZW50cyBvZiB0aGUgYnVmZmVyIGFyZSBsaWtlbHkgdG8gbm90IGJlIHVzZWQgb2Z0ZW4uXG4gIERZTkFNSUNfRFJBVzogMHg4OEU4LCAvLyBQYXNzZWQgdG8gYnVmZmVyRGF0YSBhcyBhIGhpbnQgYWJvdXQgd2hldGhlciB0aGUgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgb2Z0ZW4gYW5kIGNoYW5nZSBvZnRlbi5cbiAgQVJSQVlfQlVGRkVSOiAweDg4OTIsIC8vIFBhc3NlZCB0byBiaW5kQnVmZmVyIG9yIGJ1ZmZlckRhdGEgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiBidWZmZXIgYmVpbmcgdXNlZC5cbiAgRUxFTUVOVF9BUlJBWV9CVUZGRVI6ICAweDg4OTMsIC8vIFBhc3NlZCB0byBiaW5kQnVmZmVyIG9yIGJ1ZmZlckRhdGEgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiBidWZmZXIgYmVpbmcgdXNlZC5cbiAgQlVGRkVSX1NJWkU6IDB4ODc2NCwgLy8gUGFzc2VkIHRvIGdldEJ1ZmZlclBhcmFtZXRlciB0byBnZXQgYSBidWZmZXIncyBzaXplLlxuICBCVUZGRVJfVVNBR0U6IDB4ODc2NSwgLy8gUGFzc2VkIHRvIGdldEJ1ZmZlclBhcmFtZXRlciB0byBnZXQgdGhlIGhpbnQgZm9yIHRoZSBidWZmZXIgcGFzc2VkIGluIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXG5cbiAgLy8gVmVydGV4IGF0dHJpYnV0ZXNcbiAgLy8gQ29uc3RhbnRzIHBhc3NlZCB0byBnZXRWZXJ0ZXhBdHRyaWIoKS5cblxuICBDVVJSRU5UX1ZFUlRFWF9BVFRSSUI6IDB4ODYyNiwgLy8gUGFzc2VkIHRvIGdldFZlcnRleEF0dHJpYiB0byByZWFkIGJhY2sgdGhlIGN1cnJlbnQgdmVydGV4IGF0dHJpYnV0ZS5cbiAgVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEOiAweDg2MjIsXG4gIFZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRTogIDB4ODYyMyxcbiAgVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREU6ICAweDg2MjQsXG4gIFZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRTogIDB4ODYyNSxcbiAgVkVSVEVYX0FUVFJJQl9BUlJBWV9OT1JNQUxJWkVEOiAgMHg4ODZBLFxuICBWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVI6IDB4ODY0NSxcbiAgVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORzogIDB4ODg5RixcblxuICAvLyBDdWxsaW5nXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gY3VsbEZhY2UoKS5cblxuICBDVUxMX0ZBQ0U6IDB4MEI0NCwgLy8gUGFzc2VkIHRvIGVuYWJsZS9kaXNhYmxlIHRvIHR1cm4gb24vb2ZmIGN1bGxpbmcuIENhbiBhbHNvIGJlIHVzZWQgd2l0aCBnZXRQYXJhbWV0ZXIgdG8gZmluZCB0aGUgY3VycmVudCBjdWxsaW5nIG1ldGhvZC5cbiAgRlJPTlQ6IDB4MDQwNCwgLy8gUGFzc2VkIHRvIGN1bGxGYWNlIHRvIHNwZWNpZnkgdGhhdCBvbmx5IGZyb250IGZhY2VzIHNob3VsZCBiZSBkcmF3bi5cbiAgQkFDSzogIDB4MDQwNSwgLy8gUGFzc2VkIHRvIGN1bGxGYWNlIHRvIHNwZWNpZnkgdGhhdCBvbmx5IGJhY2sgZmFjZXMgc2hvdWxkIGJlIGRyYXduLlxuICBGUk9OVF9BTkRfQkFDSzogIDB4MDQwOCwgLy8gUGFzc2VkIHRvIGN1bGxGYWNlIHRvIHNwZWNpZnkgdGhhdCBmcm9udCBhbmQgYmFjayBmYWNlcyBzaG91bGQgYmUgZHJhd24uXG5cbiAgLy8gRW5hYmxpbmcgYW5kIGRpc2FibGluZ1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGVuYWJsZSgpIG9yIGRpc2FibGUoKS5cblxuICBCTEVORDogMHgwQkUyLCAvLyBQYXNzZWQgdG8gZW5hYmxlL2Rpc2FibGUgdG8gdHVybiBvbi9vZmYgYmxlbmRpbmcuIENhbiBhbHNvIGJlIHVzZWQgd2l0aCBnZXRQYXJhbWV0ZXIgdG8gZmluZCB0aGUgY3VycmVudCBibGVuZGluZyBtZXRob2QuXG4gIERFUFRIX1RFU1Q6ICAweDBCNzEsIC8vIFBhc3NlZCB0byBlbmFibGUvZGlzYWJsZSB0byB0dXJuIG9uL29mZiB0aGUgZGVwdGggdGVzdC4gQ2FuIGFsc28gYmUgdXNlZCB3aXRoIGdldFBhcmFtZXRlciB0byBxdWVyeSB0aGUgZGVwdGggdGVzdC5cbiAgRElUSEVSOiAgMHgwQkQwLCAvLyBQYXNzZWQgdG8gZW5hYmxlL2Rpc2FibGUgdG8gdHVybiBvbi9vZmYgZGl0aGVyaW5nLiBDYW4gYWxzbyBiZSB1c2VkIHdpdGggZ2V0UGFyYW1ldGVyIHRvIGZpbmQgdGhlIGN1cnJlbnQgZGl0aGVyaW5nIG1ldGhvZC5cbiAgUE9MWUdPTl9PRkZTRVRfRklMTDogMHg4MDM3LCAvLyBQYXNzZWQgdG8gZW5hYmxlL2Rpc2FibGUgdG8gdHVybiBvbi9vZmYgdGhlIHBvbHlnb24gb2Zmc2V0LiBVc2VmdWwgZm9yIHJlbmRlcmluZyBoaWRkZW4tbGluZSBpbWFnZXMsIGRlY2FscywgYW5kIG9yIHNvbGlkcyB3aXRoIGhpZ2hsaWdodGVkIGVkZ2VzLiBDYW4gYWxzbyBiZSB1c2VkIHdpdGggZ2V0UGFyYW1ldGVyIHRvIHF1ZXJ5IHRoZSBzY2lzc29yIHRlc3QuXG4gIFNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRTogIDB4ODA5RSwgLy8gUGFzc2VkIHRvIGVuYWJsZS9kaXNhYmxlIHRvIHR1cm4gb24vb2ZmIHRoZSBhbHBoYSB0byBjb3ZlcmFnZS4gVXNlZCBpbiBtdWx0aS1zYW1wbGluZyBhbHBoYSBjaGFubmVscy5cbiAgU0FNUExFX0NPVkVSQUdFOiAweDgwQTAsIC8vIFBhc3NlZCB0byBlbmFibGUvZGlzYWJsZSB0byB0dXJuIG9uL29mZiB0aGUgc2FtcGxlIGNvdmVyYWdlLiBVc2VkIGluIG11bHRpLXNhbXBsaW5nLlxuICBTQ0lTU09SX1RFU1Q6ICAweDBDMTEsIC8vIFBhc3NlZCB0byBlbmFibGUvZGlzYWJsZSB0byB0dXJuIG9uL29mZiB0aGUgc2Npc3NvciB0ZXN0LiBDYW4gYWxzbyBiZSB1c2VkIHdpdGggZ2V0UGFyYW1ldGVyIHRvIHF1ZXJ5IHRoZSBzY2lzc29yIHRlc3QuXG4gIFNURU5DSUxfVEVTVDogIDB4MEI5MCwgLy8gUGFzc2VkIHRvIGVuYWJsZS9kaXNhYmxlIHRvIHR1cm4gb24vb2ZmIHRoZSBzdGVuY2lsIHRlc3QuIENhbiBhbHNvIGJlIHVzZWQgd2l0aCBnZXRQYXJhbWV0ZXIgdG8gcXVlcnkgdGhlIHN0ZW5jaWwgdGVzdC5cblxuICAvLyBFcnJvcnNcbiAgLy8gQ29uc3RhbnRzIHJldHVybmVkIGZyb20gZ2V0RXJyb3IoKS5cblxuICBOT19FUlJPUjogMCwgLy8gUmV0dXJuZWQgZnJvbSBnZXRFcnJvci5cbiAgSU5WQUxJRF9FTlVNOiAgMHgwNTAwLCAvLyAgUmV0dXJuZWQgZnJvbSBnZXRFcnJvci5cbiAgSU5WQUxJRF9WQUxVRTogMHgwNTAxLCAvLyAgUmV0dXJuZWQgZnJvbSBnZXRFcnJvci5cbiAgSU5WQUxJRF9PUEVSQVRJT046IDB4MDUwMiwgLy8gIFJldHVybmVkIGZyb20gZ2V0RXJyb3IuXG4gIE9VVF9PRl9NRU1PUlk6IDB4MDUwNSwgLy8gIFJldHVybmVkIGZyb20gZ2V0RXJyb3IuXG4gIENPTlRFWFRfTE9TVF9XRUJHTDogIDB4OTI0MiwgLy8gIFJldHVybmVkIGZyb20gZ2V0RXJyb3IuXG5cbiAgLy8gRnJvbnQgZmFjZSBkaXJlY3Rpb25zXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gZnJvbnRGYWNlKCkuXG5cbiAgQ1c6ICAweDA5MDAsIC8vICBQYXNzZWQgdG8gZnJvbnRGYWNlIHRvIHNwZWNpZnkgdGhlIGZyb250IGZhY2Ugb2YgYSBwb2x5Z29uIGlzIGRyYXduIGluIHRoZSBjbG9ja3dpc2UgZGlyZWN0aW9uXG4gIENDVzogMHgwOTAxLCAvLyBQYXNzZWQgdG8gZnJvbnRGYWNlIHRvIHNwZWNpZnkgdGhlIGZyb250IGZhY2Ugb2YgYSBwb2x5Z29uIGlzIGRyYXduIGluIHRoZSBjb3VudGVyIGNsb2Nrd2lzZSBkaXJlY3Rpb25cblxuICAvLyBIaW50c1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGhpbnQoKVxuXG4gIERPTlRfQ0FSRTogMHgxMTAwLCAvLyBUaGVyZSBpcyBubyBwcmVmZXJlbmNlIGZvciB0aGlzIGJlaGF2aW9yLlxuICBGQVNURVNUOiAweDExMDEsIC8vIFRoZSBtb3N0IGVmZmljaWVudCBiZWhhdmlvciBzaG91bGQgYmUgdXNlZC5cbiAgTklDRVNUOiAweDExMDIsIC8vIFRoZSBtb3N0IGNvcnJlY3Qgb3IgdGhlIGhpZ2hlc3QgcXVhbGl0eSBvcHRpb24gc2hvdWxkIGJlIHVzZWQuXG4gIEdFTkVSQVRFX01JUE1BUF9ISU5UOiAweDgxOTIsIC8vIEhpbnQgZm9yIHRoZSBxdWFsaXR5IG9mIGZpbHRlcmluZyB3aGVuIGdlbmVyYXRpbmcgbWlwbWFwIGltYWdlcyB3aXRoIGdlbmVyYXRlTWlwbWFwKCkuXG5cbiAgLy8gRGF0YSB0eXBlc1xuXG4gIEJZVEU6ICAweDE0MDAsXG4gIFVOU0lHTkVEX0JZVEU6IDB4MTQwMSxcbiAgU0hPUlQ6IDB4MTQwMixcbiAgVU5TSUdORURfU0hPUlQ6ICAweDE0MDMsXG4gIElOVDogMHgxNDA0LFxuICBVTlNJR05FRF9JTlQ6ICAweDE0MDUsXG4gIEZMT0FUOiAweDE0MDYsXG5cbiAgLy8gUGl4ZWwgZm9ybWF0c1xuXG4gIERFUFRIX0NPTVBPTkVOVDogMHgxOTAyLFxuICBBTFBIQTogMHgxOTA2LFxuICBSR0I6IDB4MTkwNyxcbiAgUkdCQTogIDB4MTkwOCxcbiAgTFVNSU5BTkNFOiAweDE5MDksXG4gIExVTUlOQU5DRV9BTFBIQTogMHgxOTBBLFxuXG4gIC8vIFBpeGVsIHR5cGVzXG5cbiAgLy8gVU5TSUdORURfQllURTogMHgxNDAxLFxuICBVTlNJR05FRF9TSE9SVF80XzRfNF80OiAgMHg4MDMzLFxuICBVTlNJR05FRF9TSE9SVF81XzVfNV8xOiAgMHg4MDM0LFxuICBVTlNJR05FRF9TSE9SVF81XzZfNTogIDB4ODM2MyxcblxuICAvLyBTaGFkZXJzXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gY3JlYXRlU2hhZGVyKCkgb3IgZ2V0U2hhZGVyUGFyYW1ldGVyKClcblxuICBGUkFHTUVOVF9TSEFERVI6IDB4OEIzMCwgLy8gUGFzc2VkIHRvIGNyZWF0ZVNoYWRlciB0byBkZWZpbmUgYSBmcmFnbWVudCBzaGFkZXIuXG4gIFZFUlRFWF9TSEFERVI6IDB4OEIzMSwgLy8gUGFzc2VkIHRvIGNyZWF0ZVNoYWRlciB0byBkZWZpbmUgYSB2ZXJ0ZXggc2hhZGVyXG4gIENPTVBJTEVfU1RBVFVTOiAgMHg4QjgxLCAvLyBQYXNzZWQgdG8gZ2V0U2hhZGVyUGFyYW10ZXIgdG8gZ2V0IHRoZSBzdGF0dXMgb2YgdGhlIGNvbXBpbGF0aW9uLiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBzaGFkZXIgd2FzIG5vdCBjb21waWxlZC4gWW91IGNhbiB0aGVuIHF1ZXJ5IGdldFNoYWRlckluZm9Mb2cgdG8gZmluZCB0aGUgZXhhY3QgZXJyb3JcbiAgREVMRVRFX1NUQVRVUzogMHg4QjgwLCAvLyBQYXNzZWQgdG8gZ2V0U2hhZGVyUGFyYW10ZXIgdG8gZGV0ZXJtaW5lIGlmIGEgc2hhZGVyIHdhcyBkZWxldGVkIHZpYSBkZWxldGVTaGFkZXIuIFJldHVybnMgdHJ1ZSBpZiBpdCB3YXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgTElOS19TVEFUVVM6IDB4OEI4MiwgLy8gUGFzc2VkIHRvIGdldFByb2dyYW1QYXJhbWV0ZXIgYWZ0ZXIgY2FsbGluZyBsaW5rUHJvZ3JhbSB0byBkZXRlcm1pbmUgaWYgYSBwcm9ncmFtIHdhcyBsaW5rZWQgY29ycmVjdGx5LiBSZXR1cm5zIGZhbHNlIGlmIHRoZXJlIHdlcmUgZXJyb3JzLiBVc2UgZ2V0UHJvZ3JhbUluZm9Mb2cgdG8gZmluZCB0aGUgZXhhY3QgZXJyb3IuXG4gIFZBTElEQVRFX1NUQVRVUzogMHg4QjgzLCAvLyBQYXNzZWQgdG8gZ2V0UHJvZ3JhbVBhcmFtZXRlciBhZnRlciBjYWxsaW5nIHZhbGlkYXRlUHJvZ3JhbSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgdmFsaWQuIFJldHVybnMgZmFsc2UgaWYgZXJyb3JzIHdlcmUgZm91bmQuXG4gIEFUVEFDSEVEX1NIQURFUlM6ICAweDhCODUsIC8vIFBhc3NlZCB0byBnZXRQcm9ncmFtUGFyYW1ldGVyIGFmdGVyIGNhbGxpbmcgYXR0YWNoU2hhZGVyIHRvIGRldGVybWluZSBpZiB0aGUgc2hhZGVyIHdhcyBhdHRhY2hlZCBjb3JyZWN0bHkuIFJldHVybnMgZmFsc2UgaWYgZXJyb3JzIG9jY3VycmVkLlxuICBBQ1RJVkVfQVRUUklCVVRFUzogMHg4Qjg5LCAvLyBQYXNzZWQgdG8gZ2V0UHJvZ3JhbVBhcmFtZXRlciB0byBnZXQgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIGFjdGl2ZSBpbiBhIHByb2dyYW0uXG4gIEFDVElWRV9VTklGT1JNUzogMHg4Qjg2LCAvLyBQYXNzZWQgdG8gZ2V0UHJvZ3JhbVBhcmFtdGVyIHRvIGdldCB0aGUgbnVtYmVyIG9mIHVuaWZvcm1zIGFjdGl2ZSBpbiBhIHByb2dyYW0uXG4gIE1BWF9WRVJURVhfQVRUUklCUzogIDB4ODg2OSxcbiAgTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlM6ICAweDhERkIsXG4gIE1BWF9WQVJZSU5HX1ZFQ1RPUlM6IDB4OERGQyxcbiAgTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFM6ICAweDhCNEQsXG4gIE1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUzogIDB4OEI0QyxcbiAgTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDB4ODg3MiwgLy8gSW1wbGVtZW50YXRpb24gZGVwZW5kZW50IG51bWJlciBvZiBtYXhpbXVtIHRleHR1cmUgdW5pdHMuIEF0IGxlYXN0IDguXG4gIE1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlM6ICAweDhERkQsXG4gIFNIQURFUl9UWVBFOiAweDhCNEYsXG4gIFNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTjogIDB4OEI4QyxcbiAgQ1VSUkVOVF9QUk9HUkFNOiAweDhCOEQsXG5cbiAgLy8gRGVwdGggb3Igc3RlbmNpbCB0ZXN0c1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIGRlcHRoRnVuYygpIG9yIHN0ZW5jaWxGdW5jKCkuXG5cbiAgTkVWRVI6IDB4MDIwMCwgLy8gIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBuZXZlciBwYXNzLiBpLmUuIE5vdGhpbmcgd2lsbCBiZSBkcmF3bi5cbiAgQUxXQVlTOiAgMHgwMjA3LCAvLyAgUGFzc2VkIHRvIGRlcHRoRnVuY3Rpb24gb3Igc3RlbmNpbEZ1bmN0aW9uIHRvIHNwZWNpZnkgZGVwdGggb3Igc3RlbmNpbCB0ZXN0cyB3aWxsIGFsd2F5cyBwYXNzLiBpLmUuIFBpeGVscyB3aWxsIGJlIGRyYXduIGluIHRoZSBvcmRlciB0aGV5IGFyZSBkcmF3bi5cbiAgTEVTUzogIDB4MDIwMSwgLy8gIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBwYXNzIGlmIHRoZSBuZXcgZGVwdGggdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzdG9yZWQgdmFsdWUuXG4gIEVRVUFMOiAweDAyMDIsIC8vICBQYXNzZWQgdG8gZGVwdGhGdW5jdGlvbiBvciBzdGVuY2lsRnVuY3Rpb24gdG8gc3BlY2lmeSBkZXB0aCBvciBzdGVuY2lsIHRlc3RzIHdpbGwgcGFzcyBpZiB0aGUgbmV3IGRlcHRoIHZhbHVlIGlzIGVxdWFscyB0byB0aGUgc3RvcmVkIHZhbHVlLlxuICBMRVFVQUw6ICAweDAyMDMsIC8vICBQYXNzZWQgdG8gZGVwdGhGdW5jdGlvbiBvciBzdGVuY2lsRnVuY3Rpb24gdG8gc3BlY2lmeSBkZXB0aCBvciBzdGVuY2lsIHRlc3RzIHdpbGwgcGFzcyBpZiB0aGUgbmV3IGRlcHRoIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3RvcmVkIHZhbHVlLlxuICBHUkVBVEVSOiAweDAyMDQsIC8vICBQYXNzZWQgdG8gZGVwdGhGdW5jdGlvbiBvciBzdGVuY2lsRnVuY3Rpb24gdG8gc3BlY2lmeSBkZXB0aCBvciBzdGVuY2lsIHRlc3RzIHdpbGwgcGFzcyBpZiB0aGUgbmV3IGRlcHRoIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3RvcmVkIHZhbHVlLlxuICBHRVFVQUw6ICAweDAyMDYsIC8vICBQYXNzZWQgdG8gZGVwdGhGdW5jdGlvbiBvciBzdGVuY2lsRnVuY3Rpb24gdG8gc3BlY2lmeSBkZXB0aCBvciBzdGVuY2lsIHRlc3RzIHdpbGwgcGFzcyBpZiB0aGUgbmV3IGRlcHRoIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc3RvcmVkIHZhbHVlLlxuICBOT1RFUVVBTDogIDB4MDIwNSwgLy8gIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBwYXNzIGlmIHRoZSBuZXcgZGVwdGggdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSBzdG9yZWQgdmFsdWUuXG5cbiAgLy8gU3RlbmNpbCBhY3Rpb25zXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gc3RlbmNpbE9wKCkuXG5cbiAgS0VFUDogIDB4MUUwMCxcbiAgUkVQTEFDRTogMHgxRTAxLFxuICBJTkNSOiAgMHgxRTAyLFxuICBERUNSOiAgMHgxRTAzLFxuICBJTlZFUlQ6ICAweDE1MEEsXG4gIElOQ1JfV1JBUDogMHg4NTA3LFxuICBERUNSX1dSQVA6IDB4ODUwOCxcblxuICAvLyBUZXh0dXJlc1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIHRleFBhcmFtZXRlcmkoKSxcbiAgLy8gdGV4UGFyYW1ldGVyZigpLCBiaW5kVGV4dHVyZSgpLCB0ZXhJbWFnZTJEKCksIGFuZCBvdGhlcnMuXG5cbiAgTkVBUkVTVDogMHgyNjAwLFxuICBMSU5FQVI6ICAweDI2MDEsXG4gIE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6ICAweDI3MDAsXG4gIExJTkVBUl9NSVBNQVBfTkVBUkVTVDogMHgyNzAxLFxuICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IDB4MjcwMixcbiAgTElORUFSX01JUE1BUF9MSU5FQVI6ICAweDI3MDMsXG4gIFRFWFRVUkVfTUFHX0ZJTFRFUjogIDB4MjgwMCxcbiAgVEVYVFVSRV9NSU5fRklMVEVSOiAgMHgyODAxLFxuICBURVhUVVJFX1dSQVBfUzogIDB4MjgwMixcbiAgVEVYVFVSRV9XUkFQX1Q6ICAweDI4MDMsXG4gIFRFWFRVUkVfMkQ6ICAweDBERTEsXG4gIFRFWFRVUkU6IDB4MTcwMixcbiAgVEVYVFVSRV9DVUJFX01BUDogIDB4ODUxMyxcbiAgVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQOiAgMHg4NTE0LFxuICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1g6IDB4ODUxNSxcbiAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOiAweDg1MTYsXG4gIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTogMHg4NTE3LFxuICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k6IDB4ODUxOCxcbiAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOiAweDg1MTksXG4gIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjogMHg4NTFBLFxuICBNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFOiAweDg1MUMsXG4gIC8vIFRFWFRVUkUwIC0gMzEgMHg4NEMwIC0gMHg4NERGIEEgdGV4dHVyZSB1bml0LlxuICBURVhUVVJFMDogMHg4NEMwLCAvLyBBIHRleHR1cmUgdW5pdC5cbiAgQUNUSVZFX1RFWFRVUkU6IDB4ODRFMCwgLy8gVGhlIGN1cnJlbnQgYWN0aXZlIHRleHR1cmUgdW5pdC5cbiAgUkVQRUFUOiAgMHgyOTAxLFxuICBDTEFNUF9UT19FREdFOiAweDgxMkYsXG4gIE1JUlJPUkVEX1JFUEVBVDogMHg4MzcwLFxuXG4gIC8vIEVtdWxhdGlvblxuICBURVhUVVJFX1dJRFRIOiAweDEwMDAsXG4gIFRFWFRVUkVfSEVJR0hUOiAweDEwMDEsXG5cbiAgLy8gVW5pZm9ybSB0eXBlc1xuXG4gIEZMT0FUX1ZFQzI6ICAweDhCNTAsXG4gIEZMT0FUX1ZFQzM6ICAweDhCNTEsXG4gIEZMT0FUX1ZFQzQ6ICAweDhCNTIsXG4gIElOVF9WRUMyOiAgMHg4QjUzLFxuICBJTlRfVkVDMzogIDB4OEI1NCxcbiAgSU5UX1ZFQzQ6ICAweDhCNTUsXG4gIEJPT0w6ICAweDhCNTYsXG4gIEJPT0xfVkVDMjogMHg4QjU3LFxuICBCT09MX1ZFQzM6IDB4OEI1OCxcbiAgQk9PTF9WRUM0OiAweDhCNTksXG4gIEZMT0FUX01BVDI6ICAweDhCNUEsXG4gIEZMT0FUX01BVDM6ICAweDhCNUIsXG4gIEZMT0FUX01BVDQ6ICAweDhCNUMsXG4gIFNBTVBMRVJfMkQ6ICAweDhCNUUsXG4gIFNBTVBMRVJfQ1VCRTogIDB4OEI2MCxcblxuICAvLyBTaGFkZXIgcHJlY2lzaW9uLXNwZWNpZmllZCB0eXBlc1xuXG4gIExPV19GTE9BVDogMHg4REYwLFxuICBNRURJVU1fRkxPQVQ6ICAweDhERjEsXG4gIEhJR0hfRkxPQVQ6ICAweDhERjIsXG4gIExPV19JTlQ6IDB4OERGMyxcbiAgTUVESVVNX0lOVDogIDB4OERGNCxcbiAgSElHSF9JTlQ6ICAweDhERjUsXG5cbiAgLy8gRnJhbWVidWZmZXJzIGFuZCByZW5kZXJidWZmZXJzXG5cbiAgRlJBTUVCVUZGRVI6IDB4OEQ0MCxcbiAgUkVOREVSQlVGRkVSOiAgMHg4RDQxLFxuICBSR0JBNDogMHg4MDU2LFxuICBSR0I1X0ExOiAweDgwNTcsXG4gIFJHQjU2NTogIDB4OEQ2MixcbiAgREVQVEhfQ09NUE9ORU5UMTY6IDB4ODFBNSxcbiAgU1RFTkNJTF9JTkRFWDogMHgxOTAxLFxuICBTVEVOQ0lMX0lOREVYODogIDB4OEQ0OCxcbiAgREVQVEhfU1RFTkNJTDogMHg4NEY5LFxuICBSRU5ERVJCVUZGRVJfV0lEVEg6ICAweDhENDIsXG4gIFJFTkRFUkJVRkZFUl9IRUlHSFQ6IDB4OEQ0MyxcbiAgUkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVDogIDB4OEQ0NCxcbiAgUkVOREVSQlVGRkVSX1JFRF9TSVpFOiAweDhENTAsXG4gIFJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFOiAweDhENTEsXG4gIFJFTkRFUkJVRkZFUl9CTFVFX1NJWkU6ICAweDhENTIsXG4gIFJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFOiAweDhENTMsXG4gIFJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFOiAweDhENTQsXG4gIFJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkU6IDB4OEQ1NSxcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfVFlQRTogIDB4OENEMCxcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRTogIDB4OENEMSxcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOiAgMHg4Q0QyLFxuICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRTogIDB4OENEMyxcbiAgQ09MT1JfQVRUQUNITUVOVDA6IDB4OENFMCxcbiAgREVQVEhfQVRUQUNITUVOVDogIDB4OEQwMCxcbiAgU1RFTkNJTF9BVFRBQ0hNRU5UOiAgMHg4RDIwLFxuICBERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6ICAweDgyMUEsXG4gIE5PTkU6ICAwLFxuICBGUkFNRUJVRkZFUl9DT01QTEVURTogIDB4OENENSxcbiAgRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOiAweDhDRDYsXG4gIEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOiAweDhDRDcsXG4gIEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzogMHg4Q0Q5LFxuICBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDogMHg4Q0RELFxuICBGUkFNRUJVRkZFUl9CSU5ESU5HOiAweDhDQTYsXG4gIFJFTkRFUkJVRkZFUl9CSU5ESU5HOiAgMHg4Q0E3LFxuICBNQVhfUkVOREVSQlVGRkVSX1NJWkU6IDB4ODRFOCxcbiAgSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046IDB4MDUwNixcblxuICAvLyBQaXhlbCBzdG9yYWdlIG1vZGVzXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gcGl4ZWxTdG9yZWkoKS5cblxuICBVTlBBQ0tfRkxJUF9ZX1dFQkdMOiAweDkyNDAsXG4gIFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDogMHg5MjQxLFxuICBVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMOiAweDkyNDNcbn0pO1xuXG4vLyBBZGRpdGlvbmFsIGNvbnN0YW50cyBkZWZpbmVkIFdlYkdMIDJcbi8vIFRoZXNlIGNvbnN0YW50cyBhcmUgZGVmaW5lZCBvbiB0aGUgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCBpbnRlcmZhY2UuXG4vLyBBbGwgV2ViR0wgMSBjb25zdGFudHMgYXJlIGFsc28gYXZhaWxhYmxlIGluIGEgV2ViR0wgMiBjb250ZXh0LlxuXG5PYmplY3QuYXNzaWduKEdMLCB7XG4gIC8vIEdldHRpbmcgR0wgcGFyYW1ldGVyIGluZm9ybWF0aW9uXG4gIC8vIENvbnN0YW50cyBwYXNzZWQgdG8gZ2V0UGFyYW1ldGVyKClcbiAgLy8gdG8gc3BlY2lmeSB3aGF0IGluZm9ybWF0aW9uIHRvIHJldHVybi5cblxuICBSRUFEX0JVRkZFUjogMHgwQzAyLFxuICBVTlBBQ0tfUk9XX0xFTkdUSDogMHgwQ0YyLFxuICBVTlBBQ0tfU0tJUF9ST1dTIDogMHgwQ0YzLFxuICBVTlBBQ0tfU0tJUF9QSVhFTFMgOiAweDBDRjQsXG4gIFBBQ0tfUk9XX0xFTkdUSDogMHgwRDAyLFxuICBQQUNLX1NLSVBfUk9XUyA6IDB4MEQwMyxcbiAgUEFDS19TS0lQX1BJWEVMUyA6IDB4MEQwNCxcbiAgVEVYVFVSRV9CSU5ESU5HXzNEIDogMHg4MDZBLFxuICBVTlBBQ0tfU0tJUF9JTUFHRVMgOiAweDgwNkQsXG4gIFVOUEFDS19JTUFHRV9IRUlHSFQ6IDB4ODA2RSxcbiAgTUFYXzNEX1RFWFRVUkVfU0laRTogMHg4MDczLFxuICBNQVhfRUxFTUVOVFNfVkVSVElDRVM6IDB4ODBFOCxcbiAgTUFYX0VMRU1FTlRTX0lORElDRVMgOiAweDgwRTksXG4gIE1BWF9URVhUVVJFX0xPRF9CSUFTIDogMHg4NEZELFxuICBNQVhfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTOiAweDhCNDksXG4gIE1BWF9WRVJURVhfVU5JRk9STV9DT01QT05FTlRTOiAweDhCNEEsXG4gIE1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyA6IDB4ODhGRixcbiAgTUlOX1BST0dSQU1fVEVYRUxfT0ZGU0VUIDogMHg4OTA0LFxuICBNQVhfUFJPR1JBTV9URVhFTF9PRkZTRVQgOiAweDg5MDUsXG4gIE1BWF9WQVJZSU5HX0NPTVBPTkVOVFMgOiAweDhCNEIsXG4gIEZSQUdNRU5UX1NIQURFUl9ERVJJVkFUSVZFX0hJTlQ6IDB4OEI4QixcbiAgUkFTVEVSSVpFUl9ESVNDQVJEIDogMHg4Qzg5LFxuICBWRVJURVhfQVJSQVlfQklORElORyA6IDB4ODVCNSxcbiAgTUFYX1ZFUlRFWF9PVVRQVVRfQ09NUE9ORU5UUyA6IDB4OTEyMixcbiAgTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFM6IDB4OTEyNSxcbiAgTUFYX1NFUlZFUl9XQUlUX1RJTUVPVVQ6IDB4OTExMSxcbiAgTUFYX0VMRU1FTlRfSU5ERVg6IDB4OEQ2QixcblxuICAvLyBUZXh0dXJlc1xuICAvLyBDb25zdGFudHMgcGFzc2VkIHRvIHRleFBhcmFtZXRlcmkoKSxcbiAgLy8gdGV4UGFyYW1ldGVyZigpLCBiaW5kVGV4dHVyZSgpLCB0ZXhJbWFnZTJEKCksIGFuZCBvdGhlcnMuXG5cbiAgUkVEOiAweDE5MDMsXG4gIFJHQjggOiAweDgwNTEsXG4gIFJHQkE4OiAweDgwNTgsXG4gIFJHQjEwX0EyIDogMHg4MDU5LFxuICBURVhUVVJFXzNEIDogMHg4MDZGLFxuICBURVhUVVJFX1dSQVBfUiA6IDB4ODA3MixcbiAgVEVYVFVSRV9NSU5fTE9EOiAweDgxM0EsXG4gIFRFWFRVUkVfTUFYX0xPRDogMHg4MTNCLFxuICBURVhUVVJFX0JBU0VfTEVWRUwgOiAweDgxM0MsXG4gIFRFWFRVUkVfTUFYX0xFVkVMOiAweDgxM0QsXG4gIFRFWFRVUkVfQ09NUEFSRV9NT0RFIDogMHg4ODRDLFxuICBURVhUVVJFX0NPTVBBUkVfRlVOQyA6IDB4ODg0RCxcbiAgU1JHQiA6IDB4OEM0MCxcbiAgU1JHQjg6IDB4OEM0MSxcbiAgU1JHQjhfQUxQSEE4IDogMHg4QzQzLFxuICBDT01QQVJFX1JFRl9UT19URVhUVVJFIDogMHg4ODRFLFxuICBSR0JBMzJGOiAweDg4MTQsXG4gIFJHQjMyRiA6IDB4ODgxNSxcbiAgUkdCQTE2RjogMHg4ODFBLFxuICBSR0IxNkYgOiAweDg4MUIsXG4gIFRFWFRVUkVfMkRfQVJSQVkgOiAweDhDMUEsXG4gIFRFWFRVUkVfQklORElOR18yRF9BUlJBWSA6IDB4OEMxRCxcbiAgUjExRl9HMTFGX0IxMEYgOiAweDhDM0EsXG4gIFJHQjlfRTU6IDB4OEMzRCxcbiAgUkdCQTMyVUkgOiAweDhENzAsXG4gIFJHQjMyVUk6IDB4OEQ3MSxcbiAgUkdCQTE2VUkgOiAweDhENzYsXG4gIFJHQjE2VUk6IDB4OEQ3NyxcbiAgUkdCQThVSTogMHg4RDdDLFxuICBSR0I4VUkgOiAweDhEN0QsXG4gIFJHQkEzMkk6IDB4OEQ4MixcbiAgUkdCMzJJIDogMHg4RDgzLFxuICBSR0JBMTZJOiAweDhEODgsXG4gIFJHQjE2SSA6IDB4OEQ4OSxcbiAgUkdCQThJIDogMHg4RDhFLFxuICBSR0I4STogMHg4RDhGLFxuICBSRURfSU5URUdFUjogMHg4RDk0LFxuICBSR0JfSU5URUdFUjogMHg4RDk4LFxuICBSR0JBX0lOVEVHRVIgOiAweDhEOTksXG4gIFI4IDogMHg4MjI5LFxuICBSRzg6IDB4ODIyQixcbiAgUjE2RiA6IDB4ODIyRCxcbiAgUjMyRiA6IDB4ODIyRSxcbiAgUkcxNkY6IDB4ODIyRixcbiAgUkczMkY6IDB4ODIzMCxcbiAgUjhJOiAweDgyMzEsXG4gIFI4VUkgOiAweDgyMzIsXG4gIFIxNkkgOiAweDgyMzMsXG4gIFIxNlVJOiAweDgyMzQsXG4gIFIzMkkgOiAweDgyMzUsXG4gIFIzMlVJOiAweDgyMzYsXG4gIFJHOEkgOiAweDgyMzcsXG4gIFJHOFVJOiAweDgyMzgsXG4gIFJHMTZJOiAweDgyMzksXG4gIFJHMTZVSSA6IDB4ODIzQSxcbiAgUkczMkk6IDB4ODIzQixcbiAgUkczMlVJIDogMHg4MjNDLFxuICBSOF9TTk9STSA6IDB4OEY5NCxcbiAgUkc4X1NOT1JNOiAweDhGOTUsXG4gIFJHQjhfU05PUk0gOiAweDhGOTYsXG4gIFJHQkE4X1NOT1JNOiAweDhGOTcsXG4gIFJHQjEwX0EyVUkgOiAweDkwNkYsXG5cbiAgLyogY292ZXJlZCBieSBleHRlbnNpb25cbiAgQ09NUFJFU1NFRF9SMTFfRUFDIDogMHg5MjcwLFxuICBDT01QUkVTU0VEX1NJR05FRF9SMTFfRUFDOiAweDkyNzEsXG4gIENPTVBSRVNTRURfUkcxMV9FQUM6IDB4OTI3MixcbiAgQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUMgOiAweDkyNzMsXG4gIENPTVBSRVNTRURfUkdCOF9FVEMyIDogMHg5Mjc0LFxuICBDT01QUkVTU0VEX1NSR0I4X0VUQzI6IDB4OTI3NSxcbiAgQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMiA6IDB4OTI3NixcbiAgQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQyA6IDB4OTI3NyxcbiAgQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQzogMHg5Mjc4LFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyA6IDB4OTI3OSxcbiAgKi9cbiAgVEVYVFVSRV9JTU1VVEFCTEVfRk9STUFUIDogMHg5MTJGLFxuICBURVhUVVJFX0lNTVVUQUJMRV9MRVZFTFMgOiAweDgyREYsXG5cbiAgLy8gUGl4ZWwgdHlwZXNcblxuICBVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVY6IDB4ODM2OCxcbiAgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFViA6IDB4OEMzQixcbiAgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWIDogMHg4QzNFLFxuICBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgOiAweDhEQUQsXG4gIFVOU0lHTkVEX0lOVF8yNF84OiAweDg0RkEsXG4gIEhBTEZfRkxPQVQgOiAweDE0MEIsXG4gIFJHIDogMHg4MjI3LFxuICBSR19JTlRFR0VSIDogMHg4MjI4LFxuICBJTlRfMl8xMF8xMF8xMF9SRVYgOiAweDhEOUYsXG5cbiAgLy8gUXVlcmllc1xuXG4gIENVUlJFTlRfUVVFUlk6IDB4ODg2NSxcbiAgUVVFUllfUkVTVUxUIDogMHg4ODY2LFxuICBRVUVSWV9SRVNVTFRfQVZBSUxBQkxFIDogMHg4ODY3LFxuICBBTllfU0FNUExFU19QQVNTRUQgOiAweDhDMkYsXG4gIEFOWV9TQU1QTEVTX1BBU1NFRF9DT05TRVJWQVRJVkU6IDB4OEQ2QSxcblxuICAvLyBEcmF3IGJ1ZmZlcnNcblxuICBNQVhfRFJBV19CVUZGRVJTIDogMHg4ODI0LFxuICBEUkFXX0JVRkZFUjAgOiAweDg4MjUsXG4gIERSQVdfQlVGRkVSMSA6IDB4ODgyNixcbiAgRFJBV19CVUZGRVIyIDogMHg4ODI3LFxuICBEUkFXX0JVRkZFUjMgOiAweDg4MjgsXG4gIERSQVdfQlVGRkVSNCA6IDB4ODgyOSxcbiAgRFJBV19CVUZGRVI1IDogMHg4ODJBLFxuICBEUkFXX0JVRkZFUjYgOiAweDg4MkIsXG4gIERSQVdfQlVGRkVSNyA6IDB4ODgyQyxcbiAgRFJBV19CVUZGRVI4IDogMHg4ODJELFxuICBEUkFXX0JVRkZFUjkgOiAweDg4MkUsXG4gIERSQVdfQlVGRkVSMTA6IDB4ODgyRixcbiAgRFJBV19CVUZGRVIxMTogMHg4ODMwLFxuICBEUkFXX0JVRkZFUjEyOiAweDg4MzEsXG4gIERSQVdfQlVGRkVSMTM6IDB4ODgzMixcbiAgRFJBV19CVUZGRVIxNDogMHg4ODMzLFxuICBEUkFXX0JVRkZFUjE1OiAweDg4MzQsXG4gIE1BWF9DT0xPUl9BVFRBQ0hNRU5UUzogMHg4Q0RGLFxuICBDT0xPUl9BVFRBQ0hNRU5UMTogMHg4Q0UxLFxuICBDT0xPUl9BVFRBQ0hNRU5UMjogMHg4Q0UyLFxuICBDT0xPUl9BVFRBQ0hNRU5UMzogMHg4Q0UzLFxuICBDT0xPUl9BVFRBQ0hNRU5UNDogMHg4Q0U0LFxuICBDT0xPUl9BVFRBQ0hNRU5UNTogMHg4Q0U1LFxuICBDT0xPUl9BVFRBQ0hNRU5UNjogMHg4Q0U2LFxuICBDT0xPUl9BVFRBQ0hNRU5UNzogMHg4Q0U3LFxuICBDT0xPUl9BVFRBQ0hNRU5UODogMHg4Q0U4LFxuICBDT0xPUl9BVFRBQ0hNRU5UOTogMHg4Q0U5LFxuICBDT0xPUl9BVFRBQ0hNRU5UMTAgOiAweDhDRUEsXG4gIENPTE9SX0FUVEFDSE1FTlQxMSA6IDB4OENFQixcbiAgQ09MT1JfQVRUQUNITUVOVDEyIDogMHg4Q0VDLFxuICBDT0xPUl9BVFRBQ0hNRU5UMTMgOiAweDhDRUQsXG4gIENPTE9SX0FUVEFDSE1FTlQxNCA6IDB4OENFRSxcbiAgQ09MT1JfQVRUQUNITUVOVDE1IDogMHg4Q0VGLFxuXG4gIC8vIFNhbXBsZXJzXG5cbiAgU0FNUExFUl8zRCA6IDB4OEI1RixcbiAgU0FNUExFUl8yRF9TSEFET1c6IDB4OEI2MixcbiAgU0FNUExFUl8yRF9BUlJBWSA6IDB4OERDMSxcbiAgU0FNUExFUl8yRF9BUlJBWV9TSEFET1c6IDB4OERDNCxcbiAgU0FNUExFUl9DVUJFX1NIQURPVzogMHg4REM1LFxuICBJTlRfU0FNUExFUl8yRCA6IDB4OERDQSxcbiAgSU5UX1NBTVBMRVJfM0QgOiAweDhEQ0IsXG4gIElOVF9TQU1QTEVSX0NVQkUgOiAweDhEQ0MsXG4gIElOVF9TQU1QTEVSXzJEX0FSUkFZIDogMHg4RENGLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRDogMHg4REQyLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8zRDogMHg4REQzLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFOiAweDhERDQsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZOiAweDhERDcsXG4gIE1BWF9TQU1QTEVTOiAweDhENTcsXG4gIFNBTVBMRVJfQklORElORzogMHg4OTE5LFxuXG4gIC8vIEJ1ZmZlcnNcblxuICBQSVhFTF9QQUNLX0JVRkZFUjogMHg4OEVCLFxuICBQSVhFTF9VTlBBQ0tfQlVGRkVSOiAweDg4RUMsXG4gIFBJWEVMX1BBQ0tfQlVGRkVSX0JJTkRJTkc6IDB4ODhFRCxcbiAgUElYRUxfVU5QQUNLX0JVRkZFUl9CSU5ESU5HOiAweDg4RUYsXG4gIENPUFlfUkVBRF9CVUZGRVIgOiAweDhGMzYsXG4gIENPUFlfV1JJVEVfQlVGRkVSOiAweDhGMzcsXG4gIENPUFlfUkVBRF9CVUZGRVJfQklORElORyA6IDB4OEYzNixcbiAgQ09QWV9XUklURV9CVUZGRVJfQklORElORzogMHg4RjM3LFxuXG4gIC8vIERhdGEgdHlwZXNcblxuICBGTE9BVF9NQVQyeDMgOiAweDhCNjUsXG4gIEZMT0FUX01BVDJ4NCA6IDB4OEI2NixcbiAgRkxPQVRfTUFUM3gyIDogMHg4QjY3LFxuICBGTE9BVF9NQVQzeDQgOiAweDhCNjgsXG4gIEZMT0FUX01BVDR4MiA6IDB4OEI2OSxcbiAgRkxPQVRfTUFUNHgzIDogMHg4QjZBLFxuICBVTlNJR05FRF9JTlRfVkVDMjogMHg4REM2LFxuICBVTlNJR05FRF9JTlRfVkVDMzogMHg4REM3LFxuICBVTlNJR05FRF9JTlRfVkVDNDogMHg4REM4LFxuICBVTlNJR05FRF9OT1JNQUxJWkVEOiAweDhDMTcsXG4gIFNJR05FRF9OT1JNQUxJWkVEOiAweDhGOUMsXG5cbiAgLy8gVmVydGV4IGF0dHJpYnV0ZXNcblxuICBWRVJURVhfQVRUUklCX0FSUkFZX0lOVEVHRVI6IDB4ODhGRCxcbiAgVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SOiAweDg4RkUsXG5cbiAgLy8gVHJhbnNmb3JtIGZlZWRiYWNrXG5cbiAgVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9NT0RFIDogMHg4QzdGLFxuICBNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX1NFUEFSQVRFX0NPTVBPTkVOVFMgOiAweDhDODAsXG4gIFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUzogMHg4QzgzLFxuICBUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX1NUQVJUOiAweDhDODQsXG4gIFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRSA6IDB4OEM4NSxcbiAgVFJBTlNGT1JNX0ZFRURCQUNLX1BSSU1JVElWRVNfV1JJVFRFTjogMHg4Qzg4LFxuICBNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX0lOVEVSTEVBVkVEX0NPTVBPTkVOVFM6IDB4OEM4QSxcbiAgTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTOiAweDhDOEIsXG4gIElOVEVSTEVBVkVEX0FUVFJJQlM6IDB4OEM4QyxcbiAgU0VQQVJBVEVfQVRUUklCUyA6IDB4OEM4RCxcbiAgVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUjogMHg4QzhFLFxuICBUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX0JJTkRJTkc6IDB4OEM4RixcbiAgVFJBTlNGT1JNX0ZFRURCQUNLIDogMHg4RTIyLFxuICBUUkFOU0ZPUk1fRkVFREJBQ0tfUEFVU0VEOiAweDhFMjMsXG4gIFRSQU5TRk9STV9GRUVEQkFDS19BQ1RJVkU6IDB4OEUyNCxcbiAgVFJBTlNGT1JNX0ZFRURCQUNLX0JJTkRJTkcgOiAweDhFMjUsXG5cbiAgLy8gRnJhbWVidWZmZXJzIGFuZCByZW5kZXJidWZmZXJzXG5cbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT0xPUl9FTkNPRElORzogMHg4MjEwLFxuICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFOiAweDgyMTEsXG4gIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUkVEX1NJWkU6IDB4ODIxMixcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9HUkVFTl9TSVpFOiAweDgyMTMsXG4gIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFIDogMHg4MjE0LFxuICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0FMUEhBX1NJWkU6IDB4ODIxNSxcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9ERVBUSF9TSVpFOiAweDgyMTYsXG4gIEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfU1RFTkNJTF9TSVpFOiAweDgyMTcsXG4gIEZSQU1FQlVGRkVSX0RFRkFVTFQ6IDB4ODIxOCxcbiAgREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogMHg4MjFBLFxuICBERVBUSF9TVEVOQ0lMOiAweDg0RjksXG4gIERFUFRIMjRfU1RFTkNJTDggOiAweDg4RjAsXG4gIERSQVdfRlJBTUVCVUZGRVJfQklORElORyA6IDB4OENBNixcbiAgUkVBRF9GUkFNRUJVRkZFUiA6IDB4OENBOCxcbiAgRFJBV19GUkFNRUJVRkZFUiA6IDB4OENBOSxcbiAgUkVBRF9GUkFNRUJVRkZFUl9CSU5ESU5HIDogMHg4Q0FBLFxuICBSRU5ERVJCVUZGRVJfU0FNUExFUyA6IDB4OENBQixcbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSIDogMHg4Q0Q0LFxuICBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFIDogMHg4RDU2LFxuXG4gIC8vIFVuaWZvcm1zXG5cbiAgVU5JRk9STV9CVUZGRVIgOiAweDhBMTEsXG4gIFVOSUZPUk1fQlVGRkVSX0JJTkRJTkcgOiAweDhBMjgsXG4gIFVOSUZPUk1fQlVGRkVSX1NUQVJUIDogMHg4QTI5LFxuICBVTklGT1JNX0JVRkZFUl9TSVpFOiAweDhBMkEsXG4gIE1BWF9WRVJURVhfVU5JRk9STV9CTE9DS1M6IDB4OEEyQixcbiAgTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQkxPQ0tTOiAweDhBMkQsXG4gIE1BWF9DT01CSU5FRF9VTklGT1JNX0JMT0NLUzogMHg4QTJFLFxuICBNQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1M6IDB4OEEyRixcbiAgTUFYX1VOSUZPUk1fQkxPQ0tfU0laRSA6IDB4OEEzMCxcbiAgTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFMgOiAweDhBMzEsXG4gIE1BWF9DT01CSU5FRF9GUkFHTUVOVF9VTklGT1JNX0NPTVBPTkVOVFMgOiAweDhBMzMsXG4gIFVOSUZPUk1fQlVGRkVSX09GRlNFVF9BTElHTk1FTlQ6IDB4OEEzNCxcbiAgQUNUSVZFX1VOSUZPUk1fQkxPQ0tTOiAweDhBMzYsXG4gIFVOSUZPUk1fVFlQRSA6IDB4OEEzNyxcbiAgVU5JRk9STV9TSVpFIDogMHg4QTM4LFxuICBVTklGT1JNX0JMT0NLX0lOREVYOiAweDhBM0EsXG4gIFVOSUZPUk1fT0ZGU0VUIDogMHg4QTNCLFxuICBVTklGT1JNX0FSUkFZX1NUUklERSA6IDB4OEEzQyxcbiAgVU5JRk9STV9NQVRSSVhfU1RSSURFOiAweDhBM0QsXG4gIFVOSUZPUk1fSVNfUk9XX01BSk9SIDogMHg4QTNFLFxuICBVTklGT1JNX0JMT0NLX0JJTkRJTkc6IDB4OEEzRixcbiAgVU5JRk9STV9CTE9DS19EQVRBX1NJWkU6IDB4OEE0MCxcbiAgVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STVM6IDB4OEE0MixcbiAgVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STV9JTkRJQ0VTIDogMHg4QTQzLFxuICBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfVkVSVEVYX1NIQURFUjogMHg4QTQ0LFxuICBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSOiAweDhBNDYsXG5cbiAgLy8gU3luYyBvYmplY3RzXG5cbiAgT0JKRUNUX1RZUEU6IDB4OTExMixcbiAgU1lOQ19DT05ESVRJT046ICAweDkxMTMsXG4gIFNZTkNfU1RBVFVTOiAweDkxMTQsXG4gIFNZTkNfRkxBR1M6ICAweDkxMTUsXG4gIFNZTkNfRkVOQ0U6ICAweDkxMTYsXG4gIFNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFOiAgMHg5MTE3LFxuICBVTlNJR05BTEVEOiAgMHg5MTE4LFxuICBTSUdOQUxFRDogIDB4OTExOSxcbiAgQUxSRUFEWV9TSUdOQUxFRDogIDB4OTExQSxcbiAgVElNRU9VVF9FWFBJUkVEOiAweDkxMUIsXG4gIENPTkRJVElPTl9TQVRJU0ZJRUQ6IDB4OTExQyxcbiAgV0FJVF9GQUlMRUQ6IDB4OTExRCxcbiAgU1lOQ19GTFVTSF9DT01NQU5EU19CSVQ6IDB4MDAwMDAwMDEsXG5cbiAgLy8gTWlzY2VsbGFuZW91cyBjb25zdGFudHNcblxuICBDT0xPUjogMHgxODAwLFxuICBERVBUSDogMHgxODAxLFxuICBTVEVOQ0lMOiAweDE4MDIsXG4gIE1JTjogMHg4MDA3LFxuICBNQVg6IDB4ODAwOCxcbiAgREVQVEhfQ09NUE9ORU5UMjQ6IDB4ODFBNixcbiAgU1RSRUFNX1JFQUQ6IDB4ODhFMSxcbiAgU1RSRUFNX0NPUFk6IDB4ODhFMixcbiAgU1RBVElDX1JFQUQ6IDB4ODhFNSxcbiAgU1RBVElDX0NPUFk6IDB4ODhFNixcbiAgRFlOQU1JQ19SRUFEOiAgMHg4OEU5LFxuICBEWU5BTUlDX0NPUFk6ICAweDg4RUEsXG4gIERFUFRIX0NPTVBPTkVOVDMyRjogIDB4OENBQyxcbiAgREVQVEgzMkZfU1RFTkNJTDg6IDB4OENBRCxcbiAgSU5WQUxJRF9JTkRFWDogMHhGRkZGRkZGRixcbiAgVElNRU9VVF9JR05PUkVEOiAtMSxcbiAgTUFYX0NMSUVOVF9XQUlUX1RJTUVPVVRfV0VCR0w6IDB4OTI0NyxcblxuICAvLyBDb25zdGFudHMgZGVmaW5lZCBpbiBXZWJHTCBleHRlbnNpb25zXG5cbiAgLy8gQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xuXG4gIFZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRTogMHg4OEZFLCAvLyBEZXNjcmliZXMgdGhlIGZyZXF1ZW5jeSBkaXZpc29yIHVzZWQgZm9yIGluc3RhbmNlZCByZW5kZXJpbmcuXG5cbiAgLy8gV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mb1xuXG4gIFVOTUFTS0VEX1ZFTkRPUl9XRUJHTDogMHg5MjQ1LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgdmVuZG9yIHN0cmluZyBvZiB0aGUgZ3JhcGhpY3MgZHJpdmVyLlxuICBVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTDogMHg5MjQ2LCAvLyBQYXNzZWQgdG8gZ2V0UGFyYW1ldGVyIHRvIGdldCB0aGUgcmVuZGVyZXIgc3RyaW5nIG9mIHRoZSBncmFwaGljcyBkcml2ZXIuXG5cbiAgLy8gRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXG5cbiAgTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUOiAgMHg4NEZGLCAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBhbmlzb3Ryb3B5LlxuICBURVhUVVJFX01BWF9BTklTT1RST1BZX0VYVDogIDB4ODRGRSwgLy8gUGFzc2VkIHRvIHRleFBhcmFtZXRlciB0byBzZXQgdGhlIGRlc2lyZWQgbWF4aW11bSBhbmlzb3Ryb3B5IGZvciBhIHRleHR1cmUuXG5cbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcblxuICBDT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUOiAgMHg4M0YwLCAvLyBBIERYVDEtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0IgaW1hZ2UgZm9ybWF0LlxuICBDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDogMHg4M0YxLCAvLyBBIERYVDEtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0IgaW1hZ2UgZm9ybWF0IHdpdGggYSBzaW1wbGUgb24vb2ZmIGFscGhhIHZhbHVlLlxuICBDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDogMHg4M0YyLCAvLyBBIERYVDMtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0JBIGltYWdlIGZvcm1hdC4gQ29tcGFyZWQgdG8gYSAzMi1iaXQgUkdCQSB0ZXh0dXJlLCBpdCBvZmZlcnMgNDoxIGNvbXByZXNzaW9uLlxuICBDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDogMHg4M0YzLCAvLyBBIERYVDUtY29tcHJlc3NlZCBpbWFnZSBpbiBhbiBSR0JBIGltYWdlIGZvcm1hdC4gSXQgYWxzbyBwcm92aWRlcyBhIDQ6MSBjb21wcmVzc2lvbiwgYnV0IGRpZmZlcnMgdG8gdGhlIERYVDMgY29tcHJlc3Npb24gaW4gaG93IHRoZSBhbHBoYSBjb21wcmVzc2lvbiBpcyBkb25lLlxuXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9lczNcblxuICBDT01QUkVTU0VEX1IxMV9FQUM6ICAweDkyNzAsIC8vIE9uZS1jaGFubmVsIChyZWQpIHVuc2lnbmVkIGZvcm1hdCBjb21wcmVzc2lvbi5cbiAgQ09NUFJFU1NFRF9TSUdORURfUjExX0VBQzogMHg5MjcxLCAvLyBPbmUtY2hhbm5lbCAocmVkKSBzaWduZWQgZm9ybWF0IGNvbXByZXNzaW9uLlxuICBDT01QUkVTU0VEX1JHMTFfRUFDOiAweDkyNzIsIC8vIFR3by1jaGFubmVsIChyZWQgYW5kIGdyZWVuKSB1bnNpZ25lZCBmb3JtYXQgY29tcHJlc3Npb24uXG4gIENPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDOiAgMHg5MjczLCAvLyBUd28tY2hhbm5lbCAocmVkIGFuZCBncmVlbikgc2lnbmVkIGZvcm1hdCBjb21wcmVzc2lvbi5cbiAgQ09NUFJFU1NFRF9SR0I4X0VUQzI6ICAweDkyNzQsIC8vIENvbXByZXNzZXMgUkJHOCBkYXRhIHdpdGggbm8gYWxwaGEgY2hhbm5lbC5cbiAgQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQzogMHg5Mjc1LCAvLyBDb21wcmVzc2VzIFJHQkE4IGRhdGEuIFRoZSBSR0IgcGFydCBpcyBlbmNvZGVkIHRoZSBzYW1lIGFzIFJHQl9FVEMyLCBidXQgdGhlIGFscGhhIHBhcnQgaXMgZW5jb2RlZCBzZXBhcmF0ZWx5LlxuICBDT01QUkVTU0VEX1NSR0I4X0VUQzI6IDB4OTI3NiwgLy8gQ29tcHJlc3NlcyBzUkJHOCBkYXRhIHdpdGggbm8gYWxwaGEgY2hhbm5lbC5cbiAgQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUM6ICAweDkyNzcsIC8vIENvbXByZXNzZXMgc1JHQkE4IGRhdGEuIFRoZSBzUkdCIHBhcnQgaXMgZW5jb2RlZCB0aGUgc2FtZSBhcyBTUkdCX0VUQzIsIGJ1dCB0aGUgYWxwaGEgcGFydCBpcyBlbmNvZGVkIHNlcGFyYXRlbHkuXG4gIENPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6ICAweDkyNzgsIC8vIFNpbWlsYXIgdG8gUkdCOF9FVEMsIGJ1dCB3aXRoIGFiaWxpdHkgdG8gcHVuY2ggdGhyb3VnaCB0aGUgYWxwaGEgY2hhbm5lbCwgd2hpY2ggbWVhbnMgdG8gbWFrZSBpdCBjb21wbGV0ZWx5IG9wYXF1ZSBvciB0cmFuc3BhcmVudC5cbiAgQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6IDB4OTI3OSwgLy8gU2ltaWxhciB0byBTUkdCOF9FVEMsIGJ1dCB3aXRoIGFiaWxpdHkgdG8gcHVuY2ggdGhyb3VnaCB0aGUgYWxwaGEgY2hhbm5lbCwgd2hpY2ggbWVhbnMgdG8gbWFrZSBpdCBjb21wbGV0ZWx5IG9wYXF1ZSBvciB0cmFuc3BhcmVudC5cblxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcblxuICBDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HOiAweDhDMDAsIC8vIFJHQiBjb21wcmVzc2lvbiBpbiA0LWJpdCBtb2RlLiBPbmUgYmxvY2sgZm9yIGVhY2ggNMOXNCBwaXhlbHMuXG4gIENPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HOiAgMHg4QzAyLCAvLyBSR0JBIGNvbXByZXNzaW9uIGluIDQtYml0IG1vZGUuIE9uZSBibG9jayBmb3IgZWFjaCA0w5c0IHBpeGVscy5cbiAgQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRzogMHg4QzAxLCAvLyBSR0IgY29tcHJlc3Npb24gaW4gMi1iaXQgbW9kZS4gT25lIGJsb2NrIGZvciBlYWNoIDjDlzQgcGl4ZWxzLlxuICBDT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRzogIDB4OEMwMywgLy8gUkdCQSBjb21wcmVzc2lvbiBpbiAyLWJpdCBtb2RlLiBPbmUgYmxvY2sgZm9yIGVhY2ggOMOXNCBwaXhlXG5cbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcblxuICBDT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMOiAweDhENjQsIC8vIENvbXByZXNzZXMgMjQtYml0IFJHQiBkYXRhIHdpdGggbm8gYWxwaGEgY2hhbm5lbC5cblxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXG5cbiAgQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMOiAweDhDOTIsIC8vICBDb21wcmVzc2VzIFJHQiB0ZXh0dXJlcyB3aXRoIG5vIGFscGhhIGNoYW5uZWwuXG4gIENPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0w6ICAweDhDOTIsIC8vIENvbXByZXNzZXMgUkdCQSB0ZXh0dXJlcyB1c2luZyBleHBsaWNpdCBhbHBoYSBlbmNvZGluZyAodXNlZnVsIHdoZW4gYWxwaGEgdHJhbnNpdGlvbnMgYXJlIHNoYXJwKS5cbiAgQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0w6ICAweDg3RUUsIC8vIENvbXByZXNzZXMgUkdCQSB0ZXh0dXJlcyB1c2luZyBpbnRlcnBvbGF0ZWQgYWxwaGEgZW5jb2RpbmcgKHVzZWZ1bCB3aGVuIGFscGhhIHRyYW5zaXRpb25zIGFyZSBncmFkaWVudCkuXG5cbiAgLy8gV0VCR0xfZGVwdGhfdGV4dHVyZVxuXG4gIFVOU0lHTkVEX0lOVF8yNF84X1dFQkdMOiAweDg0RkEsIC8vIFVuc2lnbmVkIGludGVnZXIgdHlwZSBmb3IgMjQtYml0IGRlcHRoIHRleHR1cmUgZGF0YS5cblxuICAvLyBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XG5cbiAgSEFMRl9GTE9BVF9PRVM6ICAweDhENjEsIC8vIEhhbGYgZmxvYXRpbmctcG9pbnQgdHlwZSAoMTYtYml0KS5cblxuICAvLyBXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcblxuICBSR0JBMzJGX0VYVDogMHg4ODE0LCAvLyBSR0JBIDMyLWJpdCBmbG9hdGluZy1wb2ludCBjb2xvci1yZW5kZXJhYmxlIGZvcm1hdC5cbiAgUkdCMzJGX0VYVDogIDB4ODgxNSwgLy8gUkdCIDMyLWJpdCBmbG9hdGluZy1wb2ludCBjb2xvci1yZW5kZXJhYmxlIGZvcm1hdC5cbiAgRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT01QT05FTlRfVFlQRV9FWFQ6IDB4ODIxMSxcbiAgVU5TSUdORURfTk9STUFMSVpFRF9FWFQ6IDB4OEMxNyxcblxuICAvLyBFWFRfYmxlbmRfbWlubWF4XG5cbiAgTUlOX0VYVDogMHg4MDA3LCAvLyBQcm9kdWNlcyB0aGUgbWluaW11bSBjb2xvciBjb21wb25lbnRzIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGNvbG9ycy5cbiAgTUFYX0VYVDogMHg4MDA4LCAvLyBQcm9kdWNlcyB0aGUgbWF4aW11bSBjb2xvciBjb21wb25lbnRzIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGNvbG9ycy5cblxuICAvLyBFWFRfc1JHQlxuXG4gIFNSR0JfRVhUOiAgMHg4QzQwLCAvLyBVbnNpemVkIHNSR0IgZm9ybWF0IHRoYXQgbGVhdmVzIHRoZSBwcmVjaXNpb24gdXAgdG8gdGhlIGRyaXZlci5cbiAgU1JHQl9BTFBIQV9FWFQ6ICAweDhDNDIsIC8vIFVuc2l6ZWQgc1JHQiBmb3JtYXQgd2l0aCB1bnNpemVkIGFscGhhIGNvbXBvbmVudC5cbiAgU1JHQjhfQUxQSEE4X0VYVDogIDB4OEM0MywgLy8gU2l6ZWQgKDgtYml0KSBzUkdCIGFuZCBhbHBoYSBmb3JtYXRzLlxuICBGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTE9SX0VOQ09ESU5HX0VYVDogMHg4MjEwLCAvLyBSZXR1cm5zIHRoZSBmcmFtZWJ1ZmZlciBjb2xvciBlbmNvZGluZy5cblxuICAvLyBPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcblxuICBGUkFHTUVOVF9TSEFERVJfREVSSVZBVElWRV9ISU5UX09FUzogMHg4QjhCLCAvLyBJbmRpY2F0ZXMgdGhlIGFjY3VyYWN5IG9mIHRoZSBkZXJpdmF0aXZlIGNhbGN1bGF0aW9uIGZvciB0aGUgR0xTTCBidWlsdC1pbiBmdW5jdGlvbnM6IGRGZHgsIGRGZHksIGFuZCBmd2lkdGguXG5cbiAgLy8gV0VCR0xfZHJhd19idWZmZXJzXG5cbiAgQ09MT1JfQVRUQUNITUVOVDBfV0VCR0w6IDB4OENFMCwgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBDT0xPUl9BVFRBQ0hNRU5UMV9XRUJHTDogMHg4Q0UxLCAvLyBGcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50XG4gIENPTE9SX0FUVEFDSE1FTlQyX1dFQkdMOiAweDhDRTIsIC8vIEZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgcG9pbnRcbiAgQ09MT1JfQVRUQUNITUVOVDNfV0VCR0w6IDB4OENFMywgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBDT0xPUl9BVFRBQ0hNRU5UNF9XRUJHTDogMHg4Q0U0LCAvLyBGcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50XG4gIENPTE9SX0FUVEFDSE1FTlQ1X1dFQkdMOiAweDhDRTUsIC8vIEZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgcG9pbnRcbiAgQ09MT1JfQVRUQUNITUVOVDZfV0VCR0w6IDB4OENFNiwgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBDT0xPUl9BVFRBQ0hNRU5UN19XRUJHTDogMHg4Q0U3LCAvLyBGcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50XG4gIENPTE9SX0FUVEFDSE1FTlQ4X1dFQkdMOiAweDhDRTgsIC8vIEZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgcG9pbnRcbiAgQ09MT1JfQVRUQUNITUVOVDlfV0VCR0w6IDB4OENFOSwgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBDT0xPUl9BVFRBQ0hNRU5UMTBfV0VCR0w6ICAweDhDRUEsIC8vIEZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgcG9pbnRcbiAgQ09MT1JfQVRUQUNITUVOVDExX1dFQkdMOiAgMHg4Q0VCLCAvLyBGcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50XG4gIENPTE9SX0FUVEFDSE1FTlQxMl9XRUJHTDogIDB4OENFQywgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBDT0xPUl9BVFRBQ0hNRU5UMTNfV0VCR0w6ICAweDhDRUQsIC8vIEZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgcG9pbnRcbiAgQ09MT1JfQVRUQUNITUVOVDE0X1dFQkdMOiAgMHg4Q0VFLCAvLyBGcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50XG4gIENPTE9SX0FUVEFDSE1FTlQxNV9XRUJHTDogIDB4OENFRiwgLy8gRnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCBwb2ludFxuICBEUkFXX0JVRkZFUjBfV0VCR0w6ICAweDg4MjUsIC8vIERyYXcgYnVmZmVyXG4gIERSQVdfQlVGRkVSMV9XRUJHTDogIDB4ODgyNiwgLy8gRHJhdyBidWZmZXJcbiAgRFJBV19CVUZGRVIyX1dFQkdMOiAgMHg4ODI3LCAvLyBEcmF3IGJ1ZmZlclxuICBEUkFXX0JVRkZFUjNfV0VCR0w6ICAweDg4MjgsIC8vIERyYXcgYnVmZmVyXG4gIERSQVdfQlVGRkVSNF9XRUJHTDogIDB4ODgyOSwgLy8gRHJhdyBidWZmZXJcbiAgRFJBV19CVUZGRVI1X1dFQkdMOiAgMHg4ODJBLCAvLyBEcmF3IGJ1ZmZlclxuICBEUkFXX0JVRkZFUjZfV0VCR0w6ICAweDg4MkIsIC8vIERyYXcgYnVmZmVyXG4gIERSQVdfQlVGRkVSN19XRUJHTDogIDB4ODgyQywgLy8gRHJhdyBidWZmZXJcbiAgRFJBV19CVUZGRVI4X1dFQkdMOiAgMHg4ODJELCAvLyBEcmF3IGJ1ZmZlclxuICBEUkFXX0JVRkZFUjlfV0VCR0w6ICAweDg4MkUsIC8vIERyYXcgYnVmZmVyXG4gIERSQVdfQlVGRkVSMTBfV0VCR0w6IDB4ODgyRiwgLy8gRHJhdyBidWZmZXJcbiAgRFJBV19CVUZGRVIxMV9XRUJHTDogMHg4ODMwLCAvLyBEcmF3IGJ1ZmZlclxuICBEUkFXX0JVRkZFUjEyX1dFQkdMOiAweDg4MzEsIC8vIERyYXcgYnVmZmVyXG4gIERSQVdfQlVGRkVSMTNfV0VCR0w6IDB4ODgzMiwgLy8gRHJhdyBidWZmZXJcbiAgRFJBV19CVUZGRVIxNF9XRUJHTDogMHg4ODMzLCAvLyBEcmF3IGJ1ZmZlclxuICBEUkFXX0JVRkZFUjE1X1dFQkdMOiAweDg4MzQsIC8vIERyYXcgYnVmZmVyXG4gIE1BWF9DT0xPUl9BVFRBQ0hNRU5UU19XRUJHTDogMHg4Q0RGLCAvLyBNYXhpbXVtIG51bWJlciBvZiBmcmFtZWJ1ZmZlciBjb2xvciBhdHRhY2htZW50IHBvaW50c1xuICBNQVhfRFJBV19CVUZGRVJTX1dFQkdMOiAgMHg4ODI0LCAvLyBNYXhpbXVtIG51bWJlciBvZiBkcmF3IGJ1ZmZlcnNcblxuICAvLyBPRVNfdmVydGV4X2FycmF5X29iamVjdFxuXG4gIFZFUlRFWF9BUlJBWV9CSU5ESU5HX09FUzogIDB4ODVCNSwgLy8gVGhlIGJvdW5kIHZlcnRleCBhcnJheSBvYmplY3QgKFZBTykuXG5cbiAgLy8gRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XG5cbiAgUVVFUllfQ09VTlRFUl9CSVRTX0VYVDogIDB4ODg2NCwgLy8gVGhlIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gaG9sZCB0aGUgcXVlcnkgcmVzdWx0IGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LlxuICBDVVJSRU5UX1FVRVJZX0VYVDogMHg4ODY1LCAvLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBxdWVyeS5cbiAgUVVFUllfUkVTVUxUX0VYVDogIDB4ODg2NiwgLy8gVGhlIHF1ZXJ5IHJlc3VsdC5cbiAgUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQ6ICAweDg4NjcsIC8vIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGEgcXVlcnkgcmVzdWx0IGlzIGF2YWlsYWJsZS5cbiAgVElNRV9FTEFQU0VEX0VYVDogIDB4ODhCRiwgLy8gRWxhcHNlZCB0aW1lIChpbiBuYW5vc2Vjb25kcykuXG4gIFRJTUVTVEFNUF9FWFQ6IDB4OEUyOCwgLy8gVGhlIGN1cnJlbnQgdGltZS5cbiAgR1BVX0RJU0pPSU5UX0VYVDogIDB4OEZCQiAvLyBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgR1BVIHBlcmZvcm1lZCBhbnkgZGlzam9pbnQgb3BlcmF0aW9uLlxufSk7XG4iXX0=

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(4);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }






var ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';

// TODO - Handle context loss
// function glGetContextLossCount(gl) {
//   return (gl.luma && gl.luma.glCount) || 0;
// }

var Resource = function () {
  function Resource(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Resource);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);

    var id = opts.id,
        _opts$userData = opts.userData,
        userData = _opts$userData === undefined ? {} : _opts$userData;

    this.gl = gl;
    this.ext = null;
    this.id = id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils__["uid"])(this.constructor.name);
    this.userData = userData;
    this.opts = opts;

    // Set the handle
    // If handle was provided, use it, otherwise create a new handle

    // TODO - Stores the handle with context loss information
    // this.glCount = glGetContextLossCount(this.gl);
    this._handle = opts.handle || this._createHandle();

    this._addStats();
  }

  _createClass(Resource, [{
    key: 'toString',
    value: function toString() {
      return this.constructor.name + '(' + this.id + ')';
    }
  }, {
    key: 'delete',
    value: function _delete() {
      if (this._handle) {
        this._deleteHandle();
        this._handle = null;
        // this.glCount = undefined;
      }
      return this;
    }

    /**
     * Query a Resource parameter
     *
     * @todo - cache parameters to avoid issuing WebGL calls?
     *
     * @param {GLenum} pname
     * @return {GLint|GLfloat|GLenum} param
     */

  }, {
    key: 'getParameter',
    value: function getParameter(pname) {
      pname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__gl_constants__["c" /* glGet */])(pname);

      var parameters = this.constructor.PARAMETERS || {};

      // Use parameter definitions to handle unsupported parameters
      var parameter = parameters[pname];
      if (parameter) {
        var isWebgl2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(this.gl);

        // Check if we can query for this parameter
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          var webgl1Default = parameter.webgl1;
          var webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
          var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }

      // If unknown parameter - Could be a valid parameter not covered by PARAMS
      // Attempt to query for it and let WebGL report errors
      return this._getParameter(pname);
    }

    // Many resources support a getParameter call -
    // getParameters will get all parameters - slow but useful for debugging

  }, {
    key: 'getParameters',
    value: function getParameters() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          parameters = _ref.parameters,
          keys = _ref.keys;

      // Get parameter definitions for this Resource
      var PARAMETERS = this.constructor.PARAMETERS || {};

      // Query all parameters if no list provided
      parameters = parameters || Object.keys(PARAMETERS);

      var isWebgl2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(this.gl);

      var values = {};

      // WEBGL limits
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parameters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pname = _step.value;

          var parameter = PARAMETERS[pname];

          // Check if this parameter is available on this platform
          var parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

          if (parameterAvailable) {
            var key = keys ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__gl_constants__["d" /* glKey */])(pname) : pname;
            values[key] = this.getParameter(pname);
            if (keys && parameter.type === 'GLenum') {
              values[key] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__gl_constants__["d" /* glKey */])(values[key]);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return values;
    }

    /**
     * Update a Resource setting
     *
     * @todo - cache parameter to avoid issuing WebGL calls?
     *
     * @param {GLenum} pname - parameter (GL constant, value or key)
     * @param {GLint|GLfloat|GLenum} value
     * @return {Resource} returns self to enable chaining
     */

  }, {
    key: 'setParameter',
    value: function setParameter(pname, value) {
      pname = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__gl_constants__["c" /* glGet */])(pname);

      var parameters = this.constructor.PARAMETERS || {};

      var parameter = parameters[pname];
      if (parameter) {
        var isWebgl2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(this.gl);

        // Check if this parameter is available on this platform
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          throw new Error('Parameter not available on this platform');
        }

        // Handle string keys
        if (parameter.type === 'GLenum') {
          value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__gl_constants__["c" /* glGet */])(value);
        }
      }

      // If unknown parameter - Could be a valid parameter not covered by PARAMS
      // attempt to set it and let WebGL report errors
      this._setParameter(pname, value);
      return this;
    }

    /*
     * Batch update resource settings
     * Assumes the subclass supports a setParameter call
     */

  }, {
    key: 'setParameters',
    value: function setParameters(parameters) {
      for (var pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }

    // PUBLIC VIRTUAL METHODS

  }, {
    key: 'initialize',
    value: function initialize(opts) {}

    // PROTECTED METHODS - These must be overridden by subclass

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: '_getOptsFromHandle',
    value: function _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }

    /**
     * @param {GLenum} pname
     * @param {GLint|GLfloat|GLenum} param
     * @return {Sampler} returns self to enable chaining
     */

  }, {
    key: '_setParameter',
    value: function _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }

    // PRIVATE METHODS

  }, {
    key: '_addStats',
    value: function _addStats() {
      var name = this.constructor.name;

      var stats = __WEBPACK_IMPORTED_MODULE_0__init__["default"].stats;

      stats.resourceCount = stats.resourceCount || 0;
      stats.resourceMap = stats.resourceMap || {};

      // Resource creation stats
      stats.resourceCount++;
      stats.resourceMap[name] = stats.resourceMap[name] || { count: 0 };
      stats.resourceMap[name].count++;
    }
  }, {
    key: 'handle',
    get: function get() {
      // TODO - Add context loss handling
      // Will regenerate and reinitialize the handle if necessary
      // const glCount = glGetContextLossCount(this.gl);
      // if (this.glCount !== glCount) {
      //   this._handle = this._createHandle(this.opts);
      //   this._glCount = glCount;
      //   // Reinitialize object
      //   this.initialize(this.opts);
      // }
      return this._handle;
    }
  }]);

  return Resource;
}();

/* harmony default export */ __webpack_exports__["a"] = (Resource);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9yZXNvdXJjZS5qcyJdLCJuYW1lcyI6WyJsdW1hIiwiYXNzZXJ0V2ViR0xDb250ZXh0IiwiaXNXZWJHTDJDb250ZXh0IiwiZ2xHZXQiLCJnbEtleSIsInVpZCIsIkVSUl9SRVNPVVJDRV9NRVRIT0RfVU5ERUZJTkVEIiwiUmVzb3VyY2UiLCJnbCIsIm9wdHMiLCJpZCIsInVzZXJEYXRhIiwiZXh0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2hhbmRsZSIsImhhbmRsZSIsIl9jcmVhdGVIYW5kbGUiLCJfYWRkU3RhdHMiLCJfZGVsZXRlSGFuZGxlIiwicG5hbWUiLCJwYXJhbWV0ZXJzIiwiUEFSQU1FVEVSUyIsInBhcmFtZXRlciIsImlzV2ViZ2wyIiwicGFyYW1ldGVyQXZhaWxhYmxlIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwid2ViZ2wxRGVmYXVsdCIsIndlYmdsMSIsIndlYmdsMkRlZmF1bHQiLCJ3ZWJnbDIiLCJkZWZhdWx0VmFsdWUiLCJfZ2V0UGFyYW1ldGVyIiwia2V5cyIsIk9iamVjdCIsInZhbHVlcyIsImtleSIsImdldFBhcmFtZXRlciIsInR5cGUiLCJ2YWx1ZSIsIkVycm9yIiwiX3NldFBhcmFtZXRlciIsInNldFBhcmFtZXRlciIsInN0YXRzIiwicmVzb3VyY2VDb3VudCIsInJlc291cmNlTWFwIiwiY291bnQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPQSxJQUFQLE1BQWlCLFNBQWpCO0FBQ0EsU0FBUUMsa0JBQVIsRUFBNEJDLGVBQTVCLFFBQWtELFdBQWxEO0FBQ0EsU0FBUUMsS0FBUixFQUFlQyxLQUFmLFFBQTJCLGdCQUEzQjtBQUNBLFNBQVFDLEdBQVIsUUFBa0IsVUFBbEI7O0FBRUEsSUFBTUMsZ0NBQWdDLCtDQUF0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7SUFFcUJDLFE7QUFDbkIsb0JBQVlDLEVBQVosRUFBMkI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3pC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cmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGx1bWEgZnJvbSAnLi4vaW5pdCc7XG5pbXBvcnQge2Fzc2VydFdlYkdMQ29udGV4dCwgaXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHtnbEdldCwgZ2xLZXl9IGZyb20gJy4vZ2wtY29uc3RhbnRzJztcbmltcG9ydCB7dWlkfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IEVSUl9SRVNPVVJDRV9NRVRIT0RfVU5ERUZJTkVEID0gJ1Jlc291cmNlIHN1YmNsYXNzIG11c3QgZGVmaW5lIHZpcnR1YWwgbWV0aG9kcyc7XG5cbi8vIFRPRE8gLSBIYW5kbGUgY29udGV4dCBsb3NzXG4vLyBmdW5jdGlvbiBnbEdldENvbnRleHRMb3NzQ291bnQoZ2wpIHtcbi8vICAgcmV0dXJuIChnbC5sdW1hICYmIGdsLmx1bWEuZ2xDb3VudCkgfHwgMDtcbi8vIH1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihnbCwgb3B0cyA9IHt9KSB7XG4gICAgYXNzZXJ0V2ViR0xDb250ZXh0KGdsKTtcblxuICAgIGNvbnN0IHtpZCwgdXNlckRhdGEgPSB7fX0gPSBvcHRzO1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmV4dCA9IG51bGw7XG4gICAgdGhpcy5pZCA9IGlkIHx8IHVpZCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIHRoaXMudXNlckRhdGEgPSB1c2VyRGF0YTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuXG4gICAgLy8gU2V0IHRoZSBoYW5kbGVcbiAgICAvLyBJZiBoYW5kbGUgd2FzIHByb3ZpZGVkLCB1c2UgaXQsIG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgaGFuZGxlXG5cbiAgICAvLyBUT0RPIC0gU3RvcmVzIHRoZSBoYW5kbGUgd2l0aCBjb250ZXh0IGxvc3MgaW5mb3JtYXRpb25cbiAgICAvLyB0aGlzLmdsQ291bnQgPSBnbEdldENvbnRleHRMb3NzQ291bnQodGhpcy5nbCk7XG4gICAgdGhpcy5faGFuZGxlID0gb3B0cy5oYW5kbGUgfHwgdGhpcy5fY3JlYXRlSGFuZGxlKCk7XG5cbiAgICB0aGlzLl9hZGRTdGF0cygpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0oJHt0aGlzLmlkfSlgO1xuICB9XG5cbiAgZ2V0IGhhbmRsZSgpIHtcbiAgICAvLyBUT0RPIC0gQWRkIGNvbnRleHQgbG9zcyBoYW5kbGluZ1xuICAgIC8vIFdpbGwgcmVnZW5lcmF0ZSBhbmQgcmVpbml0aWFsaXplIHRoZSBoYW5kbGUgaWYgbmVjZXNzYXJ5XG4gICAgLy8gY29uc3QgZ2xDb3VudCA9IGdsR2V0Q29udGV4dExvc3NDb3VudCh0aGlzLmdsKTtcbiAgICAvLyBpZiAodGhpcy5nbENvdW50ICE9PSBnbENvdW50KSB7XG4gICAgLy8gICB0aGlzLl9oYW5kbGUgPSB0aGlzLl9jcmVhdGVIYW5kbGUodGhpcy5vcHRzKTtcbiAgICAvLyAgIHRoaXMuX2dsQ291bnQgPSBnbENvdW50O1xuICAgIC8vICAgLy8gUmVpbml0aWFsaXplIG9iamVjdFxuICAgIC8vICAgdGhpcy5pbml0aWFsaXplKHRoaXMub3B0cyk7XG4gICAgLy8gfVxuICAgIHJldHVybiB0aGlzLl9oYW5kbGU7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMuX2hhbmRsZSkge1xuICAgICAgdGhpcy5fZGVsZXRlSGFuZGxlKCk7XG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgLy8gdGhpcy5nbENvdW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBhIFJlc291cmNlIHBhcmFtZXRlclxuICAgKlxuICAgKiBAdG9kbyAtIGNhY2hlIHBhcmFtZXRlcnMgdG8gYXZvaWQgaXNzdWluZyBXZWJHTCBjYWxscz9cbiAgICpcbiAgICogQHBhcmFtIHtHTGVudW19IHBuYW1lXG4gICAqIEByZXR1cm4ge0dMaW50fEdMZmxvYXR8R0xlbnVtfSBwYXJhbVxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyKHBuYW1lKSB7XG4gICAgcG5hbWUgPSBnbEdldChwbmFtZSk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5jb25zdHJ1Y3Rvci5QQVJBTUVURVJTIHx8IHt9O1xuXG4gICAgLy8gVXNlIHBhcmFtZXRlciBkZWZpbml0aW9ucyB0byBoYW5kbGUgdW5zdXBwb3J0ZWQgcGFyYW1ldGVyc1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbcG5hbWVdO1xuICAgIGlmIChwYXJhbWV0ZXIpIHtcbiAgICAgIGNvbnN0IGlzV2ViZ2wyID0gaXNXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gcXVlcnkgZm9yIHRoaXMgcGFyYW1ldGVyXG4gICAgICBjb25zdCBwYXJhbWV0ZXJBdmFpbGFibGUgPVxuICAgICAgICAoISgnd2ViZ2wyJyBpbiBwYXJhbWV0ZXIpIHx8IGlzV2ViZ2wyKSAmJlxuICAgICAgICAoISgnZXh0ZW5zaW9uJyBpbiBwYXJhbWV0ZXIpIHx8IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKHBhcmFtZXRlci5leHRlbnNpb24pKTtcblxuICAgICAgaWYgKCFwYXJhbWV0ZXJBdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3Qgd2ViZ2wxRGVmYXVsdCA9IHBhcmFtZXRlci53ZWJnbDE7XG4gICAgICAgIGNvbnN0IHdlYmdsMkRlZmF1bHQgPSAnd2ViZ2wyJyBpbiBwYXJhbWV0ZXIgPyBwYXJhbWV0ZXIud2ViZ2wyIDogcGFyYW1ldGVyLndlYmdsMTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaXNXZWJnbDIgPyB3ZWJnbDJEZWZhdWx0IDogd2ViZ2wxRGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB1bmtub3duIHBhcmFtZXRlciAtIENvdWxkIGJlIGEgdmFsaWQgcGFyYW1ldGVyIG5vdCBjb3ZlcmVkIGJ5IFBBUkFNU1xuICAgIC8vIEF0dGVtcHQgdG8gcXVlcnkgZm9yIGl0IGFuZCBsZXQgV2ViR0wgcmVwb3J0IGVycm9yc1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXIocG5hbWUpO1xuICB9XG5cbiAgLy8gTWFueSByZXNvdXJjZXMgc3VwcG9ydCBhIGdldFBhcmFtZXRlciBjYWxsIC1cbiAgLy8gZ2V0UGFyYW1ldGVycyB3aWxsIGdldCBhbGwgcGFyYW1ldGVycyAtIHNsb3cgYnV0IHVzZWZ1bCBmb3IgZGVidWdnaW5nXG4gIGdldFBhcmFtZXRlcnMoe3BhcmFtZXRlcnMsIGtleXN9ID0ge30pIHtcbiAgICAvLyBHZXQgcGFyYW1ldGVyIGRlZmluaXRpb25zIGZvciB0aGlzIFJlc291cmNlXG4gICAgY29uc3QgUEFSQU1FVEVSUyA9IHRoaXMuY29uc3RydWN0b3IuUEFSQU1FVEVSUyB8fCB7fTtcblxuICAgIC8vIFF1ZXJ5IGFsbCBwYXJhbWV0ZXJzIGlmIG5vIGxpc3QgcHJvdmlkZWRcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCBPYmplY3Qua2V5cyhQQVJBTUVURVJTKTtcblxuICAgIGNvbnN0IGlzV2ViZ2wyID0gaXNXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuXG4gICAgY29uc3QgdmFsdWVzID0ge307XG5cbiAgICAvLyBXRUJHTCBsaW1pdHNcbiAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IHBhcmFtZXRlciA9IFBBUkFNRVRFUlNbcG5hbWVdO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHBhcmFtZXRlciBpcyBhdmFpbGFibGUgb24gdGhpcyBwbGF0Zm9ybVxuICAgICAgY29uc3QgcGFyYW1ldGVyQXZhaWxhYmxlID1cbiAgICAgICAgcGFyYW1ldGVyICYmXG4gICAgICAgICghKCd3ZWJnbDInIGluIHBhcmFtZXRlcikgfHwgaXNXZWJnbDIpICYmXG4gICAgICAgICghKCdleHRlbnNpb24nIGluIHBhcmFtZXRlcikgfHwgdGhpcy5nbC5nZXRFeHRlbnNpb24ocGFyYW1ldGVyLmV4dGVuc2lvbikpO1xuXG4gICAgICBpZiAocGFyYW1ldGVyQXZhaWxhYmxlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXMgPyBnbEtleShwbmFtZSkgOiBwbmFtZTtcbiAgICAgICAgdmFsdWVzW2tleV0gPSB0aGlzLmdldFBhcmFtZXRlcihwbmFtZSk7XG4gICAgICAgIGlmIChrZXlzICYmIHBhcmFtZXRlci50eXBlID09PSAnR0xlbnVtJykge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gZ2xLZXkodmFsdWVzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBSZXNvdXJjZSBzZXR0aW5nXG4gICAqXG4gICAqIEB0b2RvIC0gY2FjaGUgcGFyYW1ldGVyIHRvIGF2b2lkIGlzc3VpbmcgV2ViR0wgY2FsbHM/XG4gICAqXG4gICAqIEBwYXJhbSB7R0xlbnVtfSBwbmFtZSAtIHBhcmFtZXRlciAoR0wgY29uc3RhbnQsIHZhbHVlIG9yIGtleSlcbiAgICogQHBhcmFtIHtHTGludHxHTGZsb2F0fEdMZW51bX0gdmFsdWVcbiAgICogQHJldHVybiB7UmVzb3VyY2V9IHJldHVybnMgc2VsZiB0byBlbmFibGUgY2hhaW5pbmdcbiAgICovXG4gIHNldFBhcmFtZXRlcihwbmFtZSwgdmFsdWUpIHtcbiAgICBwbmFtZSA9IGdsR2V0KHBuYW1lKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLlBBUkFNRVRFUlMgfHwge307XG5cbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW3BuYW1lXTtcbiAgICBpZiAocGFyYW1ldGVyKSB7XG4gICAgICBjb25zdCBpc1dlYmdsMiA9IGlzV2ViR0wyQ29udGV4dCh0aGlzLmdsKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIG9uIHRoaXMgcGxhdGZvcm1cbiAgICAgIGNvbnN0IHBhcmFtZXRlckF2YWlsYWJsZSA9XG4gICAgICAgICghKCd3ZWJnbDInIGluIHBhcmFtZXRlcikgfHwgaXNXZWJnbDIpICYmXG4gICAgICAgICghKCdleHRlbnNpb24nIGluIHBhcmFtZXRlcikgfHwgdGhpcy5nbC5nZXRFeHRlbnNpb24ocGFyYW1ldGVyLmV4dGVuc2lvbikpO1xuXG4gICAgICBpZiAoIXBhcmFtZXRlckF2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBub3QgYXZhaWxhYmxlIG9uIHRoaXMgcGxhdGZvcm0nKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIHN0cmluZyBrZXlzXG4gICAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdHTGVudW0nKSB7XG4gICAgICAgIHZhbHVlID0gZ2xHZXQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHVua25vd24gcGFyYW1ldGVyIC0gQ291bGQgYmUgYSB2YWxpZCBwYXJhbWV0ZXIgbm90IGNvdmVyZWQgYnkgUEFSQU1TXG4gICAgLy8gYXR0ZW1wdCB0byBzZXQgaXQgYW5kIGxldCBXZWJHTCByZXBvcnQgZXJyb3JzXG4gICAgdGhpcy5fc2V0UGFyYW1ldGVyKHBuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKlxuICAgKiBCYXRjaCB1cGRhdGUgcmVzb3VyY2Ugc2V0dGluZ3NcbiAgICogQXNzdW1lcyB0aGUgc3ViY2xhc3Mgc3VwcG9ydHMgYSBzZXRQYXJhbWV0ZXIgY2FsbFxuICAgKi9cbiAgc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgZm9yIChjb25zdCBwbmFtZSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLnNldFBhcmFtZXRlcihwbmFtZSwgcGFyYW1ldGVyc1twbmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFBVQkxJQyBWSVJUVUFMIE1FVEhPRFNcbiAgaW5pdGlhbGl6ZShvcHRzKSB7XG4gIH1cblxuICAvLyBQUk9URUNURUQgTUVUSE9EUyAtIFRoZXNlIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc1xuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfUkVTT1VSQ0VfTUVUSE9EX1VOREVGSU5FRCk7XG4gIH1cblxuICBfZGVsZXRlSGFuZGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfUkVTT1VSQ0VfTUVUSE9EX1VOREVGSU5FRCk7XG4gIH1cblxuICBfZ2V0T3B0c0Zyb21IYW5kbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9SRVNPVVJDRV9NRVRIT0RfVU5ERUZJTkVEKTtcbiAgfVxuXG4gIF9nZXRQYXJhbWV0ZXIocG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX1JFU09VUkNFX01FVEhPRF9VTkRFRklORUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R0xlbnVtfSBwbmFtZVxuICAgKiBAcGFyYW0ge0dMaW50fEdMZmxvYXR8R0xlbnVtfSBwYXJhbVxuICAgKiBAcmV0dXJuIHtTYW1wbGVyfSByZXR1cm5zIHNlbGYgdG8gZW5hYmxlIGNoYWluaW5nXG4gICAqL1xuICBfc2V0UGFyYW1ldGVyKHBuYW1lLCB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfUkVTT1VSQ0VfTUVUSE9EX1VOREVGSU5FRCk7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICBfYWRkU3RhdHMoKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGNvbnN0IHtzdGF0c30gPSBsdW1hO1xuICAgIHN0YXRzLnJlc291cmNlQ291bnQgPSBzdGF0cy5yZXNvdXJjZUNvdW50IHx8IDA7XG4gICAgc3RhdHMucmVzb3VyY2VNYXAgPSBzdGF0cy5yZXNvdXJjZU1hcCB8fCB7fTtcblxuICAgIC8vIFJlc291cmNlIGNyZWF0aW9uIHN0YXRzXG4gICAgc3RhdHMucmVzb3VyY2VDb3VudCsrO1xuICAgIHN0YXRzLnJlc291cmNlTWFwW25hbWVdID0gc3RhdHMucmVzb3VyY2VNYXBbbmFtZV0gfHwge2NvdW50OiAwfTtcbiAgICBzdGF0cy5yZXNvdXJjZU1hcFtuYW1lXS5jb3VudCsrO1xuICB9XG59XG4iXX0=

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return __WEBPACK_IMPORTED_MODULE_0__geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cone_geometry__ = __webpack_require__(97);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return __WEBPACK_IMPORTED_MODULE_1__cone_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cube_geometry__ = __webpack_require__(98);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return __WEBPACK_IMPORTED_MODULE_2__cube_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cylinder_geometry__ = __webpack_require__(99);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return __WEBPACK_IMPORTED_MODULE_3__cylinder_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ico_sphere_geometry__ = __webpack_require__(100);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "IcoSphereGeometry", function() { return __WEBPACK_IMPORTED_MODULE_4__ico_sphere_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__plane_geometry__ = __webpack_require__(101);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return __WEBPACK_IMPORTED_MODULE_5__plane_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sphere_geometry__ = __webpack_require__(102);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return __WEBPACK_IMPORTED_MODULE_6__sphere_geometry__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__truncated_cone_geometry__ = __webpack_require__(32);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TruncatedConeGeometry", function() { return __WEBPACK_IMPORTED_MODULE_7__truncated_cone_geometry__["a"]; });









//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0IiwiR2VvbWV0cnkiLCJDb25lR2VvbWV0cnkiLCJDdWJlR2VvbWV0cnkiLCJDeWxpbmRlckdlb21ldHJ5IiwiSWNvU3BoZXJlR2VvbWV0cnkiLCJQbGFuZUdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJUcnVuY2F0ZWRDb25lR2VvbWV0cnkiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVFBLFdBQVdDLFFBQW5CLFFBQWtDLFlBQWxDOztBQUVBLFNBQVFELFdBQVdFLFlBQW5CLFFBQXNDLGlCQUF0QztBQUNBLFNBQVFGLFdBQVdHLFlBQW5CLFFBQXNDLGlCQUF0QztBQUNBLFNBQVFILFdBQVdJLGdCQUFuQixRQUEwQyxxQkFBMUM7QUFDQSxTQUFRSixXQUFXSyxpQkFBbkIsUUFBMkMsdUJBQTNDO0FBQ0EsU0FBUUwsV0FBV00sYUFBbkIsUUFBdUMsa0JBQXZDO0FBQ0EsU0FBUU4sV0FBV08sY0FBbkIsUUFBd0MsbUJBQXhDO0FBQ0EsU0FBUVAsV0FBV1EscUJBQW5CLFFBQStDLDJCQUEvQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7ZGVmYXVsdCBhcyBHZW9tZXRyeX0gZnJvbSAnLi9nZW9tZXRyeSc7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBDb25lR2VvbWV0cnl9IGZyb20gJy4vY29uZS1nZW9tZXRyeSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQ3ViZUdlb21ldHJ5fSBmcm9tICcuL2N1YmUtZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEN5bGluZGVyR2VvbWV0cnl9IGZyb20gJy4vY3lsaW5kZXItZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEljb1NwaGVyZUdlb21ldHJ5fSBmcm9tICcuL2ljby1zcGhlcmUtZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBsYW5lR2VvbWV0cnl9IGZyb20gJy4vcGxhbmUtZ2VvbWV0cnknO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNwaGVyZUdlb21ldHJ5fSBmcm9tICcuL3NwaGVyZS1nZW9tZXRyeSc7XG5leHBvcnQge2RlZmF1bHQgYXMgVHJ1bmNhdGVkQ29uZUdlb21ldHJ5fSBmcm9tICcuL3RydW5jYXRlZC1jb25lLWdlb21ldHJ5JztcbiJdfQ==

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glMatrix = undefined;
exports.configure = configure;
exports.checkNumber = checkNumber;
exports.formatValue = formatValue;
exports.isArray = isArray;
exports.clone = clone;
exports.radians = radians;
exports.degrees = degrees;
exports.sin = sin;
exports.cos = cos;
exports.tan = tan;
exports.asin = asin;
exports.acos = acos;
exports.atan = atan;
exports.clamp = clamp;
exports.equals = equals;

var _glMatrix = __webpack_require__(9);

// TODO - remove
_glMatrix.glMatrix.debug = true; /* eslint-disable no-shadow */

_glMatrix.glMatrix.printRowMajor = true;
_glMatrix.glMatrix.precision = 4;
exports.glMatrix = _glMatrix.glMatrix;
function configure(options) {
  if ('epsilon' in options) {
    _glMatrix.glMatrix.EPSILON = options.epsilon;
  }

  if ('debug' in options) {
    _glMatrix.glMatrix.debug = options.debug;
  }
}

function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error('Invalid number ' + value);
  }
  return value;
}

function formatValue(value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _glMatrix.glMatrix.precision || 4;

  return parseFloat(value.toPrecision(precision));
}

// Returns true if value is either an array or a typed array
// Note: does not return true for ArrayBuffers and DataViews
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
}

// If the array has a clone function, calls it, otherwise returns a copy
function clone(array) {
  return array.clone ? array.clone() : new Array(array);
}

// If the argument value is an array, applies the func element wise,
// otherwise applies func to the argument value
function map(value, func) {
  if (isArray(value)) {
    var result = clone(value);
    for (var i = 0; i < result.length; ++i) {
      result[i] = func(result[i], i, result);
    }
    return result;
  }
  return func(value);
}

//
// GLSL math function equivalents
// Works on both single values and vectors
//

function radians(degrees) {
  return map(degrees, function (degrees) {
    return degrees / 180 * Math.PI;
  });
}

// GLSL equivalent: Works on single values and vectors
function degrees(radians) {
  return map(radians, function (radians) {
    return radians * 180 / Math.PI;
  });
}

// GLSL equivalent: Works on single values and vectors
function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}

// GLSL equivalent: Works on single values and vectors
function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}

// GLSL equivalent: Works on single values and vectors
function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}

// GLSL equivalent: Works on single values and vectors
function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}

// GLSL equivalent: Works on single values and vectors
function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}

// GLSL equivalent: Works on single values and vectors
function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}

// TODO - glsl equivalent
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function equals(a, b) {
  return Math.abs(a - b) <= _glMatrix.glMatrix.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy9jb21tb24uanMiXSwibmFtZXMiOlsiY29uZmlndXJlIiwiY2hlY2tOdW1iZXIiLCJmb3JtYXRWYWx1ZSIsImlzQXJyYXkiLCJjbG9uZSIsInJhZGlhbnMiLCJkZWdyZWVzIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwiY2xhbXAiLCJlcXVhbHMiLCJkZWJ1ZyIsInByaW50Um93TWFqb3IiLCJwcmVjaXNpb24iLCJnbE1hdHJpeCIsIm9wdGlvbnMiLCJFUFNJTE9OIiwiZXBzaWxvbiIsInZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJFcnJvciIsInBhcnNlRmxvYXQiLCJ0b1ByZWNpc2lvbiIsIkFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJhcnJheSIsIm1hcCIsImZ1bmMiLCJyZXN1bHQiLCJpIiwiTWF0aCIsIlBJIiwiYW5nbGUiLCJtaW4iLCJtYXgiLCJhIiwiYiIsImFicyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O1FBU2dCQSxTLEdBQUFBLFM7UUFVQUMsVyxHQUFBQSxXO1FBT0FDLFcsR0FBQUEsVztRQU1BQyxPLEdBQUFBLE87UUFLQUMsSyxHQUFBQSxLO1FBc0JBQyxPLEdBQUFBLE87UUFLQUMsTyxHQUFBQSxPO1FBS0FDLEcsR0FBQUEsRztRQUtBQyxHLEdBQUFBLEc7UUFLQUMsRyxHQUFBQSxHO1FBS0FDLEksR0FBQUEsSTtRQUtBQyxJLEdBQUFBLEk7UUFLQUMsSSxHQUFBQSxJO1FBS0FDLEssR0FBQUEsSztRQUlBQyxNLEdBQUFBLE07O0FBdEdoQjs7QUFFQTtBQUNBLG1CQUFTQyxLQUFULEdBQWlCLElBQWpCLEMsQ0FKQTs7QUFLQSxtQkFBU0MsYUFBVCxHQUF5QixJQUF6QjtBQUNBLG1CQUFTQyxTQUFULEdBQXFCLENBQXJCO1FBQ1FDLFE7QUFFRCxTQUFTbEIsU0FBVCxDQUFtQm1CLE9BQW5CLEVBQTRC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T0FBSixFQUFhO0FBQUEsV0FBU2lDLEtBQUs1QixJQUFMLENBQVU4QixLQUFWLENBQVQ7QUFBQSxHQUFiLENBQVA7QUFDRDs7QUFFRDtBQUNPLFNBQVM3QixJQUFULENBQWNOLE9BQWQsRUFBdUI7QUFDNUIsU0FBTzZCLElBQUk3QixPQUFKLEVBQWE7QUFBQSxXQUFTaUMsS0FBSzNCLElBQUwsQ0FBVTZCLEtBQVYsQ0FBVDtBQUFBLEdBQWIsQ0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBUzVCLElBQVQsQ0FBY1AsT0FBZCxFQUF1QjtBQUM1QixTQUFPNkIsSUFBSTdCLE9BQUosRUFBYTtBQUFBLFdBQVNpQyxLQUFLMUIsSUFBTCxDQUFVNEIsS0FBVixDQUFUO0FBQUEsR0FBYixDQUFQO0FBQ0Q7O0FBRUQ7QUFDTyxTQUFTM0IsS0FBVCxDQUFlUyxLQUFmLEVBQXNCbUIsR0FBdEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQ3JDLFNBQU9KLEtBQUtJLEdBQUwsQ0FBU0QsR0FBVCxFQUFjSCxLQUFLRyxHQUFMLENBQVNDLEdBQVQsRUFBY3BCLEtBQWQsQ0FBZCxDQUFQO0FBQ0Q7O0FBRU0sU0FBU1IsTUFBVCxDQUFnQjZCLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQjtBQUMzQixTQUFPTixLQUFLTyxHQUFMLENBQVNGLElBQUlDLENBQWIsS0FDTCxtQkFBU3hCLE9BQVQsR0FBbUJrQixLQUFLSSxHQUFMLENBQVMsR0FBVCxFQUFjSixLQUFLTyxHQUFMLENBQVNGLENBQVQsQ0FBZCxFQUEyQkwsS0FBS08sR0FBTCxDQUFTRCxDQUFULENBQTNCLENBRHJCO0FBRUQiLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tc2hhZG93ICovXG5pbXBvcnQge2dsTWF0cml4fSBmcm9tICdnbC1tYXRyaXgnO1xuXG4vLyBUT0RPIC0gcmVtb3ZlXG5nbE1hdHJpeC5kZWJ1ZyA9IHRydWU7XG5nbE1hdHJpeC5wcmludFJvd01ham9yID0gdHJ1ZTtcbmdsTWF0cml4LnByZWNpc2lvbiA9IDQ7XG5leHBvcnQge2dsTWF0cml4fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGlmICgnZXBzaWxvbicgaW4gb3B0aW9ucykge1xuICAgIGdsTWF0cml4LkVQU0lMT04gPSBvcHRpb25zLmVwc2lsb247XG4gIH1cblxuICBpZiAoJ2RlYnVnJyBpbiBvcHRpb25zKSB7XG4gICAgZ2xNYXRyaXguZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja051bWJlcih2YWx1ZSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyICR7dmFsdWV9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHByZWNpc2lvbiA9IGdsTWF0cml4LnByZWNpc2lvbiB8fCA0KSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKHByZWNpc2lvbikpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgZWl0aGVyIGFuIGFycmF5IG9yIGEgdHlwZWQgYXJyYXlcbi8vIE5vdGU6IGRvZXMgbm90IHJldHVybiB0cnVlIGZvciBBcnJheUJ1ZmZlcnMgYW5kIERhdGFWaWV3c1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkKTtcbn1cblxuLy8gSWYgdGhlIGFycmF5IGhhcyBhIGNsb25lIGZ1bmN0aW9uLCBjYWxscyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgYSBjb3B5XG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmNsb25lID8gYXJyYXkuY2xvbmUoKSA6IG5ldyBBcnJheShhcnJheSk7XG59XG5cbi8vIElmIHRoZSBhcmd1bWVudCB2YWx1ZSBpcyBhbiBhcnJheSwgYXBwbGllcyB0aGUgZnVuYyBlbGVtZW50IHdpc2UsXG4vLyBvdGhlcndpc2UgYXBwbGllcyBmdW5jIHRvIHRoZSBhcmd1bWVudCB2YWx1ZVxuZnVuY3Rpb24gbWFwKHZhbHVlLCBmdW5jKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNsb25lKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W2ldID0gZnVuYyhyZXN1bHRbaV0sIGksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmModmFsdWUpO1xufVxuXG4vL1xuLy8gR0xTTCBtYXRoIGZ1bmN0aW9uIGVxdWl2YWxlbnRzXG4vLyBXb3JrcyBvbiBib3RoIHNpbmdsZSB2YWx1ZXMgYW5kIHZlY3RvcnNcbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIG1hcChkZWdyZWVzLCBkZWdyZWVzID0+IGRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJKTtcbn1cblxuLy8gR0xTTCBlcXVpdmFsZW50OiBXb3JrcyBvbiBzaW5nbGUgdmFsdWVzIGFuZCB2ZWN0b3JzXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgcmFkaWFucyA9PiByYWRpYW5zICogMTgwIC8gTWF0aC5QSSk7XG59XG5cbi8vIEdMU0wgZXF1aXZhbGVudDogV29ya3Mgb24gc2luZ2xlIHZhbHVlcyBhbmQgdmVjdG9yc1xuZXhwb3J0IGZ1bmN0aW9uIHNpbihyYWRpYW5zKSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC5zaW4oYW5nbGUpKTtcbn1cblxuLy8gR0xTTCBlcXVpdmFsZW50OiBXb3JrcyBvbiBzaW5nbGUgdmFsdWVzIGFuZCB2ZWN0b3JzXG5leHBvcnQgZnVuY3Rpb24gY29zKHJhZGlhbnMpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLmNvcyhhbmdsZSkpO1xufVxuXG4vLyBHTFNMIGVxdWl2YWxlbnQ6IFdvcmtzIG9uIHNpbmdsZSB2YWx1ZXMgYW5kIHZlY3RvcnNcbmV4cG9ydCBmdW5jdGlvbiB0YW4ocmFkaWFucykge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGgudGFuKGFuZ2xlKSk7XG59XG5cbi8vIEdMU0wgZXF1aXZhbGVudDogV29ya3Mgb24gc2luZ2xlIHZhbHVlcyBhbmQgdmVjdG9yc1xuZXhwb3J0IGZ1bmN0aW9uIGFzaW4ocmFkaWFucykge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGguYXNpbihhbmdsZSkpO1xufVxuXG4vLyBHTFNMIGVxdWl2YWxlbnQ6IFdvcmtzIG9uIHNpbmdsZSB2YWx1ZXMgYW5kIHZlY3RvcnNcbmV4cG9ydCBmdW5jdGlvbiBhY29zKHJhZGlhbnMpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLmFjb3MoYW5nbGUpKTtcbn1cblxuLy8gR0xTTCBlcXVpdmFsZW50OiBXb3JrcyBvbiBzaW5nbGUgdmFsdWVzIGFuZCB2ZWN0b3JzXG5leHBvcnQgZnVuY3Rpb24gYXRhbihyYWRpYW5zKSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC5hdGFuKGFuZ2xlKSk7XG59XG5cbi8vIFRPRE8gLSBnbHNsIGVxdWl2YWxlbnRcbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PVxuICAgIGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG4iXX0=

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__animation_loop__ = __webpack_require__(91);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoop", function() { return __WEBPACK_IMPORTED_MODULE_0__animation_loop__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return __WEBPACK_IMPORTED_MODULE_0__animation_loop__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return __WEBPACK_IMPORTED_MODULE_0__animation_loop__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return __WEBPACK_IMPORTED_MODULE_1__model__["a"]; });


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2luZGV4LmpzIl0sIm5hbWVzIjpbImRlZmF1bHQiLCJBbmltYXRpb25Mb29wIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJNb2RlbCJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEsV0FBV0MsYUFBbkIsRUFBa0NDLHFCQUFsQyxFQUF5REMsb0JBQXpELFFBQ08sa0JBRFA7QUFFQSxTQUFRSCxXQUFXSSxLQUFuQixRQUErQixTQUEvQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7ZGVmYXVsdCBhcyBBbmltYXRpb25Mb29wLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lfVxuICBmcm9tICcuL2FuaW1hdGlvbi1sb29wJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNb2RlbH0gZnJvbSAnLi9tb2RlbCc7XG4iXX0=

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





var ILLEGAL_ARG = 'Geometry: Illegal argument';

var Geometry = function () {
  function Geometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Geometry);

    var id = opts.id,
        _opts$drawMode = opts.drawMode,
        drawMode = _opts$drawMode === undefined ? 'TRIANGLES' : _opts$drawMode,
        _opts$vertexCount = opts.vertexCount,
        vertexCount = _opts$vertexCount === undefined ? undefined : _opts$vertexCount,
        attributes = opts.attributes;


    __WEBPACK_IMPORTED_MODULE_1_assert___default()(drawMode, ILLEGAL_ARG);

    this.id = id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["uid"])(this.constructor.name);
    this.drawMode = drawMode;
    this.vertexCount = vertexCount;
    this.attributes = {};
    this.needsRedraw = true;
    this.userData = {};
    Object.seal(this);

    if (attributes) {
      this.setAttributes(attributes);
    } else {
      __WEBPACK_IMPORTED_MODULE_0__utils__["log"].once('Geometry: top-level attributes are deprecated, use "attributes" param');
      // TODO this is deprecated
      delete opts.id;
      delete opts.drawMode;
      delete opts.vertexCount;
      delete opts.attributes;
      this.setAttributes(opts);
    }
  }

  _createClass(Geometry, [{
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = redraw;
      return this;
    }
  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearRedrawFlags = _ref.clearRedrawFlags,
          clearRedrawFlags = _ref$clearRedrawFlags === undefined ? false : _ref$clearRedrawFlags;

      var redraw = false;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }
  }, {
    key: 'setVertexCount',
    value: function setVertexCount(vertexCount) {
      this.vertexCount = vertexCount;
    }
  }, {
    key: 'getVertexCount',
    value: function getVertexCount() {
      if (this.vertexCount !== undefined) {
        return this.vertexCount;
      } else if (this.attributes.indices) {
        return this.attributes.indices.value.length;
      } else if (this.attributes.vertices) {
        return this.attributes.vertices.value.length / 3;
      } else if (this.attributes.positions) {
        return this.attributes.positions.value.length / 3;
      }
      return false;
    }
  }, {
    key: 'hasAttribute',
    value: function hasAttribute(attributeName) {
      return Boolean(this.attributes[attributeName]);
    }
  }, {
    key: 'getAttribute',
    value: function getAttribute(attributeName) {
      var attribute = this.attributes[attributeName];
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(attribute);
      return attribute.value;
    }
  }, {
    key: 'getArray',
    value: function getArray(attributeName) {
      var attribute = this.attributes[attributeName];
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(attribute);
      return attribute.value;
    }
  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    // Attribute
    // value: typed array
    // type: indices, vertices, uvs
    // size: elements per vertex
    // target: WebGL buffer type (string or constant)

  }, {
    key: 'setAttributes',
    value: function setAttributes(attributes) {
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Wrap "unwrapped" arrays and try to autodetect their type
        attribute = ArrayBuffer.isView(attribute) ? { value: attribute } : attribute;

        __WEBPACK_IMPORTED_MODULE_1_assert___default()(ArrayBuffer.isView(attribute.value), this._print(attributeName) + ': must be typed array or object with value as typed array');

        this._autoDetectAttribute(attributeName, attribute);

        this.attributes[attributeName] = Object.assign({}, attribute, {
          instanced: attribute.instanced || 0
        });
      }
      this.setNeedsRedraw();
      return this;
    }

    // Check for well known attribute names
    /* eslint-disable default-case, complexity */

  }, {
    key: '_autoDetectAttribute',
    value: function _autoDetectAttribute(attributeName, attribute) {
      var category = void 0;
      switch (attributeName) {
        case 'indices':
          category = category || 'indices';
          break;
        case 'texCoords':
        case 'texCoord1':
        case 'texCoord2':
        case 'texCoord3':
          category = 'uvs';
          break;
        case 'vertices':
        case 'positions':
        case 'normals':
        case 'pickingColors':
          category = 'vectors';
          break;
      }

      // Check for categorys
      switch (category) {
        case 'vectors':
          attribute.size = attribute.size || 3;
          break;
        case 'uvs':
          attribute.size = attribute.size || 2;
          break;
        case 'indices':
          attribute.size = attribute.size || 1;
          attribute.isIndexed = attribute.isIndexed || true;
          __WEBPACK_IMPORTED_MODULE_1_assert___default()(attribute.value instanceof Uint16Array || attribute.value instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
          break;
      }

      __WEBPACK_IMPORTED_MODULE_1_assert___default()(attribute.size, 'attribute ' + attributeName + ' needs size');
    }
    /* eslint-enable default-case, complexity */

  }, {
    key: '_print',
    value: function _print(attributeName) {
      return 'Geometry ' + this.id + ' attribute ' + attributeName;
    }
  }]);

  return Geometry;
}();

/* harmony default export */ __webpack_exports__["a"] = (Geometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9nZW9tZXRyeS5qcyJdLCJuYW1lcyI6WyJ1aWQiLCJsb2ciLCJhc3NlcnQiLCJJTExFR0FMX0FSRyIsIkdlb21ldHJ5Iiwib3B0cyIsImlkIiwiZHJhd01vZGUiLCJ2ZXJ0ZXhDb3VudCIsInVuZGVmaW5lZCIsImF0dHJpYnV0ZXMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJuZWVkc1JlZHJhdyIsInVzZXJEYXRhIiwiT2JqZWN0Iiwic2VhbCIsInNldEF0dHJpYnV0ZXMiLCJvbmNlIiwicmVkcmF3IiwiY2xlYXJSZWRyYXdGbGFncyIsImluZGljZXMiLCJ2YWx1ZSIsImxlbmd0aCIsInZlcnRpY2VzIiwicG9zaXRpb25zIiwiYXR0cmlidXRlTmFtZSIsIkJvb2xlYW4iLCJhdHRyaWJ1dGUiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9wcmludCIsIl9hdXRvRGV0ZWN0QXR0cmlidXRlIiwiYXNzaWduIiwiaW5zdGFuY2VkIiwic2V0TmVlZHNSZWRyYXciLCJjYXRlZ29yeSIsInNpemUiLCJpc0luZGV4ZWQiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBUUEsR0FBUixRQUFrQixVQUFsQjtBQUNBLFNBQVFDLEdBQVIsUUFBa0IsVUFBbEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGNBQWMsNEJBQXBCOztJQUVxQkMsUTtBQUVuQixzQkFBdUI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsUUFFbkJDLEVBRm1CLEdBTWpCRCxJQU5pQixDQUVuQkMsRUFGbUI7QUFBQSx5QkFNakJELElBTmlCLENBR25CRSxRQUhtQjtBQUFBLFFBR25CQSxRQUhtQixrQ0FHUixXQUhRO0FBQUEsNEJBTWpCRixJQU5pQixDQUluQkcsV0FKbUI7QUFBQSxRQUluQkEsV0FKbUIscUNBSUxDLFNBSks7QUFBQSxRQUtuQkMsVUFMbUIsR0FNakJM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QXBDLGlCQUNFMEIsVUFBVU4sS0FBVixZQUEyQmlCLFdBQTNCLElBQ0FYLFVBQVVOLEtBQVYsWUFBMkJrQixXQUY3QixFQUdFLHVEQUhGO0FBS0E7QUFmRjs7QUFrQkF0QyxhQUFPMEIsVUFBVVMsSUFBakIsaUJBQW9DWCxhQUFwQztBQUNEO0FBQ0Q7Ozs7MkJBRU9BLGEsRUFBZTtBQUNwQiwyQkFBbUIsS0FBS3BCLEVBQXhCLG1CQUF3Q29CLGFBQXhDO0FBQ0Q7Ozs7OztlQTFKa0J0QixRIiwiZmlsZSI6Imdlb21ldHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1aWR9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IElMTEVHQUxfQVJHID0gJ0dlb21ldHJ5OiBJbGxlZ2FsIGFyZ3VtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cnkge1xuXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZHJhd01vZGUgPSAnVFJJQU5HTEVTJyxcbiAgICAgIHZlcnRleENvdW50ID0gdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBvcHRzO1xuXG4gICAgYXNzZXJ0KGRyYXdNb2RlLCBJTExFR0FMX0FSRyk7XG5cbiAgICB0aGlzLmlkID0gaWQgfHwgdWlkKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlO1xuICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cub25jZSgnR2VvbWV0cnk6IHRvcC1sZXZlbCBhdHRyaWJ1dGVzIGFyZSBkZXByZWNhdGVkLCB1c2UgXCJhdHRyaWJ1dGVzXCIgcGFyYW0nKTtcbiAgICAgIC8vIFRPRE8gdGhpcyBpcyBkZXByZWNhdGVkXG4gICAgICBkZWxldGUgb3B0cy5pZDtcbiAgICAgIGRlbGV0ZSBvcHRzLmRyYXdNb2RlO1xuICAgICAgZGVsZXRlIG9wdHMudmVydGV4Q291bnQ7XG4gICAgICBkZWxldGUgb3B0cy5hdHRyaWJ1dGVzO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5uZWVkc1JlZHJhdztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgc2V0VmVydGV4Q291bnQodmVydGV4Q291bnQpIHtcbiAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XG4gIH1cblxuICBnZXRWZXJ0ZXhDb3VudCgpIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJ0ZXhDb3VudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXR0cmlidXRlcy5pbmRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmluZGljZXMudmFsdWUubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdHRyaWJ1dGVzLnZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnZlcnRpY2VzLnZhbHVlLmxlbmd0aCAvIDM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucy52YWx1ZS5sZW5ndGggLyAzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gIH1cblxuICBnZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICBhc3NlcnQoYXR0cmlidXRlKTtcbiAgICByZXR1cm4gYXR0cmlidXRlLnZhbHVlO1xuICB9XG5cbiAgZ2V0QXJyYXkoYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICBhc3NlcnQoYXR0cmlidXRlKTtcbiAgICByZXR1cm4gYXR0cmlidXRlLnZhbHVlO1xuICB9XG5cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlXG4gIC8vIHZhbHVlOiB0eXBlZCBhcnJheVxuICAvLyB0eXBlOiBpbmRpY2VzLCB2ZXJ0aWNlcywgdXZzXG4gIC8vIHNpemU6IGVsZW1lbnRzIHBlciB2ZXJ0ZXhcbiAgLy8gdGFyZ2V0OiBXZWJHTCBidWZmZXIgdHlwZSAoc3RyaW5nIG9yIGNvbnN0YW50KVxuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIFdyYXAgXCJ1bndyYXBwZWRcIiBhcnJheXMgYW5kIHRyeSB0byBhdXRvZGV0ZWN0IHRoZWlyIHR5cGVcbiAgICAgIGF0dHJpYnV0ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhhdHRyaWJ1dGUpID8ge3ZhbHVlOiBhdHRyaWJ1dGV9IDogYXR0cmlidXRlO1xuXG4gICAgICBhc3NlcnQoQXJyYXlCdWZmZXIuaXNWaWV3KGF0dHJpYnV0ZS52YWx1ZSksXG4gICAgICAgIGAke3RoaXMuX3ByaW50KGF0dHJpYnV0ZU5hbWUpfTogbXVzdCBiZSB0eXBlZCBhcnJheSBvciBvYmplY3Qgd2l0aCB2YWx1ZSBhcyB0eXBlZCBhcnJheWApO1xuXG4gICAgICB0aGlzLl9hdXRvRGV0ZWN0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZSwge1xuICAgICAgICBpbnN0YW5jZWQ6IGF0dHJpYnV0ZS5pbnN0YW5jZWQgfHwgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENoZWNrIGZvciB3ZWxsIGtub3duIGF0dHJpYnV0ZSBuYW1lc1xuICAvKiBlc2xpbnQtZGlzYWJsZSBkZWZhdWx0LWNhc2UsIGNvbXBsZXhpdHkgKi9cbiAgX2F1dG9EZXRlY3RBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSB7XG4gICAgbGV0IGNhdGVnb3J5O1xuICAgIHN3aXRjaCAoYXR0cmlidXRlTmFtZSkge1xuICAgIGNhc2UgJ2luZGljZXMnOlxuICAgICAgY2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCAnaW5kaWNlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXhDb29yZHMnOlxuICAgIGNhc2UgJ3RleENvb3JkMSc6XG4gICAgY2FzZSAndGV4Q29vcmQyJzpcbiAgICBjYXNlICd0ZXhDb29yZDMnOlxuICAgICAgY2F0ZWdvcnkgPSAndXZzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZlcnRpY2VzJzpcbiAgICBjYXNlICdwb3NpdGlvbnMnOlxuICAgIGNhc2UgJ25vcm1hbHMnOlxuICAgIGNhc2UgJ3BpY2tpbmdDb2xvcnMnOlxuICAgICAgY2F0ZWdvcnkgPSAndmVjdG9ycyc7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY2F0ZWdvcnlzXG4gICAgc3dpdGNoIChjYXRlZ29yeSkge1xuICAgIGNhc2UgJ3ZlY3RvcnMnOlxuICAgICAgYXR0cmlidXRlLnNpemUgPSBhdHRyaWJ1dGUuc2l6ZSB8fCAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXZzJzpcbiAgICAgIGF0dHJpYnV0ZS5zaXplID0gYXR0cmlidXRlLnNpemUgfHwgMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luZGljZXMnOlxuICAgICAgYXR0cmlidXRlLnNpemUgPSBhdHRyaWJ1dGUuc2l6ZSB8fCAxO1xuICAgICAgYXR0cmlidXRlLmlzSW5kZXhlZCA9IGF0dHJpYnV0ZS5pc0luZGV4ZWQgfHwgdHJ1ZTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXksXG4gICAgICAgICdhdHRyaWJ1dGUgYXJyYXkgZm9yIFwiaW5kaWNlc1wiIG11c3QgYmUgb2YgaW50ZWdlciB0eXBlJ1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydChhdHRyaWJ1dGUuc2l6ZSwgYGF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9IG5lZWRzIHNpemVgKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGRlZmF1bHQtY2FzZSwgY29tcGxleGl0eSAqL1xuXG4gIF9wcmludChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIGBHZW9tZXRyeSAke3RoaXMuaWR9IGF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9YDtcbiAgfVxufVxuIl19

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__ = __webpack_require__(107);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderingContext", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBuffer", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLFramebuffer", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderbuffer", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLTexture", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUniformLocation", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLActiveInfo", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShaderPrecisionFormat", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL2RenderingContext", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "webGLTypesAvailable", function() { return __WEBPACK_IMPORTED_MODULE_0__api_webgl_types__["m"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_constants__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_constants__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_constants__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__context__ = __webpack_require__(2);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGLContext", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2Context", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "setContextDefaults", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "glContextWithState", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "pollContext", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "glGetDebugInfo", function() { return __WEBPACK_IMPORTED_MODULE_2__context__["k"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__buffer__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return __WEBPACK_IMPORTED_MODULE_3__buffer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shader__ = __webpack_require__(60);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return __WEBPACK_IMPORTED_MODULE_4__shader__["default"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return __WEBPACK_IMPORTED_MODULE_4__shader__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return __WEBPACK_IMPORTED_MODULE_4__shader__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__program__ = __webpack_require__(59);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Program", function() { return __WEBPACK_IMPORTED_MODULE_5__program__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__framebuffer__ = __webpack_require__(35);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return __WEBPACK_IMPORTED_MODULE_6__framebuffer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__renderbuffer__ = __webpack_require__(36);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Renderbuffer", function() { return __WEBPACK_IMPORTED_MODULE_7__renderbuffer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__texture_2d__ = __webpack_require__(61);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Texture2D", function() { return __WEBPACK_IMPORTED_MODULE_8__texture_2d__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__texture_cube__ = __webpack_require__(115);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TextureCube", function() { return __WEBPACK_IMPORTED_MODULE_9__texture_cube__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__vertex_attributes__ = __webpack_require__(117);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "VertexAttributes", function() { return __WEBPACK_IMPORTED_MODULE_10__vertex_attributes__; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__draw__ = __webpack_require__(111);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return __WEBPACK_IMPORTED_MODULE_11__draw__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__functions__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return __WEBPACK_IMPORTED_MODULE_12__functions__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "readPixels", function() { return __WEBPACK_IMPORTED_MODULE_12__functions__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "readPixelsFromBuffer", function() { return __WEBPACK_IMPORTED_MODULE_12__functions__["readPixelsFromBuffer"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__uniforms__ = __webpack_require__(62);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "parseUniformName", function() { return __WEBPACK_IMPORTED_MODULE_13__uniforms__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "getUniformSetter", function() { return __WEBPACK_IMPORTED_MODULE_13__uniforms__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "checkUniformValues", function() { return __WEBPACK_IMPORTED_MODULE_13__uniforms__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__vertex_array_object__ = __webpack_require__(116);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VertexArrayObject", function() { return __WEBPACK_IMPORTED_MODULE_14__vertex_array_object__["a"]; });
// luma.gl Base WebGL wrapper library
// Provides simple class/function wrappers around the low level webgl objects
// These classes are intentionally close to the WebGL API
// but make it easier to use.
// Higher level abstractions can be built on these classes

// Exports WebGL API constants and types, plus some basic type checks







// WebGL context functions and helpers


// WebGL1 objects











// Functions






// WebGL2

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9pbmRleC5qcyJdLCJuYW1lcyI6WyJJbWFnZSIsIldlYkdMUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMUHJvZ3JhbSIsIldlYkdMU2hhZGVyIiwiV2ViR0xCdWZmZXIiLCJXZWJHTEZyYW1lYnVmZmVyIiwiV2ViR0xSZW5kZXJidWZmZXIiLCJXZWJHTFRleHR1cmUiLCJXZWJHTFVuaWZvcm1Mb2NhdGlvbiIsIldlYkdMQWN0aXZlSW5mbyIsIldlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0IiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsIndlYkdMVHlwZXNBdmFpbGFibGUiLCJHTCIsImRlZmF1bHQiLCJpc1dlYkdMQ29udGV4dCIsImlzV2ViR0wyQ29udGV4dCIsIkJ1ZmZlciIsIlNoYWRlciIsIlZlcnRleFNoYWRlciIsIkZyYWdtZW50U2hhZGVyIiwiUHJvZ3JhbSIsIkZyYW1lYnVmZmVyIiwiUmVuZGVyYnVmZmVyIiwiVGV4dHVyZTJEIiwiVGV4dHVyZUN1YmUiLCJWZXJ0ZXhBdHRyaWJ1dGVzIiwiZHJhdyIsImNsZWFyIiwicmVhZFBpeGVscyIsInJlYWRQaXhlbHNGcm9tQnVmZmVyIiwicGFyc2VVbmlmb3JtTmFtZSIsImdldFVuaWZvcm1TZXR0ZXIiLCJjaGVja1VuaWZvcm1WYWx1ZXMiLCJWZXJ0ZXhBcnJheU9iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQ0VBLEtBREYsRUFFRUMscUJBRkYsRUFHRUMsWUFIRixFQUlFQyxXQUpGLEVBS0VDLFdBTEYsRUFNRUMsZ0JBTkYsRUFPRUMsaUJBUEYsRUFRRUMsWUFSRixFQVNFQyxvQkFURixFQVVFQyxlQVZGLEVBV0VDLDBCQVhGLEVBWUVDLHNCQVpGLEVBY0VDLG1CQWRGLFFBZU8sbUJBZlA7O0FBaUJBLFNBQVFDLEVBQVIsUUFBaUIsZ0JBQWpCO0FBQ0EsU0FBUUEsTUFBTUMsT0FBZCxRQUE0QixnQkFBNUI7O0FBRUEsU0FDRUMsY0FERixFQUVFQyxlQUZGLFFBR08sV0FIUDs7QUFLQTtBQUNBLGNBQWMsV0FBZDs7QUFFQTtBQUNBLFNBQVFGLFdBQVdHLE1BQW5CLFFBQWdDLFVBQWhDO0FBQ0EsU0FBUUgsV0FBV0ksTUFBbkIsRUFBMkJDLFlBQTNCLEVBQXlDQyxjQUF6QyxRQUE4RCxVQUE5RDtBQUNBLFNBQVFOLFdBQVdPLE9BQW5CLFFBQWlDLFdBQWpDO0FBQ0EsU0FBUVAsV0FBV1EsV0FBbkIsUUFBcUMsZUFBckM7QUFDQSxTQUFRUixXQUFXUyxZQUFuQixRQUFzQyxnQkFBdEM7QUFDQSxTQUFRVCxXQUFXVSxTQUFuQixRQUFtQyxjQUFuQztBQUNBLFNBQVFWLFdBQVdXLFdBQW5CLFFBQXFDLGdCQUFyQzs7QUFFQSxPQUFPLEtBQUtDLGdCQUFaLE1BQWtDLHFCQUFsQztBQUNBLFNBQVFBLGdCQUFSOztBQUVBO0FBQ0EsU0FDRUMsSUFERixRQUVPLFFBRlA7O0FBSUEsU0FDRUMsS0FERixFQUVFQyxVQUZGLEVBR0VDLG9CQUhGLFFBSU8sYUFKUDs7QUFNQSxTQUNFQyxnQkFERixFQUVFQyxnQkFGRixFQUdFQyxrQkFIRixRQUlPLFlBSlA7O0FBTUE7QUFDQSxTQUFRbkIsV0FBV29CLGlCQUFuQixRQUEyQyx1QkFBM0MiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsdW1hLmdsIEJhc2UgV2ViR0wgd3JhcHBlciBsaWJyYXJ5XG4vLyBQcm92aWRlcyBzaW1wbGUgY2xhc3MvZnVuY3Rpb24gd3JhcHBlcnMgYXJvdW5kIHRoZSBsb3cgbGV2ZWwgd2ViZ2wgb2JqZWN0c1xuLy8gVGhlc2UgY2xhc3NlcyBhcmUgaW50ZW50aW9uYWxseSBjbG9zZSB0byB0aGUgV2ViR0wgQVBJXG4vLyBidXQgbWFrZSBpdCBlYXNpZXIgdG8gdXNlLlxuLy8gSGlnaGVyIGxldmVsIGFic3RyYWN0aW9ucyBjYW4gYmUgYnVpbHQgb24gdGhlc2UgY2xhc3Nlc1xuXG4vLyBFeHBvcnRzIFdlYkdMIEFQSSBjb25zdGFudHMgYW5kIHR5cGVzLCBwbHVzIHNvbWUgYmFzaWMgdHlwZSBjaGVja3NcbmV4cG9ydCB7XG4gIEltYWdlLFxuICBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFdlYkdMUHJvZ3JhbSxcbiAgV2ViR0xTaGFkZXIsXG4gIFdlYkdMQnVmZmVyLFxuICBXZWJHTEZyYW1lYnVmZmVyLFxuICBXZWJHTFJlbmRlcmJ1ZmZlcixcbiAgV2ViR0xUZXh0dXJlLFxuICBXZWJHTFVuaWZvcm1Mb2NhdGlvbixcbiAgV2ViR0xBY3RpdmVJbmZvLFxuICBXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdCxcbiAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcblxuICB3ZWJHTFR5cGVzQXZhaWxhYmxlXG59IGZyb20gJy4vYXBpL3dlYmdsLXR5cGVzJztcblxuZXhwb3J0IHtHTH0gZnJvbSAnLi9nbC1jb25zdGFudHMnO1xuZXhwb3J0IHtHTCBhcyBkZWZhdWx0fSBmcm9tICcuL2dsLWNvbnN0YW50cyc7XG5cbmV4cG9ydCB7XG4gIGlzV2ViR0xDb250ZXh0LFxuICBpc1dlYkdMMkNvbnRleHRcbn0gZnJvbSAnLi9jb250ZXh0JztcblxuLy8gV2ViR0wgY29udGV4dCBmdW5jdGlvbnMgYW5kIGhlbHBlcnNcbmV4cG9ydCAqIGZyb20gJy4vY29udGV4dCc7XG5cbi8vIFdlYkdMMSBvYmplY3RzXG5leHBvcnQge2RlZmF1bHQgYXMgQnVmZmVyfSBmcm9tICcuL2J1ZmZlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgU2hhZGVyLCBWZXJ0ZXhTaGFkZXIsIEZyYWdtZW50U2hhZGVyfSBmcm9tICcuL3NoYWRlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgUHJvZ3JhbX0gZnJvbSAnLi9wcm9ncmFtJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGcmFtZWJ1ZmZlcn0gZnJvbSAnLi9mcmFtZWJ1ZmZlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgUmVuZGVyYnVmZmVyfSBmcm9tICcuL3JlbmRlcmJ1ZmZlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgVGV4dHVyZTJEfSBmcm9tICcuL3RleHR1cmUtMmQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRleHR1cmVDdWJlfSBmcm9tICcuL3RleHR1cmUtY3ViZSc7XG5cbmltcG9ydCAqIGFzIFZlcnRleEF0dHJpYnV0ZXMgZnJvbSAnLi92ZXJ0ZXgtYXR0cmlidXRlcyc7XG5leHBvcnQge1ZlcnRleEF0dHJpYnV0ZXN9O1xuXG4vLyBGdW5jdGlvbnNcbmV4cG9ydCB7XG4gIGRyYXdcbn0gZnJvbSAnLi9kcmF3JztcblxuZXhwb3J0IHtcbiAgY2xlYXIsXG4gIHJlYWRQaXhlbHMsXG4gIHJlYWRQaXhlbHNGcm9tQnVmZmVyXG59IGZyb20gJy4vZnVuY3Rpb25zJztcblxuZXhwb3J0IHtcbiAgcGFyc2VVbmlmb3JtTmFtZSxcbiAgZ2V0VW5pZm9ybVNldHRlcixcbiAgY2hlY2tVbmlmb3JtVmFsdWVzXG59IGZyb20gJy4vdW5pZm9ybXMnO1xuXG4vLyBXZWJHTDJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWZXJ0ZXhBcnJheU9iamVjdH0gZnJvbSAnLi92ZXJ0ZXgtYXJyYXktb2JqZWN0JztcbiJdfQ==

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__buffer__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TEXTURE_FORMATS;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-inline-comments, max-len */







// Legal combinations for internalFormat, format and type
var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_5_6_5] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_4_4_4_4, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_5_5_5_1] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LUMINANCE_ALPHA, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LUMINANCE_ALPHA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LUMINANCE, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LUMINANCE, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ALPHA, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ALPHA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].R8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RED, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].R16F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RED, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].R32F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RED, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].R8UI, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RED_INTEGER, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG16F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG32F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG8UI, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RG_INTEGER, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SRGB8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB565, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_5_6_5] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].R11F_G11F_B10F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_INT_10F_11F_11F_REV, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB9_E5, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB16FG, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB32F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB8UI, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB_INTEGER, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SRGB8_ALPHA8, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB5_A1, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_5_5_5_1] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA4, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT_4_4_4_4] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA16F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].HALF_FLOAT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA32F, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA8UI, { dataFormat: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA_INTEGER, types: [__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE] }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB_S3TC_DXT1_EXT, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_S3TC_DXT1_EXT, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_S3TC_DXT3_EXT, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_S3TC_DXT5_EXT, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_R11_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_SIGNED_R11_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RG11_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_SIGNED_RG11_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB8_ETC2, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA8_ETC2_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_SRGB8_ETC2, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB_PVRTC_4BPPV1_IMG, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB_PVRTC_2BPPV1_IMG, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB_ETC1_WEBGL, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGB_ATC_WEBGL, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL, { compressed: true }), _defineProperty(_TEXTURE_FORMATS, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL, { compressed: true }), _TEXTURE_FORMATS);

var Texture = function (_Resource) {
  _inherits(Texture, _Resource);

  // target cannot be modified by bind:
  // textures are special because when you first bind them to a target,
  // they get special information. When you first bind a texture as a
  // GL_TEXTURE_2D, you are actually setting special state in the texture.
  // You are saying that this texture is a 2D texture.
  // And it will always be a 2D texture; this state cannot be changed ever.
  // If you have a texture that was first bound as a GL_TEXTURE_2D,
  // you must always bind it as a GL_TEXTURE_2D;
  // attempting to bind it as GL_TEXTURE_1D will give rise to an error
  // (while run-time).
  function Texture(gl, opts) {
    _classCallCheck(this, Texture);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["uid"])('texture') : _opts$id,
        handle = opts.handle,
        target = opts.target;

    var _this = _possibleConstructorReturn(this, (Texture.__proto__ || Object.getPrototypeOf(Texture)).call(this, gl, { id: id, handle: handle }));

    _this.target = target;
    _this.hasFloatTexture = gl.getExtension('OES_texture_float');
    _this.textureUnit = undefined;
    return _this;
  }

  _createClass(Texture, [{
    key: 'toString',
    value: function toString() {
      return 'Texture(' + this.id + ',' + this.width + 'x' + this.height + ')';
    }

    /* eslint-disable brace-style */

  }, {
    key: 'initialize',


    /* eslint-disable max-len, max-statements */
    value: function initialize() {
      var _this2 = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$data = opts.data,
          data = _opts$data === undefined ? null : _opts$data,
          _opts$format = opts.format,
          format = _opts$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _opts$format,
          _opts$type = opts.type,
          type = _opts$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _opts$type,
          _opts$border = opts.border,
          border = _opts$border === undefined ? 0 : _opts$border,
          _opts$mipmaps = opts.mipmaps,
          mipmaps = _opts$mipmaps === undefined ? false : _opts$mipmaps,
          _opts$recreate = opts.recreate,
          recreate = _opts$recreate === undefined ? false : _opts$recreate,
          _opts$parameters = opts.parameters,
          parameters = _opts$parameters === undefined ? {} : _opts$parameters,
          _opts$pixelStore = opts.pixelStore,
          pixelStore = _opts$pixelStore === undefined ? {} : _opts$pixelStore;
      var width = opts.width,
          height = opts.height,
          dataFormat = opts.dataFormat;

      // Deduce width and height

      // Temporarily apply any pixel store settings and build textures
      var _deduceParameters2 = this._deduceParameters({
        format: format, type: type, dataFormat: dataFormat, compressed: false, data: data, width: width, height: height
      });

      width = _deduceParameters2.width;
      height = _deduceParameters2.height;
      dataFormat = _deduceParameters2.dataFormat;
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["j" /* withParameters */])(this.gl, pixelStore, function () {
        _this2.setImageData({ data: data, width: width, height: height, format: format, type: type, dataFormat: dataFormat, border: border, mipmaps: mipmaps });

        if (mipmaps) {
          _this2.generateMipmap();
        }
      });

      // Set texture sampler parameters
      this.setParameters(parameters);

      // Store opts for accessors
      this.opts.width = width;
      this.opts.height = height;
      this.opts.format = format;
      this.opts.type = type;
      this.opts.dataFormat = dataFormat;
      this.opts.border = border;

      // TODO - Store data to enable auto recreate on context loss
      if (recreate) {
        this.opts.data = data;
      }
    }

    // Call to regenerate mipmaps after modifying texture(s)

  }, {
    key: 'generateMipmap',
    value: function generateMipmap() {
      var _this3 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.gl.bindTexture(this.target, this.handle);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["j" /* withParameters */])(this.gl, params, function () {
        _this3.gl.generateMipmap(_this3.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }

    /**
     * Redefines an area of an existing texture
     * Note: does not allocate storage
     */

  }, {
    key: 'subImage',
    value: function subImage(_ref) {
      var _ref$target = _ref.target,
          target = _ref$target === undefined ? this.target : _ref$target,
          _ref$pixels = _ref.pixels,
          pixels = _ref$pixels === undefined ? null : _ref$pixels,
          _ref$data = _ref.data,
          data = _ref$data === undefined ? null : _ref$data,
          _ref$x = _ref.x,
          x = _ref$x === undefined ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === undefined ? 0 : _ref$y,
          width = _ref.width,
          height = _ref.height,
          _ref$level = _ref.level,
          level = _ref$level === undefined ? 0 : _ref$level,
          _ref$format = _ref.format,
          format = _ref$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref$format,
          type = _ref.type,
          dataFormat = _ref.dataFormat,
          _ref$compressed = _ref.compressed,
          compressed = _ref$compressed === undefined ? false : _ref$compressed,
          _ref$offset = _ref.offset,
          offset = _ref$offset === undefined ? 0 : _ref$offset,
          _ref$border = _ref.border,
          border = _ref$border === undefined ? 0 : _ref$border;

      // Support ndarrays
      var _deduceParameters3 = this._deduceParameters({
        format: format, type: type, dataFormat: dataFormat, compressed: compressed, data: data, width: width, height: height });

      type = _deduceParameters3.type;
      dataFormat = _deduceParameters3.dataFormat;
      compressed = _deduceParameters3.compressed;
      width = _deduceParameters3.width;
      height = _deduceParameters3.height;
      if (data && data.data) {
        var ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }

      // Support buffers
      if (data instanceof __WEBPACK_IMPORTED_MODULE_3__buffer__["a" /* default */]) {
        data = data.handle;
      }

      this.gl.bindTexture(this.target, this.handle);

      // TODO - x,y parameters
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, format, width, height, border, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, format, width, height, border, dataFormat, type, data);
      } else if (data instanceof __WEBPACK_IMPORTED_MODULE_0__api__["b" /* WebGLBuffer */]) {
        // WebGL2 allows us to create texture directly from a WebGL buffer
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
        // This texImage2D signature uses currently bound GL_PIXEL_UNPACK_BUFFER
        this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, data);
        this.gl.texSubImage2D(target, level, format, width, height, border, format, type, offset);
        this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].GL_PIXEL_UNPACK_BUFFER, null);
      } else {
        // Assume data is a browser supported object (ImageData, Canvas, ...)
        this.gl.texSubImage2D(target, level, x, y, format, type, data);
      }

      this.gl.bindTexture(this.target, null);
    }
    /* eslint-enable max-len, max-statements, complexity */

    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     *
     * Note that binding a texture into a Framebuffer's color buffer and
     * rendering can be faster.
     */

  }, {
    key: 'copyFramebuffer',
    value: function copyFramebuffer(_ref2) {
      var _ref2$target = _ref2.target,
          target = _ref2$target === undefined ? this.target : _ref2$target,
          framebuffer = _ref2.framebuffer,
          _ref2$offset = _ref2.offset,
          offset = _ref2$offset === undefined ? 0 : _ref2$offset,
          _ref2$x = _ref2.x,
          x = _ref2$x === undefined ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === undefined ? 0 : _ref2$y,
          width = _ref2.width,
          height = _ref2.height,
          _ref2$level = _ref2.level,
          level = _ref2$level === undefined ? 0 : _ref2$level,
          _ref2$internalFormat = _ref2.internalFormat,
          internalFormat = _ref2$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref2$internalFormat,
          _ref2$border = _ref2.border,
          border = _ref2$border === undefined ? 0 : _ref2$border;

      if (framebuffer) {
        framebuffer.bind();
      }

      // target
      this.bind();
      this.gl.copyTexImage2D(this.target, level, internalFormat, x, y, width, height, border);
      this.unbind();

      if (framebuffer) {
        framebuffer.unbind();
      }
    }
  }, {
    key: 'getActiveUnit',
    value: function getActiveUnit() {
      return this.gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ACTIVE_TEXTURE) - __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE0;
    }

    // target cannot be modified by bind:
    // textures are special because when you first bind them to a target,
    // they get special information. When you first bind a texture as a
    // GL_TEXTURE_2D, you are actually setting special state in the texture.
    // You are saying that this texture is a 2D texture.
    // And it will always be a 2D texture; this state cannot be changed ever.
    // If you have a texture that was first bound as a GL_TEXTURE_2D,
    // you must always bind it as a GL_TEXTURE_2D;
    // attempting to bind it as GL_TEXTURE_1D will give rise to an error
    // (while run-time).

  }, {
    key: 'bind',
    value: function bind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;

      if (textureUnit === undefined) {
        throw new Error('Texture.bind: must specify texture unit');
      }
      this.textureUnit = textureUnit;
      this.gl.activeTexture(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE0 + textureUnit);
      this.gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      if (this.textureUnit === undefined) {
        throw new Error('Texture.unbind: texture unit not specified');
      }
      this.gl.activeTexture(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE0 + this.textureUnit);
      this.gl.bindTexture(this.target, null);
      return this.textureUnit;
    }

    // PRIVATE METHODS

    /*
     * Allocates storage
     * @param {*} pixels -
     *  null - create empty texture of specified format
     *  Typed array - init from image data in typed array
     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
     *  HTMLImageElement|Image - Inits with content of image. Auto width/height
     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
     *  HTMLVideoElement - Creates video texture. Auto width/height
     *
     * @param {GLint} width -
     * @param {GLint} height -
     * @param {GLint} mipMapLevel -
     * @param {GLenum} format - format of image data.
     * @param {GLenum} type
     *  - format of array (autodetect from type) or
     *  - (WEBGL2) format of buffer
     * @param {Number} offset - (WEBGL2) offset from start of buffer
     * @param {GLint} border - must be 0.
     */
    /* eslint-disable max-len, max-statements, complexity */

  }, {
    key: 'setImageData',
    value: function setImageData(_ref3) {
      var _ref3$target = _ref3.target,
          target = _ref3$target === undefined ? this.target : _ref3$target,
          _ref3$pixels = _ref3.pixels,
          pixels = _ref3$pixels === undefined ? null : _ref3$pixels,
          _ref3$data = _ref3.data,
          data = _ref3$data === undefined ? null : _ref3$data,
          width = _ref3.width,
          height = _ref3.height,
          _ref3$level = _ref3.level,
          level = _ref3$level === undefined ? 0 : _ref3$level,
          _ref3$format = _ref3.format,
          format = _ref3$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref3$format,
          type = _ref3.type,
          dataFormat = _ref3.dataFormat,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === undefined ? 0 : _ref3$offset,
          _ref3$border = _ref3.border,
          border = _ref3$border === undefined ? 0 : _ref3$border,
          _ref3$compressed = _ref3.compressed,
          compressed = _ref3$compressed === undefined ? false : _ref3$compressed;

      var _deduceParameters4 = this._deduceParameters({
        format: format, type: type, dataFormat: dataFormat, compressed: compressed, data: data, width: width, height: height });

      type = _deduceParameters4.type;
      dataFormat = _deduceParameters4.dataFormat;
      compressed = _deduceParameters4.compressed;
      width = _deduceParameters4.width;
      height = _deduceParameters4.height;
      var gl = this.gl;

      gl.bindTexture(this.target, this.handle);

      var dataType = null;

      var _getDataType2 = this._getDataType({ data: data, compressed: compressed });

      data = _getDataType2.data;
      dataType = _getDataType2.dataType;

      switch (dataType) {
        case 'compressed':
          gl.compressedTexImage2D(this.target, level, format, width, height, border, data);
          break;
        case 'typed-array':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;
        case 'buffer':
          // WebGL2 enables creating textures directly from a WebGL buffer
          __WEBPACK_IMPORTED_MODULE_5_assert___default()(gl instanceof __WEBPACK_IMPORTED_MODULE_0__api__["c" /* WebGL2RenderingContext */], 'Requires WebGL2');
          gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, data.handle || data);
          gl.texImage2D(target, level, format, width, height, border, format, type, offset);
          break;
        case 'browser-obejct':
        default:
          gl.texImage2D(target, level, format, format, type, data);
      }
    }
    /* eslint-enable max-len, max-statements, complexity */

  }, {
    key: '_getDataType',
    value: function _getDataType(_ref4) {
      var data = _ref4.data,
          _ref4$compressed = _ref4.compressed,
          compressed = _ref4$compressed === undefined ? false : _ref4$compressed;

      if (compressed) {
        return { data: data, dataType: 'compressed' };
      }
      if (data === null || ArrayBuffer.isView(data)) {
        return { data: data, dataType: 'typed-array' };
      }
      if (data instanceof __WEBPACK_IMPORTED_MODULE_3__buffer__["a" /* default */]) {
        return { data: data.handle, dataType: 'buffer' };
      }
      if (data instanceof __WEBPACK_IMPORTED_MODULE_0__api__["b" /* WebGLBuffer */]) {
        return { data: data, dataType: 'buffer' };
      }
      // Assume data is a browser supported object (ImageData, Canvas, ...)
      return { data: data, dataType: 'browser-object' };
    }

    // Image 3D copies from Typed Array or WebGLBuffer

  }, {
    key: 'setImage3D',
    value: function setImage3D(_ref5) {
      var _ref5$level = _ref5.level,
          level = _ref5$level === undefined ? 0 : _ref5$level,
          _ref5$internalformat = _ref5.internalformat,
          internalformat = _ref5$internalformat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref5$internalformat,
          width = _ref5.width,
          height = _ref5.height,
          _ref5$depth = _ref5.depth,
          depth = _ref5$depth === undefined ? 1 : _ref5$depth,
          _ref5$border = _ref5.border,
          border = _ref5$border === undefined ? 0 : _ref5$border,
          format = _ref5.format,
          _ref5$type = _ref5.type,
          type = _ref5$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref5$type,
          _ref5$offset = _ref5.offset,
          offset = _ref5$offset === undefined ? 0 : _ref5$offset,
          pixels = _ref5.pixels;

      if (ArrayBuffer.isView(pixels)) {
        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, pixels);
        return this;
      }

      if (pixels instanceof __WEBPACK_IMPORTED_MODULE_3__buffer__["a" /* default */]) {
        this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, pixels.handle);
        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, offset);
      }

      return this;
    }

    // HELPER METHODS

  }, {
    key: '_deduceParameters',
    value: function _deduceParameters(opts) {
      var format = opts.format,
          data = opts.data;
      var width = opts.width,
          height = opts.height,
          dataFormat = opts.dataFormat,
          type = opts.type,
          compressed = opts.compressed;

      // Deduce format and type from format

      var textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];

      // Deduce compression from format
      compressed = compressed || textureFormat && textureFormat.compressed;

      var _deduceImageSize2 = this._deduceImageSize({ data: data, width: width, height: height });

      width = _deduceImageSize2.width;
      height = _deduceImageSize2.height;


      return { dataFormat: dataFormat, type: type, compressed: compressed, width: width, height: height, format: format, data: data };
    }

    /* global ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement */

  }, {
    key: '_deduceImageSize',
    value: function _deduceImageSize(_ref6) {
      var data = _ref6.data,
          width = _ref6.width,
          height = _ref6.height;

      var size = void 0;

      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
        size = { width: data.naturalWidth, height: data.naturalHeight };
      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
        size = { width: data.videoWidth, height: data.videoHeight };
      } else if (!data) {
        size = { width: width >= 0 ? width : 1, height: height >= 0 ? height : 1 };
      }

      __WEBPACK_IMPORTED_MODULE_5_assert___default()(size, 'Could not deduced texture size');
      __WEBPACK_IMPORTED_MODULE_5_assert___default()(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
      __WEBPACK_IMPORTED_MODULE_5_assert___default()(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');

      return size;
    }

    // RESOURCE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createTexture();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteTexture(this.handle);
    }
  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      switch (pname) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_WIDTH:
          return this.opts.width;
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_HEIGHT:
          return this.opts.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          var value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
  }, {
    key: '_setParameter',
    value: function _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);

      // Apparently there are some integer/float conversion rules that made
      // the WebGL committe expose two parameter setting functions in JavaScript.
      // For now, pick the float version for parameters specified as GLfloat.
      switch (pname) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MIN_LOD:
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MAX_LOD:
          this.gl.texParameterf(this.handle, pname, param);
          break;

        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_WIDTH:
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_HEIGHT:
          throw new Error('Cannot set emulated parameter');

        default:
          this.gl.bindTexture(this.target, this.handle);
          this.gl.texParameteri(this.target, pname, param);
          break;
      }

      this.gl.bindTexture(this.target, null);
      return this;
    }
  }, {
    key: 'width',
    get: function get() {
      return this.opts.width;
    }
  }, {
    key: 'height',
    get: function get() {
      return this.opts.width;
    }
  }, {
    key: 'format',
    get: function get() {
      return this.opts.format;
    }
  }, {
    key: 'type',
    get: function get() {
      return this.opts.type;
    }
  }, {
    key: 'dataFormat',
    get: function get() {
      return this.opts.dataFormat;
    }
  }, {
    key: 'border',
    get: function get() {
      return this.opts.border;
    }
  }, {
    key: 'mipmaps',
    get: function get() {
      return this.opts.mipmaps;
    }
  }]);

  return Texture;
}(__WEBPACK_IMPORTED_MODULE_2__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Texture);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90ZXh0dXJlLmpzIl0sIm5hbWVzIjpbIkdMIiwiV2ViR0xCdWZmZXIiLCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0Iiwid2l0aFBhcmFtZXRlcnMiLCJhc3NlcnRXZWJHTDJDb250ZXh0IiwiUmVzb3VyY2UiLCJCdWZmZXIiLCJ1aWQiLCJhc3NlcnQiLCJURVhUVVJFX0ZPUk1BVFMiLCJSR0IiLCJkYXRhRm9ybWF0IiwidHlwZXMiLCJVTlNJR05FRF9CWVRFIiwiVU5TSUdORURfU0hPUlRfNV82XzUiLCJSR0JBIiwiVU5TSUdORURfU0hPUlRfNF80XzRfNCIsIlVOU0lHTkVEX1NIT1JUXzVfNV81XzEiLCJMVU1JTkFOQ0VfQUxQSEEiLCJMVU1JTkFOQ0UiLCJBTFBIQSIsIlI4IiwiUkVEIiwiUjE2RiIsIkhBTEZfRkxPQVQiLCJGTE9BVCIsIlIzMkYiLCJSOFVJIiwiUkVEX0lOVEVHRVIiLCJSRzgiLCJSRyIsIlJHMTZGIiwiUkczMkYiLCJSRzhVSSIsIlJHX0lOVEVHRVIiLCJSR0I4IiwiU1JHQjgiLCJSR0I1NjUiLCJSMTFGX0cxMUZfQjEwRiIsIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYiLCJSR0I5X0U1IiwiUkdCMTZGRyIsIlJHQjMyRiIsIlJHQjhVSSIsIlJHQl9JTlRFR0VSIiwiUkdCQTgiLCJTUkdCOF9BTFBIQTgiLCJSR0I1X0ExIiwiUkdCQTQiLCJSR0JBMTZGIiwiUkdCQTMyRiIsIlJHQkE4VUkiLCJSR0JBX0lOVEVHRVIiLCJDT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUIiwiY29tcHJlc3NlZCIsIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUIiwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQiLCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCIsIkNPTVBSRVNTRURfUjExX0VBQyIsIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMiLCJDT01QUkVTU0VEX1JHMTFfRUFDIiwiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUMiLCJDT01QUkVTU0VEX1JHQjhfRVRDMiIsIkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUMiLCJDT01QUkVTU0VEX1NSR0I4X0VUQzIiLCJDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyIsIkNPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIiLCJDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMiIsIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUciLCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyIsIkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUciLCJDT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRyIsIkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wiLCJDT01QUkVTU0VEX1JHQl9BVENfV0VCR0wiLCJDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMIiwiQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0wiLCJUZXh0dXJlIiwiZ2wiLCJvcHRzIiwiaWQiLCJoYW5kbGUiLCJ0YXJnZXQiLCJoYXNGbG9hdFRleHR1cmUiLCJnZXRFeHRlbnNpb24iLCJ0ZXh0dXJlVW5pdCIsInVuZGVmaW5lZCIsIndpZHRoIiwiaGVpZ2h0IiwiZGF0YSIsImZvcm1hdCIsInR5cGUiLCJib3JkZXIiLCJtaXBtYXBzIiwicmVjcmVhdGUiLCJwYXJhbWV0ZXJzIiwicGl4ZWxTdG9yZSIsIl9kZWR1Y2VQYXJhbWV0ZXJzIiwic2V0SW1hZ2VEYXRhIiwiZ2VuZXJhdGVNaXBtYXAiLCJzZXRQYXJhbWV0ZXJzIiwicGFyYW1zIiwiYmluZFRleHR1cmUiLCJwaXhlbHMiLCJ4IiwieSIsImxldmVsIiwib2Zmc2V0IiwibmRhcnJheSIsInNoYXBlIiwiY29tcHJlc3NlZFRleFN1YkltYWdlMkQiLCJ0ZXhTdWJJbWFnZTJEIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJiaW5kQnVmZmVyIiwiUElYRUxfVU5QQUNLX0JVRkZFUiIsIkdMX1BJWEVMX1VOUEFDS19CVUZGRVIiLCJmcmFtZWJ1ZmZlciIsImludGVybmFsRm9ybWF0IiwiYmluZCIsImNvcHlUZXhJbWFnZTJEIiwidW5iaW5kIiwiZ2V0UGFyYW1ldGVyIiwiQUNUSVZFX1RFWFRVUkUiLCJURVhUVVJFMCIsIkVycm9yIiwiYWN0aXZlVGV4dHVyZSIsImRhdGFUeXBlIiwiX2dldERhdGFUeXBlIiwiY29tcHJlc3NlZFRleEltYWdlMkQiLCJ0ZXhJbWFnZTJEIiwiaW50ZXJuYWxmb3JtYXQiLCJkZXB0aCIsInRleEltYWdlM0QiLCJ0ZXh0dXJlRm9ybWF0IiwiX2RlZHVjZUltYWdlU2l6ZSIsInNpemUiLCJJbWFnZURhdGEiLCJIVE1MSW1hZ2VFbGVtZW50IiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsIkhUTUxDYW52YXNFbGVtZW50IiwiSFRNTFZpZGVvRWxlbWVudCIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImNyZWF0ZVRleHR1cmUiLCJkZWxldGVUZXh0dXJlIiwicG5hbWUiLCJURVhUVVJFX1dJRFRIIiwiVEVYVFVSRV9IRUlHSFQiLCJ2YWx1ZSIsImdldFRleFBhcmFtZXRlciIsInBhcmFtIiwiVEVYVFVSRV9NSU5fTE9EIiwiVEVYVFVSRV9NQVhfTE9EIiwidGV4UGFyYW1ldGVyZiIsInRleFBhcmFtZXRlcmkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsT0FBT0EsRUFBUCxJQUFZQyxXQUFaLEVBQXlCQyxzQkFBekIsUUFBc0QsT0FBdEQ7QUFDQSxTQUFRQyxjQUFSLEVBQXdCQyxtQkFBeEIsUUFBa0QsV0FBbEQ7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixVQUFuQjtBQUNBLFNBQVFDLEdBQVIsUUFBa0IsVUFBbEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBO0FBQ0EsSUFB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Q0FBVVEsS0FBakI7QUFBeUI7Ozt3QkFDM0I7QUFBRSxhQUFPLEtBQUtSLElBQUwsQ0FBVVcsTUFBakI7QUFBMEI7Ozt3QkFDOUI7QUFBRSxhQUFPLEtBQUtYLElBQUwsQ0FBVVksSUFBakI7QUFBd0I7Ozt3QkFDcEI7QUFBRSxhQUFPLEtBQUtaLElBQUwsQ0FBVW5FLFVBQWpCO0FBQThCOzs7d0JBQ3BDO0FBQUUsYUFBTyxLQUFLbUUsSUFBTCxDQUFVYSxNQUFqQjtBQUEwQjs7O3dCQUMzQjtBQUFFLGFBQU8sS0FBS2IsSUFBTCxDQUFVYyxPQUFqQjtBQUEyQjs7OztFQXRDUnZGLFE7O2VBQWhCdUUsTyIsImZpbGUiOiJ0ZXh0dXJlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8taW5saW5lLWNvbW1lbnRzLCBtYXgtbGVuICovXG5pbXBvcnQgR0wsIHtXZWJHTEJ1ZmZlciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHt3aXRoUGFyYW1ldGVycywgYXNzZXJ0V2ViR0wyQ29udGV4dH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCBCdWZmZXIgZnJvbSAnLi9idWZmZXInO1xuaW1wb3J0IHt1aWR9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gTGVnYWwgY29tYmluYXRpb25zIGZvciBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0IGFuZCB0eXBlXG5jb25zdCBURVhUVVJFX0ZPUk1BVFMgPSB7XG4gIFtHTC5SR0JdOiB7ZGF0YUZvcm1hdDogR0wuUkdCLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEUsIEdMLlVOU0lHTkVEX1NIT1JUXzVfNl81XX0sXG4gIFtHTC5SR0JBXToge2RhdGFGb3JtYXQ6IEdMLlJHQkEsIHR5cGVzOiBbR0wuVU5TSUdORURfQllURSwgR0wuVU5TSUdORURfU0hPUlRfNF80XzRfNCwgR0wuVU5TSUdORURfU0hPUlRfNV81XzVfMV19LFxuICBbR0wuTFVNSU5BTkNFX0FMUEhBXToge2RhdGFGb3JtYXQ6IEdMLkxVTUlOQU5DRV9BTFBIQSwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG4gIFtHTC5MVU1JTkFOQ0VdOiB7ZGF0YUZvcm1hdDogR0wuTFVNSU5BTkNFLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEVdfSxcbiAgW0dMLkFMUEhBXToge2RhdGFGb3JtYXQ6IEdMLkFMUEhBLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEVdfSxcbiAgW0dMLlI4XToge2RhdGFGb3JtYXQ6IEdMLlJFRCwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG4gIFtHTC5SMTZGXToge2RhdGFGb3JtYXQ6IEdMLlJFRCwgdHlwZXM6IFtHTC5IQUxGX0ZMT0FULCBHTC5GTE9BVF19LFxuICBbR0wuUjMyRl06IHtkYXRhRm9ybWF0OiBHTC5SRUQsIHR5cGVzOiBbR0wuRkxPQVRdfSxcbiAgW0dMLlI4VUldOiB7ZGF0YUZvcm1hdDogR0wuUkVEX0lOVEVHRVIsIHR5cGVzOiBbR0wuVU5TSUdORURfQllURV19LFxuICBbR0wuUkc4XToge2RhdGFGb3JtYXQ6IEdMLlJHLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEVdfSxcbiAgW0dMLlJHMTZGXToge2RhdGFGb3JtYXQ6IEdMLlJHLCB0eXBlczogW0dMLkhBTEZfRkxPQVQsIEdMLkZMT0FUXX0sXG4gIFtHTC5SRzMyRl06IHtkYXRhRm9ybWF0OiBHTC5SRywgdHlwZXM6IFtHTC5GTE9BVF19LFxuICBbR0wuUkc4VUldOiB7ZGF0YUZvcm1hdDogR0wuUkdfSU5URUdFUiwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG4gIFtHTC5SR0I4XToge2RhdGFGb3JtYXQ6IEdMLlJHQiwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG4gIFtHTC5TUkdCOF06IHtkYXRhRm9ybWF0OiBHTC5SR0IsIHR5cGVzOiBbR0wuVU5TSUdORURfQllURV19LFxuICBbR0wuUkdCNTY1XToge2RhdGFGb3JtYXQ6IEdMLlJHQiwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFLCBHTC5VTlNJR05FRF9TSE9SVF81XzZfNV19LFxuICBbR0wuUjExRl9HMTFGX0IxMEZdOiB7ZGF0YUZvcm1hdDogR0wuUkdCLCB0eXBlczogW0dMLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYsIEdMLkhBTEZfRkxPQVQsIEdMLkZMT0FUXX0sXG4gIFtHTC5SR0I5X0U1XToge2RhdGFGb3JtYXQ6IEdMLlJHQiwgdHlwZXM6IFtHTC5IQUxGX0ZMT0FULCBHTC5GTE9BVF19LFxuICBbR0wuUkdCMTZGR106IHtkYXRhRm9ybWF0OiBHTC5SR0IsIHR5cGVzOiBbR0wuSEFMRl9GTE9BVCwgR0wuRkxPQVRdfSxcbiAgW0dMLlJHQjMyRl06IHtkYXRhRm9ybWF0OiBHTC5SR0IsIHR5cGVzOiBbR0wuRkxPQVRdfSxcbiAgW0dMLlJHQjhVSV06IHtkYXRhRm9ybWF0OiBHTC5SR0JfSU5URUdFUiwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG4gIFtHTC5SR0JBOF06IHtkYXRhRm9ybWF0OiBHTC5SR0JBLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEVdfSxcbiAgW0dMLlNSR0I4X0FMUEhBOF06IHtkYXRhRm9ybWF0OiBHTC5SR0JBLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEVdfSxcbiAgW0dMLlJHQjVfQTFdOiB7ZGF0YUZvcm1hdDogR0wuUkdCQSwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFLCBHTC5VTlNJR05FRF9TSE9SVF81XzVfNV8xXX0sXG4gIFtHTC5SR0JBNF06IHtkYXRhRm9ybWF0OiBHTC5SR0JBLCB0eXBlczogW0dMLlVOU0lHTkVEX0JZVEUsIEdMLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdfSxcbiAgW0dMLlJHQkExNkZdOiB7ZGF0YUZvcm1hdDogR0wuUkdCQSwgdHlwZXM6IFtHTC5IQUxGX0ZMT0FULCBHTC5GTE9BVF19LFxuICBbR0wuUkdCQTMyRl06IHtkYXRhRm9ybWF0OiBHTC5SR0JBLCB0eXBlczogW0dMLkZMT0FUXX0sXG4gIFtHTC5SR0JBOFVJXToge2RhdGFGb3JtYXQ6IEdMLlJHQkFfSU5URUdFUiwgdHlwZXM6IFtHTC5VTlNJR05FRF9CWVRFXX0sXG5cbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcblxuICBbR0wuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVF06IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUXToge2NvbXByZXNzZWQ6IHRydWV9LFxuICBbR0wuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFRdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVF06IHtjb21wcmVzc2VkOiB0cnVlfSxcblxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXMzXG5cbiAgW0dMLkNPTVBSRVNTRURfUjExX0VBQ106IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1JHMTFfRUFDXToge2NvbXByZXNzZWQ6IHRydWV9LFxuICBbR0wuQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUNdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1JHQjhfRVRDMl06IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUNdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1NSR0I4X0VUQzJdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQ106IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzJdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMl06IHtjb21wcmVzc2VkOiB0cnVlfSxcblxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcblxuICBbR0wuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNR106IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HXToge2NvbXByZXNzZWQ6IHRydWV9LFxuICBbR0wuQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNR106IHtjb21wcmVzc2VkOiB0cnVlfSxcbiAgW0dMLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXToge2NvbXByZXNzZWQ6IHRydWV9LFxuXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXG5cbiAgW0dMLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG5cbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Y1xuXG4gIFtHTC5DT01QUkVTU0VEX1JHQl9BVENfV0VCR0xdOiB7Y29tcHJlc3NlZDogdHJ1ZX0sXG4gIFtHTC5DT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMXToge2NvbXByZXNzZWQ6IHRydWV9LFxuICBbR0wuQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xdOiB7Y29tcHJlc3NlZDogdHJ1ZX1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUgZXh0ZW5kcyBSZXNvdXJjZSB7XG5cbiAgLy8gdGFyZ2V0IGNhbm5vdCBiZSBtb2RpZmllZCBieSBiaW5kOlxuICAvLyB0ZXh0dXJlcyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdoZW4geW91IGZpcnN0IGJpbmQgdGhlbSB0byBhIHRhcmdldCxcbiAgLy8gdGhleSBnZXQgc3BlY2lhbCBpbmZvcm1hdGlvbi4gV2hlbiB5b3UgZmlyc3QgYmluZCBhIHRleHR1cmUgYXMgYVxuICAvLyBHTF9URVhUVVJFXzJELCB5b3UgYXJlIGFjdHVhbGx5IHNldHRpbmcgc3BlY2lhbCBzdGF0ZSBpbiB0aGUgdGV4dHVyZS5cbiAgLy8gWW91IGFyZSBzYXlpbmcgdGhhdCB0aGlzIHRleHR1cmUgaXMgYSAyRCB0ZXh0dXJlLlxuICAvLyBBbmQgaXQgd2lsbCBhbHdheXMgYmUgYSAyRCB0ZXh0dXJlOyB0aGlzIHN0YXRlIGNhbm5vdCBiZSBjaGFuZ2VkIGV2ZXIuXG4gIC8vIElmIHlvdSBoYXZlIGEgdGV4dHVyZSB0aGF0IHdhcyBmaXJzdCBib3VuZCBhcyBhIEdMX1RFWFRVUkVfMkQsXG4gIC8vIHlvdSBtdXN0IGFsd2F5cyBiaW5kIGl0IGFzIGEgR0xfVEVYVFVSRV8yRDtcbiAgLy8gYXR0ZW1wdGluZyB0byBiaW5kIGl0IGFzIEdMX1RFWFRVUkVfMUQgd2lsbCBnaXZlIHJpc2UgdG8gYW4gZXJyb3JcbiAgLy8gKHdoaWxlIHJ1bi10aW1lKS5cbiAgY29uc3RydWN0b3IoZ2wsIG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCA9IHVpZCgndGV4dHVyZScpLFxuICAgICAgaGFuZGxlLFxuICAgICAgdGFyZ2V0XG4gICAgICAvLyAsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCB3cmFwUywgd3JhcFRcbiAgICB9ID0gb3B0cztcblxuICAgIHN1cGVyKGdsLCB7aWQsIGhhbmRsZX0pO1xuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5oYXNGbG9hdFRleHR1cmUgPSBnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgdGhpcy50ZXh0dXJlVW5pdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgVGV4dHVyZSgke3RoaXMuaWR9LCR7dGhpcy53aWR0aH14JHt0aGlzLmhlaWdodH0pYDtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGJyYWNlLXN0eWxlICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMub3B0cy53aWR0aDsgfVxuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5vcHRzLndpZHRoOyB9XG4gIGdldCBmb3JtYXQoKSB7IHJldHVybiB0aGlzLm9wdHMuZm9ybWF0OyB9XG4gIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5vcHRzLnR5cGU7IH1cbiAgZ2V0IGRhdGFGb3JtYXQoKSB7IHJldHVybiB0aGlzLm9wdHMuZGF0YUZvcm1hdDsgfVxuICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gdGhpcy5vcHRzLmJvcmRlcjsgfVxuICBnZXQgbWlwbWFwcygpIHsgcmV0dXJuIHRoaXMub3B0cy5taXBtYXBzOyB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhID0gbnVsbCxcbiAgICAgIGZvcm1hdCA9IEdMLlJHQkEsXG4gICAgICB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICAgIGJvcmRlciA9IDAsXG4gICAgICBtaXBtYXBzID0gZmFsc2UsXG4gICAgICByZWNyZWF0ZSA9IGZhbHNlLFxuICAgICAgcGFyYW1ldGVycyA9IHt9LFxuICAgICAgcGl4ZWxTdG9yZSA9IHt9XG4gICAgfSA9IG9wdHM7XG5cbiAgICBsZXQge3dpZHRoLCBoZWlnaHQsIGRhdGFGb3JtYXR9ID0gb3B0cztcblxuICAgIC8vIERlZHVjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgKHt3aWR0aCwgaGVpZ2h0LCBkYXRhRm9ybWF0fSA9IHRoaXMuX2RlZHVjZVBhcmFtZXRlcnMoe1xuICAgICAgZm9ybWF0LCB0eXBlLCBkYXRhRm9ybWF0LCBjb21wcmVzc2VkOiBmYWxzZSwgZGF0YSwgd2lkdGgsIGhlaWdodFxuICAgIH0pKTtcblxuICAgIC8vIFRlbXBvcmFyaWx5IGFwcGx5IGFueSBwaXhlbCBzdG9yZSBzZXR0aW5ncyBhbmQgYnVpbGQgdGV4dHVyZXNcbiAgICB3aXRoUGFyYW1ldGVycyh0aGlzLmdsLCBwaXhlbFN0b3JlLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldEltYWdlRGF0YSh7ZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhRm9ybWF0LCBib3JkZXIsIG1pcG1hcHN9KTtcblxuICAgICAgaWYgKG1pcG1hcHMpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2V0IHRleHR1cmUgc2FtcGxlciBwYXJhbWV0ZXJzXG4gICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuXG4gICAgLy8gU3RvcmUgb3B0cyBmb3IgYWNjZXNzb3JzXG4gICAgdGhpcy5vcHRzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5vcHRzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm9wdHMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMub3B0cy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9wdHMuZGF0YUZvcm1hdCA9IGRhdGFGb3JtYXQ7XG4gICAgdGhpcy5vcHRzLmJvcmRlciA9IGJvcmRlcjtcblxuICAgIC8vIFRPRE8gLSBTdG9yZSBkYXRhIHRvIGVuYWJsZSBhdXRvIHJlY3JlYXRlIG9uIGNvbnRleHQgbG9zc1xuICAgIGlmIChyZWNyZWF0ZSkge1xuICAgICAgdGhpcy5vcHRzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgdG8gcmVnZW5lcmF0ZSBtaXBtYXBzIGFmdGVyIG1vZGlmeWluZyB0ZXh0dXJlKHMpXG4gIGdlbmVyYXRlTWlwbWFwKHBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgIHdpdGhQYXJhbWV0ZXJzKHRoaXMuZ2wsIHBhcmFtcywgKCkgPT4ge1xuICAgICAgdGhpcy5nbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLnRhcmdldCk7XG4gICAgfSk7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVkZWZpbmVzIGFuIGFyZWEgb2YgYW4gZXhpc3RpbmcgdGV4dHVyZVxuICAgKiBOb3RlOiBkb2VzIG5vdCBhbGxvY2F0ZSBzdG9yYWdlXG4gICAqL1xuICBzdWJJbWFnZSh7XG4gICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgcGl4ZWxzID0gbnVsbCxcbiAgICBkYXRhID0gbnVsbCxcbiAgICB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGV2ZWwgPSAwLFxuICAgIGZvcm1hdCA9IEdMLlJHQkEsXG4gICAgdHlwZSxcbiAgICBkYXRhRm9ybWF0LFxuICAgIGNvbXByZXNzZWQgPSBmYWxzZSxcbiAgICBvZmZzZXQgPSAwLFxuICAgIGJvcmRlciA9IDBcbiAgfSkge1xuICAgICh7dHlwZSwgZGF0YUZvcm1hdCwgY29tcHJlc3NlZCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzLl9kZWR1Y2VQYXJhbWV0ZXJzKHtcbiAgICAgIGZvcm1hdCwgdHlwZSwgZGF0YUZvcm1hdCwgY29tcHJlc3NlZCwgZGF0YSwgd2lkdGgsIGhlaWdodH0pKTtcblxuICAgIC8vIFN1cHBvcnQgbmRhcnJheXNcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEpIHtcbiAgICAgIGNvbnN0IG5kYXJyYXkgPSBkYXRhO1xuICAgICAgZGF0YSA9IG5kYXJyYXkuZGF0YTtcbiAgICAgIHdpZHRoID0gbmRhcnJheS5zaGFwZVswXTtcbiAgICAgIGhlaWdodCA9IG5kYXJyYXkuc2hhcGVbMV07XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBidWZmZXJzXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIGRhdGEgPSBkYXRhLmhhbmRsZTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMudGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG5cbiAgICAvLyBUT0RPIC0geCx5IHBhcmFtZXRlcnNcbiAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCh0YXJnZXQsXG4gICAgICAgIGxldmVsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5nbC50ZXhTdWJJbWFnZTJEKHRhcmdldCxcbiAgICAgICAgbGV2ZWwsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBkYXRhRm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgdGhpcy5nbC50ZXhTdWJJbWFnZTJEKHRhcmdldCxcbiAgICAgICAgbGV2ZWwsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBkYXRhRm9ybWF0LCB0eXBlLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xuICAgICAgLy8gV2ViR0wyIGFsbG93cyB1cyB0byBjcmVhdGUgdGV4dHVyZSBkaXJlY3RseSBmcm9tIGEgV2ViR0wgYnVmZmVyXG4gICAgICBhc3NlcnRXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuICAgICAgLy8gVGhpcyB0ZXhJbWFnZTJEIHNpZ25hdHVyZSB1c2VzIGN1cnJlbnRseSBib3VuZCBHTF9QSVhFTF9VTlBBQ0tfQlVGRkVSXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIoR0wuUElYRUxfVU5QQUNLX0JVRkZFUiwgZGF0YSk7XG4gICAgICB0aGlzLmdsLnRleFN1YkltYWdlMkQodGFyZ2V0LFxuICAgICAgICBsZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcihHTC5HTF9QSVhFTF9VTlBBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXNzdW1lIGRhdGEgaXMgYSBicm93c2VyIHN1cHBvcnRlZCBvYmplY3QgKEltYWdlRGF0YSwgQ2FudmFzLCAuLi4pXG4gICAgICB0aGlzLmdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeCwgeSwgZm9ybWF0LCB0eXBlLCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMudGFyZ2V0LCBudWxsKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSB0d28tZGltZW5zaW9uYWwgdGV4dHVyZSBpbWFnZSBvciBjdWJlLW1hcCB0ZXh0dXJlIGltYWdlIHdpdGhcbiAgICogcGl4ZWxzIGZyb20gdGhlIGN1cnJlbnQgZnJhbWVidWZmZXIgKHJhdGhlciB0aGFuIGZyb20gY2xpZW50IG1lbW9yeSkuXG4gICAqIChnbC5jb3B5VGV4SW1hZ2UyRCB3cmFwcGVyKVxuICAgKlxuICAgKiBOb3RlIHRoYXQgYmluZGluZyBhIHRleHR1cmUgaW50byBhIEZyYW1lYnVmZmVyJ3MgY29sb3IgYnVmZmVyIGFuZFxuICAgKiByZW5kZXJpbmcgY2FuIGJlIGZhc3Rlci5cbiAgICovXG4gIGNvcHlGcmFtZWJ1ZmZlcih7XG4gICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgZnJhbWVidWZmZXIsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGV2ZWwgPSAwLFxuICAgIGludGVybmFsRm9ybWF0ID0gR0wuUkdCQSxcbiAgICBib3JkZXIgPSAwXG4gIH0pIHtcbiAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgIGZyYW1lYnVmZmVyLmJpbmQoKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXRcbiAgICB0aGlzLmJpbmQoKTtcbiAgICB0aGlzLmdsLmNvcHlUZXhJbWFnZTJEKFxuICAgICAgdGhpcy50YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm9yZGVyKTtcbiAgICB0aGlzLnVuYmluZCgpO1xuXG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBmcmFtZWJ1ZmZlci51bmJpbmQoKTtcbiAgICB9XG4gIH1cblxuICBnZXRBY3RpdmVVbml0KCkge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcihHTC5BQ1RJVkVfVEVYVFVSRSkgLSBHTC5URVhUVVJFMDtcbiAgfVxuXG4gIC8vIHRhcmdldCBjYW5ub3QgYmUgbW9kaWZpZWQgYnkgYmluZDpcbiAgLy8gdGV4dHVyZXMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3aGVuIHlvdSBmaXJzdCBiaW5kIHRoZW0gdG8gYSB0YXJnZXQsXG4gIC8vIHRoZXkgZ2V0IHNwZWNpYWwgaW5mb3JtYXRpb24uIFdoZW4geW91IGZpcnN0IGJpbmQgYSB0ZXh0dXJlIGFzIGFcbiAgLy8gR0xfVEVYVFVSRV8yRCwgeW91IGFyZSBhY3R1YWxseSBzZXR0aW5nIHNwZWNpYWwgc3RhdGUgaW4gdGhlIHRleHR1cmUuXG4gIC8vIFlvdSBhcmUgc2F5aW5nIHRoYXQgdGhpcyB0ZXh0dXJlIGlzIGEgMkQgdGV4dHVyZS5cbiAgLy8gQW5kIGl0IHdpbGwgYWx3YXlzIGJlIGEgMkQgdGV4dHVyZTsgdGhpcyBzdGF0ZSBjYW5ub3QgYmUgY2hhbmdlZCBldmVyLlxuICAvLyBJZiB5b3UgaGF2ZSBhIHRleHR1cmUgdGhhdCB3YXMgZmlyc3QgYm91bmQgYXMgYSBHTF9URVhUVVJFXzJELFxuICAvLyB5b3UgbXVzdCBhbHdheXMgYmluZCBpdCBhcyBhIEdMX1RFWFRVUkVfMkQ7XG4gIC8vIGF0dGVtcHRpbmcgdG8gYmluZCBpdCBhcyBHTF9URVhUVVJFXzFEIHdpbGwgZ2l2ZSByaXNlIHRvIGFuIGVycm9yXG4gIC8vICh3aGlsZSBydW4tdGltZSkuXG5cbiAgYmluZCh0ZXh0dXJlVW5pdCA9IHRoaXMudGV4dHVyZVVuaXQpIHtcbiAgICBpZiAodGV4dHVyZVVuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlLmJpbmQ6IG11c3Qgc3BlY2lmeSB0ZXh0dXJlIHVuaXQnKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0O1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZShHTC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMudGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG4gICAgcmV0dXJuIHRleHR1cmVVbml0O1xuICB9XG5cbiAgdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmVVbml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZS51bmJpbmQ6IHRleHR1cmUgdW5pdCBub3Qgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZShHTC5URVhUVVJFMCArIHRoaXMudGV4dHVyZVVuaXQpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVVbml0O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLypcbiAgICogQWxsb2NhdGVzIHN0b3JhZ2VcbiAgICogQHBhcmFtIHsqfSBwaXhlbHMgLVxuICAgKiAgbnVsbCAtIGNyZWF0ZSBlbXB0eSB0ZXh0dXJlIG9mIHNwZWNpZmllZCBmb3JtYXRcbiAgICogIFR5cGVkIGFycmF5IC0gaW5pdCBmcm9tIGltYWdlIGRhdGEgaW4gdHlwZWQgYXJyYXlcbiAgICogIEJ1ZmZlcnxXZWJHTEJ1ZmZlciAtIChXRUJHTDIpIGluaXQgZnJvbSBpbWFnZSBkYXRhIGluIFdlYkdMQnVmZmVyXG4gICAqICBIVE1MSW1hZ2VFbGVtZW50fEltYWdlIC0gSW5pdHMgd2l0aCBjb250ZW50IG9mIGltYWdlLiBBdXRvIHdpZHRoL2hlaWdodFxuICAgKiAgSFRNTENhbnZhc0VsZW1lbnQgLSBJbml0cyB3aXRoIGNvbnRlbnRzIG9mIGNhbnZhcy4gQXV0byB3aWR0aC9oZWlnaHRcbiAgICogIEhUTUxWaWRlb0VsZW1lbnQgLSBDcmVhdGVzIHZpZGVvIHRleHR1cmUuIEF1dG8gd2lkdGgvaGVpZ2h0XG4gICAqXG4gICAqIEBwYXJhbSB7R0xpbnR9IHdpZHRoIC1cbiAgICogQHBhcmFtIHtHTGludH0gaGVpZ2h0IC1cbiAgICogQHBhcmFtIHtHTGludH0gbWlwTWFwTGV2ZWwgLVxuICAgKiBAcGFyYW0ge0dMZW51bX0gZm9ybWF0IC0gZm9ybWF0IG9mIGltYWdlIGRhdGEuXG4gICAqIEBwYXJhbSB7R0xlbnVtfSB0eXBlXG4gICAqICAtIGZvcm1hdCBvZiBhcnJheSAoYXV0b2RldGVjdCBmcm9tIHR5cGUpIG9yXG4gICAqICAtIChXRUJHTDIpIGZvcm1hdCBvZiBidWZmZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIChXRUJHTDIpIG9mZnNldCBmcm9tIHN0YXJ0IG9mIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMaW50fSBib3JkZXIgLSBtdXN0IGJlIDAuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuLCBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuICBzZXRJbWFnZURhdGEoe1xuICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxuICAgIHBpeGVscyA9IG51bGwsXG4gICAgZGF0YSA9IG51bGwsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxldmVsID0gMCxcbiAgICBmb3JtYXQgPSBHTC5SR0JBLFxuICAgIHR5cGUsXG4gICAgZGF0YUZvcm1hdCxcbiAgICBvZmZzZXQgPSAwLFxuICAgIGJvcmRlciA9IDAsXG4gICAgY29tcHJlc3NlZCA9IGZhbHNlXG4gIH0pIHtcbiAgICAoe3R5cGUsIGRhdGFGb3JtYXQsIGNvbXByZXNzZWQsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcy5fZGVkdWNlUGFyYW1ldGVycyh7XG4gICAgICBmb3JtYXQsIHR5cGUsIGRhdGFGb3JtYXQsIGNvbXByZXNzZWQsIGRhdGEsIHdpZHRoLCBoZWlnaHR9KSk7XG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBnbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy5oYW5kbGUpO1xuXG4gICAgbGV0IGRhdGFUeXBlID0gbnVsbDtcbiAgICAoe2RhdGEsIGRhdGFUeXBlfSA9IHRoaXMuX2dldERhdGFUeXBlKHtkYXRhLCBjb21wcmVzc2VkfSkpO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlICdjb21wcmVzc2VkJzpcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCBsZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHlwZWQtYXJyYXknOlxuICAgICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGJvcmRlciwgZGF0YUZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdidWZmZXInOlxuICAgICAgLy8gV2ViR0wyIGVuYWJsZXMgY3JlYXRpbmcgdGV4dHVyZXMgZGlyZWN0bHkgZnJvbSBhIFdlYkdMIGJ1ZmZlclxuICAgICAgYXNzZXJ0KGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgJ1JlcXVpcmVzIFdlYkdMMicpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihHTC5QSVhFTF9VTlBBQ0tfQlVGRkVSLCBkYXRhLmhhbmRsZSB8fCBkYXRhKTtcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgb2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jyb3dzZXItb2JlamN0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiwgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cblxuICBfZ2V0RGF0YVR5cGUoe2RhdGEsIGNvbXByZXNzZWQgPSBmYWxzZX0pIHtcbiAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgcmV0dXJuIHtkYXRhLCBkYXRhVHlwZTogJ2NvbXByZXNzZWQnfTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09IG51bGwgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4ge2RhdGEsIGRhdGFUeXBlOiAndHlwZWQtYXJyYXknfTtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiB7ZGF0YTogZGF0YS5oYW5kbGUsIGRhdGFUeXBlOiAnYnVmZmVyJ307XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcbiAgICAgIHJldHVybiB7ZGF0YSwgZGF0YVR5cGU6ICdidWZmZXInfTtcbiAgICB9XG4gICAgLy8gQXNzdW1lIGRhdGEgaXMgYSBicm93c2VyIHN1cHBvcnRlZCBvYmplY3QgKEltYWdlRGF0YSwgQ2FudmFzLCAuLi4pXG4gICAgcmV0dXJuIHtkYXRhLCBkYXRhVHlwZTogJ2Jyb3dzZXItb2JqZWN0J307XG4gIH1cblxuICAvLyBJbWFnZSAzRCBjb3BpZXMgZnJvbSBUeXBlZCBBcnJheSBvciBXZWJHTEJ1ZmZlclxuICBzZXRJbWFnZTNEKHtcbiAgICBsZXZlbCA9IDAsXG4gICAgaW50ZXJuYWxmb3JtYXQgPSBHTC5SR0JBLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBkZXB0aCA9IDEsXG4gICAgYm9yZGVyID0gMCxcbiAgICBmb3JtYXQsXG4gICAgdHlwZSA9IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBwaXhlbHNcbiAgfSkge1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGl4ZWxzKSkge1xuICAgICAgdGhpcy5nbC50ZXhJbWFnZTNEKFxuICAgICAgICB0aGlzLnRhcmdldCwgbGV2ZWwsIGludGVybmFsZm9ybWF0LFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgYm9yZGVyLCBmb3JtYXQsIHR5cGUsIHBpeGVscyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIoR0wuUElYRUxfVU5QQUNLX0JVRkZFUiwgcGl4ZWxzLmhhbmRsZSk7XG4gICAgICB0aGlzLmdsLnRleEltYWdlM0QoXG4gICAgICAgIHRoaXMudGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEhFTFBFUiBNRVRIT0RTXG5cbiAgX2RlZHVjZVBhcmFtZXRlcnMob3B0cykge1xuICAgIGNvbnN0IHtmb3JtYXQsIGRhdGF9ID0gb3B0cztcbiAgICBsZXQge3dpZHRoLCBoZWlnaHQsIGRhdGFGb3JtYXQsIHR5cGUsIGNvbXByZXNzZWR9ID0gb3B0cztcblxuICAgIC8vIERlZHVjZSBmb3JtYXQgYW5kIHR5cGUgZnJvbSBmb3JtYXRcbiAgICBjb25zdCB0ZXh0dXJlRm9ybWF0ID0gVEVYVFVSRV9GT1JNQVRTW2Zvcm1hdF07XG4gICAgZGF0YUZvcm1hdCA9IGRhdGFGb3JtYXQgfHwgKHRleHR1cmVGb3JtYXQgJiYgdGV4dHVyZUZvcm1hdC5kYXRhRm9ybWF0KTtcbiAgICB0eXBlID0gdHlwZSB8fCAodGV4dHVyZUZvcm1hdCAmJiB0ZXh0dXJlRm9ybWF0LnR5cGVzWzBdKTtcblxuICAgIC8vIERlZHVjZSBjb21wcmVzc2lvbiBmcm9tIGZvcm1hdFxuICAgIGNvbXByZXNzZWQgPSBjb21wcmVzc2VkIHx8ICh0ZXh0dXJlRm9ybWF0ICYmIHRleHR1cmVGb3JtYXQuY29tcHJlc3NlZCk7XG5cbiAgICAoe3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fZGVkdWNlSW1hZ2VTaXplKHtkYXRhLCB3aWR0aCwgaGVpZ2h0fSkpO1xuXG4gICAgcmV0dXJuIHtkYXRhRm9ybWF0LCB0eXBlLCBjb21wcmVzc2VkLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGRhdGF9O1xuICB9XG5cbiAgLyogZ2xvYmFsIEltYWdlRGF0YSwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQsIEhUTUxWaWRlb0VsZW1lbnQgKi9cbiAgX2RlZHVjZUltYWdlU2l6ZSh7ZGF0YSwgd2lkdGgsIGhlaWdodH0pIHtcbiAgICBsZXQgc2l6ZTtcblxuICAgIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICBzaXplID0ge3dpZHRoOiBkYXRhLndpZHRoLCBoZWlnaHQ6IGRhdGEuaGVpZ2h0fTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICBzaXplID0ge3dpZHRoOiBkYXRhLm5hdHVyYWxXaWR0aCwgaGVpZ2h0OiBkYXRhLm5hdHVyYWxIZWlnaHR9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgc2l6ZSA9IHt3aWR0aDogZGF0YS53aWR0aCwgaGVpZ2h0OiBkYXRhLmhlaWdodH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgc2l6ZSA9IHt3aWR0aDogZGF0YS52aWRlb1dpZHRoLCBoZWlnaHQ6IGRhdGEudmlkZW9IZWlnaHR9O1xuICAgIH1cbiAgICBlbHNlIGlmICghZGF0YSkge1xuICAgICAgc2l6ZSA9IHt3aWR0aDogd2lkdGggPj0gMCA/IHdpZHRoIDogMSwgaGVpZ2h0OiBoZWlnaHQgPj0gMCA/IGhlaWdodCA6IDF9O1xuICAgIH1cblxuICAgIGFzc2VydChzaXplLCAnQ291bGQgbm90IGRlZHVjZWQgdGV4dHVyZSBzaXplJyk7XG4gICAgYXNzZXJ0KHdpZHRoID09PSB1bmRlZmluZWQgfHwgc2l6ZS53aWR0aCA9PT0gd2lkdGgsICdEZWR1Y2VkIHRleHR1cmUgd2lkdGggZG9lcyBub3QgbWF0Y2ggc3VwcGxpZWQgd2lkdGgnKTtcbiAgICBhc3NlcnQoaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgc2l6ZS5oZWlnaHQgPT09IGhlaWdodCwgJ0RlZHVjZWQgdGV4dHVyZSBoZWlnaHQgZG9lcyBub3QgbWF0Y2ggc3VwcGxpZWQgaGVpZ2h0Jyk7XG5cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8vIFJFU09VUkNFIE1FVEhPRFNcblxuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgfVxuXG4gIF9kZWxldGVIYW5kbGUoKSB7XG4gICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuaGFuZGxlKTtcbiAgfVxuXG4gIF9nZXRQYXJhbWV0ZXIocG5hbWUpIHtcbiAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgY2FzZSBHTC5URVhUVVJFX1dJRFRIOlxuICAgICAgcmV0dXJuIHRoaXMub3B0cy53aWR0aDtcbiAgICBjYXNlIEdMLlRFWFRVUkVfSEVJR0hUOlxuICAgICAgcmV0dXJuIHRoaXMub3B0cy5oZWlnaHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nbC5nZXRUZXhQYXJhbWV0ZXIodGhpcy50YXJnZXQsIHBuYW1lKTtcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIG51bGwpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIF9zZXRQYXJhbWV0ZXIocG5hbWUsIHBhcmFtKSB7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy5oYW5kbGUpO1xuXG4gICAgLy8gQXBwYXJlbnRseSB0aGVyZSBhcmUgc29tZSBpbnRlZ2VyL2Zsb2F0IGNvbnZlcnNpb24gcnVsZXMgdGhhdCBtYWRlXG4gICAgLy8gdGhlIFdlYkdMIGNvbW1pdHRlIGV4cG9zZSB0d28gcGFyYW1ldGVyIHNldHRpbmcgZnVuY3Rpb25zIGluIEphdmFTY3JpcHQuXG4gICAgLy8gRm9yIG5vdywgcGljayB0aGUgZmxvYXQgdmVyc2lvbiBmb3IgcGFyYW1ldGVycyBzcGVjaWZpZWQgYXMgR0xmbG9hdC5cbiAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgY2FzZSBHTC5URVhUVVJFX01JTl9MT0Q6XG4gICAgY2FzZSBHTC5URVhUVVJFX01BWF9MT0Q6XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmYodGhpcy5oYW5kbGUsIHBuYW1lLCBwYXJhbSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgR0wuVEVYVFVSRV9XSURUSDpcbiAgICBjYXNlIEdMLlRFWFRVUkVfSEVJR0hUOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGVtdWxhdGVkIHBhcmFtZXRlcicpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRhcmdldCwgcG5hbWUsIHBhcmFtKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXX0=

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(37);

var ReactCurrentOwner = __webpack_require__(38);

var warning = __webpack_require__(11);
var canDefineProperty = __webpack_require__(39);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(120);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = createMat4;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_matrix__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix management

// However since it is used by mapbox etc, it should already be present
// in most target application bundles.



var IDENTITY = createMat4();

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply(vpm, vpm, this.projectionMatrix);
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // matrix for conversion from location to screen coordinates
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].scale(m, m, [this.width / 2, -this.height / 2, 1]);
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].translate(m, m, [1, -1, 0]);
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply(m, m, this.viewProjectionMatrix);

    var mInverse = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].equals(viewport.projectionMatrix, this.projectionMatrix) && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      __WEBPACK_IMPORTED_MODULE_1_assert___default()(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat2 = this.projectFlat([x0, y0]),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = this.transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? false : _ref3$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["vec2"].lerp([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // TODO - replace with math.gl

  }, {
    key: 'transformVector',
    value: function transformVector(matrix, vector) {
      var result = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["vec4"].transformMat4([0, 0, 0, 0], vector, matrix);
      var scale = 1 / result[3];
      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["vec4"].multiply(result, result, [scale, scale, scale, scale]);
      return result;
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      },

      // Subclass can add additional params
      // TODO - Fragile: better to make base Viewport class aware of all params
      this._getParams());

      return matrices;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return {
        pixelsPerMeter: [1, 1, 1],
        metersPerPixel: [1, 1, 1],
        pixelsPerDegree: [1, 1, 1],
        degreesPerPixel: [1, 1, 1]
      };
    }

    // INTERNAL METHODS

    // Can be subclassed to add additional fields to `getMatrices`

  }, {
    key: '_getParams',
    value: function _getParams() {
      return {};
    }
  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }]);

  return Viewport;
}();

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


/* harmony default export */ __webpack_exports__["a"] = (Viewport);
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzIl0sIm5hbWVzIjpbIm1hdDQiLCJ2ZWM0IiwidmVjMiIsImFzc2VydCIsIklERU5USVRZIiwiY3JlYXRlTWF0NCIsIkVSUl9BUkdVTUVOVCIsIlZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInNjYWxlIiwidnBtIiwibXVsdGlwbHkiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsIm0iLCJ0cmFuc2xhdGUiLCJtSW52ZXJzZSIsImludmVydCIsIkVycm9yIiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4IiwicGl4ZWxVbnByb2plY3Rpb25NYXRyaXgiLCJlcXVhbHMiLCJiaW5kIiwicHJvamVjdCIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsImdldE1hdHJpY2VzIiwidmlld3BvcnQiLCJ4eXoiLCJ0b3BMZWZ0IiwieDAiLCJ5MCIsInowIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJYIiwiWSIsInYiLCJ0cmFuc2Zvcm1WZWN0b3IiLCJ4IiwieSIsInkyIiwibGVuZ3RoIiwidGFyZ2V0WiIsImNvb3JkMCIsImNvb3JkMSIsInoxIiwidCIsImxlcnAiLCJ2VW5wcm9qZWN0ZWQiLCJtYXRyaXgiLCJ2ZWN0b3IiLCJyZXN1bHQiLCJ0cmFuc2Zvcm1NYXQ0IiwiX3Byb2plY3RGbGF0IiwiYXJndW1lbnRzIiwiX3VucHJvamVjdEZsYXQiLCJtb2RlbE1hdHJpeCIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJtYXRyaWNlcyIsIk9iamVjdCIsImFzc2lnbiIsIl9nZXRQYXJhbXMiLCJwaXhlbHNQZXJNZXRlciIsIm1ldGVyc1BlclBpeGVsIiwicGl4ZWxzUGVyRGVncmVlIiwiZGVncmVlc1BlclBpeGVsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFNBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFQO0FBQ0QiLCJmaWxlIjoidmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggbWFuYWdlbWVudFxuXG4vLyBIb3dldmVyIHNpbmNlIGl0IGlzIHVzZWQgYnkgbWFwYm94IGV0YywgaXQgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudFxuLy8gaW4gbW9zdCB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlcy5cbmltcG9ydCB7bWF0NCwgdmVjNCwgdmVjMn0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICAvLyBEZXNjXG4gICAgdmlld01hdHJpeCA9IElERU5USVRZLFxuICAgIHByb2plY3Rpb25NYXRyaXggPSBJREVOVElUWVxuICB9ID0ge30pIHtcbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcbiAgICB0aGlzLnNjYWxlID0gMTtcblxuICAgIHRoaXMudmlld01hdHJpeCA9IHZpZXdNYXRyaXg7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCBpbiBcInJldmVyc2VcIiBvcmRlclxuICAgIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcblxuICAgIC8vIENhbGN1bGF0ZSBtYXRyaWNlcyBhbmQgc2NhbGVzIG5lZWRlZCBmb3IgcHJvamVjdGlvblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBtYXRyaWNlcyB0aGF0IGNvbnZlcnRzIHByZXByb2plY3RlZCBsbmdMYXRzIHRvIHNjcmVlbiBwaXhlbHNcbiAgICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKiBOb3RlOiBDdXJyZW50bHkgcmV0dXJucyBib3R0b20tbGVmdCBjb29yZGluYXRlcyFcbiAgICAgKiBOb3RlOiBTdGFydHMgd2l0aCB0aGUgR0wgcHJvamVjdGlvbiBtYXRyaXggYW5kIGFkZHMgc3RlcHMgdG8gdGhlXG4gICAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogV2ViR0wgY29udHJvbHMgY2xpcCBzcGFjZSB0byBzY3JlZW4gcHJvamVjdGlvbiB3aXRoIGdsLnZpZXdwb3J0XG4gICAgICogICAgICAgYW5kIGRvZXMgbm90IG5lZWQgdGhpcyBzdGVwLlxuICAgICAqL1xuICAgIGNvbnN0IG0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgICAvLyBtYXRyaXggZm9yIGNvbnZlcnNpb24gZnJvbSBsb2NhdGlvbiB0byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFsxLCAtMSwgMF0pO1xuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDQuaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG5cbiAgICB0aGlzLmVxdWFscyA9IHRoaXMuZXF1YWxzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0ID0gdGhpcy5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3QgPSB0aGlzLnVucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdEZsYXQgPSB0aGlzLnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3RGbGF0ID0gdGhpcy51bnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRNYXRyaWNlcyA9IHRoaXMuZ2V0TWF0cmljZXMuYmluZCh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvLyBUd28gdmlld3BvcnRzIGFyZSBlcXVhbCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBpZGVudGljYWwsIGFuZCBpZlxuICAvLyB0aGVpciB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpY2VzIGFyZSAoYXBwcm94aW1hdGVseSkgZXF1YWwuXG4gIGVxdWFscyh2aWV3cG9ydCkge1xuICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCBbeDAsIHkwLCB6MCA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeDApICYmIE51bWJlci5pc0Zpbml0ZSh5MCkgJiYgTnVtYmVyLmlzRmluaXRlKHowKSwgRVJSX0FSR1VNRU5UKTtcblxuICAgIGNvbnN0IFtYLCBZXSA9IHRoaXMucHJvamVjdEZsYXQoW3gwLCB5MF0pO1xuICAgIGNvbnN0IHYgPSB0aGlzLnRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW1gsIFksIHowLCAxXSk7XG5cbiAgICBjb25zdCBbeCwgeV0gPSB2O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSBmYWxzZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4LCB5LCB0YXJnZXRaID0gMF0gPSB4eXo7XG5cbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuXG4gICAgLy8gc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgY29ycmVjdCBwcm9qZWN0ZWQgeiB2YWx1ZSBmb3IgdGhlIHBvaW50LFxuICAgIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdCBsaW5lIHdpdGggej0wXG4gICAgY29uc3QgY29vcmQwID0gdGhpcy50cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAwLCAxXSk7XG4gICAgY29uc3QgY29vcmQxID0gdGhpcy50cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAxLCAxXSk7XG5cbiAgICBjb25zdCB6MCA9IGNvb3JkMFsyXTtcbiAgICBjb25zdCB6MSA9IGNvb3JkMVsyXTtcblxuICAgIGNvbnN0IHQgPSB6MCA9PT0gejEgPyAwIDogKHRhcmdldFogLSB6MCkgLyAoejEgLSB6MCk7XG4gICAgY29uc3QgdiA9IHZlYzIubGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xuXG4gICAgY29uc3QgdlVucHJvamVjdGVkID0gdGhpcy51bnByb2plY3RGbGF0KHYpO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gdlVucHJvamVjdGVkIDogW3ZVbnByb2plY3RlZFswXSwgdlVucHJvamVjdGVkWzFdLCAwXTtcbiAgfVxuXG4gIC8vIFRPRE8gLSByZXBsYWNlIHdpdGggbWF0aC5nbFxuICB0cmFuc2Zvcm1WZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2ZWM0LnRyYW5zZm9ybU1hdDQoWzAsIDAsIDAsIDBdLCB2ZWN0b3IsIG1hdHJpeCk7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gcmVzdWx0WzNdO1xuICAgIHZlYzQubXVsdGlwbHkocmVzdWx0LCByZXN1bHQsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIGdldE1hdHJpY2VzKHttb2RlbE1hdHJpeCA9IG51bGx9ID0ge30pIHtcbiAgICBsZXQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0Lm11bHRpcGx5KFtdLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXggPSBtYXQ0Lm11bHRpcGx5KFtdLCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmludmVydChbXSwgcGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRyaWNlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4OiB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld01hdHJpeDogdGhpcy52aWV3TWF0cml4LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICAvLyBwcm9qZWN0L3VucHJvamVjdCBiZXR3ZWVuIHBpeGVscyBhbmQgd29ybGRcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZVxuICAgIH0sXG5cbiAgICAgIC8vIFN1YmNsYXNzIGNhbiBhZGQgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgIC8vIFRPRE8gLSBGcmFnaWxlOiBiZXR0ZXIgdG8gbWFrZSBiYXNlIFZpZXdwb3J0IGNsYXNzIGF3YXJlIG9mIGFsbCBwYXJhbXNcbiAgICAgIHRoaXMuX2dldFBhcmFtcygpXG4gICAgKTtcblxuICAgIHJldHVybiBtYXRyaWNlcztcbiAgfVxuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwaXhlbHNQZXJNZXRlcjogWzEsIDEsIDFdLFxuICAgICAgbWV0ZXJzUGVyUGl4ZWw6IFsxLCAxLCAxXSxcbiAgICAgIHBpeGVsc1BlckRlZ3JlZTogWzEsIDEsIDFdLFxuICAgICAgZGVncmVlc1BlclBpeGVsOiBbMSwgMSwgMV1cbiAgICB9O1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIENhbiBiZSBzdWJjbGFzc2VkIHRvIGFkZCBhZGRpdGlvbmFsIGZpZWxkcyB0byBgZ2V0TWF0cmljZXNgXG4gIF9nZXRQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgX3Byb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIF91bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxufVxuXG4vLyBIZWxwZXIsIGF2b2lkcyBsb3ctcHJlY2lzaW9uIDMyIGJpdCBtYXRyaWNlcyBmcm9tIGdsLW1hdHJpeCBtYXQ0LmNyZWF0ZSgpXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cbiJdfQ==

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _common = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

var MathArray = function (_extendableBuiltin2) {
  _inherits(MathArray, _extendableBuiltin2);

  function MathArray() {
    _classCallCheck(this, MathArray);

    return _possibleConstructorReturn(this, (MathArray.__proto__ || Object.getPrototypeOf(MathArray)).apply(this, arguments));
  }

  _createClass(MathArray, [{
    key: 'clone',
    value: function clone() {
      var Subclass = this.constructor;
      var clone = new Subclass().copy(this);
      clone.check();
      return clone;
    }
  }, {
    key: 'copy',
    value: function copy(array) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i];
      }
      this.check();
      return this;
    }
  }, {
    key: 'set',
    value: function set() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = args[i] || 0;
      }
      this.check();
      return this;
    }
  }, {
    key: 'fromArray',
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }
      this.check();
      return this;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var string = '';
      for (var i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i]);
      }
      return this.constructor.name + '(' + string + ')';
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        array[offset + i] = this[i];
      }
      return array;
    }
  }, {
    key: 'toFloat32Array',
    value: function toFloat32Array() {
      return new Float32Array(this);
    }
  }, {
    key: 'equals',
    value: function equals(array) {
      if (this.length !== array.length) {
        return false;
      }
      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (!(0, _common.equals)(this[i], array[i])) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(array) {
      if (this.length !== array.length) {
        return false;
      }
      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'validate',
    value: function validate() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

      var valid = array.length === this.ELEMENTS;
      for (var i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(array[i]);
      }
      return valid;
    }
  }, {
    key: 'check',
    value: function check() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

      if (_common.glMatrix.debug && !this.validate(array)) {
        throw new Error('Invalid ' + this.constructor.name);
      }
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      var length = this.len();
      if (length !== 0) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }
      this.check();
      return this;
    }
  }]);

  return MathArray;
}(_extendableBuiltin(Array));

exports.default = MathArray;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy9tYXRoLWFycmF5LmpzIl0sIm5hbWVzIjpbIk1hdGhBcnJheSIsIlN1YmNsYXNzIiwiY29uc3RydWN0b3IiLCJjbG9uZSIsImNvcHkiLCJjaGVjayIsImFycmF5IiwiaSIsIkVMRU1FTlRTIiwiYXJncyIsIm9mZnNldCIsInN0cmluZyIsIm5hbWUiLCJGbG9hdDMyQXJyYXkiLCJsZW5ndGgiLCJ2YWxpZCIsIk51bWJlciIsImlzRmluaXRlIiwiZGVidWciLCJ2YWxpZGF0ZSIsIkVycm9yIiwibGVuIiwiQXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkEsUzs7Ozs7Ozs7Ozs7NEJBRVg7QUFDTixVQUFNQyxXQUFXLEtBQUtDLFdBQXRCO0FBQ0EsVUFBTUMsUUFBUSxJQUFJRixRQUFKLEdBQWVHLElBQWYsQ0FBb0IsSUFBcEIsQ0FBZDtBQUNBRCxZQUFNRSxLQUFOO0FBQ0EsYUFBT0YsS0FBUDtBQUNEOzs7eUJBRUlHLEssRUFBTztBQUNWLFdBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtDLFFBQXpCLEVBQW1DLEVBQUVELENBQXJDLEVBQXdDO0FBQ3RDLGFBQUtBLENBQUwsSUFBVUQsTUFBTUMsQ0FBTixDQUFWO0FBQ0Q7QUFDRCxXQUFLRixLQUFMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7OzswQkFFWTtBQUFBLHdDQUFOSSxJQUFNO0FBQU5BLFlBQU07QUFBQTs7QUFDWCxXQUFLLElBQUlGLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxRQUF6QixFQUFtQyxFQUFFRCxDQUFyQyxFQUF3QztBQUN0QyxhQUFLQSxDQUFMLElBQVVFLEtBQUtGLENBQUwsS0FBVyxDQUFyQjtBQUNEO0FBQ0QsV0FBS0YsS0FBTDtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7OEJBRVNDLEssRUFBbUI7QUFBQSxVQUFaSSxNQUFZ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TyxNQUFYO0FBQ0Q7QUFDRjtBQUNELFdBQUtULEtBQUw7QUFDQSxhQUFPLElBQVA7QUFDRDs7OztxQkFuR29DaUIsSzs7a0JBQWxCdEIsUyIsImZpbGUiOiJtYXRoLWFycmF5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtmb3JtYXRWYWx1ZSwgZXF1YWxzLCBnbE1hdHJpeH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRoQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgU3ViY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFN1YmNsYXNzKCkuY29weSh0aGlzKTtcbiAgICBjbG9uZS5jaGVjaygpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGNvcHkoYXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IGFycmF5W2ldO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQoLi4uYXJncykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gYXJnc1tpXSB8fCAwO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHN0cmluZyArPSAoaSA+IDAgPyAnLCAnIDogJycpICsgZm9ybWF0VmFsdWUodGhpc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9KCR7c3RyaW5nfSlgO1xuICB9XG5cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGldID0gdGhpc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdG9GbG9hdDMyQXJyYXkoKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcyk7XG4gIH1cblxuICBlcXVhbHMoYXJyYXkpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgaWYgKCFlcXVhbHModGhpc1tpXSwgYXJyYXlbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBleGFjdEVxdWFscyhhcnJheSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBpZiAodGhpc1tpXSAhPT0gYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhbGlkYXRlKGFycmF5ID0gdGhpcykge1xuICAgIGxldCB2YWxpZCA9IGFycmF5Lmxlbmd0aCA9PT0gdGhpcy5FTEVNRU5UUztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiBOdW1iZXIuaXNGaW5pdGUoYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICBjaGVjayhhcnJheSA9IHRoaXMpIHtcbiAgICBpZiAoZ2xNYXRyaXguZGVidWcgJiYgIXRoaXMudmFsaWRhdGUoYXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgbm9ybWFsaXplKCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuKCk7XG4gICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAvPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIl19

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return COORDINATE_SYSTEM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LIFECYCLE; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Note: The numeric values here are matched by shader code in the
// "project" and "project64" shader modules. Both places need to be
// updated.

// TODO: Maybe "POSITIONS" would be a better name?
var COORDINATE_SYSTEM = {
  // Positions are interpreted as [lng, lat, elevation]
  // lng lat are degrees, elevation is meters. distances as meters.
  LNGLAT: 1.0,

  // Positions are interpreted as lng lat offsets: [deltaLng, deltaLat, elevation]
  // deltaLng, deltaLat are delta degrees, elevation is meters.
  // distances as meters.
  LNGLAT_OFFSETS: 3.0,

  // Positions are interpreted as meter offsets, distances as meters
  METER_OFFSETS: 2.0,
  METERS: 2.0,

  // Positions and distances are not transformed: [x, y, z] in unit coordinates
  IDENTITY: 0.0
};

var LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Intialized',
  OUTDATED: 'Outdated. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29uc3RhbnRzLmpzIl0sIm5hbWVzIjpbIkNPT1JESU5BVEVfU1lTVEVNIiwiTE5HTEFUIiwiTE5HTEFUX09GRlNFVFMiLCJNRVRFUl9PRkZTRVRTIiwiTUVURVJTIiwiSURFTlRJVFkiLCJMSUZFQ1lDTEUiLCJOT19TVEFURSIsIk1BVENIRUQiLCJJTklUSUFMSVpFRCIsIk9VVERBVEVEIiwiRklOQUxJWkVEIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLElBQU1BLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0FDLFVBQVEsR0FIdUI7O0FBSy9CO0FBQ0E7QUFDQTtBQUNBQyxrQkFBZ0IsR0FSZTs7QUFVL0I7QUFDQUMsaUJBQWUsR0FYZ0I7QUFZL0JDLFVBQVEsR0FadUI7O0FBYy9CO0FBQ0FDLFlBQVU7QUFmcUIsQ0FBMUI7O0FBa0JQLE9BQU8sSUFBTUMsWUFBWTtBQUN2QkMsWUFBVSxnQkFEYTtBQUV2QkMsV0FBUyxnREFGYztBQUd2QkMsZUFBYSxZQUhVO0FBSXZCQyxZQUFVLHVDQUphO0FBS3ZCQyxhQUFXO0FBTFksQ0FBbEIiLCJmaWxlIjoiY29uc3RhbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIE5vdGU6IFRoZSBudW1lcmljIHZhbHVlcyBoZXJlIGFyZSBtYXRjaGVkIGJ5IHNoYWRlciBjb2RlIGluIHRoZVxuLy8gXCJwcm9qZWN0XCIgYW5kIFwicHJvamVjdDY0XCIgc2hhZGVyIG1vZHVsZXMuIEJvdGggcGxhY2VzIG5lZWQgdG8gYmVcbi8vIHVwZGF0ZWQuXG5cbi8vIFRPRE86IE1heWJlIFwiUE9TSVRJT05TXCIgd291bGQgYmUgYSBiZXR0ZXIgbmFtZT9cbmV4cG9ydCBjb25zdCBDT09SRElOQVRFX1NZU1RFTSA9IHtcbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBbbG5nLCBsYXQsIGVsZXZhdGlvbl1cbiAgLy8gbG5nIGxhdCBhcmUgZGVncmVlcywgZWxldmF0aW9uIGlzIG1ldGVycy4gZGlzdGFuY2VzIGFzIG1ldGVycy5cbiAgTE5HTEFUOiAxLjAsXG5cbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBsbmcgbGF0IG9mZnNldHM6IFtkZWx0YUxuZywgZGVsdGFMYXQsIGVsZXZhdGlvbl1cbiAgLy8gZGVsdGFMbmcsIGRlbHRhTGF0IGFyZSBkZWx0YSBkZWdyZWVzLCBlbGV2YXRpb24gaXMgbWV0ZXJzLlxuICAvLyBkaXN0YW5jZXMgYXMgbWV0ZXJzLlxuICBMTkdMQVRfT0ZGU0VUUzogMy4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgbWV0ZXIgb2Zmc2V0cywgZGlzdGFuY2VzIGFzIG1ldGVyc1xuICBNRVRFUl9PRkZTRVRTOiAyLjAsXG4gIE1FVEVSUzogMi4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhbmQgZGlzdGFuY2VzIGFyZSBub3QgdHJhbnNmb3JtZWQ6IFt4LCB5LCB6XSBpbiB1bml0IGNvb3JkaW5hdGVzXG4gIElERU5USVRZOiAwLjBcbn07XG5cbmV4cG9ydCBjb25zdCBMSUZFQ1lDTEUgPSB7XG4gIE5PX1NUQVRFOiAnQXdhaXRpbmcgc3RhdGUnLFxuICBNQVRDSEVEOiAnTWF0Y2hlZC4gU3RhdGUgdHJhbnNmZXJyZWQgZnJvbSBwcmV2aW91cyBsYXllcicsXG4gIElOSVRJQUxJWkVEOiAnSW50aWFsaXplZCcsXG4gIE9VVERBVEVEOiAnT3V0ZGF0ZWQuIEF3YWl0aW5nIGdhcmJhZ2UgY29sbGVjdGlvbicsXG4gIEZJTkFMSVpFRDogJ0ZpbmFsaXplZCEgQXdhaXRpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uJ1xufTtcbiJdfQ==

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BufferLayout */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_typed_array_utils__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }







var ERR_BUFFER_PARAMS = 'Illegal or missing parameter to Buffer';

var BufferLayout =
/**
 * @classdesc
 * Store characteristics of a data layout
 * This data can be used when updating vertex attributes with
 * the associated buffer, freeing the application from keeping
 * track of this metadata.
 *
 * @class
 * @param {GLuint} size - number of values per element (1-4)
 * @param {GLuint} type - type of values (e.g. gl.FLOAT)
 * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]
 * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion
 * @param {GLuint} stride=0 - supports strided arrays
 * @param {GLuint} offset=0 - supports strided arrays
 */
function BufferLayout() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      type = _ref.type,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? 1 : _ref$size,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? 0 : _ref$offset,
      _ref$stride = _ref.stride,
      stride = _ref$stride === undefined ? 0 : _ref$stride,
      _ref$normalized = _ref.normalized,
      normalized = _ref$normalized === undefined ? false : _ref$normalized,
      _ref$integer = _ref.integer,
      integer = _ref$integer === undefined ? false : _ref$integer,
      _ref$instanced = _ref.instanced,
      instanced = _ref$instanced === undefined ? 0 : _ref$instanced;

  _classCallCheck(this, BufferLayout);

  this.type = type;
  this.size = size;
  this.offset = offset;
  this.stride = stride;
  this.normalized = normalized;
  this.integer = integer;
  this.instanced = instanced;
};

var Buffer = function (_Resource) {
  _inherits(Buffer, _Resource);

  function Buffer(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Buffer);

    // In WebGL1, we need to make sure we use GL.ELEMENT_ARRAY_BUFFER when
    // initializing element buffers, otherwise the buffer type will be locked
    // to a generic (non-element) buffer.
    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type
    var _this = _possibleConstructorReturn(this, (Buffer.__proto__ || Object.getPrototypeOf(Buffer)).call(this, gl, opts));

    _this.target = opts.target || (_this.gl.webgl2 ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER : __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ARRAY_BUFFER);
    _this.index = null;
    _this.setData(opts);
    Object.seal(_this);
    return _this;
  }

  /*
   * Stores the layout of data with the buffer which makes it easy to
   * e.g. set it as an attribute later
   */


  _createClass(Buffer, [{
    key: 'setDataLayout',
    value: function setDataLayout(_ref2) {
      var layout = _ref2.layout,
          type = _ref2.type,
          _ref2$size = _ref2.size,
          size = _ref2$size === undefined ? 1 : _ref2$size,
          _ref2$offset = _ref2.offset,
          offset = _ref2$offset === undefined ? 0 : _ref2$offset,
          _ref2$stride = _ref2.stride,
          stride = _ref2$stride === undefined ? 0 : _ref2$stride,
          _ref2$normalized = _ref2.normalized,
          normalized = _ref2$normalized === undefined ? false : _ref2$normalized,
          _ref2$integer = _ref2.integer,
          integer = _ref2$integer === undefined ? false : _ref2$integer,
          _ref2$instanced = _ref2.instanced,
          instanced = _ref2$instanced === undefined ? 0 : _ref2$instanced;

      this.layout = layout || new BufferLayout({
        type: type || this.type, // Use autodeduced type if available
        size: size,
        offset: offset,
        stride: stride,
        normalized: normalized,
        integer: integer,
        instanced: instanced
      });
      return this;
    }

    /**
     * Creates and initializes the buffer object's data store.
     *
     * @param {ArrayBufferView} opt.data - contents
     * @param {GLsizeiptr} opt.bytes - the size of the buffer object's data store.
     * @param {GLenum} opt.usage=gl.STATIC_DRAW - Allocation hint for GPU driver
     *
     * Characteristics of stored data, hints for vertex attribute
     *
     * @param {GLenum} opt.dataType=gl.FLOAT - type of data stored in buffer
     * @param {GLuint} opt.size=1 - number of values per vertex
     * @returns {Buffer} Returns itself for chaining.
     */

  }, {
    key: 'setData',
    value: function setData() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref3.data,
          bytes = _ref3.bytes,
          _ref3$usage = _ref3.usage,
          usage = _ref3$usage === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].STATIC_DRAW : _ref3$usage,
          layout = _ref3.layout,
          type = _ref3.type,
          _ref3$size = _ref3.size,
          size = _ref3$size === undefined ? 1 : _ref3$size,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === undefined ? 0 : _ref3$offset,
          _ref3$stride = _ref3.stride,
          stride = _ref3$stride === undefined ? 0 : _ref3$stride,
          _ref3$normalized = _ref3.normalized,
          normalized = _ref3$normalized === undefined ? false : _ref3$normalized,
          _ref3$integer = _ref3.integer,
          integer = _ref3$integer === undefined ? false : _ref3$integer,
          _ref3$instanced = _ref3.instanced,
          instanced = _ref3$instanced === undefined ? 0 : _ref3$instanced;

      var opts = arguments[0];

      if (!data) {
        bytes = bytes || 0;
      } else {
        type = type || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_typed_array_utils__["a" /* getGLTypeFromTypedArray */])(data);
        bytes = data.byteLength;
        __WEBPACK_IMPORTED_MODULE_4_assert___default()(type, ERR_BUFFER_PARAMS);
      }

      this.bytes = bytes;
      this.bytesUsed = bytes;
      this.data = data;
      this.type = type;
      this.usage = usage;

      // Call after type is set
      this.setDataLayout(Object.assign(opts));

      // Create the buffer - binding it here for the first time locks the type
      // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type
      var target = this.gl.webgl2 ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_WRITE_BUFFER : this.target;
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data || bytes, usage);
      this.gl.bindBuffer(target, null);

      return this;
    }

    /**
     * Updates a subset of a buffer object's data store.
     * @param {ArrayBufferView} opt.data - contents
     * @returns {Buffer} Returns itself for chaining.
     */

  }, {
    key: 'subData',
    value: function subData() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref4.data,
          _ref4$offset = _ref4.offset,
          offset = _ref4$offset === undefined ? 0 : _ref4$offset,
          _ref4$srcOffset = _ref4.srcOffset,
          srcOffset = _ref4$srcOffset === undefined ? 0 : _ref4$srcOffset,
          length = _ref4.length;

      __WEBPACK_IMPORTED_MODULE_4_assert___default()(data, ERR_BUFFER_PARAMS);

      // WebGL2: subData supports additional srcOffset and length parameters
      if (srcOffset !== 0 || length !== undefined) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
        this.gl.bindBuffer(this.target, this.handle);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);
        this.gl.bindBuffer(this.target, null);
        return this;
      }

      // Create the buffer - binding it here for the first time locks the type
      // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type
      var target = this.gl.webgl2 ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_WRITE_BUFFER : this.target;
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferSubData(target, offset, data);
      this.gl.bindBuffer(target, null);
      return this;
    }

    /**
     * WEBGL2 ONLY: Copies part of the data of another buffer into this buffer
     *
     * Note: readOffset, writeOffset and size must all be greater than or equal to zero.
     * Furthermore, readOffset+sizereadOffset+size must not exceeed the size of
     * the source buffer object, and writeOffset+sizewriteOffset+size must not
     * exceeed the size of the buffer bound to writeTarget. If the source and
     * destination are the same buffer object, then the source and destination
     * ranges must not overlap.
     *
     * @param {GLintptr} readOffset - byte offset from which to start reading from the buffer.
     * @param {GLintptr} writeOffset - byte offset from which to start writing to the buffer.
     * @param {GLsizei}  size - bytes specifying the size of the data to be copied
     */

  }, {
    key: 'copySubData',
    value: function copySubData(_ref5) {
      var sourceBuffer = _ref5.sourceBuffer,
          _ref5$readOffset = _ref5.readOffset,
          readOffset = _ref5$readOffset === undefined ? 0 : _ref5$readOffset,
          _ref5$writeOffset = _ref5.writeOffset,
          writeOffset = _ref5$writeOffset === undefined ? 0 : _ref5$writeOffset,
          size = _ref5.size;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);

      // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER, sourceBuffer.handle);
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_WRITE_BUFFER, this.handle);

      this.gl.copyBufferSubData(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_WRITE_BUFFER, readOffset, writeOffset, size);

      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER, null);
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_WRITE_BUFFER, null);
    }

    /**
     * WEBGL2 ONLY: Reads data from buffer into an ArrayBuffer or SharedArrayBuffer.
     *
     * @param {GLintptr} srcByteOffset - byte offset from which to start reading from the buffer.
     * @param {ArrayBufferView | ArrayBuffer | SharedArrayBuffer} dstData -
     *   memory to which to write the buffer data.
     * @param {GLuint} srcOffset=0 - element index offset where to start reading the buffer.
     * @param {GLuint} length=0  Optional, defaulting to 0.
     */

  }, {
    key: 'getSubData',
    value: function getSubData(_ref6) {
      var dstData = _ref6.dstData,
          _ref6$srcByteOffset = _ref6.srcByteOffset,
          srcByteOffset = _ref6$srcByteOffset === undefined ? 0 : _ref6$srcByteOffset,
          _ref6$dstOffset = _ref6.dstOffset,
          dstOffset = _ref6$dstOffset === undefined ? 0 : _ref6$dstOffset,
          _ref6$length = _ref6.length,
          length = _ref6$length === undefined ? 0 : _ref6$length;

      // TODO optimize dstData according to offset and length
      dstData = dstData || new ArrayBuffer(this.bytes);
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER, this.handle);
      this.gl.getBufferSubData(this.target, srcByteOffset, dstData, dstOffset, length);
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER, null);
      return dstData;
    }

    /**
     * Binds a buffer to a given binding point (target).
     *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.
     *
     * @param {Glenum} target - target for the bind operation.
     *
     * @param {GLuint} index= - the index of the target.
     *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state
     * @param {GLuint} offset=0 - the index of the target.
     *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.
     * @param {GLuint} size= - the index of the target.
     *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.
     * @returns {Buffer} - Returns itself for chaining.
     */

  }, {
    key: 'bind',
    value: function bind() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$target = _ref7.target,
          target = _ref7$target === undefined ? this.target : _ref7$target,
          _ref7$index = _ref7.index,
          index = _ref7$index === undefined ? this.index : _ref7$index,
          _ref7$offset = _ref7.offset,
          offset = _ref7$offset === undefined ? 0 : _ref7$offset,
          size = _ref7.size;

      // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could
      // be used as direct binding points, they will not affect transform feedback or
      // uniform buffer state. Instead indexed bindings need to be made.
      var type = target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNIFORM_BUFFER || target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRANSFORM_FEEDBACK_BUFFER ? size !== undefined ? 'ranged' : ' indexed' : 'non-indexed';

      switch (type) {
        case 'non-indexed':
          this.gl.bindBuffer(target, this.handle);
          break;
        case 'indexed':
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
          __WEBPACK_IMPORTED_MODULE_4_assert___default()(offset === 0, ERR_BUFFER_PARAMS); // Make sure offset wasn't supplied
          this.gl.bindBufferBase(target, index, this.handle);
          break;
        case 'ranged':
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
          break;
        default:
          throw new Error(ERR_BUFFER_PARAMS);
      }

      return this;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$target = _ref8.target,
          target = _ref8$target === undefined ? this.target : _ref8$target,
          _ref8$index = _ref8.index,
          index = _ref8$index === undefined ? this.index : _ref8$index;

      var isIndexedBuffer = target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNIFORM_BUFFER || target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRANSFORM_FEEDBACK_BUFFER;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }
      return this;
    }

    // gl.TRANSFORM_FEEDBACK_BUFFER_BINDING: Returns a WebGLBuffer.
    // gl.TRANSFORM_FEEDBACK_BUFFER_SIZE: Returns a GLsizeiptr.
    // gl.TRANSFORM_FEEDBACK_BUFFER_START: Returns a GLintptr.
    // gl.UNIFORM_BUFFER_BINDING: Returns a WebGLBuffer.
    // gl.UNIFORM_BUFFER_SIZE: Returns a GLsizeiptr.
    // gl.UNIFORM_BUFFER_START: Returns a GLintptr.

  }, {
    key: 'getIndexedParameter',
    value: function getIndexedParameter(binding, index) {
      // Create the buffer - if binding it here for the first time, this locks the type
      // In WebGL2, use GL.COPY_READ_BUFFER to avoid locking the type
      var target = this.gl.webgl2 ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COPY_READ_BUFFER : this.target;
      this.gl.bindBuffer(target, index);
      return this.gl.getIndexedParameter(binding, index);
    }

    // RESOURCE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createBuffer();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
    }
  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      var value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
  }]);

  return Buffer;
}(__WEBPACK_IMPORTED_MODULE_3__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Buffer);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9idWZmZXIuanMiXSwibmFtZXMiOlsiR0wiLCJhc3NlcnRXZWJHTDJDb250ZXh0IiwiZ2V0R0xUeXBlRnJvbVR5cGVkQXJyYXkiLCJSZXNvdXJjZSIsImFzc2VydCIsIkVSUl9CVUZGRVJfUEFSQU1TIiwiQnVmZmVyTGF5b3V0IiwidHlwZSIsInNpemUiLCJvZmZzZXQiLCJzdHJpZGUiLCJub3JtYWxpemVkIiwiaW50ZWdlciIsImluc3RhbmNlZCIsIkJ1ZmZlciIsImdsIiwib3B0cyIsInRhcmdldCIsIndlYmdsMiIsIkNPUFlfUkVBRF9CVUZGRVIiLCJBUlJBWV9CVUZGRVIiLCJpbmRleCIsInNldERhdGEiLCJPYmplY3QiLCJzZWFsIiwibGF5b3V0IiwiZGF0YSIsImJ5dGVzIiwidXNhZ2UiLCJTVEFUSUNfRFJBVyIsImFyZ3VtZW50cyIsImJ5dGVMZW5ndGgiLCJieXRlc1VzZWQiLCJzZXREYXRhTGF5b3V0IiwiYXNzaWduIiwiQ09QWV9XUklURV9CVUZGRVIiLCJiaW5kQnVmZmVyIiwiaGFuZGxlIiwiYnVmZmVyRGF0YSIsInNyY09mZnNldCIsImxlbmd0aCIsInVuZGVmaW5lZCIsImJ1ZmZlclN1YkRhdGEiLCJzb3VyY2VCdWZmZXIiLCJyZWFkT2Zmc2V0Iiwid3JpdGVPZmZzZXQiLCJjb3B5QnVmZmVyU3ViRGF0YSIsImRzdERhdGEiLCJzcmNCeXRlT2Zmc2V0IiwiZHN0T2Zmc2V0IiwiQXJyYXlCdWZmZXIiLCJnZXRCdWZmZXJTdWJEYXRhIiwiVU5JRk9STV9CVUZGRVIiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIiwiYmluZEJ1ZmZlckJhc2UiLCJiaW5kQnVmZmVyUmFuZ2UiLCJFcnJvciIsImlzSW5kZXhlZEJ1ZmZlciIsImJpbmRpbmciLCJnZXRJbmRleGVkUGFyYW1ldGVyIiwiY3JlYXRlQnVmZmVyIiwiZGVsZXRlQnVmZmVyIiwicG5hbWUiLCJ2YWx1ZSIsImdldEJ1ZmZlclBhcmFtZXRlciJdLCJtYXBw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WUFBUixDQUFxQixLQUFLeEIsTUFBMUI7QUFDRDs7O2tDQUVheUIsSyxFQUFPO0FBQ25CLFdBQUsvQyxFQUFMLENBQVFxQixVQUFSLENBQW1CLEtBQUtuQixNQUF4QixFQUFnQyxLQUFLb0IsTUFBckM7QUFDQSxVQUFNMEIsUUFBUSxLQUFLaEQsRUFBTCxDQUFRaUQsa0JBQVIsQ0FBMkIsS0FBSy9DLE1BQWhDLEVBQXdDNkMsS0FBeEMsQ0FBZDtBQUNBLFdBQUsvQyxFQUFMLENBQVFxQixVQUFSLENBQW1CLEtBQUtuQixNQUF4QixFQUFnQyxJQUFoQztBQUNBLGFBQU84QyxLQUFQO0FBQ0Q7Ozs7RUF2UWlDNUQsUTs7ZUFBZlcsTSIsImZpbGUiOiJidWZmZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR0wgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthc3NlcnRXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHtnZXRHTFR5cGVGcm9tVHlwZWRBcnJheX0gZnJvbSAnLi4vdXRpbHMvdHlwZWQtYXJyYXktdXRpbHMnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcmVzb3VyY2UnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBFUlJfQlVGRkVSX1BBUkFNUyA9ICdJbGxlZ2FsIG9yIG1pc3NpbmcgcGFyYW1ldGVyIHRvIEJ1ZmZlcic7XG5cbmV4cG9ydCBjbGFzcyBCdWZmZXJMYXlvdXQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBTdG9yZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgYSBkYXRhIGxheW91dFxuICAgKiBUaGlzIGRhdGEgY2FuIGJlIHVzZWQgd2hlbiB1cGRhdGluZyB2ZXJ0ZXggYXR0cmlidXRlcyB3aXRoXG4gICAqIHRoZSBhc3NvY2lhdGVkIGJ1ZmZlciwgZnJlZWluZyB0aGUgYXBwbGljYXRpb24gZnJvbSBrZWVwaW5nXG4gICAqIHRyYWNrIG9mIHRoaXMgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0dMdWludH0gc2l6ZSAtIG51bWJlciBvZiB2YWx1ZXMgcGVyIGVsZW1lbnQgKDEtNClcbiAgICogQHBhcmFtIHtHTHVpbnR9IHR5cGUgLSB0eXBlIG9mIHZhbHVlcyAoZS5nLiBnbC5GTE9BVClcbiAgICogQHBhcmFtIHtHTGJvb2x9IG5vcm1hbGl6ZWQ9ZmFsc2UgLSBub3JtYWxpemUgaW50ZWdlcnMgdG8gWy0xLDFdIG9yIFswLDFdXG4gICAqIEBwYXJhbSB7R0x1aW50fSBpbnRlZ2VyPWZhbHNlIC0gV2ViR0wyIG9ubHksIGludC10by1mbG9hdCBjb252ZXJzaW9uXG4gICAqIEBwYXJhbSB7R0x1aW50fSBzdHJpZGU9MCAtIHN1cHBvcnRzIHN0cmlkZWQgYXJyYXlzXG4gICAqIEBwYXJhbSB7R0x1aW50fSBvZmZzZXQ9MCAtIHN1cHBvcnRzIHN0cmlkZWQgYXJyYXlzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gQ2hhcmFjdGVyaXN0aWNzIG9mIHN0b3JlZCBkYXRhLFxuICAgIHR5cGUsXG4gICAgc2l6ZSA9IDEsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBzdHJpZGUgPSAwLFxuICAgIG5vcm1hbGl6ZWQgPSBmYWxzZSxcbiAgICBpbnRlZ2VyID0gZmFsc2UsXG4gICAgaW5zdGFuY2VkID0gMFxuICB9ID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgdGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICB0aGlzLmludGVnZXIgPSBpbnRlZ2VyO1xuICAgIHRoaXMuaW5zdGFuY2VkID0gaW5zdGFuY2VkO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlciBleHRlbmRzIFJlc291cmNlIHtcbiAgY29uc3RydWN0b3IoZ2wsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKGdsLCBvcHRzKTtcbiAgICAvLyBJbiBXZWJHTDEsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIHVzZSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUiB3aGVuXG4gICAgLy8gaW5pdGlhbGl6aW5nIGVsZW1lbnQgYnVmZmVycywgb3RoZXJ3aXNlIHRoZSBidWZmZXIgdHlwZSB3aWxsIGJlIGxvY2tlZFxuICAgIC8vIHRvIGEgZ2VuZXJpYyAobm9uLWVsZW1lbnQpIGJ1ZmZlci5cbiAgICAvLyBJbiBXZWJHTDIsIHdlIGNhbiB1c2UgR0wuQ09QWV9SRUFEX0JVRkZFUiB3aGljaCBhdm9pZHMgbG9ja2luZyB0aGUgdHlwZVxuICAgIHRoaXMudGFyZ2V0ID0gb3B0cy50YXJnZXQgfHwgKHRoaXMuZ2wud2ViZ2wyID8gR0wuQ09QWV9SRUFEX0JVRkZFUiA6IEdMLkFSUkFZX0JVRkZFUik7XG4gICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgdGhpcy5zZXREYXRhKG9wdHMpO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLypcbiAgICogU3RvcmVzIHRoZSBsYXlvdXQgb2YgZGF0YSB3aXRoIHRoZSBidWZmZXIgd2hpY2ggbWFrZXMgaXQgZWFzeSB0b1xuICAgKiBlLmcuIHNldCBpdCBhcyBhbiBhdHRyaWJ1dGUgbGF0ZXJcbiAgICovXG4gIHNldERhdGFMYXlvdXQoe1xuICAgIGxheW91dCxcbiAgICB0eXBlLFxuICAgIHNpemUgPSAxLFxuICAgIG9mZnNldCA9IDAsXG4gICAgc3RyaWRlID0gMCxcbiAgICBub3JtYWxpemVkID0gZmFsc2UsXG4gICAgaW50ZWdlciA9IGZhbHNlLFxuICAgIGluc3RhbmNlZCA9IDBcbiAgfSkge1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IG5ldyBCdWZmZXJMYXlvdXQoe1xuICAgICAgdHlwZTogdHlwZSB8fCB0aGlzLnR5cGUsIC8vIFVzZSBhdXRvZGVkdWNlZCB0eXBlIGlmIGF2YWlsYWJsZVxuICAgICAgc2l6ZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIG5vcm1hbGl6ZWQsXG4gICAgICBpbnRlZ2VyLFxuICAgICAgaW5zdGFuY2VkXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGJ1ZmZlciBvYmplY3QncyBkYXRhIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gb3B0LmRhdGEgLSBjb250ZW50c1xuICAgKiBAcGFyYW0ge0dMc2l6ZWlwdHJ9IG9wdC5ieXRlcyAtIHRoZSBzaXplIG9mIHRoZSBidWZmZXIgb2JqZWN0J3MgZGF0YSBzdG9yZS5cbiAgICogQHBhcmFtIHtHTGVudW19IG9wdC51c2FnZT1nbC5TVEFUSUNfRFJBVyAtIEFsbG9jYXRpb24gaGludCBmb3IgR1BVIGRyaXZlclxuICAgKlxuICAgKiBDaGFyYWN0ZXJpc3RpY3Mgb2Ygc3RvcmVkIGRhdGEsIGhpbnRzIGZvciB2ZXJ0ZXggYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7R0xlbnVtfSBvcHQuZGF0YVR5cGU9Z2wuRkxPQVQgLSB0eXBlIG9mIGRhdGEgc3RvcmVkIGluIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMdWludH0gb3B0LnNpemU9MSAtIG51bWJlciBvZiB2YWx1ZXMgcGVyIHZlcnRleFxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBzZXREYXRhKHtcbiAgICBkYXRhLFxuICAgIGJ5dGVzLFxuICAgIHVzYWdlID0gR0wuU1RBVElDX0RSQVcsXG4gICAgLy8gTGF5b3V0IG9mIHN0b3JlZCBkYXRhXG4gICAgbGF5b3V0LFxuICAgIHR5cGUsXG4gICAgc2l6ZSA9IDEsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBzdHJpZGUgPSAwLFxuICAgIG5vcm1hbGl6ZWQgPSBmYWxzZSxcbiAgICBpbnRlZ2VyID0gZmFsc2UsXG4gICAgaW5zdGFuY2VkID0gMFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0gYXJndW1lbnRzWzBdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBieXRlcyA9IGJ5dGVzIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0eXBlIHx8IGdldEdMVHlwZUZyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgYnl0ZXMgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBhc3NlcnQodHlwZSwgRVJSX0JVRkZFUl9QQVJBTVMpO1xuICAgIH1cblxuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLmJ5dGVzVXNlZCA9IGJ5dGVzO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG5cbiAgICAvLyBDYWxsIGFmdGVyIHR5cGUgaXMgc2V0XG4gICAgdGhpcy5zZXREYXRhTGF5b3V0KE9iamVjdC5hc3NpZ24ob3B0cykpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBidWZmZXIgLSBiaW5kaW5nIGl0IGhlcmUgZm9yIHRoZSBmaXJzdCB0aW1lIGxvY2tzIHRoZSB0eXBlXG4gICAgLy8gSW4gV2ViR0wyLCB1c2UgR0wuQ09QWV9XUklURV9CVUZGRVIgdG8gYXZvaWQgbG9ja2luZyB0aGUgdHlwZVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2wud2ViZ2wyID8gR0wuQ09QWV9XUklURV9CVUZGRVIgOiB0aGlzLnRhcmdldDtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRhcmdldCwgZGF0YSB8fCBieXRlcywgdXNhZ2UpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhIHN1YnNldCBvZiBhIGJ1ZmZlciBvYmplY3QncyBkYXRhIHN0b3JlLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gb3B0LmRhdGEgLSBjb250ZW50c1xuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBzdWJEYXRhKHtcbiAgICBkYXRhLCAgICAgICAgICAvLyBEYXRhIChUeXBlZCBBcnJheSBvciBBcnJheUJ1ZmZlciksIGxlbmd0aCBpcyBpbmZlcnJlZCB1bmxlc3MgcHJvdmlkZWRcbiAgICBvZmZzZXQgPSAwLCAgICAvLyBPZmZzZXQgaW50byBidWZmZXJcbiAgICBzcmNPZmZzZXQgPSAwLCAvLyBXZWJHTDIgb25seTogT2Zmc2V0IGludG8gc3JjRGF0YVxuICAgIGxlbmd0aCAgICAgICAgIC8vIFdlYkdMMiBvbmx5OiBOdW1iZXIgb2YgYnl0ZXMgdG8gYmUgY29waWVkXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydChkYXRhLCBFUlJfQlVGRkVSX1BBUkFNUyk7XG5cbiAgICAvLyBXZWJHTDI6IHN1YkRhdGEgc3VwcG9ydHMgYWRkaXRpb25hbCBzcmNPZmZzZXQgYW5kIGxlbmd0aCBwYXJhbWV0ZXJzXG4gICAgaWYgKHNyY09mZnNldCAhPT0gMCB8fCBsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0V2ViR0wyQ29udGV4dCh0aGlzLmdsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgICAgdGhpcy5nbC5idWZmZXJTdWJEYXRhKHRoaXMudGFyZ2V0LCBvZmZzZXQsIGRhdGEsIHNyY09mZnNldCwgbGVuZ3RoIHx8IDApO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCBudWxsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgYnVmZmVyIC0gYmluZGluZyBpdCBoZXJlIGZvciB0aGUgZmlyc3QgdGltZSBsb2NrcyB0aGUgdHlwZVxuICAgIC8vIEluIFdlYkdMMiwgdXNlIEdMLkNPUFlfV1JJVEVfQlVGRkVSIHRvIGF2b2lkIGxvY2tpbmcgdGhlIHR5cGVcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdsLndlYmdsMiA/IEdMLkNPUFlfV1JJVEVfQlVGRkVSIDogdGhpcy50YXJnZXQ7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgIHRoaXMuZ2wuYnVmZmVyU3ViRGF0YSh0YXJnZXQsIG9mZnNldCwgZGF0YSk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV0VCR0wyIE9OTFk6IENvcGllcyBwYXJ0IG9mIHRoZSBkYXRhIG9mIGFub3RoZXIgYnVmZmVyIGludG8gdGhpcyBidWZmZXJcbiAgICpcbiAgICogTm90ZTogcmVhZE9mZnNldCwgd3JpdGVPZmZzZXQgYW5kIHNpemUgbXVzdCBhbGwgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXG4gICAqIEZ1cnRoZXJtb3JlLCByZWFkT2Zmc2V0K3NpemVyZWFkT2Zmc2V0K3NpemUgbXVzdCBub3QgZXhjZWVlZCB0aGUgc2l6ZSBvZlxuICAgKiB0aGUgc291cmNlIGJ1ZmZlciBvYmplY3QsIGFuZCB3cml0ZU9mZnNldCtzaXpld3JpdGVPZmZzZXQrc2l6ZSBtdXN0IG5vdFxuICAgKiBleGNlZWVkIHRoZSBzaXplIG9mIHRoZSBidWZmZXIgYm91bmQgdG8gd3JpdGVUYXJnZXQuIElmIHRoZSBzb3VyY2UgYW5kXG4gICAqIGRlc3RpbmF0aW9uIGFyZSB0aGUgc2FtZSBidWZmZXIgb2JqZWN0LCB0aGVuIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uXG4gICAqIHJhbmdlcyBtdXN0IG5vdCBvdmVybGFwLlxuICAgKlxuICAgKiBAcGFyYW0ge0dMaW50cHRyfSByZWFkT2Zmc2V0IC0gYnl0ZSBvZmZzZXQgZnJvbSB3aGljaCB0byBzdGFydCByZWFkaW5nIGZyb20gdGhlIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtHTGludHB0cn0gd3JpdGVPZmZzZXQgLSBieXRlIG9mZnNldCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmcgdG8gdGhlIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtHTHNpemVpfSAgc2l6ZSAtIGJ5dGVzIHNwZWNpZnlpbmcgdGhlIHNpemUgb2YgdGhlIGRhdGEgdG8gYmUgY29waWVkXG4gICAqL1xuICBjb3B5U3ViRGF0YSh7XG4gICAgc291cmNlQnVmZmVyLFxuICAgIHJlYWRPZmZzZXQgPSAwLFxuICAgIHdyaXRlT2Zmc2V0ID0gMCxcbiAgICBzaXplXG4gIH0pIHtcbiAgICBhc3NlcnRXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuXG4gICAgLy8gVXNlIEdMLkNPUFlfUkVBRF9CVUZGRVIrR0wuQ09QWV9XUklURV9CVUZGRVIgYXZvaWQgZGlzdHVyYmluZyBvdGhlciB0YXJnZXRzIGFuZCBsb2NraW5nIHR5cGVcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIoR0wuQ09QWV9SRUFEX0JVRkZFUiwgc291cmNlQnVmZmVyLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKEdMLkNPUFlfV1JJVEVfQlVGRkVSLCB0aGlzLmhhbmRsZSk7XG5cbiAgICB0aGlzLmdsLmNvcHlCdWZmZXJTdWJEYXRhKFxuICAgICAgR0wuQ09QWV9SRUFEX0JVRkZFUiwgR0wuQ09QWV9XUklURV9CVUZGRVIsXG4gICAgICByZWFkT2Zmc2V0LCB3cml0ZU9mZnNldCwgc2l6ZSk7XG5cbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIoR0wuQ09QWV9SRUFEX0JVRkZFUiwgbnVsbCk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKEdMLkNPUFlfV1JJVEVfQlVGRkVSLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXRUJHTDIgT05MWTogUmVhZHMgZGF0YSBmcm9tIGJ1ZmZlciBpbnRvIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0dMaW50cHRyfSBzcmNCeXRlT2Zmc2V0IC0gYnl0ZSBvZmZzZXQgZnJvbSB3aGljaCB0byBzdGFydCByZWFkaW5nIGZyb20gdGhlIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyfSBkc3REYXRhIC1cbiAgICogICBtZW1vcnkgdG8gd2hpY2ggdG8gd3JpdGUgdGhlIGJ1ZmZlciBkYXRhLlxuICAgKiBAcGFyYW0ge0dMdWludH0gc3JjT2Zmc2V0PTAgLSBlbGVtZW50IGluZGV4IG9mZnNldCB3aGVyZSB0byBzdGFydCByZWFkaW5nIHRoZSBidWZmZXIuXG4gICAqIEBwYXJhbSB7R0x1aW50fSBsZW5ndGg9MCAgT3B0aW9uYWwsIGRlZmF1bHRpbmcgdG8gMC5cbiAgICovXG4gIGdldFN1YkRhdGEoe1xuICAgIGRzdERhdGEsXG4gICAgc3JjQnl0ZU9mZnNldCA9IDAsXG4gICAgZHN0T2Zmc2V0ID0gMCxcbiAgICBsZW5ndGggPSAwXG4gIH0pIHtcbiAgICAvLyBUT0RPIG9wdGltaXplIGRzdERhdGEgYWNjb3JkaW5nIHRvIG9mZnNldCBhbmQgbGVuZ3RoXG4gICAgZHN0RGF0YSA9IGRzdERhdGEgfHwgbmV3IEFycmF5QnVmZmVyKHRoaXMuYnl0ZXMpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcihHTC5DT1BZX1JFQURfQlVGRkVSLCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5nZXRCdWZmZXJTdWJEYXRhKHRoaXMudGFyZ2V0LCBzcmNCeXRlT2Zmc2V0LCBkc3REYXRhLCBkc3RPZmZzZXQsIGxlbmd0aCk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKEdMLkNPUFlfUkVBRF9CVUZGRVIsIG51bGwpO1xuICAgIHJldHVybiBkc3REYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgYnVmZmVyIHRvIGEgZ2l2ZW4gYmluZGluZyBwb2ludCAodGFyZ2V0KS5cbiAgICogICBHTC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIGFuZCBHTC5VTklGT1JNX0JVRkZFUiB0YWtlIGFuIGluZGV4LCBhbmQgb3B0aW9uYWxseSBhIHJhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0dsZW51bX0gdGFyZ2V0IC0gdGFyZ2V0IGZvciB0aGUgYmluZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7R0x1aW50fSBpbmRleD0gLSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldC5cbiAgICogICAtIEdMLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIgYW5kIEdMLlVOSUZPUk1fQlVGRkVSIG5lZWQgYW4gaW5kZXggdG8gYWZmZWN0IHN0YXRlXG4gICAqIEBwYXJhbSB7R0x1aW50fSBvZmZzZXQ9MCAtIHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LlxuICAgKiAgIC0gR0wuVU5JRk9STV9CVUZGRVI6IGBvZmZzZXRgIG11c3QgYmUgYWxpZ25lZCB0byBHTC5VTklGT1JNX0JVRkZFUl9PRkZTRVRfQUxJR05NRU5ULlxuICAgKiBAcGFyYW0ge0dMdWludH0gc2l6ZT0gLSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldC5cbiAgICogICAtIEdMLlVOSUZPUk1fQlVGRkVSOiBgc2l6ZWAgbXVzdCBiZSBhIG1pbmltdW0gb2YgR0wuVU5JRk9STV9CTE9DS19TSVpFX0RBVEEuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYmluZCh7dGFyZ2V0ID0gdGhpcy50YXJnZXQsIGluZGV4ID0gdGhpcy5pbmRleCwgb2Zmc2V0ID0gMCwgc2l6ZX0gPSB7fSkge1xuICAgIC8vIE5PVEU6IFdoaWxlIEdMLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIgYW5kIEdMLlVOSUZPUk1fQlVGRkVSIGNvdWxkXG4gICAgLy8gYmUgdXNlZCBhcyBkaXJlY3QgYmluZGluZyBwb2ludHMsIHRoZXkgd2lsbCBub3QgYWZmZWN0IHRyYW5zZm9ybSBmZWVkYmFjayBvclxuICAgIC8vIHVuaWZvcm0gYnVmZmVyIHN0YXRlLiBJbnN0ZWFkIGluZGV4ZWQgYmluZGluZ3MgbmVlZCB0byBiZSBtYWRlLlxuICAgIGNvbnN0IHR5cGUgPSAodGFyZ2V0ID09PSBHTC5VTklGT1JNX0JVRkZFUiB8fCB0YXJnZXQgPT09IEdMLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIpID9cbiAgICAgIChzaXplICE9PSB1bmRlZmluZWQgPyAncmFuZ2VkJyA6ICcgaW5kZXhlZCcpIDogJ25vbi1pbmRleGVkJztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ25vbi1pbmRleGVkJzpcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luZGV4ZWQnOlxuICAgICAgYXNzZXJ0V2ViR0wyQ29udGV4dCh0aGlzLmdsKTtcbiAgICAgIGFzc2VydChvZmZzZXQgPT09IDAsIEVSUl9CVUZGRVJfUEFSQU1TKTsgLy8gTWFrZSBzdXJlIG9mZnNldCB3YXNuJ3Qgc3VwcGxpZWRcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlckJhc2UodGFyZ2V0LCBpbmRleCwgdGhpcy5oYW5kbGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmFuZ2VkJzpcbiAgICAgIGFzc2VydFdlYkdMMkNvbnRleHQodGhpcy5nbCk7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXJSYW5nZSh0YXJnZXQsIGluZGV4LCB0aGlzLmhhbmRsZSwgb2Zmc2V0LCBzaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0JVRkZFUl9QQVJBTVMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW5iaW5kKHt0YXJnZXQgPSB0aGlzLnRhcmdldCwgaW5kZXggPSB0aGlzLmluZGV4fSA9IHt9KSB7XG4gICAgY29uc3QgaXNJbmRleGVkQnVmZmVyID0gdGFyZ2V0ID09PSBHTC5VTklGT1JNX0JVRkZFUiB8fCB0YXJnZXQgPT09IEdMLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVI7XG4gICAgaWYgKGlzSW5kZXhlZEJ1ZmZlcikge1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyQmFzZSh0YXJnZXQsIGluZGV4LCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9CSU5ESU5HOiBSZXR1cm5zIGEgV2ViR0xCdWZmZXIuXG4gIC8vIGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRTogUmV0dXJucyBhIEdMc2l6ZWlwdHIuXG4gIC8vIGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU1RBUlQ6IFJldHVybnMgYSBHTGludHB0ci5cbiAgLy8gZ2wuVU5JRk9STV9CVUZGRVJfQklORElORzogUmV0dXJucyBhIFdlYkdMQnVmZmVyLlxuICAvLyBnbC5VTklGT1JNX0JVRkZFUl9TSVpFOiBSZXR1cm5zIGEgR0xzaXplaXB0ci5cbiAgLy8gZ2wuVU5JRk9STV9CVUZGRVJfU1RBUlQ6IFJldHVybnMgYSBHTGludHB0ci5cbiAgZ2V0SW5kZXhlZFBhcmFtZXRlcihiaW5kaW5nLCBpbmRleCkge1xuICAgIC8vIENyZWF0ZSB0aGUgYnVmZmVyIC0gaWYgYmluZGluZyBpdCBoZXJlIGZvciB0aGUgZmlyc3QgdGltZSwgdGhpcyBsb2NrcyB0aGUgdHlwZVxuICAgIC8vIEluIFdlYkdMMiwgdXNlIEdMLkNPUFlfUkVBRF9CVUZGRVIgdG8gYXZvaWQgbG9ja2luZyB0aGUgdHlwZVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2wud2ViZ2wyID8gR0wuQ09QWV9SRUFEX0JVRkZFUiA6IHRoaXMudGFyZ2V0O1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRJbmRleGVkUGFyYW1ldGVyKGJpbmRpbmcsIGluZGV4KTtcbiAgfVxuXG4gIC8vIFJFU09VUkNFIE1FVEhPRFNcblxuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgX2RlbGV0ZUhhbmRsZSgpIHtcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmhhbmRsZSk7XG4gIH1cblxuICBfZ2V0UGFyYW1ldGVyKHBuYW1lKSB7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdsLmdldEJ1ZmZlclBhcmFtZXRlcih0aGlzLnRhcmdldCwgcG5hbWUpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgbnVsbCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4iXX0=

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webgl__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl_uniforms__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__deprecated_scenegraph_object_3d__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__deprecated_scenegraph_object_3d___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__deprecated_scenegraph_object_3d__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_globals__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__utils_globals__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__debug_seer_integration__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_assert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_seer__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_seer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_seer__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// A scenegraph object node








// import {SHADERS} from '../experimental/shaders';




var MSG_INSTANCED_PARAM_DEPRECATED = 'Warning: Model constructor: parameter "instanced" renamed to "isInstanced".\nThis will become a hard error in a future version of luma.gl.';

var ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';

// Model abstract O3D Class

var Model = function (_Object3D) {
  _inherits(Model, _Object3D);

  function Model(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Model);

    opts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__webgl__["isWebGLContext"])(gl) ? Object.assign({}, opts, { gl: gl }) : gl;

    var _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this, opts));

    _this.init(opts);
    return _this;
  }

  /* eslint-disable max-statements  */
  /* eslint-disable complexity  */


  _createClass(Model, [{
    key: 'init',
    value: function init() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          program = _ref.program,
          _ref$gl = _ref.gl,
          gl = _ref$gl === undefined ? null : _ref$gl,
          _ref$vs = _ref.vs,
          vs = _ref$vs === undefined ? __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default.a.vs : _ref$vs,
          _ref$fs = _ref.fs,
          fs = _ref$fs === undefined ? __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default.a.fs : _ref$fs,
          defaultUniforms = _ref.defaultUniforms,
          _ref$shaderlibs = _ref.shaderlibs,
          shaderlibs = _ref$shaderlibs === undefined ? {} : _ref$shaderlibs,
          _ref$isInstanced = _ref.isInstanced,
          isInstanced = _ref$isInstanced === undefined ? false : _ref$isInstanced,
          instanced = _ref.instanced,
          _ref$vertexCount = _ref.vertexCount,
          vertexCount = _ref$vertexCount === undefined ? undefined : _ref$vertexCount,
          _ref$instanceCount = _ref.instanceCount,
          instanceCount = _ref$instanceCount === undefined ? 0 : _ref$instanceCount,
          drawMode = _ref.drawMode,
          _ref$uniforms = _ref.uniforms,
          uniforms = _ref$uniforms === undefined ? {} : _ref$uniforms,
          _ref$attributes = _ref.attributes,
          attributes = _ref$attributes === undefined ? {} : _ref$attributes,
          _ref$geometry = _ref.geometry,
          geometry = _ref$geometry === undefined ? null : _ref$geometry,
          _ref$pickable = _ref.pickable,
          pickable = _ref$pickable === undefined ? true : _ref$pickable,
          _ref$pick = _ref.pick,
          pick = _ref$pick === undefined ? null : _ref$pick,
          _ref$render = _ref.render,
          render = _ref$render === undefined ? null : _ref$render,
          _ref$onBeforeRender = _ref.onBeforeRender,
          onBeforeRender = _ref$onBeforeRender === undefined ? function () {} : _ref$onBeforeRender,
          _ref$onAfterRender = _ref.onAfterRender,
          onAfterRender = _ref$onAfterRender === undefined ? function () {} : _ref$onAfterRender,
          _ref$timerQueryEnable = _ref.timerQueryEnabled,
          timerQueryEnabled = _ref$timerQueryEnable === undefined ? false : _ref$timerQueryEnable;

      // Assign default uniforms if any of the default shaders is being used
      if (vs === __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default.a.vs || fs === __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default.a.fs && defaultUniforms === undefined) {
        defaultUniforms = __WEBPACK_IMPORTED_MODULE_6__deprecated_shaderlib___default.a.defaultUniforms;
      }

      // set a custom program per o3d
      this.program = program || new __WEBPACK_IMPORTED_MODULE_0__webgl__["Program"](gl, { vs: vs, fs: fs });
      __WEBPACK_IMPORTED_MODULE_8_assert___default()(this.program instanceof __WEBPACK_IMPORTED_MODULE_0__webgl__["Program"], 'Model needs a program');

      if (instanced) {
        /* global console */
        /* eslint-disable no-console */
        console.warn(MSG_INSTANCED_PARAM_DEPRECATED);
        isInstanced = isInstanced || instanced;
      }

      // TODO - remove?
      this.buffers = {};
      this.userData = {};
      this.drawParams = {};
      this.dynamic = false;
      this.needsRedraw = true;

      // Attributes and buffers
      this.setGeometry(geometry);

      this.attributes = {};
      this.setAttributes(attributes);

      uniforms = Object.assign({}, this.program.defaultUniforms, uniforms);
      this.uniforms = {};
      this.setUniforms(uniforms);

      // geometry might have set drawMode and vertexCount
      if (drawMode !== undefined) {
        this.drawMode = drawMode;
      }
      if (vertexCount !== undefined) {
        this.vertexCount = vertexCount;
      }
      this.isInstanced = isInstanced;
      this.instanceCount = instanceCount;

      // picking options
      this.pickable = Boolean(pickable);
      this.pick = pick || function () {
        return false;
      };

      this.onBeforeRender = onBeforeRender;
      this.onAfterRender = onAfterRender;

      // assert(program || program instanceof Program);
      __WEBPACK_IMPORTED_MODULE_8_assert___default()(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);

      // TimerQuery - TODO replace with Query class
      this.ext = this.program.gl.getExtension('EXT_disjoint_timer_query');
      this.timerQueryEnabled = timerQueryEnabled && this.ext !== null;
      this.timeElapsedQuery = undefined;
      this.lastQueryReturned = true;

      this.stats = {
        accumulatedFrameTime: 0,
        averageFrameTime: 0,
        profileFrameCount: 0
      };
    }
    /* eslint-enable max-statements */
    /* eslint-enable complexity */

  }, {
    key: 'destroy',
    value: function destroy() {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__debug_seer_integration__["a" /* removeModel */])(this.id);
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = redraw;
      return this;
    }
  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? false : _ref2$clearRedrawFlag;

      var redraw = false;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      redraw = redraw || this.geometry.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      return redraw;
    }
  }, {
    key: 'setDrawMode',
    value: function setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
  }, {
    key: 'getDrawMode',
    value: function getDrawMode() {
      return this.drawMode;
    }
  }, {
    key: 'setVertexCount',
    value: function setVertexCount(vertexCount) {
      __WEBPACK_IMPORTED_MODULE_8_assert___default()(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
  }, {
    key: 'getVertexCount',
    value: function getVertexCount() {
      return this.vertexCount;
    }
  }, {
    key: 'setInstanceCount',
    value: function setInstanceCount(instanceCount) {
      __WEBPACK_IMPORTED_MODULE_8_assert___default()(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
  }, {
    key: 'getInstanceCount',
    value: function getInstanceCount() {
      return this.instanceCount;
    }
  }, {
    key: 'getProgram',
    value: function getProgram() {
      return this.program;
    }

    // TODO - just set attributes, don't hold on to geometry

  }, {
    key: 'setGeometry',
    value: function setGeometry(geometry) {
      this.geometry = geometry;
      this.vertexCount = geometry.getVertexCount();
      this.drawMode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__webgl_api__["d" /* glGet */])(geometry.drawMode);
      this._createBuffersFromAttributeDescriptors(this.geometry.getAttributes());
      this.setNeedsRedraw();
      return this;
    }
  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }
  }, {
    key: 'setAttributes',
    value: function setAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      Object.assign(this.attributes, attributes);
      this._createBuffersFromAttributeDescriptors(attributes);
      this.setNeedsRedraw();
      return this;
    }
  }, {
    key: 'getUniforms',
    value: function getUniforms() {
      return this.uniforms;
    }

    // TODO - should actually set the uniforms

  }, {
    key: 'setUniforms',
    value: function setUniforms() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__webgl__["checkUniformValues"])(uniforms, this.id);
      Object.assign(this.uniforms, uniforms);
      this.setNeedsRedraw();
      return this;
    }

    // TODO - uniform names are too strongly linked camera <=> default shaders
    // At least all special handling is collected here.

  }, {
    key: 'addViewUniforms',
    value: function addViewUniforms(uniforms) {
      // TODO - special treatment of these parameters should be removed
      var camera = uniforms.camera,
          viewMatrix = uniforms.viewMatrix,
          modelMatrix = uniforms.modelMatrix;
      // Camera exposes uniforms that can be used directly in shaders

      var cameraUniforms = camera ? camera.getUniforms() : {};

      var viewUniforms = viewMatrix ? this.getCoordinateUniforms(viewMatrix, modelMatrix) : {};

      return Object.assign({}, uniforms, cameraUniforms, viewUniforms);
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var _ref3$uniforms = _ref3.uniforms,
          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms,
          _ref3$attributes = _ref3.attributes,
          attributes = _ref3$attributes === undefined ? {} : _ref3$attributes,
          _ref3$settings = _ref3.settings,
          settings = _ref3$settings === undefined ? {} : _ref3$settings,
          _ref3$samplers = _ref3.samplers,
          samplers = _ref3$samplers === undefined ? {} : _ref3$samplers;

      return this.render(uniforms, attributes, samplers, settings);
    }
  }, {
    key: 'render',
    value: function render() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var samplers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (__WEBPACK_IMPORTED_MODULE_5__utils_globals__["window"].__SEER_INITIALIZED__) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__debug_seer_integration__["b" /* addModel */])(this);
      }

      var resolvedUniforms = this.addViewUniforms(uniforms);

      this.setUniforms(resolvedUniforms);

      __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, '>>> RENDERING MODEL ' + this.id, this);

      this.setProgramState();

      this._logAttributesAndUniforms(3, resolvedUniforms);

      this.onBeforeRender();

      var drawParams = this.drawParams;
      if (drawParams.isInstanced && !this.isInstanced) {
        __WEBPACK_IMPORTED_MODULE_4__utils__["log"].warn(0, 'Found instanced attributes on non-instanced model');
      }
      var isIndexed = drawParams.isIndexed,
          indexType = drawParams.indexType;
      var isInstanced = this.isInstanced,
          instanceCount = this.instanceCount;


      this._timerQueryStart();

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__webgl__["draw"])(this.program.gl, {
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        isIndexed: isIndexed,
        indexType: indexType,
        isInstanced: isInstanced,
        instanceCount: instanceCount
      });

      this._timerQueryEnd();

      this.onAfterRender();

      this.unsetProgramState();

      this.setNeedsRedraw(false);

      __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, '<<< RENDERING MODEL ' + this.id + ' - complete');

      return this;
    }
  }, {
    key: 'setProgramState',
    value: function setProgramState() {
      var program = this.program;

      program.use();
      this.drawParams = {};
      program.setBuffers(this.buffers, { drawParams: this.drawParams });
      program.setUniforms(this.uniforms, this.samplers);
      return this;
    }
  }, {
    key: 'unsetProgramState',
    value: function unsetProgramState() {
      // Ensures all vertex attributes are disabled and ELEMENT_ARRAY_BUFFER
      // is unbound
      this.program.unsetBuffers();
      return this;
    }

    // PROFILING - TODO - rebuild using Query class

  }, {
    key: '_timerQueryStart',
    value: function _timerQueryStart() {
      if (this.timerQueryEnabled === true && this.lastQueryReturned === true) {
        this.program.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        this.timeElapsedQuery = this.ext.createQueryEXT();
        this.ext.beginQueryEXT(this.ext.TIME_ELAPSED_EXT, this.timeElapsedQuery);
      }
    }
  }, {
    key: '_timerQueryEnd',
    value: function _timerQueryEnd() {
      if (this.timerQueryEnabled === true) {
        if (this.lastQueryReturned === true) {
          this.ext.endQueryEXT(this.ext.TIME_ELAPSED_EXT);
          this.profileFrameCount++;
          this.lastQueryReturned = false;
        }
        // ...at some point in the future, after returning control to the browser
        // and being called again:
        var disjoint = this.program.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (disjoint) {
          this.lastQueryReturned = true;
          // Have to redo all of the measurements.
        } else {
          var available = this.ext.getQueryObjectEXT(this.timeElapsedQuery, this.ext.QUERY_RESULT_AVAILABLE_EXT);

          if (available) {
            var timeElapsed = this.ext.getQueryObjectEXT(this.timeElapsedQuery, this.ext.QUERY_RESULT_EXT) / 1e6;
            this.lastQueryReturned = true;

            // Do something useful with the time.  Note that care should be
            // taken to use all significant bits of the result, not just the
            // least significant 32 bits.

            // Update stats (e.g. for seer)
            this.stats.lastFrameTime = timeElapsed;
            this.stats.accumulatedTimeFrame += timeElapsed;
            this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;

            // Log stats
            __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, 'program.id: ', this.program.id);
            __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, 'last frame time: ' + this.stats.lastFrameTime + 'ms');
            __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, 'average frame time ' + this.stats.averageFrameTime + 'ms');
            __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, 'accumulated frame time: ' + this.stats.accumulatedFrameTime + 'ms');
            __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(2, 'profile frame count: ' + this.stats.profileFrameCount);
          }
        }
      }
    }

    // Makes sure buffers are created for all attributes
    // and that the program is updated with those buffers
    // TODO - do we need the separation between "attributes" and "buffers"
    // couldn't apps just create buffers directly?

  }, {
    key: '_createBuffersFromAttributeDescriptors',
    value: function _createBuffersFromAttributeDescriptors(attributes) {
      var gl = this.program.gl;


      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute instanceof __WEBPACK_IMPORTED_MODULE_0__webgl__["Buffer"]) {
          this.buffers[attributeName] = attribute;
        } else {
          // Autocreate a buffer
          this.buffers[attributeName] = this.buffers[attributeName] || new __WEBPACK_IMPORTED_MODULE_0__webgl__["Buffer"](gl, {
            target: attribute.isIndexed ? __WEBPACK_IMPORTED_MODULE_0__webgl__["GL"].ELEMENT_ARRAY_BUFFER : __WEBPACK_IMPORTED_MODULE_0__webgl__["GL"].ARRAY_BUFFER
          });

          var buffer = this.buffers[attributeName];
          buffer.setData({ data: attribute.value }).setDataLayout(attribute);
        }
      }

      return this;
    }
  }, {
    key: '_logAttributesAndUniforms',
    value: function _logAttributesAndUniforms() {
      var priority = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
      var uniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (__WEBPACK_IMPORTED_MODULE_4__utils__["log"].priority >= priority) {
        var attributeTable = this._getAttributesTable({
          header: 'Attributes ' + this.id,
          program: this.program,
          attributes: Object.assign({}, this.geometry.attributes, this.attributes)
        });
        __WEBPACK_IMPORTED_MODULE_4__utils__["log"].table(priority, attributeTable);

        var _getUniformsTable = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__webgl_uniforms__["d" /* getUniformsTable */])({
          header: 'Uniforms ' + this.id,
          program: this.program,
          uniforms: Object.assign({}, this.uniforms, uniforms)
        }),
            table = _getUniformsTable.table,
            unusedTable = _getUniformsTable.unusedTable,
            unusedCount = _getUniformsTable.unusedCount;

        __WEBPACK_IMPORTED_MODULE_4__utils__["log"].table(priority, table);
        __WEBPACK_IMPORTED_MODULE_4__utils__["log"].log(priority, (unusedCount || 'No') + ' unused uniforms ', unusedTable);
      }

      if (__WEBPACK_IMPORTED_MODULE_5__utils_globals__["window"].__SEER_INITIALIZED__) {
        var uniformsObject = Object.assign({}, this.uniforms, uniforms);
        __WEBPACK_IMPORTED_MODULE_9_seer___default.a.indexedListItem('luma.gl', this.id, uniformsObject);
      }
    }

    // Todo move to attributes manager

  }, {
    key: '_getAttributesTable',
    value: function _getAttributesTable() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          attributes = _ref4.attributes,
          _ref4$header = _ref4.header,
          header = _ref4$header === undefined ? 'Attributes' : _ref4$header,
          instanced = _ref4.instanced,
          program = _ref4.program;

      __WEBPACK_IMPORTED_MODULE_8_assert___default()(program);
      var attributeLocations = program._attributeLocations;
      var table = _defineProperty({}, header, {});

      // Add used attributes
      for (var attributeName in attributeLocations) {
        var attribute = attributes[attributeName];
        var location = attributeLocations[attributeName];
        table[attributeName] = this._getAttributeEntry(attribute, location);
      }

      // Add any unused attributes
      for (var _attributeName in attributes) {
        var _attribute = attributes[_attributeName];
        if (!table[_attributeName]) {
          table[_attributeName] = this._getAttributeEntry(_attribute, null);
        }
      }

      return table;
    }
  }, {
    key: '_getAttributeEntry',
    value: function _getAttributeEntry(attribute, location) {
      var round = function round(num) {
        return Math.round(num * 10) / 10;
      };

      var type = 'NOT PROVIDED';
      var instanced = 0;
      var size = 'N/A';
      var verts = 'N/A';
      var bytes = 'N/A';
      var value = 'N/A';

      if (attribute && location === null) {
        location = attribute.isIndexed ? 'ELEMENT_ARRAY_BUFFER' : 'NOT USED';
      }

      if (attribute instanceof __WEBPACK_IMPORTED_MODULE_0__webgl__["Buffer"]) {
        var buffer = attribute;
        type = buffer.layout.type;
        instanced = buffer.layout.instanced;
        size = buffer.layout.size;
        verts = round(buffer.data.length / buffer.layout.size);
        bytes = buffer.data.length * buffer.data.BYTES_PER_ELEMENT;
      } else if (attribute) {
        type = attribute.value.constructor.name;
        instanced = attribute.instanced;
        size = attribute.size;
        verts = round(attribute.value.length / attribute.size);
        bytes = attribute.value.length * attribute.value.BYTES_PER_ELEMENT;
        value = attribute.value;
      }

      // Generate a type name by dropping Array from Float32Array etc.
      type = String(type).replace('Array', '');
      // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array
      var isInteger = type.indexOf('nt') !== -1;

      return {
        Location: '' + location + (instanced ? ' [instanced]' : ''),
        'Type Size x Verts = Bytes': type + ' ' + size + ' x ' + verts + ' = ' + bytes,
        Value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["formatValue"])(value, { size: size, isInteger: isInteger })
      };
    }

    // DEPRECATED / REMOVED

  }, {
    key: 'isPickable',
    value: function isPickable() {
      return this.pickable;
    }
  }, {
    key: 'setPickable',
    value: function setPickable() {
      var pickable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.pickable = Boolean(pickable);
      return this;
    }
  }, {
    key: 'getGeometry',
    value: function getGeometry() {
      return this.geometry;
    }
  }]);

  return Model;
}(__WEBPACK_IMPORTED_MODULE_3__deprecated_scenegraph_object_3d___default.a);

/* harmony default export */ __webpack_exports__["a"] = (Model);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL21vZGVsLmpzIl0sIm5hbWVzIjpbIkdMIiwiQnVmZmVyIiwiUHJvZ3JhbSIsImRyYXciLCJjaGVja1VuaWZvcm1WYWx1ZXMiLCJpc1dlYkdMQ29udGV4dCIsImdldFVuaWZvcm1zVGFibGUiLCJnbEdldCIsIk9iamVjdDNEIiwibG9nIiwiZm9ybWF0VmFsdWUiLCJ3aW5kb3ciLCJTSEFERVJTIiwiYWRkTW9kZWwiLCJyZW1vdmVNb2RlbCIsImFzc2VydCIsInNlZXIiLCJNU0dfSU5TVEFOQ0VEX1BBUkFNX0RFUFJFQ0FURUQiLCJFUlJfTU9ERUxfUEFSQU1TIiwiTW9kZWwiLCJnbCIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbml0IiwicHJvZ3JhbSIsInZzIiwiZnMiLCJkZWZhdWx0VW5pZm9ybXMiLCJzaGFkZXJsaWJzIiwiaXNJbnN0YW5jZWQiLCJpbnN0YW5jZWQiLCJ2ZXJ0ZXhDb3VudCIsInVuZGVmaW5lZCIsImluc3RhbmNlQ291bnQiLCJkcmF3TW9kZSIsInVuaWZvcm1zIiwiYXR0cmlidXRlcyIsImdlb21ldHJ5IiwicGlja2FibGUiLCJwaWNrIiwicmVuZGVyIiwib25CZWZvcmVSZW5kZXIiLCJvbkFmdGVyUmVuZGVyIiwidGltZXJRdWVyeUVuYWJsZWQiLCJjb25zb2xlIiwid2FybiIsImJ1ZmZlcnMiLCJ1c2VyRGF0YSIsImRyYXdQYXJhbXMiLCJkeW5hbWljIiwibmVlZHNSZWRyYXciLCJzZXRHZW9tZXRyeSIsInNldEF0dHJpYnV0ZXMiLCJzZXRVbmlmb3JtcyIsIkJvb2xlYW4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImV4dCIsImdldEV4dGVuc2lvbiIsInRpbWVFbGFwc2VkUXVlcnkiLCJsYXN0UXVlcnlSZXR1cm5lZCIsInN0YXRzIiwiYWNjdW11bGF0ZWRGcmFtZVRpbWUiLCJhdmVyYWdlRnJhbWVUaW1lIiwicHJvZmlsZUZyYW1lQ291bnQiLCJpZCIsInJlZHJhdyIsImNsZWFyUmVkcmF3RmxhZ3MiLCJnZXROZWVkc1JlZHJhdyIsImdldFZlcnRleENvdW50IiwiX2NyZWF0ZUJ1ZmZlcnNGcm9tQXR0cmlidXRlRGVzY3JpcHRvcnMiLCJnZXRBdHRyaWJ1dGVzIiwic2V0TmVlZHNSZWRyYXciLCJjYW1lcmEiLCJ2aWV3TWF0cml4IiwibW9kZWxNYXRyaXgiLCJjYW1lcmFVbmlmb3JtcyIsImdldFVuaWZvcm1zIiwidmlld1VuaWZvcm1zIiwiZ2V0Q29vcmRpbmF0ZVVuaWZvcm1zIiwic2V0dGluZ3MiLCJzYW1wbGVycyIsIl9fU0VFUl9JTklUSUFMSVpFRF9fIiwicmVzb2x2ZWRVbmlmb3JtcyIsImFkZFZpZXdVbmlmb3JtcyIsInNldFByb2dyYW1TdGF0ZSIsIl9sb2dBdHRyaWJ1dGVzQW5kVW5pZm9ybXMiLCJpc0luZGV4ZWQiLCJpbmRleFR5cGUiLCJfdGltZXJRdWVyeVN0YXJ0IiwiZ2V0RHJhd01vZGUiLCJfdGltZXJRdWVyeUVuZCIsInVuc2V0UHJvZ3JhbVN0YXRlIiwidXNlIiwic2V0QnVmZmVycyIsInVuc2V0QnVmZmVycyIsImdldFBhcmFtZXRlciIsIkdQVV9ESVNKT0lOVF9FWFQiLCJjcmVhdGVRdWVyeUVYVCIsImJlZ2luUXVlcnlFWFQiLCJUSU1FX0VMQVBTRURfRVhUIiwiZW5kUXVlcnlFWFQiLCJkaXNqb2ludCIsImF2YWlsYWJsZSIsImdldFF1ZXJ5T2JqZWN0RVhUIiwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQiLCJ0aW1lRWxhcHNlZCIsIlFVRVJZX1JFU1VMVF9FWFQiLCJsYXN0RnJhbWVUaW1lIiwiYWNjdW11bGF0ZWRUaW1lRnJhbWUiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXIiLCJzZXREYXRhIiwiZGF0YSIsInZhbHVlIiwic2V0RGF0YUxheW91dCIsInByaW9yaXR5IiwiYXR0cmlidXRlVGFibGUiLCJfZ2V0QXR0cmlidXRlc1RhYmxlIiwiaGVhZGVyIiwidGFibGUiLCJ1bnVzZWRUYWJsZSIsInVudXNlZENvdW50IiwidW5pZm9ybXNPYmplY3QiLCJpbmRleGVkTGlzdEl0ZW0iLCJhdHRyaWJ1dGVMb2NhdGlvbnMiLCJfYXR0cmlidXRlTG9jYXRpb25zIiwibG9jYXRpb24iLCJfZ2V0QXR0cmlidXRlRW50cnkiLCJyb3VuZCIsIk1hdGgiLCJudW0iLCJ0eXBlIiwic2l6ZSIsInZlcnRzIiwiYnl0ZXMiLCJsYXlvdXQiLCJsZW5ndGgiLCJCWVRFU19QRVJfRUxFTUVOVCIsImNvbnN0cnVjdG9yIiwibmFtZSIsIlN0cmluZyIsInJlcGxhY2UiLCJpc0ludGVnZXIiLCJpbmRleE9mIiwiTG9jYXRpb24iLCJWYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsU0FBUUEsRUFBUixFQUFZQyxNQUFaLEVBQW9CQyxPQUFwQixFQUE2QkMsSUFBN0IsRUFBbUNDLGtCQUFuQyxFQUF1REMsY0FBdkQsUUFBNEUsVUFBNUU7QUFDQSxTQUFRQyxnQkFBUixRQUErQixtQkFBL0I7QUFDQSxTQUFRQyxLQUFSLFFBQW9CLGNBQXBCOztBQUVBLE9BQU9DLFFBQVAsTUFBcUIsb0NBQXJCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxXQUFiLFFBQStCLFVBQS9CO0FBQ0EsU0FBUUMsTUFBUixRQUFxQixrQkFBckI7QUFDQSxPQUFPQyxPQUFQLE1BQW9CLHlCQUFwQjtBQUNBO0FBQ0EsU0FBUUMsUUFBUixFQUFrQkMsV0FBbEIsUUFBb0MsMkJBQXBDO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjtBQUNBLE9BQU9DLElBQVAsTUFBaUIsTUFBakI7O0FBRUEsSUFBTUMsNktBQU47O0FBSUEsSUFBTUMsbUJBQW1CLHNDQUF6Qjs7QUFFQTs7SUFDcUJDLEs7OztBQUNuQixpQkFBWUMsRUFBWixFQUEyQjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFDekJBLFdBQU9oQixlQUFlZSxFQUFmLElBQXFCRSxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFr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TUMsWUFBWVgsS0FBS1ksT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBQyxDQUExQzs7QUFFQSxhQUFPO0FBQ0xDLHVCQUFhbEIsUUFBYixJQUF3QnJHLFlBQVksY0FBWixHQUE2QixFQUFyRCxDQURLO0FBRUwscUNBQWdDMEcsSUFBaEMsU0FBd0NDLElBQXhDLFdBQWtEQyxLQUFsRCxXQUE2REMsS0FGeEQ7QUFHTFcsZUFBTzdJLFlBQVk2RyxLQUFaLEVBQW1CLEVBQUNtQixVQUFELEVBQU9VLG9CQUFQLEVBQW5CO0FBSEYsT0FBUDtBQUtEOztBQUVEOzs7O2lDQUNhO0FBQ1gsYUFBTyxLQUFLN0csUUFBWjtBQUNEOzs7a0NBRTRCO0FBQUEsVUFBakJBLFFBQWlCLHVFQUFOLElBQU07O0FBQzNCLFdBQUtBLFFBQUwsR0FBZ0JnQixRQUFRaEIsUUFBUixDQUFoQjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7a0NBRWE7QUFDWixhQUFPLEtBQUtELFFBQVo7QUFDRDs7OztFQTdjZ0M5QixROztlQUFkVyxLIiwiZmlsZSI6Im1vZGVsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBzY2VuZWdyYXBoIG9iamVjdCBub2RlXG5pbXBvcnQge0dMLCBCdWZmZXIsIFByb2dyYW0sIGRyYXcsIGNoZWNrVW5pZm9ybVZhbHVlcywgaXNXZWJHTENvbnRleHR9IGZyb20gJy4uL3dlYmdsJztcbmltcG9ydCB7Z2V0VW5pZm9ybXNUYWJsZX0gZnJvbSAnLi4vd2ViZ2wvdW5pZm9ybXMnO1xuaW1wb3J0IHtnbEdldH0gZnJvbSAnLi4vd2ViZ2wvYXBpJztcblxuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL2RlcHJlY2F0ZWQvc2NlbmVncmFwaC9vYmplY3QtM2QnO1xuaW1wb3J0IHtsb2csIGZvcm1hdFZhbHVlfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge3dpbmRvd30gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgU0hBREVSUyBmcm9tICcuLi9kZXByZWNhdGVkL3NoYWRlcmxpYic7XG4vLyBpbXBvcnQge1NIQURFUlN9IGZyb20gJy4uL2V4cGVyaW1lbnRhbC9zaGFkZXJzJztcbmltcG9ydCB7YWRkTW9kZWwsIHJlbW92ZU1vZGVsfSBmcm9tICcuLi9kZWJ1Zy9zZWVyLWludGVncmF0aW9uJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBzZWVyIGZyb20gJ3NlZXInO1xuXG5jb25zdCBNU0dfSU5TVEFOQ0VEX1BBUkFNX0RFUFJFQ0FURUQgPSBgXFxcbldhcm5pbmc6IE1vZGVsIGNvbnN0cnVjdG9yOiBwYXJhbWV0ZXIgXCJpbnN0YW5jZWRcIiByZW5hbWVkIHRvIFwiaXNJbnN0YW5jZWRcIi5cblRoaXMgd2lsbCBiZWNvbWUgYSBoYXJkIGVycm9yIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgbHVtYS5nbC5gO1xuXG5jb25zdCBFUlJfTU9ERUxfUEFSQU1TID0gJ01vZGVsIG5lZWRzIGRyYXdNb2RlIGFuZCB2ZXJ0ZXhDb3VudCc7XG5cbi8vIE1vZGVsIGFic3RyYWN0IE8zRCBDbGFzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWwgZXh0ZW5kcyBPYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzID0ge30pIHtcbiAgICBvcHRzID0gaXNXZWJHTENvbnRleHQoZ2wpID8gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge2dsfSkgOiBnbDtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLmluaXQob3B0cyk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAgKi9cbiAgaW5pdCh7XG4gICAgcHJvZ3JhbSxcbiAgICBnbCA9IG51bGwsXG4gICAgdnMgPSBTSEFERVJTLnZzLFxuICAgIGZzID0gU0hBREVSUy5mcyxcbiAgICBkZWZhdWx0VW5pZm9ybXMsXG4gICAgc2hhZGVybGlicyA9IHt9LFxuXG4gICAgaXNJbnN0YW5jZWQgPSBmYWxzZSwgLy8gRW5hYmxlcyBpbnN0YW5jZWQgcmVuZGVyaW5nXG4gICAgaW5zdGFuY2VkLCAvLyBkZXByZWNhdGVkXG4gICAgdmVydGV4Q291bnQgPSB1bmRlZmluZWQsXG4gICAgaW5zdGFuY2VDb3VudCA9IDAsXG5cbiAgICAvLyBFeHRyYSB1bmlmb3JtcyBhbmQgYXR0cmlidXRlcyAoYmV5b25kIGdlb21ldHJ5LCBtYXRlcmlhbCwgY2FtZXJhKVxuICAgIGRyYXdNb2RlLFxuICAgIHVuaWZvcm1zID0ge30sXG4gICAgYXR0cmlidXRlcyA9IHt9LFxuICAgIGdlb21ldHJ5ID0gbnVsbCxcblxuICAgIC8vIFBpY2tpbmdcbiAgICBwaWNrYWJsZSA9IHRydWUsXG4gICAgcGljayA9IG51bGwsXG4gICAgcmVuZGVyID0gbnVsbCxcbiAgICBvbkJlZm9yZVJlbmRlciA9ICgpID0+IHt9LFxuICAgIG9uQWZ0ZXJSZW5kZXIgPSAoKSA9PiB7fSxcblxuICAgIC8vIE90aGVyIG9wdHNcbiAgICB0aW1lclF1ZXJ5RW5hYmxlZCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHVuaWZvcm1zIGlmIGFueSBvZiB0aGUgZGVmYXVsdCBzaGFkZXJzIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodnMgPT09IFNIQURFUlMudnMgfHwgZnMgPT09IFNIQURFUlMuZnMgJiYgZGVmYXVsdFVuaWZvcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmF1bHRVbmlmb3JtcyA9IFNIQURFUlMuZGVmYXVsdFVuaWZvcm1zO1xuICAgIH1cblxuICAgIC8vIHNldCBhIGN1c3RvbSBwcm9ncmFtIHBlciBvM2RcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtIHx8IG5ldyBQcm9ncmFtKGdsLCB7dnMsIGZzfSk7XG4gICAgYXNzZXJ0KHRoaXMucHJvZ3JhbSBpbnN0YW5jZW9mIFByb2dyYW0sICdNb2RlbCBuZWVkcyBhIHByb2dyYW0nKTtcblxuICAgIGlmIChpbnN0YW5jZWQpIHtcbiAgICAgIC8qIGdsb2JhbCBjb25zb2xlICovXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLndhcm4oTVNHX0lOU1RBTkNFRF9QQVJBTV9ERVBSRUNBVEVEKTtcbiAgICAgIGlzSW5zdGFuY2VkID0gaXNJbnN0YW5jZWQgfHwgaW5zdGFuY2VkO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSByZW1vdmU/XG4gICAgdGhpcy5idWZmZXJzID0ge307XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgIHRoaXMuZHJhd1BhcmFtcyA9IHt9O1xuICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgLy8gQXR0cmlidXRlcyBhbmQgYnVmZmVyc1xuICAgIHRoaXMuc2V0R2VvbWV0cnkoZ2VvbWV0cnkpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuXG4gICAgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb2dyYW0uZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3Jtcyk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgIHRoaXMuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuXG4gICAgLy8gZ2VvbWV0cnkgbWlnaHQgaGF2ZSBzZXQgZHJhd01vZGUgYW5kIHZlcnRleENvdW50XG4gICAgaWYgKGRyYXdNb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZHJhd01vZGUgPSBkcmF3TW9kZTtcbiAgICB9XG4gICAgaWYgKHZlcnRleENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcbiAgICB9XG4gICAgdGhpcy5pc0luc3RhbmNlZCA9IGlzSW5zdGFuY2VkO1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGluc3RhbmNlQ291bnQ7XG5cbiAgICAvLyBwaWNraW5nIG9wdGlvbnNcbiAgICB0aGlzLnBpY2thYmxlID0gQm9vbGVhbihwaWNrYWJsZSk7XG4gICAgdGhpcy5waWNrID0gcGljayB8fCAoKCkgPT4gZmFsc2UpO1xuXG4gICAgdGhpcy5vbkJlZm9yZVJlbmRlciA9IG9uQmVmb3JlUmVuZGVyO1xuICAgIHRoaXMub25BZnRlclJlbmRlciA9IG9uQWZ0ZXJSZW5kZXI7XG5cbiAgICAvLyBhc3NlcnQocHJvZ3JhbSB8fCBwcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSk7XG4gICAgYXNzZXJ0KHRoaXMuZHJhd01vZGUgIT09IHVuZGVmaW5lZCAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy52ZXJ0ZXhDb3VudCksXG4gICAgICBFUlJfTU9ERUxfUEFSQU1TKTtcblxuICAgIC8vIFRpbWVyUXVlcnkgLSBUT0RPIHJlcGxhY2Ugd2l0aCBRdWVyeSBjbGFzc1xuICAgIHRoaXMuZXh0ID0gdGhpcy5wcm9ncmFtLmdsLmdldEV4dGVuc2lvbignRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5Jyk7XG4gICAgdGhpcy50aW1lclF1ZXJ5RW5hYmxlZCA9IHRpbWVyUXVlcnlFbmFibGVkICYmIHRoaXMuZXh0ICE9PSBudWxsO1xuICAgIHRoaXMudGltZUVsYXBzZWRRdWVyeSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhc3RRdWVyeVJldHVybmVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICBhY2N1bXVsYXRlZEZyYW1lVGltZTogMCxcbiAgICAgIGF2ZXJhZ2VGcmFtZVRpbWU6IDAsXG4gICAgICBwcm9maWxlRnJhbWVDb3VudDogMFxuICAgIH07XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICBkZXN0cm95KCkge1xuICAgIHJlbW92ZU1vZGVsKHRoaXMuaWQpO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLmdlb21ldHJ5LmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSk7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIHNldERyYXdNb2RlKGRyYXdNb2RlKSB7XG4gICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0RHJhd01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd01vZGU7XG4gIH1cblxuICBzZXRWZXJ0ZXhDb3VudCh2ZXJ0ZXhDb3VudCkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodmVydGV4Q291bnQpKTtcbiAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRWZXJ0ZXhDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhDb3VudDtcbiAgfVxuXG4gIHNldEluc3RhbmNlQ291bnQoaW5zdGFuY2VDb3VudCkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoaW5zdGFuY2VDb3VudCkpO1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGluc3RhbmNlQ291bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRJbnN0YW5jZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlQ291bnQ7XG4gIH1cblxuICBnZXRQcm9ncmFtKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyYW07XG4gIH1cblxuICAvLyBUT0RPIC0ganVzdCBzZXQgYXR0cmlidXRlcywgZG9uJ3QgaG9sZCBvbiB0byBnZW9tZXRyeVxuICBzZXRHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLnZlcnRleENvdW50ID0gZ2VvbWV0cnkuZ2V0VmVydGV4Q291bnQoKTtcbiAgICB0aGlzLmRyYXdNb2RlID0gZ2xHZXQoZ2VvbWV0cnkuZHJhd01vZGUpO1xuICAgIHRoaXMuX2NyZWF0ZUJ1ZmZlcnNGcm9tQXR0cmlidXRlRGVzY3JpcHRvcnModGhpcy5nZW9tZXRyeS5nZXRBdHRyaWJ1dGVzKCkpO1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuX2NyZWF0ZUJ1ZmZlcnNGcm9tQXR0cmlidXRlRGVzY3JpcHRvcnMoYXR0cmlidXRlcyk7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0VW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXM7XG4gIH1cblxuICAvLyBUT0RPIC0gc2hvdWxkIGFjdHVhbGx5IHNldCB0aGUgdW5pZm9ybXNcbiAgc2V0VW5pZm9ybXModW5pZm9ybXMgPSB7fSkge1xuICAgIGNoZWNrVW5pZm9ybVZhbHVlcyh1bmlmb3JtcywgdGhpcy5pZCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnVuaWZvcm1zLCB1bmlmb3Jtcyk7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gVE9ETyAtIHVuaWZvcm0gbmFtZXMgYXJlIHRvbyBzdHJvbmdseSBsaW5rZWQgY2FtZXJhIDw9PiBkZWZhdWx0IHNoYWRlcnNcbiAgLy8gQXQgbGVhc3QgYWxsIHNwZWNpYWwgaGFuZGxpbmcgaXMgY29sbGVjdGVkIGhlcmUuXG4gIGFkZFZpZXdVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgIC8vIFRPRE8gLSBzcGVjaWFsIHRyZWF0bWVudCBvZiB0aGVzZSBwYXJhbWV0ZXJzIHNob3VsZCBiZSByZW1vdmVkXG4gICAgY29uc3Qge2NhbWVyYSwgdmlld01hdHJpeCwgbW9kZWxNYXRyaXh9ID0gdW5pZm9ybXM7XG4gICAgLy8gQ2FtZXJhIGV4cG9zZXMgdW5pZm9ybXMgdGhhdCBjYW4gYmUgdXNlZCBkaXJlY3RseSBpbiBzaGFkZXJzXG4gICAgY29uc3QgY2FtZXJhVW5pZm9ybXMgPSBjYW1lcmEgPyBjYW1lcmEuZ2V0VW5pZm9ybXMoKSA6IHt9O1xuXG4gICAgY29uc3Qgdmlld1VuaWZvcm1zID0gdmlld01hdHJpeCA/XG4gICAgICB0aGlzLmdldENvb3JkaW5hdGVVbmlmb3Jtcyh2aWV3TWF0cml4LCBtb2RlbE1hdHJpeCkgOiB7fTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3JtcywgY2FtZXJhVW5pZm9ybXMsIHZpZXdVbmlmb3Jtcyk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3JtcyA9IHt9LCBhdHRyaWJ1dGVzID0ge30sIHNldHRpbmdzID0ge30sIHNhbXBsZXJzID0ge319KSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKHVuaWZvcm1zLCBhdHRyaWJ1dGVzLCBzYW1wbGVycywgc2V0dGluZ3MpO1xuICB9XG5cbiAgcmVuZGVyKHVuaWZvcm1zID0ge30sIGF0dHJpYnV0ZXMgPSB7fSwgc2V0dGluZ3MgPSB7fSwgc2FtcGxlcnMgPSB7fSkge1xuICAgIGlmICh3aW5kb3cuX19TRUVSX0lOSVRJQUxJWkVEX18pIHtcbiAgICAgIGFkZE1vZGVsKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkVW5pZm9ybXMgPSB0aGlzLmFkZFZpZXdVbmlmb3Jtcyh1bmlmb3Jtcyk7XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKHJlc29sdmVkVW5pZm9ybXMpO1xuXG4gICAgbG9nLmxvZygyLCBgPj4+IFJFTkRFUklORyBNT0RFTCAke3RoaXMuaWR9YCwgdGhpcyk7XG5cbiAgICB0aGlzLnNldFByb2dyYW1TdGF0ZSgpO1xuXG4gICAgdGhpcy5fbG9nQXR0cmlidXRlc0FuZFVuaWZvcm1zKDMsIHJlc29sdmVkVW5pZm9ybXMpO1xuXG4gICAgdGhpcy5vbkJlZm9yZVJlbmRlcigpO1xuXG4gICAgY29uc3QgZHJhd1BhcmFtcyA9IHRoaXMuZHJhd1BhcmFtcztcbiAgICBpZiAoZHJhd1BhcmFtcy5pc0luc3RhbmNlZCAmJiAhdGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgbG9nLndhcm4oMCwgJ0ZvdW5kIGluc3RhbmNlZCBhdHRyaWJ1dGVzIG9uIG5vbi1pbnN0YW5jZWQgbW9kZWwnKTtcbiAgICB9XG4gICAgY29uc3Qge2lzSW5kZXhlZCwgaW5kZXhUeXBlfSA9IGRyYXdQYXJhbXM7XG4gICAgY29uc3Qge2lzSW5zdGFuY2VkLCBpbnN0YW5jZUNvdW50fSA9IHRoaXM7XG5cbiAgICB0aGlzLl90aW1lclF1ZXJ5U3RhcnQoKTtcblxuICAgIGRyYXcodGhpcy5wcm9ncmFtLmdsLCB7XG4gICAgICBkcmF3TW9kZTogdGhpcy5nZXREcmF3TW9kZSgpLFxuICAgICAgdmVydGV4Q291bnQ6IHRoaXMuZ2V0VmVydGV4Q291bnQoKSxcbiAgICAgIGlzSW5kZXhlZCxcbiAgICAgIGluZGV4VHlwZSxcbiAgICAgIGlzSW5zdGFuY2VkLFxuICAgICAgaW5zdGFuY2VDb3VudFxuICAgIH0pO1xuXG4gICAgdGhpcy5fdGltZXJRdWVyeUVuZCgpO1xuXG4gICAgdGhpcy5vbkFmdGVyUmVuZGVyKCk7XG5cbiAgICB0aGlzLnVuc2V0UHJvZ3JhbVN0YXRlKCk7XG5cbiAgICB0aGlzLnNldE5lZWRzUmVkcmF3KGZhbHNlKTtcblxuICAgIGxvZy5sb2coMiwgYDw8PCBSRU5ERVJJTkcgTU9ERUwgJHt0aGlzLmlkfSAtIGNvbXBsZXRlYCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByb2dyYW1TdGF0ZSgpIHtcbiAgICBjb25zdCB7cHJvZ3JhbX0gPSB0aGlzO1xuICAgIHByb2dyYW0udXNlKCk7XG4gICAgdGhpcy5kcmF3UGFyYW1zID0ge307XG4gICAgcHJvZ3JhbS5zZXRCdWZmZXJzKHRoaXMuYnVmZmVycywge2RyYXdQYXJhbXM6IHRoaXMuZHJhd1BhcmFtc30pO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybXModGhpcy51bmlmb3JtcywgdGhpcy5zYW1wbGVycyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bnNldFByb2dyYW1TdGF0ZSgpIHtcbiAgICAvLyBFbnN1cmVzIGFsbCB2ZXJ0ZXggYXR0cmlidXRlcyBhcmUgZGlzYWJsZWQgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSXG4gICAgLy8gaXMgdW5ib3VuZFxuICAgIHRoaXMucHJvZ3JhbS51bnNldEJ1ZmZlcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFBST0ZJTElORyAtIFRPRE8gLSByZWJ1aWxkIHVzaW5nIFF1ZXJ5IGNsYXNzXG4gIF90aW1lclF1ZXJ5U3RhcnQoKSB7XG4gICAgaWYgKHRoaXMudGltZXJRdWVyeUVuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5sYXN0UXVlcnlSZXR1cm5lZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5wcm9ncmFtLmdsLmdldFBhcmFtZXRlcih0aGlzLmV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgIHRoaXMudGltZUVsYXBzZWRRdWVyeSA9IHRoaXMuZXh0LmNyZWF0ZVF1ZXJ5RVhUKCk7XG4gICAgICB0aGlzLmV4dC5iZWdpblF1ZXJ5RVhUKHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHRoaXMudGltZUVsYXBzZWRRdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgX3RpbWVyUXVlcnlFbmQoKSB7XG4gICAgaWYgKHRoaXMudGltZXJRdWVyeUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RRdWVyeVJldHVybmVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZXh0LmVuZFF1ZXJ5RVhUKHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICB0aGlzLnByb2ZpbGVGcmFtZUNvdW50Kys7XG4gICAgICAgIHRoaXMubGFzdFF1ZXJ5UmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIC4uLmF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgYWZ0ZXIgcmV0dXJuaW5nIGNvbnRyb2wgdG8gdGhlIGJyb3dzZXJcbiAgICAgIC8vIGFuZCBiZWluZyBjYWxsZWQgYWdhaW46XG4gICAgICBjb25zdCBkaXNqb2ludCA9IHRoaXMucHJvZ3JhbS5nbC5nZXRQYXJhbWV0ZXIodGhpcy5leHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICBpZiAoZGlzam9pbnQpIHtcbiAgICAgICAgdGhpcy5sYXN0UXVlcnlSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgIC8vIEhhdmUgdG8gcmVkbyBhbGwgb2YgdGhlIG1lYXN1cmVtZW50cy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuZXh0LmdldFF1ZXJ5T2JqZWN0RVhUKHRoaXMudGltZUVsYXBzZWRRdWVyeSxcbiAgICAgICAgICB0aGlzLmV4dC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG5cbiAgICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gdGhpcy5leHQuZ2V0UXVlcnlPYmplY3RFWFQodGhpcy50aW1lRWxhcHNlZFF1ZXJ5LFxuICAgICAgICAgICAgdGhpcy5leHQuUVVFUllfUkVTVUxUX0VYVCkgLyAxZTY7XG4gICAgICAgICAgdGhpcy5sYXN0UXVlcnlSZXR1cm5lZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBEbyBzb21ldGhpbmcgdXNlZnVsIHdpdGggdGhlIHRpbWUuICBOb3RlIHRoYXQgY2FyZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyB0YWtlbiB0byB1c2UgYWxsIHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIHJlc3VsdCwgbm90IGp1c3QgdGhlXG4gICAgICAgICAgLy8gbGVhc3Qgc2lnbmlmaWNhbnQgMzIgYml0cy5cblxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0cyAoZS5nLiBmb3Igc2VlcilcbiAgICAgICAgICB0aGlzLnN0YXRzLmxhc3RGcmFtZVRpbWUgPSB0aW1lRWxhcHNlZDtcbiAgICAgICAgICB0aGlzLnN0YXRzLmFjY3VtdWxhdGVkVGltZUZyYW1lICs9IHRpbWVFbGFwc2VkO1xuICAgICAgICAgIHRoaXMuc3RhdHMuYXZlcmFnZUZyYW1lVGltZSA9XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmFjY3VtdWxhdGVkRnJhbWVUaW1lIC8gdGhpcy5zdGF0cy5wcm9maWxlRnJhbWVDb3VudDtcblxuICAgICAgICAgIC8vIExvZyBzdGF0c1xuICAgICAgICAgIGxvZy5sb2coMiwgJ3Byb2dyYW0uaWQ6ICcsIHRoaXMucHJvZ3JhbS5pZCk7XG4gICAgICAgICAgbG9nLmxvZygyLCBgbGFzdCBmcmFtZSB0aW1lOiAke3RoaXMuc3RhdHMubGFzdEZyYW1lVGltZX1tc2ApO1xuICAgICAgICAgIGxvZy5sb2coMiwgYGF2ZXJhZ2UgZnJhbWUgdGltZSAke3RoaXMuc3RhdHMuYXZlcmFnZUZyYW1lVGltZX1tc2ApO1xuICAgICAgICAgIGxvZy5sb2coMiwgYGFjY3VtdWxhdGVkIGZyYW1lIHRpbWU6ICR7dGhpcy5zdGF0cy5hY2N1bXVsYXRlZEZyYW1lVGltZX1tc2ApO1xuICAgICAgICAgIGxvZy5sb2coMiwgYHByb2ZpbGUgZnJhbWUgY291bnQ6ICR7dGhpcy5zdGF0cy5wcm9maWxlRnJhbWVDb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1ha2VzIHN1cmUgYnVmZmVycyBhcmUgY3JlYXRlZCBmb3IgYWxsIGF0dHJpYnV0ZXNcbiAgLy8gYW5kIHRoYXQgdGhlIHByb2dyYW0gaXMgdXBkYXRlZCB3aXRoIHRob3NlIGJ1ZmZlcnNcbiAgLy8gVE9ETyAtIGRvIHdlIG5lZWQgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBcImF0dHJpYnV0ZXNcIiBhbmQgXCJidWZmZXJzXCJcbiAgLy8gY291bGRuJ3QgYXBwcyBqdXN0IGNyZWF0ZSBidWZmZXJzIGRpcmVjdGx5P1xuICBfY3JlYXRlQnVmZmVyc0Zyb21BdHRyaWJ1dGVEZXNjcmlwdG9ycyhhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qge3Byb2dyYW06IHtnbH19ID0gdGhpcztcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICBpZiAoYXR0cmlidXRlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF1dG9jcmVhdGUgYSBidWZmZXJcbiAgICAgICAgdGhpcy5idWZmZXJzW2F0dHJpYnV0ZU5hbWVdID1cbiAgICAgICAgICB0aGlzLmJ1ZmZlcnNbYXR0cmlidXRlTmFtZV0gfHwgbmV3IEJ1ZmZlcihnbCwge1xuICAgICAgICAgICAgdGFyZ2V0OiBhdHRyaWJ1dGUuaXNJbmRleGVkID8gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBHTC5BUlJBWV9CVUZGRVJcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGJ1ZmZlclxuICAgICAgICAgIC5zZXREYXRhKHtkYXRhOiBhdHRyaWJ1dGUudmFsdWV9KVxuICAgICAgICAgIC5zZXREYXRhTGF5b3V0KGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfbG9nQXR0cmlidXRlc0FuZFVuaWZvcm1zKHByaW9yaXR5ID0gMywgdW5pZm9ybXMgPSB7fSkge1xuICAgIGlmIChsb2cucHJpb3JpdHkgPj0gcHJpb3JpdHkpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZVRhYmxlID0gdGhpcy5fZ2V0QXR0cmlidXRlc1RhYmxlKHtcbiAgICAgICAgaGVhZGVyOiBgQXR0cmlidXRlcyAke3RoaXMuaWR9YCxcbiAgICAgICAgcHJvZ3JhbTogdGhpcy5wcm9ncmFtLFxuICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMsIHRoaXMuYXR0cmlidXRlcylcbiAgICAgIH0pO1xuICAgICAgbG9nLnRhYmxlKHByaW9yaXR5LCBhdHRyaWJ1dGVUYWJsZSk7XG5cbiAgICAgIGNvbnN0IHt0YWJsZSwgdW51c2VkVGFibGUsIHVudXNlZENvdW50fSA9IGdldFVuaWZvcm1zVGFibGUoe1xuICAgICAgICBoZWFkZXI6IGBVbmlmb3JtcyAke3RoaXMuaWR9YCxcbiAgICAgICAgcHJvZ3JhbTogdGhpcy5wcm9ncmFtLFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy51bmlmb3JtcywgdW5pZm9ybXMpXG4gICAgICB9KTtcblxuICAgICAgbG9nLnRhYmxlKHByaW9yaXR5LCB0YWJsZSk7XG4gICAgICBsb2cubG9nKHByaW9yaXR5LCBgJHt1bnVzZWRDb3VudCB8fCAnTm8nfSB1bnVzZWQgdW5pZm9ybXMgYCwgdW51c2VkVGFibGUpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuX19TRUVSX0lOSVRJQUxJWkVEX18pIHtcbiAgICAgIGNvbnN0IHVuaWZvcm1zT2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy51bmlmb3JtcywgdW5pZm9ybXMpO1xuICAgICAgc2Vlci5pbmRleGVkTGlzdEl0ZW0oJ2x1bWEuZ2wnLCB0aGlzLmlkLCB1bmlmb3Jtc09iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVG9kbyBtb3ZlIHRvIGF0dHJpYnV0ZXMgbWFuYWdlclxuICBfZ2V0QXR0cmlidXRlc1RhYmxlKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGhlYWRlciA9ICdBdHRyaWJ1dGVzJyxcbiAgICBpbnN0YW5jZWQsXG4gICAgcHJvZ3JhbVxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQocHJvZ3JhbSk7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb25zID0gcHJvZ3JhbS5fYXR0cmlidXRlTG9jYXRpb25zO1xuICAgIGNvbnN0IHRhYmxlID0ge1toZWFkZXJdOiB7fX07XG5cbiAgICAvLyBBZGQgdXNlZCBhdHRyaWJ1dGVzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgdGFibGVbYXR0cmlidXRlTmFtZV0gPSB0aGlzLl9nZXRBdHRyaWJ1dGVFbnRyeShhdHRyaWJ1dGUsIGxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW55IHVudXNlZCBhdHRyaWJ1dGVzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIXRhYmxlW2F0dHJpYnV0ZU5hbWVdKSB7XG4gICAgICAgIHRhYmxlW2F0dHJpYnV0ZU5hbWVdID0gdGhpcy5fZ2V0QXR0cmlidXRlRW50cnkoYXR0cmlidXRlLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICBfZ2V0QXR0cmlidXRlRW50cnkoYXR0cmlidXRlLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IHJvdW5kID0gbnVtID0+IE1hdGgucm91bmQobnVtICogMTApIC8gMTA7XG5cbiAgICBsZXQgdHlwZSA9ICdOT1QgUFJPVklERUQnO1xuICAgIGxldCBpbnN0YW5jZWQgPSAwO1xuICAgIGxldCBzaXplID0gJ04vQSc7XG4gICAgbGV0IHZlcnRzID0gJ04vQSc7XG4gICAgbGV0IGJ5dGVzID0gJ04vQSc7XG4gICAgbGV0IHZhbHVlID0gJ04vQSc7XG5cbiAgICBpZiAoYXR0cmlidXRlICYmIGxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgICBsb2NhdGlvbiA9IGF0dHJpYnV0ZS5pc0luZGV4ZWQgPyAnRUxFTUVOVF9BUlJBWV9CVUZGRVInIDogJ05PVCBVU0VEJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhdHRyaWJ1dGU7XG4gICAgICB0eXBlID0gYnVmZmVyLmxheW91dC50eXBlO1xuICAgICAgaW5zdGFuY2VkID0gYnVmZmVyLmxheW91dC5pbnN0YW5jZWQ7XG4gICAgICBzaXplID0gYnVmZmVyLmxheW91dC5zaXplO1xuICAgICAgdmVydHMgPSByb3VuZChidWZmZXIuZGF0YS5sZW5ndGggLyBidWZmZXIubGF5b3V0LnNpemUpO1xuICAgICAgYnl0ZXMgPSBidWZmZXIuZGF0YS5sZW5ndGggKiBidWZmZXIuZGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgdHlwZSA9IGF0dHJpYnV0ZS52YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaW5zdGFuY2VkID0gYXR0cmlidXRlLmluc3RhbmNlZDtcbiAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIHZlcnRzID0gcm91bmQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgICAgIGJ5dGVzID0gYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAqIGF0dHJpYnV0ZS52YWx1ZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGEgdHlwZSBuYW1lIGJ5IGRyb3BwaW5nIEFycmF5IGZyb20gRmxvYXQzMkFycmF5IGV0Yy5cbiAgICB0eXBlID0gU3RyaW5nKHR5cGUpLnJlcGxhY2UoJ0FycmF5JywgJycpO1xuICAgIC8vIExvb2sgZm9yICdudCcgdG8gZGV0ZWN0IGludGVnZXIgdHlwZXMsIGUuZy4gSW50MzJBcnJheSwgVWludDMyQXJyYXlcbiAgICBjb25zdCBpc0ludGVnZXIgPSB0eXBlLmluZGV4T2YoJ250JykgIT09IC0xO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIExvY2F0aW9uOiBgJHtsb2NhdGlvbn0ke2luc3RhbmNlZCA/ICcgW2luc3RhbmNlZF0nIDogJyd9YCxcbiAgICAgICdUeXBlIFNpemUgeCBWZXJ0cyA9IEJ5dGVzJzogYCR7dHlwZX0gJHtzaXplfSB4ICR7dmVydHN9ID0gJHtieXRlc31gLFxuICAgICAgVmFsdWU6IGZvcm1hdFZhbHVlKHZhbHVlLCB7c2l6ZSwgaXNJbnRlZ2VyfSlcbiAgICB9O1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCAvIFJFTU9WRURcbiAgaXNQaWNrYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5waWNrYWJsZTtcbiAgfVxuXG4gIHNldFBpY2thYmxlKHBpY2thYmxlID0gdHJ1ZSkge1xuICAgIHRoaXMucGlja2FibGUgPSBCb29sZWFuKHBpY2thYmxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5O1xuICB9XG59XG4iXX0=

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var TruncatedConeGeometry = function (_Geometry) {
  _inherits(TruncatedConeGeometry, _Geometry);

  // Primitives inspired by TDL http://code.google.com/p/webglsamples/,
  // copyright 2011 Google Inc. new BSD License
  // (http://www.opensource.org/licenses/bsd-license.php).
  /* eslint-disable max-statements, complexity */
  function TruncatedConeGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TruncatedConeGeometry);

    var _opts$bottomRadius = opts.bottomRadius,
        bottomRadius = _opts$bottomRadius === undefined ? 0 : _opts$bottomRadius,
        _opts$topRadius = opts.topRadius,
        topRadius = _opts$topRadius === undefined ? 0 : _opts$topRadius,
        _opts$height = opts.height,
        height = _opts$height === undefined ? 1 : _opts$height,
        _opts$nradial = opts.nradial,
        nradial = _opts$nradial === undefined ? 10 : _opts$nradial,
        _opts$nvertical = opts.nvertical,
        nvertical = _opts$nvertical === undefined ? 10 : _opts$nvertical,
        _opts$topCap = opts.topCap,
        topCap = _opts$topCap === undefined ? false : _opts$topCap,
        _opts$bottomCap = opts.bottomCap,
        bottomCap = _opts$bottomCap === undefined ? false : _opts$bottomCap;


    var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
    var numVertices = (nradial + 1) * (nvertical + 1 + extra);

    var slant = Math.atan2(bottomRadius - topRadius, height);
    var msin = Math.sin;
    var mcos = Math.cos;
    var mpi = Math.PI;
    var cosSlant = mcos(slant);
    var sinSlant = msin(slant);
    var start = topCap ? -2 : 0;
    var end = nvertical + (bottomCap ? 2 : 0);
    var vertsAroundEdge = nradial + 1;

    var positions = new Float32Array(numVertices * 3);
    var normals = new Float32Array(numVertices * 3);
    var texCoords = new Float32Array(numVertices * 2);
    var indices = new Uint16Array(nradial * (nvertical + extra) * 6);

    var i3 = 0;
    var i2 = 0;
    for (var i = start; i <= end; i++) {
      var v = i / nvertical;
      var y = height * v;
      var ringRadius = void 0;

      if (i < 0) {
        y = 0;
        v = 1;
        ringRadius = bottomRadius;
      } else if (i > nvertical) {
        y = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
      }
      if (i === -2 || i === nvertical + 2) {
        ringRadius = 0;
        v = 0;
      }
      y -= height / 2;
      for (var j = 0; j < vertsAroundEdge; j++) {
        var sin = msin(j * mpi * 2 / nradial);
        var cos = mcos(j * mpi * 2 / nradial);

        positions[i3 + 0] = sin * ringRadius;
        positions[i3 + 1] = y;
        positions[i3 + 2] = cos * ringRadius;

        normals[i3 + 0] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
        normals[i3 + 1] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
        normals[i3 + 2] = i < 0 || i > nvertical ? 0 : cos * cosSlant;

        texCoords[i2 + 0] = j / nradial;
        texCoords[i2 + 1] = v;

        i2 += 2;
        i3 += 3;
      }
    }

    for (var _i = 0; _i < nvertical + extra; _i++) {
      for (var _j = 0; _j < nradial; _j++) {
        var index = (_i * nradial + _j) * 6;
        indices[index + 0] = vertsAroundEdge * (_i + 0) + 0 + _j;
        indices[index + 1] = vertsAroundEdge * (_i + 0) + 1 + _j;
        indices[index + 2] = vertsAroundEdge * (_i + 1) + 1 + _j;
        indices[index + 3] = vertsAroundEdge * (_i + 0) + 0 + _j;
        indices[index + 4] = vertsAroundEdge * (_i + 1) + 1 + _j;
        indices[index + 5] = vertsAroundEdge * (_i + 1) + 0 + _j;
      }
    }

    return _possibleConstructorReturn(this, (TruncatedConeGeometry.__proto__ || Object.getPrototypeOf(TruncatedConeGeometry)).call(this, Object.assign({}, opts, {
      attributes: {
        positions: positions,
        normals: normals,
        texCoords: texCoords,
        indices: indices
      }
    })));
  }

  return TruncatedConeGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (TruncatedConeGeometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS90cnVuY2F0ZWQtY29uZS1nZW9tZXRyeS5qcyJdLCJuYW1lcyI6WyJHZW9tZXRyeSIsIlRydW5jYXRlZENvbmVHZW9tZXRyeSIsIm9wdHMiLCJib3R0b21SYWRpdXMiLCJ0b3BSYWRpdXMiLCJoZWlnaHQiLCJucmFkaWFsIiwibnZlcnRpY2FsIiwidG9wQ2FwIiwiYm90dG9tQ2FwIiwiZXh0cmEiLCJudW1WZXJ0aWNlcyIsInNsYW50IiwiTWF0aCIsImF0YW4yIiwibXNpbiIsInNpbiIsIm1jb3MiLCJjb3MiLCJtcGkiLCJQSSIsImNvc1NsYW50Iiwic2luU2xhbnQiLCJzdGFydCIsImVuZCIsInZlcnRzQXJvdW5kRWRnZSIsInBvc2l0aW9ucyIsIkZsb2F0MzJBcnJheSIsIm5vcm1hbHMiLCJ0ZXhDb29yZHMiLCJpbmRpY2VzIiwiVWludDE2QXJyYXkiLCJpMyIsImkyIiwiaSIsInYiLCJ5IiwicmluZ1JhZGl1cyIsImoiLCJpbmRleCIsIk9iamVjdCIsImFzc2lnbiIsImF0dHJpYnV0ZXMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLFFBQVAsTUFBcUIsWUFBckI7O0lBRXFCQyxxQjs7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLDZCQVNqQkEsSUFUaUIsQ0FFbkJDLFlBRm1CO0FBQUEsUUFFbkJBLFlBRm1CLHNDQUVKLENBRkk7QUFBQSwwQkFTakJELElBVGlCLENBR25CRSxTQUhtQjtBQUFBLFFBR25CQSxTQUhtQixtQ0FHUCxDQUhPO0FBQUEsdUJBU2pCRixJQVRpQixDQUluQkcsTUFKbUI7QUFBQSxRQUluQkEsTUFKbUIsZ0NBSVYsQ0FKVTtBQUFBLHdCQVNqQkgsSUFUaUIsQ0FLbkJJLE9BTG1CO0FBQUEsUUFLbkJBLE9BTG1CLGlDQUtULEVBTFM7QUFBQSwwQkFTakJKLElBVGlCLENBTW5CSyxTQU5tQjtBQUFBLFFB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QXZCLElBQTRCLENBQTVCLEdBQWdDSSxFQUFyRDtBQUNBUixnQkFBUVMsUUFBUSxDQUFoQixJQUFxQmQsbUJBQW1CUyxLQUFJLENBQXZCLElBQTRCLENBQTVCLEdBQWdDSSxFQUFyRDtBQUNEO0FBQ0Y7O0FBbkZvQix5SUFxRmZFLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCdkMsSUFBbEIsRUFBd0I7QUFDNUJ3QyxrQkFBWTtBQUNWaEIsNEJBRFU7QUFFVkUsd0JBRlU7QUFHVkMsNEJBSFU7QUFJVkM7QUFKVTtBQURnQixLQUF4QixDQXJGZTtBQTZGdEI7OztFQW5HZ0Q5QixROztlQUE5QkMscUIiLCJmaWxlIjoidHJ1bmNhdGVkLWNvbmUtZ2VvbWV0cnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9nZW9tZXRyeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRydW5jYXRlZENvbmVHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAvLyBQcmltaXRpdmVzIGluc3BpcmVkIGJ5IFRETCBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2xzYW1wbGVzLyxcbiAgLy8gY29weXJpZ2h0IDIwMTEgR29vZ2xlIEluYy4gbmV3IEJTRCBMaWNlbnNlXG4gIC8vIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL2JzZC1saWNlbnNlLnBocCkuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJvdHRvbVJhZGl1cyA9IDAsXG4gICAgICB0b3BSYWRpdXMgPSAwLFxuICAgICAgaGVpZ2h0ID0gMSxcbiAgICAgIG5yYWRpYWwgPSAxMCxcbiAgICAgIG52ZXJ0aWNhbCA9IDEwLFxuICAgICAgdG9wQ2FwID0gZmFsc2UsXG4gICAgICBib3R0b21DYXAgPSBmYWxzZVxuICAgIH0gPSBvcHRzO1xuXG4gICAgY29uc3QgZXh0cmEgPSAodG9wQ2FwID8gMiA6IDApICsgKGJvdHRvbUNhcCA/IDIgOiAwKTtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IChucmFkaWFsICsgMSkgKiAobnZlcnRpY2FsICsgMSArIGV4dHJhKTtcblxuICAgIGNvbnN0IHNsYW50ID0gTWF0aC5hdGFuMihib3R0b21SYWRpdXMgLSB0b3BSYWRpdXMsIGhlaWdodCk7XG4gICAgY29uc3QgbXNpbiA9IE1hdGguc2luO1xuICAgIGNvbnN0IG1jb3MgPSBNYXRoLmNvcztcbiAgICBjb25zdCBtcGkgPSBNYXRoLlBJO1xuICAgIGNvbnN0IGNvc1NsYW50ID0gbWNvcyhzbGFudCk7XG4gICAgY29uc3Qgc2luU2xhbnQgPSBtc2luKHNsYW50KTtcbiAgICBjb25zdCBzdGFydCA9IHRvcENhcCA/IC0yIDogMDtcbiAgICBjb25zdCBlbmQgPSBudmVydGljYWwgKyAoYm90dG9tQ2FwID8gMiA6IDApO1xuICAgIGNvbnN0IHZlcnRzQXJvdW5kRWRnZSA9IG5yYWRpYWwgKyAxO1xuXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0aWNlcyAqIDMpO1xuICAgIGNvbnN0IG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVZlcnRpY2VzICogMyk7XG4gICAgY29uc3QgdGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0aWNlcyAqIDIpO1xuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobnJhZGlhbCAqIChudmVydGljYWwgKyBleHRyYSkgKiA2KTtcblxuICAgIGxldCBpMyA9IDA7XG4gICAgbGV0IGkyID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIGxldCB2ID0gaSAvIG52ZXJ0aWNhbDtcbiAgICAgIGxldCB5ID0gaGVpZ2h0ICogdjtcbiAgICAgIGxldCByaW5nUmFkaXVzO1xuXG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIHYgPSAxO1xuICAgICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzO1xuICAgICAgfSBlbHNlIGlmIChpID4gbnZlcnRpY2FsKSB7XG4gICAgICAgIHkgPSBoZWlnaHQ7XG4gICAgICAgIHYgPSAxO1xuICAgICAgICByaW5nUmFkaXVzID0gdG9wUmFkaXVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmluZ1JhZGl1cyA9IGJvdHRvbVJhZGl1cyArXG4gICAgICAgICAgKHRvcFJhZGl1cyAtIGJvdHRvbVJhZGl1cykgKiAoaSAvIG52ZXJ0aWNhbCk7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gLTIgfHwgaSA9PT0gbnZlcnRpY2FsICsgMikge1xuICAgICAgICByaW5nUmFkaXVzID0gMDtcbiAgICAgICAgdiA9IDA7XG4gICAgICB9XG4gICAgICB5IC09IGhlaWdodCAvIDI7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRzQXJvdW5kRWRnZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNpbiA9IG1zaW4oaiAqIG1waSAqIDIgLyBucmFkaWFsKTtcbiAgICAgICAgY29uc3QgY29zID0gbWNvcyhqICogbXBpICogMiAvIG5yYWRpYWwpO1xuXG4gICAgICAgIHBvc2l0aW9uc1tpMyArIDBdID0gc2luICogcmluZ1JhZGl1cztcbiAgICAgICAgcG9zaXRpb25zW2kzICsgMV0gPSB5O1xuICAgICAgICBwb3NpdGlvbnNbaTMgKyAyXSA9IGNvcyAqIHJpbmdSYWRpdXM7XG5cbiAgICAgICAgbm9ybWFsc1tpMyArIDBdID0gKGkgPCAwIHx8IGkgPiBudmVydGljYWwpID8gMCA6IChzaW4gKiBjb3NTbGFudCk7XG4gICAgICAgIG5vcm1hbHNbaTMgKyAxXSA9IChpIDwgMCkgPyAtMSA6IChpID4gbnZlcnRpY2FsID8gMSA6IHNpblNsYW50KTtcbiAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gKGkgPCAwIHx8IGkgPiBudmVydGljYWwpID8gMCA6IChjb3MgKiBjb3NTbGFudCk7XG5cbiAgICAgICAgdGV4Q29vcmRzW2kyICsgMF0gPSBqIC8gbnJhZGlhbDtcbiAgICAgICAgdGV4Q29vcmRzW2kyICsgMV0gPSB2O1xuXG4gICAgICAgIGkyICs9IDI7XG4gICAgICAgIGkzICs9IDM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudmVydGljYWwgKyBleHRyYTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5yYWRpYWw7IGorKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IChpICogbnJhZGlhbCArIGopICogNjtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDBdID0gdmVydHNBcm91bmRFZGdlICogKGkgKyAwKSArIDAgKyBqO1xuICAgICAgICBpbmRpY2VzW2luZGV4ICsgMV0gPSB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoaSArIDApICsgMSArIGo7XG4gICAgICAgIGluZGljZXNbaW5kZXggKyAyXSA9IHZlcnRzQXJvdW5kRWRnZSAqIChpICsgMSkgKyAxICsgajtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDNdID0gdmVydHNBcm91bmRFZGdlICogKGkgKyAwKSArIDAgKyBqO1xuICAgICAgICBpbmRpY2VzW2luZGV4ICsgNF0gPSB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoaSArIDEpICsgMSArIGo7XG4gICAgICAgIGluZGljZXNbaW5kZXggKyA1XSA9IHZlcnRzQXJvdW5kRWRnZSAqIChpICsgMSkgKyAwICsgajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgbm9ybWFscyxcbiAgICAgICAgdGV4Q29vcmRzLFxuICAgICAgICBpbmRpY2VzXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_is_browser__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_globals__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__utils_globals__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__package_json__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__package_json__);
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_1__utils_globals__, "global")) __webpack_require__.d(__webpack_exports__, "global", function() { return __WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"]; });



// Version detection
// TODO - this imports a rather large JSON file, we only need one field


var STARTUP_MESSAGE = 'Assign luma.log.priority in console to control logging: 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\nluma.log.break[], set to gl funcs, luma.log.profile[] set to model names';

if (__WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma && __WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma.VERSION !== __WEBPACK_IMPORTED_MODULE_3__package_json__["version"]) {
  throw new Error('luma.gl - multiple versions detected: ' + __WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma.VERSION + ' vs ' + __WEBPACK_IMPORTED_MODULE_3__package_json__["version"]);
}

if (!__WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma) {
  /* global console */
  /* eslint-disable no-console */
  if (__WEBPACK_IMPORTED_MODULE_0__utils_is_browser__["b" /* isBrowser */]) {
    console.log('luma.gl ' + __WEBPACK_IMPORTED_MODULE_3__package_json__["version"] + ' - ' + STARTUP_MESSAGE);
  }

  __WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma = __WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma || {
    VERSION: __WEBPACK_IMPORTED_MODULE_3__package_json__["version"],
    version: __WEBPACK_IMPORTED_MODULE_3__package_json__["version"],
    log: __WEBPACK_IMPORTED_MODULE_2__utils_log__["b" /* default */],

    // A global stats object that various components can add information to
    // E.g. see webgl/resource.js
    stats: {},

    // Keep some luma globals in a sub-object
    // This allows us to dynamically detect if certain modules have been
    // included (such as IO and headless) and enable related functionality,
    // without unconditionally requiring and thus bundling big dependencies
    // into the app.
    globals: {
      headlessGL: null,
      headlessTypes: null,
      modules: {},
      nodeIO: {}
    }
  };
}


/* harmony default export */ __webpack_exports__["default"] = (__WEBPACK_IMPORTED_MODULE_1__utils_globals__["global"].luma);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbml0LmpzIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsImdsb2JhbCIsImxvZyIsInZlcnNpb24iLCJTVEFSVFVQX01FU1NBR0UiLCJsdW1hIiwiVkVSU0lPTiIsIkVycm9yIiwiY29uc29sZSIsInN0YXRzIiwiZ2xvYmFscyIsImhlYWRsZXNzR0wiLCJoZWFkbGVzc1R5cGVzIiwibW9kdWxlcyIsIm5vZGVJTyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEsU0FBUixRQUF3QixvQkFBeEI7QUFDQSxTQUFRQyxNQUFSLFFBQXFCLGlCQUFyQjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsYUFBaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUUMsT0FBUixRQUFzQixpQkFBdEI7O0FBRUEsSUFBTUMsd05BQU47O0FBS0EsSUFBSUgsT0FBT0ksSUFBUCxJQUFlSixPQUFPSSxJQUFQLENBQVlDLE9BQVosS0FBd0JILE9BQTNDLEVBQW9EO0FBQ2xELFFBQU0sSUFBSUksS0FBSiw0Q0FBbUROLE9BQU9JLElBQVAsQ0FBWUMsT0FBL0QsWUFBNkVILE9BQTdFLENBQU47QUFDRDs7QUFFRCxJQUFJLENBQUNGLE9BQU9JLElBQVosRUFBa0I7QUFDaEI7QUFDQTtBQUNBLE1BQUlMLFNBQUosRUFBZTtBQUNiUSxZQUFRTixHQUFSLGNBQXVCQyxPQUF2QixXQUFvQ0MsZUFBcEM7QUFDRDs7QUFFREgsU0FBT0ksSUFBUCxHQUFjSixPQUFPSSxJQUFQLElBQWU7QUFDM0JDLGFBQVNILE9BRGtCO0FBRTNCQSxvQkFGMkI7QUFHM0JELFlBSDJCOztBQUszQjtBQUNBO0FBQ0FPLFdBQU8sRUFQb0I7O0FBUzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsYUFBUztBQUNQQyxrQkFBWSxJQURMO0FBRVBDLHFCQUFlLElBRlI7QUFHUEMsZUFBUyxFQUhGO0FBSVBDLGNBQVE7QUFKRDtBQWRrQixHQUE3QjtBQXFCRDs7QUFFRCxTQUFRYixNQUFSO0FBQ0EsZUFBZUEsT0FBT0ksSUFBdEIiLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNCcm93c2VyfSBmcm9tICcuL3V0aWxzL2lzLWJyb3dzZXInO1xuaW1wb3J0IHtnbG9iYWx9IGZyb20gJy4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvbG9nJztcbi8vIFZlcnNpb24gZGV0ZWN0aW9uXG4vLyBUT0RPIC0gdGhpcyBpbXBvcnRzIGEgcmF0aGVyIGxhcmdlIEpTT04gZmlsZSwgd2Ugb25seSBuZWVkIG9uZSBmaWVsZFxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuXG5jb25zdCBTVEFSVFVQX01FU1NBR0UgPSBgXFxcbkFzc2lnbiBsdW1hLmxvZy5wcmlvcml0eSBpbiBjb25zb2xlIHRvIGNvbnRyb2wgbG9nZ2luZzogXFxcbjA6IG5vbmUsIDE6IG1pbmltYWwsIDI6IHZlcmJvc2UsIDM6IGF0dHJpYnV0ZS91bmlmb3JtcywgNDogZ2wgbG9nc1xubHVtYS5sb2cuYnJlYWtbXSwgc2V0IHRvIGdsIGZ1bmNzLCBsdW1hLmxvZy5wcm9maWxlW10gc2V0IHRvIG1vZGVsIG5hbWVzYDtcblxuaWYgKGdsb2JhbC5sdW1hICYmIGdsb2JhbC5sdW1hLlZFUlNJT04gIT09IHZlcnNpb24pIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBsdW1hLmdsIC0gbXVsdGlwbGUgdmVyc2lvbnMgZGV0ZWN0ZWQ6ICR7Z2xvYmFsLmx1bWEuVkVSU0lPTn0gdnMgJHt2ZXJzaW9ufWApO1xufVxuXG5pZiAoIWdsb2JhbC5sdW1hKSB7XG4gIC8qIGdsb2JhbCBjb25zb2xlICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGNvbnNvbGUubG9nKGBsdW1hLmdsICR7dmVyc2lvbn0gLSAke1NUQVJUVVBfTUVTU0FHRX1gKTtcbiAgfVxuXG4gIGdsb2JhbC5sdW1hID0gZ2xvYmFsLmx1bWEgfHwge1xuICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgdmVyc2lvbixcbiAgICBsb2csXG5cbiAgICAvLyBBIGdsb2JhbCBzdGF0cyBvYmplY3QgdGhhdCB2YXJpb3VzIGNvbXBvbmVudHMgY2FuIGFkZCBpbmZvcm1hdGlvbiB0b1xuICAgIC8vIEUuZy4gc2VlIHdlYmdsL3Jlc291cmNlLmpzXG4gICAgc3RhdHM6IHt9LFxuXG4gICAgLy8gS2VlcCBzb21lIGx1bWEgZ2xvYmFscyBpbiBhIHN1Yi1vYmplY3RcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBkeW5hbWljYWxseSBkZXRlY3QgaWYgY2VydGFpbiBtb2R1bGVzIGhhdmUgYmVlblxuICAgIC8vIGluY2x1ZGVkIChzdWNoIGFzIElPIGFuZCBoZWFkbGVzcykgYW5kIGVuYWJsZSByZWxhdGVkIGZ1bmN0aW9uYWxpdHksXG4gICAgLy8gd2l0aG91dCB1bmNvbmRpdGlvbmFsbHkgcmVxdWlyaW5nIGFuZCB0aHVzIGJ1bmRsaW5nIGJpZyBkZXBlbmRlbmNpZXNcbiAgICAvLyBpbnRvIHRoZSBhcHAuXG4gICAgZ2xvYmFsczoge1xuICAgICAgaGVhZGxlc3NHTDogbnVsbCxcbiAgICAgIGhlYWRsZXNzVHlwZXM6IG51bGwsXG4gICAgICBtb2R1bGVzOiB7fSxcbiAgICAgIG5vZGVJTzoge31cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7Z2xvYmFsfTtcbmV4cG9ydCBkZWZhdWx0IGdsb2JhbC5sdW1hO1xuIl19

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _glMatrix = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector3 = function (_MathArray) {
  _inherits(Vector3, _MathArray);

  // Creates a new vec3, either empty, or from an array or from values
  function Vector3() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Vector3);

    var _this = _possibleConstructorReturn(this, (Vector3.__proto__ || Object.getPrototypeOf(Vector3)).call(this));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z);
    }
    return _this;
  }

  _createClass(Vector3, [{
    key: 'set',
    value: function set(x, y, z) {
      _glMatrix.vec3.set(this, x, y, z);
      this.check();
      return this;
    }
  }, {
    key: 'equals',
    value: function equals(vector) {
      return _glMatrix.vec3.equals(this, vector);
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(vector) {
      return _glMatrix.vec3.exactEquals(this, vector);
    }

    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

  }, {
    key: 'len',

    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

    value: function len() {
      return _glMatrix.vec3.len(this);
    }
  }, {
    key: 'distance',
    value: function distance(vector) {
      return _glMatrix.vec3.distance(this.vector);
    }
  }, {
    key: 'angle',
    value: function angle(vector) {
      return _glMatrix.vec3.angle(this, vector);
    }

    // MODIFIERS

  }, {
    key: 'add',
    value: function add() {
      for (var _len = arguments.length, vectors = Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = vectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vector = _step.value;

          _glMatrix.vec3.add(this, vector);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'subtract',
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = vectors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var vector = _step2.value;

          _glMatrix.vec3.subtract(this, vector);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'multiply',
    value: function multiply() {
      for (var _len3 = arguments.length, vectors = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        vectors[_key3] = arguments[_key3];
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = vectors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var vector = _step3.value;

          _glMatrix.vec3.multiply(this, vector);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'divide',
    value: function divide() {
      for (var _len4 = arguments.length, vectors = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        vectors[_key4] = arguments[_key4];
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = vectors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var vector = _step4.value;

          _glMatrix.vec3.divide(this, vector);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'scale',
    value: function scale(_scale) {
      if (Number.isFinite(_scale)) {
        _glMatrix.vec3.scale(this, this, _scale);
      } else {
        _glMatrix.vec3.dot(this, this, _scale);
      }
      this.check();
      return this;
    }
  }, {
    key: 'scaleAndAdd',
    value: function scaleAndAdd(vector, scale) {
      _glMatrix.vec3.scaleAndAdd(this, this, vector, scale);
      this.check();
      return this;
    }
  }, {
    key: 'negate',
    value: function negate() {
      _glMatrix.vec3.negate(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'inverse',
    value: function inverse() {
      _glMatrix.vec3.inverse(this, this);
      this.check();
      return this;
    }

    // normalize() {
    //   vec3.normalize(this, this);
    //   this.check();
    //   return this;
    // }

  }, {
    key: 'dot',
    value: function dot(vector) {
      _glMatrix.vec3.dot(this, this, vector);
      this.check();
      return this;
    }
  }, {
    key: 'cross',
    value: function cross(vector) {
      _glMatrix.vec3.cross(this, this, vector);
      this.check();
      return this;
    }
  }, {
    key: 'lerp',
    value: function lerp(scale) {
      _glMatrix.vec3.lerp(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'operation',
    value: function operation(_operation) {
      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      _operation.apply(undefined, [this, this].concat(args));
      this.check();
      return this;
    }

    /*
    min() {
      vec3.min(this, this);
      this.check();
      return this;
    }
     max() {
      vec3.max(this, this);
      this.check();
      return this;
    }
     rotateX(origin, angle) {
      vec3.rotateX(this, this, origin, angle);
      this.check();
      return this;
    }
     rotateY(origin, angle) {
      vec3.rotateY(this, this, origin, angle);
      this.check();
      return this;
    }
     rotateZ(origin, angle) {
      vec3.rotateZ(this, this, origin, angle);
      this.check();
      return this;
    }
     ceil() {
      vec3.ceil(this, this);
      this.check();
      return this;
    }
     floor() {
      vec3.floor(this, this);
      this.check();
      return this;
    }
     hermite(scale) {
      vec3.hermite(this, this, scale);
      this.check();
      return this;
    }
     bezier(scale) {
      vec3.bezier(this, this, scale);
      this.check();
      return this;
    }
     random(scale) {
      vec3.random(this, this, scale);
      this.check();
      return this;
    }
    */

  }, {
    key: 'ELEMENTS',
    get: function get() {
      return 3;
    }
  }, {
    key: 'x',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'y',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'z',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }], [{
    key: 'fromArray',
    value: function fromArray(array) {
      if (array instanceof Vector3) {
        return array;
      }
      return new (Function.prototype.bind.apply(Vector3, [null].concat(_toConsumableArray(array))))();
    }
  }, {
    key: 'dot',
    value: function dot(a, b) {
      return Vector3.fromArray(a).dot(b);
    }
  }, {
    key: 'cross',
    value: function cross(a, b) {
      return Vector3.fromArray(a).cross(b);
    }
  }]);

  return Vector3;
}(_mathArray2.default);

exports.default = Vector3;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy92ZWN0b3IzLmpzIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJ4IiwieSIsInoiLCJBcnJheSIsImlzQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjb3B5Iiwic2V0IiwiY2hlY2siLCJ2ZWN0b3IiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsImxlbiIsImRpc3RhbmNlIiwiYW5nbGUiLCJ2ZWN0b3JzIiwiYWRkIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImRpdmlkZSIsInNjYWxlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJkb3QiLCJzY2FsZUFuZEFkZCIsIm5lZ2F0ZSIsImludmVyc2UiLCJjcm9zcyIsImxlcnAiLCJvcGVyYXRpb24iLCJhcmdzIiwidmFsdWUiLCJhcnJheSIsImEiLCJiIiwiZnJvbUFycmF5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVxQkEsTzs7O0FBQ25CO0FBQ0EscUJBQWlDO0FBQUEsUUFBckJDLENBQXFCLHVFQUFqQixDQUFpQjtBQUFBLFFBQWRDLENBQWMsdUVBQVYsQ0FBVTtBQUFBLFFBQVBDLENBQU8sdUVBQUgsQ0FBRzs7QUFBQTs7QUFBQTs7QUFFL0IsUUFBSUMsTUFBTUMsT0FBTixDQUFjSixDQUFkLEtBQW9CSyxVQUFVQyxNQUFWLEtBQXFCLENBQTdDLEVBQWdEO0FBQzlDLFlBQUtDLElBQUwsQ0FBVVAsQ0FBVjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQUtRLEdBQUwsQ0FBU1IsQ0FBVCxFQUFZQyxDQUFaLEVBQWVDLENBQWY7QUFDRDtBQU44QjtBQU9oQzs7Ozt3QkFTR0YsQyxFQUFHQyxDLEVBQUdDLEMsRUFBRztBQUNYLHFCQUFLTSxHQUFMLENBQVMsSUFBVCxFQUFlUixDQUFmLEVBQWtCQyxDQUFsQixFQUFxQkMsQ0FBckI7QUFDQSxXQUFLTyxLQUFMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7OzsyQkFF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QUFFLGFBQU8sS0FBSyxDQUFMLENBQVA7QUFBaUIsSztzQkFDMUJBLEssRUFBTztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7Ozs4QkE3QnBDQyxLLEVBQU87QUFDdEIsVUFBSUEsaUJBQWlCbEMsT0FBckIsRUFBOEI7QUFDNUIsZUFBT2tDLEtBQVA7QUFDRDtBQUNELGdEQUFXbEMsT0FBWCxtQ0FBc0JrQyxLQUF0QjtBQUNEOzs7d0JBaUhVQyxDLEVBQUdDLEMsRUFBRztBQUNmLGFBQU9wQyxRQUFRcUMsU0FBUixDQUFrQkYsQ0FBbEIsRUFBcUJWLEdBQXJCLENBQXlCVyxDQUF6QixDQUFQO0FBQ0Q7OzswQkFRWUQsQyxFQUFHQyxDLEVBQUc7QUFDakIsYUFBT3BDLFFBQVFxQyxTQUFSLENBQWtCRixDQUFsQixFQUFxQk4sS0FBckIsQ0FBMkJPLENBQTNCLENBQVA7QUFDRDs7Ozs7O2tCQTdJa0JwQyxPIiwiZmlsZSI6InZlY3RvcjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vbWF0aC1hcnJheSc7XG5pbXBvcnQge2NoZWNrTnVtYmVyfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBNYXRoQXJyYXkge1xuICAvLyBDcmVhdGVzIGEgbmV3IHZlYzMsIGVpdGhlciBlbXB0eSwgb3IgZnJvbSBhbiBhcnJheSBvciBmcm9tIHZhbHVlc1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmNvcHkoeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KHgsIHksIHopO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBWZWN0b3IzKSB7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVmVjdG9yMyguLi5hcnJheSk7XG4gIH1cblxuICBzZXQoeCwgeSwgeikge1xuICAgIHZlYzMuc2V0KHRoaXMsIHgsIHksIHopO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGVxdWFscyh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjMy5lcXVhbHModGhpcywgdmVjdG9yKTtcbiAgfVxuXG4gIGV4YWN0RXF1YWxzKHZlY3Rvcikge1xuICAgIHJldHVybiB2ZWMzLmV4YWN0RXF1YWxzKHRoaXMsIHZlY3Rvcik7XG4gIH1cblxuICAvLyBHZXR0ZXJzL3NldHRlcnNcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzLCBicmFjZS1zdHlsZSwgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICBnZXQgRUxFTUVOVFMoKSB7IHJldHVybiAzOyB9XG4gIGdldCB4KCkgICAgICB7IHJldHVybiB0aGlzWzBdOyB9XG4gIHNldCB4KHZhbHVlKSB7IHJldHVybiB0aGlzWzBdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCB5KCkgICAgICB7IHJldHVybiB0aGlzWzFdOyB9XG4gIHNldCB5KHZhbHVlKSB7IHJldHVybiB0aGlzWzFdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCB6KCkgICAgICB7IHJldHVybiB0aGlzWzJdOyB9XG4gIHNldCB6KHZhbHVlKSB7IHJldHVybiB0aGlzWzJdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tbXVsdGktc3BhY2VzLCBicmFjZS1zdHlsZSwgbm8tcmV0dXJuLWFzc2lnbiAqL1xuXG4gIGxlbigpIHtcbiAgICByZXR1cm4gdmVjMy5sZW4odGhpcyk7XG4gIH1cblxuICBkaXN0YW5jZSh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjMy5kaXN0YW5jZSh0aGlzLiB2ZWN0b3IpO1xuICB9XG5cbiAgYW5nbGUodmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlYzMuYW5nbGUodGhpcywgdmVjdG9yKTtcbiAgfVxuXG4gIC8vIE1PRElGSUVSU1xuXG4gIGFkZCguLi52ZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCB2ZWN0b3Igb2YgdmVjdG9ycykge1xuICAgICAgdmVjMy5hZGQodGhpcywgdmVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3VidHJhY3QoLi4udmVjdG9ycykge1xuICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgIHZlYzMuc3VidHJhY3QodGhpcywgdmVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsdGlwbHkoLi4udmVjdG9ycykge1xuICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgIHZlYzMubXVsdGlwbHkodGhpcywgdmVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGl2aWRlKC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICB2ZWMzLmRpdmlkZSh0aGlzLCB2ZWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzY2FsZShzY2FsZSkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2NhbGUpKSB7XG4gICAgICB2ZWMzLnNjYWxlKHRoaXMsIHRoaXMsIHNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5kb3QodGhpcywgdGhpcywgc2NhbGUpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzY2FsZUFuZEFkZCh2ZWN0b3IsIHNjYWxlKSB7XG4gICAgdmVjMy5zY2FsZUFuZEFkZCh0aGlzLCB0aGlzLCB2ZWN0b3IsIHNjYWxlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBuZWdhdGUoKSB7XG4gICAgdmVjMy5uZWdhdGUodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW52ZXJzZSgpIHtcbiAgICB2ZWMzLmludmVyc2UodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplKCkge1xuICAvLyAgIHZlYzMubm9ybWFsaXplKHRoaXMsIHRoaXMpO1xuICAvLyAgIHRoaXMuY2hlY2soKTtcbiAgLy8gICByZXR1cm4gdGhpcztcbiAgLy8gfVxuXG4gIGRvdCh2ZWN0b3IpIHtcbiAgICB2ZWMzLmRvdCh0aGlzLCB0aGlzLCB2ZWN0b3IpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBkb3QoYSwgYikge1xuICAgIHJldHVybiBWZWN0b3IzLmZyb21BcnJheShhKS5kb3QoYik7XG4gIH1cblxuICBjcm9zcyh2ZWN0b3IpIHtcbiAgICB2ZWMzLmNyb3NzKHRoaXMsIHRoaXMsIHZlY3Rvcik7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIGNyb3NzKGEsIGIpIHtcbiAgICByZXR1cm4gVmVjdG9yMy5mcm9tQXJyYXkoYSkuY3Jvc3MoYik7XG4gIH1cblxuICBsZXJwKHNjYWxlKSB7XG4gICAgdmVjMy5sZXJwKHRoaXMsIHRoaXMsIHNjYWxlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvcGVyYXRpb24ob3BlcmF0aW9uLCAuLi5hcmdzKSB7XG4gICAgb3BlcmF0aW9uKHRoaXMsIHRoaXMsIC4uLmFyZ3MpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qXG4gIG1pbigpIHtcbiAgICB2ZWMzLm1pbih0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtYXgoKSB7XG4gICAgdmVjMy5tYXgodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlWChvcmlnaW4sIGFuZ2xlKSB7XG4gICAgdmVjMy5yb3RhdGVYKHRoaXMsIHRoaXMsIG9yaWdpbiwgYW5nbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVkob3JpZ2luLCBhbmdsZSkge1xuICAgIHZlYzMucm90YXRlWSh0aGlzLCB0aGlzLCBvcmlnaW4sIGFuZ2xlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVaKG9yaWdpbiwgYW5nbGUpIHtcbiAgICB2ZWMzLnJvdGF0ZVoodGhpcywgdGhpcywgb3JpZ2luLCBhbmdsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2VpbCgpIHtcbiAgICB2ZWMzLmNlaWwodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZmxvb3IoKSB7XG4gICAgdmVjMy5mbG9vcih0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBoZXJtaXRlKHNjYWxlKSB7XG4gICAgdmVjMy5oZXJtaXRlKHRoaXMsIHRoaXMsIHNjYWxlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBiZXppZXIoc2NhbGUpIHtcbiAgICB2ZWMzLmJlemllcih0aGlzLCB0aGlzLCBzY2FsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmFuZG9tKHNjYWxlKSB7XG4gICAgdmVjMy5yYW5kb20odGhpcywgdGhpcywgc2NhbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAqL1xufVxuIl19

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__context_limits__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__texture_2d__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renderbuffer__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_typed_array_utils__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











// Local constants - will collapse during minification
var GL_FRAMEBUFFER = 0x8D40;
var GL_RENDERBUFFER = 0x8D41;
var GL_DRAW_FRAMEBUFFER = 0;
var GL_READ_FRAMEBUFFER = 0;

var GL_COLOR_ATTACHMENT0 = 0x8CE0;
var GL_DEPTH_ATTACHMENT = 0x8D00;
var GL_STENCIL_ATTACHMENT = 0x8D20;
// const GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

var GL_TEXTURE_3D = 0x806F;
var GL_TEXTURE_2D_ARRAY = 0x8C1A;
var GL_TEXTURE_2D = 0x0DE1;
var GL_TEXTURE_CUBE_MAP = 0x8513;

var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

var Framebuffer = function (_Resource) {
  _inherits(Framebuffer, _Resource);

  function Framebuffer(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Framebuffer);

    // Public members
    var _this = _possibleConstructorReturn(this, (Framebuffer.__proto__ || Object.getPrototypeOf(Framebuffer)).call(this, gl, opts));

    _this.width = null;
    _this.height = null;
    _this.attachments = {};
    _this.initialize(opts);

    Object.seal(_this);
    return _this;
  }

  _createClass(Framebuffer, [{
    key: 'initialize',
    value: function initialize(_ref) {
      var _ref$width = _ref.width,
          width = _ref$width === undefined ? 1 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === undefined ? 1 : _ref$height,
          _ref$attachments = _ref.attachments,
          attachments = _ref$attachments === undefined ? null : _ref$attachments,
          _ref$color = _ref.color,
          color = _ref$color === undefined ? true : _ref$color,
          _ref$depth = _ref.depth,
          depth = _ref$depth === undefined ? true : _ref$depth,
          _ref$stencil = _ref.stencil,
          stencil = _ref$stencil === undefined ? false : _ref$stencil,
          _ref$check = _ref.check,
          check = _ref$check === undefined ? true : _ref$check;

      __WEBPACK_IMPORTED_MODULE_8_assert___default()(width >= 0 && height >= 0, 'Width and height need to be integers');

      // Store actual width and height for diffing
      this.width = width;
      this.height = height;

      // Resize any provided attachments - note that resize only resizes if needed
      // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)
      if (attachments) {
        for (var attachment in attachments) {
          var target = attachments[attachment];
          var object = Array.isArray(target) ? target[0] : target;
          object.resize({ width: width, height: height });
        }
      } else {
        // Create any requested default attachments
        attachments = this._createDefaultAttachments({ color: color, depth: depth, stencil: stencil, width: width, height: height });
      }

      // Any current attachments need to be removed, create a map with null values
      var attachmentsToRemove = Object.keys(this.attachments).reduce(function (map, key) {
        map[key] = null;
        return map;
      }, {});

      // Unattach/attach the attachments
      this.attach(Object.assign(attachmentsToRemove, attachments));

      // Checks that framebuffer was properly set up, if not, throws an explanatory error
      if (check) {
        this.checkStatus();
      }
    }
  }, {
    key: 'resize',
    value: function resize(_ref2) {
      var width = _ref2.width,
          height = _ref2.height;

      if (width === this.width && height === this.height) {
        return this;
      }
      __WEBPACK_IMPORTED_MODULE_7__utils__["log"].log(2, 'Resizing framebuffer ' + this.id + ' to ' + width + 'x' + height);
      return this.initialize(Object.assign({}, this.opts, { width: width, height: height }));
    }

    // Attach from a map of attachments

  }, {
    key: 'attach',
    value: function attach(attachments) {
      this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);

      for (var attachment in attachments) {
        var object = attachments[attachment];
        if (!object) {
          this._unattach({ attachment: attachment });
        } else if (object instanceof __WEBPACK_IMPORTED_MODULE_5__renderbuffer__["a" /* default */]) {
          this._attachRenderbuffer({ attachment: attachment, renderbuffer: object });
        } else if (Array.isArray(object)) {
          var _object = _slicedToArray(object, 3),
              texture = _object[0],
              _object$ = _object[1],
              layer = _object$ === undefined ? 0 : _object$,
              _object$2 = _object[2],
              level = _object$2 === undefined ? 0 : _object$2;

          this._attachTexture({ attachment: attachment, texture: texture, layer: layer, level: level });
        } else {
          this._attachTexture({ attachment: attachment, texture: object, layer: 0, level: 0 });
        }
      }
      Object.assign(this.attachments, attachments);

      this.gl.bindFramebuffer(GL_FRAMEBUFFER, null);
    }
  }, {
    key: 'checkStatus',
    value: function checkStatus() {
      var gl = this.gl;

      gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);
      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);
      gl.bindFramebuffer(GL_FRAMEBUFFER, null);
      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
  }, {
    key: 'readPixels',


    // NOTE: Slow requires roundtrip to GPU
    // App can provide pixelArray or have it auto allocated by this method
    // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,
    //  newly allocated by this method unless provided by app.
    value: function readPixels(_ref3) {
      var _ref3$x = _ref3.x,
          x = _ref3$x === undefined ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === undefined ? 0 : _ref3$y,
          width = _ref3.width,
          height = _ref3.height,
          _ref3$format = _ref3.format,
          format = _ref3$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref3$format,
          type = _ref3.type,
          _ref3$pixelArray = _ref3.pixelArray,
          pixelArray = _ref3$pixelArray === undefined ? null : _ref3$pixelArray;
      var gl = this.gl;

      // Deduce type and allocated pixelArray if needed

      if (!pixelArray) {
        // Allocate pixel array if not already available, using supplied type
        type = type || gl.UNSIGNED_BYTE;
        var ArrayType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_typed_array_utils__["b" /* getTypedArrayFromGLType */])(type);
        var components = glFormatToComponents(format);
        // TODO - check for composite type (components = 1).
        pixelArray = pixelArray || new ArrayType(width * height * components);
      }

      // Pixel array available, if necessary, deduce type from it.
      type = type || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_typed_array_utils__["a" /* getGLTypeFromTypedArray */])(pixelArray);

      this.bind();
      this.gl.readPixels(x, y, width, height, format, type, pixelArray);
      this.unbind();

      return pixelArray;
    }

    // Selects a color buffer as the source for pixels for subsequent calls to
    // copyTexImage2D, copyTexSubImage2D, copyTexSubImage3D or readPixels.
    // src
    //  gl.BACK: Reads from the back color buffer.
    //  gl.NONE: Reads from no color buffer.
    //  gl.COLOR_ATTACHMENT{0-15}: Reads from one of 16 color attachment buffers.

  }, {
    key: 'readBuffer',
    value: function readBuffer(_ref4) {
      var src = _ref4.src;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(this.gl);
      this.gl.readBuffer(src);
      return this;
    }

    // WEBGL2 INTERFACE

    // Copies a rectangle of pixels between framebuffers

  }, {
    key: 'blit',
    value: function blit(_ref5) {
      var srcFramebuffer = _ref5.srcFramebuffer,
          srcX0 = _ref5.srcX0,
          srcY0 = _ref5.srcY0,
          srcX1 = _ref5.srcX1,
          srcY1 = _ref5.srcY1,
          dstX0 = _ref5.dstX0,
          dstY0 = _ref5.dstY0,
          dstX1 = _ref5.dstX1,
          dstY1 = _ref5.dstY1,
          mask = _ref5.mask,
          _ref5$filter = _ref5.filter,
          filter = _ref5$filter === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].NEAREST : _ref5$filter;
      var gl = this.gl;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);

      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, this.handle);
      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, srcFramebuffer.handle);
      gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, null);
      return this;
    }

    // signals to the GL that it need not preserve all pixels of a specified region
    // of the framebuffer

  }, {
    key: 'invalidate',
    value: function invalidate(_ref6) {
      var _ref6$attachments = _ref6.attachments,
          attachments = _ref6$attachments === undefined ? [] : _ref6$attachments,
          _ref6$x = _ref6.x,
          x = _ref6$x === undefined ? 0 : _ref6$x,
          _ref6$y = _ref6.y,
          y = _ref6$y === undefined ? 0 : _ref6$y,
          width = _ref6.width,
          height = _ref6.height;
      var gl = this.gl;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, this.handle);
      var invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
      if (invalidateAll) {
        gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments);
      } else {
        this.gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments, x, y, width, height);
      }
      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, null);
      return this;
    }

    // Return the value for the passed pname given the target and attachment.
    // The type returned is the natural type for the requested pname:
    // pname returned type
    // If an OpenGL error is generated, returns null.
    /* eslint-disable complexity */

  }, {
    key: 'getAttachmentParameter',
    value: function getAttachmentParameter() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$target = _ref7.target,
          target = _ref7$target === undefined ? this.target : _ref7$target,
          _ref7$attachment = _ref7.attachment,
          attachment = _ref7$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref7$attachment,
          pname = _ref7.pname;

      var caps = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__context_limits__["a" /* getContextCaps */])(this.gl);

      switch (pname) {
        // EXT_sRGB or WebGL2
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
          if (!caps.EXT_sRGB) {
            return __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LINEAR;
          }
          break;
        // WebGL2
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
          // GLint
          if (!caps.webgl2) {
            return 8;
          }
          break;
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
          // GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.
          if (!caps.webgl2) {
            return __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_INT;
          }
          break;

        default:
      }

      return this.gl.getFramebufferAttachmentParameter(target, attachment, pname);
    }
    /* eslint-enable complexity */

  }, {
    key: 'getAttachmentParameters',
    value: function getAttachmentParameters() {
      var attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GL_COLOR_ATTACHMENT0;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.ATTACHMENT_PARAMETERS || {};

      var values = {};
      for (var pname in parameters) {
        values[pname] = this.getParameter(pname);
      }
      return this;
    }

    // WEBGL INTERFACE

  }, {
    key: 'bind',
    value: function bind() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$target = _ref8.target,
          target = _ref8$target === undefined ? GL_FRAMEBUFFER : _ref8$target;

      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$target = _ref9.target,
          target = _ref9$target === undefined ? GL_FRAMEBUFFER : _ref9$target;

      this.gl.bindFramebuffer(target, null);
      return this;
    }

    // PRIVATE METHODS

  }, {
    key: '_createDefaultAttachments',
    value: function _createDefaultAttachments(_ref10) {
      var color = _ref10.color,
          depth = _ref10.depth,
          stencil = _ref10.stencil,
          width = _ref10.width,
          height = _ref10.height;

      var defaultAttachments = {};

      // Add a color buffer if requested and not supplied
      if (color) {
        var _parameters;

        defaultAttachments[GL_COLOR_ATTACHMENT0] = new __WEBPACK_IMPORTED_MODULE_4__texture_2d__["a" /* default */](this.gl, {
          data: null,
          format: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA,
          type: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE,
          width: width,
          height: height,
          parameters: (_parameters = {}, _defineProperty(_parameters, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MIN_FILTER, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].NEAREST), _defineProperty(_parameters, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MAG_FILTER, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].NEAREST), _parameters)
        });
      }

      // Add a depth buffer if requested and not supplied
      if (depth) {
        defaultAttachments[GL_DEPTH_ATTACHMENT] = new __WEBPACK_IMPORTED_MODULE_5__renderbuffer__["a" /* default */](this.gl, {
          format: __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].DEPTH_COMPONENT16,
          width: width,
          height: height
        });
      }

      // TODO - handle stencil and combined depth and stencil

      return defaultAttachments;
    }
  }, {
    key: '_unattach',
    value: function _unattach(_ref11) {
      var attachment = _ref11.attachment;

      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);
      this.gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, null);
      delete this.attachments[attachment];
    }
  }, {
    key: '_attachRenderbuffer',
    value: function _attachRenderbuffer(_ref12) {
      var _ref12$attachment = _ref12.attachment,
          attachment = _ref12$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref12$attachment,
          renderbuffer = _ref12.renderbuffer;
      var gl = this.gl;
      // TODO - is the bind needed?
      // gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.handle);

      gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderbuffer.handle);
      // TODO - is the unbind needed?
      // gl.bindRenderbuffer(GL_RENDERBUFFER, null);

      this.attachments[attachment] = renderbuffer;
    }

    // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`
    // level = 0 - mipmapLevel (must be 0 in WebGL1)

  }, {
    key: '_attachTexture',
    value: function _attachTexture(_ref13) {
      var _ref13$attachment = _ref13.attachment,
          attachment = _ref13$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref13$attachment,
          texture = _ref13.texture,
          layer = _ref13.layer,
          level = _ref13.level;
      var gl = this.gl;

      gl.bindTexture(texture.target, texture.handle);

      switch (texture.target) {
        case GL_TEXTURE_2D_ARRAY:
        case GL_TEXTURE_3D:
          gl.framebufferTextureLayer(GL_FRAMEBUFFER, attachment, texture.target, level, layer);
          break;

        case GL_TEXTURE_CUBE_MAP:
          // layer must be a cubemap face (or if index, converted to cube map face)
          var face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, face, texture.handle, level);
          break;

        case GL_TEXTURE_2D:
          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texture.handle, level);
          break;

        default:
          __WEBPACK_IMPORTED_MODULE_8_assert___default()(false, 'Illegal texture type');
      }

      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }

    // RESOURCE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createFramebuffer();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
  }, {
    key: 'color',
    get: function get() {
      return this.attachments[GL_COLOR_ATTACHMENT0] || null;
    }
  }, {
    key: 'texture',
    get: function get() {
      return this.attachments[GL_COLOR_ATTACHMENT0] || null;
    }
  }, {
    key: 'depth',
    get: function get() {
      return this.attachments[GL_DEPTH_ATTACHMENT] || null;
    }
  }, {
    key: 'stencil',
    get: function get() {
      return this.attachments[GL_STENCIL_ATTACHMENT] || null;
    }
  }]);

  return Framebuffer;
}(__WEBPACK_IMPORTED_MODULE_3__resource__["a" /* default */]);

// Map an index to a cube map face constant


/* harmony default export */ __webpack_exports__["a"] = (Framebuffer);
function mapIndexToCubeMapFace(layer) {
  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)
  // if smaller assume layer is index, otherwise assume it is already a cube map face constant
  return layer < GL_TEXTURE_CUBE_MAP_POSITIVE_X ? layer + GL_TEXTURE_CUBE_MAP_POSITIVE_X : layer;
}

// Returns number of components in a specific WebGL format
function glFormatToComponents(format) {
  switch (format) {
    case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ALPHA:
      return 1;
    case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGB:
      return 3;
    case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA:
      return 4;
    default:
      throw new Error('Unknown format');
  }
}

// Get a string describing the framebuffer error if installed
function _getFrameBufferStatus(status) {
  // Use error mapping if installed
  var STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || 'Framebuffer error ' + status;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9mcmFtZWJ1ZmZlci5qcyJdLCJuYW1lcyI6WyJHTCIsImFzc2VydFdlYkdMQ29udGV4dCIsImFzc2VydFdlYkdMMkNvbnRleHQiLCJnZXRDb250ZXh0Q2FwcyIsIlJlc291cmNlIiwiVGV4dHVyZTJEIiwiUmVuZGVyYnVmZmVyIiwiZ2V0VHlwZWRBcnJheUZyb21HTFR5cGUiLCJnZXRHTFR5cGVGcm9tVHlwZWRBcnJheSIsImxvZyIsImFzc2VydCIsIkdMX0ZSQU1FQlVGRkVSIiwiR0xfUkVOREVSQlVGRkVSIiwiR0xfRFJBV19GUkFNRUJVRkZFUiIsIkdMX1JFQURfRlJBTUVCVUZGRVIiLCJHTF9DT0xPUl9BVFRBQ0hNRU5UMCIsIkdMX0RFUFRIX0FUVEFDSE1FTlQiLCJHTF9TVEVOQ0lMX0FUVEFDSE1FTlQiLCJHTF9URVhUVVJFXzNEIiwiR0xfVEVYVFVSRV8yRF9BUlJBWSIsIkdMX1RFWFRVUkVfMkQiLCJHTF9URVhUVVJFX0NVQkVfTUFQIiwiR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIiwiRnJhbWVidWZmZXIiLCJnbCIsIm9wdHMiLCJ3aWR0aCIsImhlaWdodCIsImF0dGFjaG1lbnRzIiwiaW5pdGlhbGl6ZSIsIk9iamVjdCIsInNlYWwiLCJjb2xvciIsImRlcHRoIiwic3RlbmNpbCIsImNoZWNrIiwiYXR0YWNobWVudCIsInRhcmdldCIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInJlc2l6ZSIsIl9jcmVhdGVEZWZhdWx0QXR0YWNobWVudHMiLCJhdHRhY2htZW50c1RvUmVtb3ZlIiwia2V5cyIsInJlZHVjZSIsIm1hcCIsImtleSIsImF0dGFjaCIsImFzc2lnbiIsImNoZWNrU3RhdHVzIiwiaWQiLCJiaW5kRnJhbWVidWZmZXIiLCJoYW5kbGUiLCJfdW5hdHRhY2giLCJfYXR0YWNoUmVuZGVyYnVmZmVyIiwicmVuZGVyYnVmZmVyIiwidGV4dHVyZSIsImxheWVyIiwibGV2ZWwiLCJfYXR0YWNoVGV4dHVyZSIsInN0YXR1cyIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsIkVycm9yIiwiX2dldEZyYW1lQnVmZmVyU3RhdHVzIiwieCIsInkiLCJmb3JtYXQiLCJSR0JBIiwidHlwZSIsInBpeGVsQXJyYXkiLCJVTlNJR05FRF9CWVRFIiwiQXJyYXlUeXBlIiwiY29tcG9uZW50cyIsImdsRm9ybWF0VG9Db21wb25lbnRzIiwiYmluZCIsInJlYWRQaXhlbHMiLCJ1bmJpbmQiLCJzcmMiLCJyZWFkQnVmZmVyIiwic3JjRnJhbWVidWZmZXIiLCJzcmNYMCIsInNyY1kwIiwic3JjWDEiLCJzcmNZMSIsImRzdFgwIiwiZHN0WTAiLCJkc3RYMSIsImRzdFkxIiwibWFzayIsImZpbHRlciIsIk5FQVJFU1QiLCJibGl0RnJhbWVidWZmZXIiLCJpbnZhbGlkYXRlQWxsIiwidW5kZWZpbmVkIiwiaW52YWxpZGF0ZUZyYW1lYnVmZmVyIiwicG5hbWUiLCJjYXBzIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9DT0xPUl9FTkNPRElORyIsIkVYVF9zUkdCIiwiTElORUFSIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9SRURfU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfR1JFRU5fU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9BTFBIQV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9ERVBUSF9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkUiLCJ3ZWJnbDIiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFIiwiVU5TSUdORURfSU5UIiwiZ2V0RnJhbWVidWZmZXJBdHRhY2htZW50UGFyYW1ldGVyIiwicGFyYW1ldGVycyIsImNvbnN0cnVjdG9yIiwiQVRUQUNITUVOVF9QQVJBTUVURVJTIiwidmFsdWVzIiwiZ2V0UGFyYW1ldGVyIiwiZGVmYXVsdEF0dGFjaG1lbnRzIiwiZGF0YSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIkRFUFRIX0NPTVBPTkVOVDE2IiwiYmluZFJlbmRlcmJ1ZmZlciIsImZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyIiwiYmluZFRleHR1cmUiLCJmcmFtZWJ1ZmZlclRleHR1cmVMYXllciIsImZhY2UiLCJtYXBJbmRleFRvQ3ViZU1hcEZhY2UiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJBTFBIQSIsIlJHQiIsIlNUQVRVUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsRUFBUCxNQUFlLE9BQWY7QUFDQSxTQUFRQyxrQkFBUixFQUE0QkMsbUJBQTVCLFFBQXNELFdBQXREO0FBQ0EsU0FBUUMsY0FBUixRQUE2QixrQkFBN0I7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixjQUF0QjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsZ0JBQXpCO0FBQ0EsU0FBUUMsdUJBQVIsRUFBaUNDLHVCQUFqQyxRQUErRCw0QkFBL0Q7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTtBQUNBLElBQU1DLGlCQUFpQixNQUF2QjtBQUNBLElBQU1DLGtCQUFrQixNQUF4QjtBQUNBLElBQU1DLHNCQUFzQixDQUE1QjtBQUNBLElBQU1DLHNCQUFzQixDQUE1Qjs7QUFFQSxJQUFNQyx1QkFBdUIsTUFBN0I7QUFDQSxJQUFNQyxzQkFBc0IsTUFBNUI7QUFDQSxJQUFNQyx3QkFBd0IsTUFBOUI7QUFDQTs7QUFFQSxJQUFNQyxnQkFBZ0IsTUFBdEI7QUFDQSxJQUFNQyxzQkFBc0IsTUFBNUI7QUFDQSxJQUFNQyxnQkFBZ0IsTUFBdEI7QUFDQSxJQUFNQyxzQkFB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bUJBQWpCLEtBQXlDLElBQWhEO0FBQ0Q7Ozt3QkFFYTtBQUNaLGFBQU8sS0FBS1ksV0FBTCxDQUFpQlgscUJBQWpCLEtBQTJDLElBQWxEO0FBQ0Q7Ozs7RUFoSHNDYixROztBQWlYekM7OztlQWpYcUJtQixXO0FBa1hyQixTQUFTeUcscUJBQVQsQ0FBK0J0RSxLQUEvQixFQUFzQztBQUNwQztBQUNBO0FBQ0EsU0FBT0EsUUFBUXBDLDhCQUFSLEdBQ0xvQyxRQUFRcEMsOEJBREgsR0FFTG9DLEtBRkY7QUFHRDs7QUFFRDtBQUNBLFNBQVNpQixvQkFBVCxDQUE4QlAsTUFBOUIsRUFBc0M7QUFDcEMsVUFBUUEsTUFBUjtBQUNBLFNBQUtwRSxHQUFHb0ksS0FBUjtBQUFlLGFBQU8sQ0FBUDtBQUNmLFNBQUtwSSxHQUFHcUksR0FBUjtBQUFhLGFBQU8sQ0FBUDtBQUNiLFNBQUtySSxHQUFHcUUsSUFBUjtBQUFjLGFBQU8sQ0FBUDtBQUNkO0FBQVMsWUFBTSxJQUFJTCxLQUFKLENBQVUsZ0JBQVYsQ0FBTjtBQUpUO0FBTUQ7O0FBRUQ7QUFDQSxTQUFTQyxxQkFBVCxDQUErQkosTUFBL0IsRUFBdUM7QUFDckM7QUFDQSxNQUFNeUUsU0FBUy9HLFlBQVkrRyxNQUFaLElBQXNCLEVBQXJDO0FBQ0EsU0FBT0EsT0FBT3pFLE1BQVAsNEJBQXVDQSxNQUE5QztBQUNEIiwiZmlsZSI6ImZyYW1lYnVmZmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdMIGZyb20gJy4vYXBpJztcbmltcG9ydCB7YXNzZXJ0V2ViR0xDb250ZXh0LCBhc3NlcnRXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHtnZXRDb250ZXh0Q2Fwc30gZnJvbSAnLi9jb250ZXh0LWxpbWl0cyc7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi9yZXNvdXJjZSc7XG5pbXBvcnQgVGV4dHVyZTJEIGZyb20gJy4vdGV4dHVyZS0yZCc7XG5pbXBvcnQgUmVuZGVyYnVmZmVyIGZyb20gJy4vcmVuZGVyYnVmZmVyJztcbmltcG9ydCB7Z2V0VHlwZWRBcnJheUZyb21HTFR5cGUsIGdldEdMVHlwZUZyb21UeXBlZEFycmF5fSBmcm9tICcuLi91dGlscy90eXBlZC1hcnJheS11dGlscyc7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBMb2NhbCBjb25zdGFudHMgLSB3aWxsIGNvbGxhcHNlIGR1cmluZyBtaW5pZmljYXRpb25cbmNvbnN0IEdMX0ZSQU1FQlVGRkVSID0gMHg4RDQwO1xuY29uc3QgR0xfUkVOREVSQlVGRkVSID0gMHg4RDQxO1xuY29uc3QgR0xfRFJBV19GUkFNRUJVRkZFUiA9IDA7XG5jb25zdCBHTF9SRUFEX0ZSQU1FQlVGRkVSID0gMDtcblxuY29uc3QgR0xfQ09MT1JfQVRUQUNITUVOVDAgPSAweDhDRTA7XG5jb25zdCBHTF9ERVBUSF9BVFRBQ0hNRU5UID0gMHg4RDAwO1xuY29uc3QgR0xfU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4RDIwO1xuLy8gY29uc3QgR0xfREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4MjFBO1xuXG5jb25zdCBHTF9URVhUVVJFXzNEID0gMHg4MDZGO1xuY29uc3QgR0xfVEVYVFVSRV8yRF9BUlJBWSA9IDB4OEMxQTtcbmNvbnN0IEdMX1RFWFRVUkVfMkQgPSAweDBERTE7XG5jb25zdCBHTF9URVhUVVJFX0NVQkVfTUFQID0gMHg4NTEzO1xuXG5jb25zdCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lYnVmZmVyIGV4dGVuZHMgUmVzb3VyY2Uge1xuXG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzID0ge30pIHtcbiAgICBzdXBlcihnbCwgb3B0cyk7XG5cbiAgICAvLyBQdWJsaWMgbWVtYmVyc1xuICAgIHRoaXMud2lkdGggPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLmF0dGFjaG1lbnRzID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplKG9wdHMpO1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICBpbml0aWFsaXplKHtcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICBhdHRhY2htZW50cyA9IG51bGwsXG4gICAgY29sb3IgPSB0cnVlLFxuICAgIGRlcHRoID0gdHJ1ZSxcbiAgICBzdGVuY2lsID0gZmFsc2UsXG4gICAgY2hlY2sgPSB0cnVlXG4gIH0pIHtcbiAgICBhc3NlcnQod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCwgJ1dpZHRoIGFuZCBoZWlnaHQgbmVlZCB0byBiZSBpbnRlZ2VycycpO1xuXG4gICAgLy8gU3RvcmUgYWN0dWFsIHdpZHRoIGFuZCBoZWlnaHQgZm9yIGRpZmZpbmdcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvLyBSZXNpemUgYW55IHByb3ZpZGVkIGF0dGFjaG1lbnRzIC0gbm90ZSB0aGF0IHJlc2l6ZSBvbmx5IHJlc2l6ZXMgaWYgbmVlZGVkXG4gICAgLy8gTm90ZTogQSBmcmFtZWJ1ZmZlciBoYXMgbm8gc2VwYXJhdGUgc2l6ZSwgaXQgaXMgZGVmaW5lZCBieSBpdHMgYXR0YWNobWVudHMgKHdoaWNoIG11c3QgYWdyZWUpXG4gICAgaWYgKGF0dGFjaG1lbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgaW4gYXR0YWNobWVudHMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXR0YWNobWVudHNbYXR0YWNobWVudF07XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldFswXSA6IHRhcmdldDtcbiAgICAgICAgb2JqZWN0LnJlc2l6ZSh7d2lkdGgsIGhlaWdodH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYW55IHJlcXVlc3RlZCBkZWZhdWx0IGF0dGFjaG1lbnRzXG4gICAgICBhdHRhY2htZW50cyA9IHRoaXMuX2NyZWF0ZURlZmF1bHRBdHRhY2htZW50cyh7Y29sb3IsIGRlcHRoLCBzdGVuY2lsLCB3aWR0aCwgaGVpZ2h0fSk7XG4gICAgfVxuXG4gICAgLy8gQW55IGN1cnJlbnQgYXR0YWNobWVudHMgbmVlZCB0byBiZSByZW1vdmVkLCBjcmVhdGUgYSBtYXAgd2l0aCBudWxsIHZhbHVlc1xuICAgIGNvbnN0IGF0dGFjaG1lbnRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyh0aGlzLmF0dGFjaG1lbnRzKS5yZWR1Y2UoKG1hcCwga2V5KSA9PiB7XG4gICAgICBtYXBba2V5XSA9IG51bGw7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcblxuICAgIC8vIFVuYXR0YWNoL2F0dGFjaCB0aGUgYXR0YWNobWVudHNcbiAgICB0aGlzLmF0dGFjaChPYmplY3QuYXNzaWduKGF0dGFjaG1lbnRzVG9SZW1vdmUsIGF0dGFjaG1lbnRzKSk7XG5cbiAgICAvLyBDaGVja3MgdGhhdCBmcmFtZWJ1ZmZlciB3YXMgcHJvcGVybHkgc2V0IHVwLCBpZiBub3QsIHRocm93cyBhbiBleHBsYW5hdG9yeSBlcnJvclxuICAgIGlmIChjaGVjaykge1xuICAgICAgdGhpcy5jaGVja1N0YXR1cygpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSh7d2lkdGgsIGhlaWdodH0pIHtcbiAgICBpZiAod2lkdGggPT09IHRoaXMud2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxvZy5sb2coMiwgYFJlc2l6aW5nIGZyYW1lYnVmZmVyICR7dGhpcy5pZH0gdG8gJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIHt3aWR0aCwgaGVpZ2h0fSkpO1xuICB9XG5cbiAgLy8gQXR0YWNoIGZyb20gYSBtYXAgb2YgYXR0YWNobWVudHNcbiAgYXR0YWNoKGF0dGFjaG1lbnRzKSB7XG4gICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIsIHRoaXMuaGFuZGxlKTtcblxuICAgIGZvciAoY29uc3QgYXR0YWNobWVudCBpbiBhdHRhY2htZW50cykge1xuICAgICAgY29uc3Qgb2JqZWN0ID0gYXR0YWNobWVudHNbYXR0YWNobWVudF07XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICB0aGlzLl91bmF0dGFjaCh7YXR0YWNobWVudH0pO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZW5kZXJidWZmZXIpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoUmVuZGVyYnVmZmVyKHthdHRhY2htZW50LCByZW5kZXJidWZmZXI6IG9iamVjdH0pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgY29uc3QgW3RleHR1cmUsIGxheWVyID0gMCwgbGV2ZWwgPSAwXSA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5fYXR0YWNoVGV4dHVyZSh7YXR0YWNobWVudCwgdGV4dHVyZSwgbGF5ZXIsIGxldmVsfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hdHRhY2hUZXh0dXJlKHthdHRhY2htZW50LCB0ZXh0dXJlOiBvYmplY3QsIGxheWVyOiAwLCBsZXZlbDogMH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0YWNobWVudHMsIGF0dGFjaG1lbnRzKTtcblxuICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSLCBudWxsKTtcbiAgfVxuXG4gIGNoZWNrU3RhdHVzKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xuICAgIGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoR0xfRlJBTUVCVUZGRVIpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihfZ2V0RnJhbWVCdWZmZXJTdGF0dXMoc3RhdHVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaG1lbnRzW0dMX0NPTE9SX0FUVEFDSE1FTlQwXSB8fCBudWxsO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNobWVudHNbR0xfQ09MT1JfQVRUQUNITUVOVDBdIHx8IG51bGw7XG4gIH1cblxuICBnZXQgZGVwdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNobWVudHNbR0xfREVQVEhfQVRUQUNITUVOVF0gfHwgbnVsbDtcbiAgfVxuXG4gIGdldCBzdGVuY2lsKCkge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaG1lbnRzW0dMX1NURU5DSUxfQVRUQUNITUVOVF0gfHwgbnVsbDtcbiAgfVxuXG4gIC8vIE5PVEU6IFNsb3cgcmVxdWlyZXMgcm91bmR0cmlwIHRvIEdQVVxuICAvLyBBcHAgY2FuIHByb3ZpZGUgcGl4ZWxBcnJheSBvciBoYXZlIGl0IGF1dG8gYWxsb2NhdGVkIGJ5IHRoaXMgbWV0aG9kXG4gIC8vIEByZXR1cm5zIHtVaW50OEFycmF5fFVpbnQxNkFycmF5fEZsb2F0QXJyYXl9IC0gcGl4ZWwgYXJyYXksXG4gIC8vICBuZXdseSBhbGxvY2F0ZWQgYnkgdGhpcyBtZXRob2QgdW5sZXNzIHByb3ZpZGVkIGJ5IGFwcC5cbiAgcmVhZFBpeGVscyh7XG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZvcm1hdCA9IEdMLlJHQkEsXG4gICAgdHlwZSxcbiAgICBwaXhlbEFycmF5ID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG5cbiAgICAvLyBEZWR1Y2UgdHlwZSBhbmQgYWxsb2NhdGVkIHBpeGVsQXJyYXkgaWYgbmVlZGVkXG4gICAgaWYgKCFwaXhlbEFycmF5KSB7XG4gICAgICAvLyBBbGxvY2F0ZSBwaXhlbCBhcnJheSBpZiBub3QgYWxyZWFkeSBhdmFpbGFibGUsIHVzaW5nIHN1cHBsaWVkIHR5cGVcbiAgICAgIHR5cGUgPSB0eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICBjb25zdCBBcnJheVR5cGUgPSBnZXRUeXBlZEFycmF5RnJvbUdMVHlwZSh0eXBlKTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnbEZvcm1hdFRvQ29tcG9uZW50cyhmb3JtYXQpO1xuICAgICAgLy8gVE9ETyAtIGNoZWNrIGZvciBjb21wb3NpdGUgdHlwZSAoY29tcG9uZW50cyA9IDEpLlxuICAgICAgcGl4ZWxBcnJheSA9IHBpeGVsQXJyYXkgfHwgbmV3IEFycmF5VHlwZSh3aWR0aCAqIGhlaWdodCAqIGNvbXBvbmVudHMpO1xuICAgIH1cblxuICAgIC8vIFBpeGVsIGFycmF5IGF2YWlsYWJsZSwgaWYgbmVjZXNzYXJ5LCBkZWR1Y2UgdHlwZSBmcm9tIGl0LlxuICAgIHR5cGUgPSB0eXBlIHx8IGdldEdMVHlwZUZyb21UeXBlZEFycmF5KHBpeGVsQXJyYXkpO1xuXG4gICAgdGhpcy5iaW5kKCk7XG4gICAgdGhpcy5nbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgcGl4ZWxBcnJheSk7XG4gICAgdGhpcy51bmJpbmQoKTtcblxuICAgIHJldHVybiBwaXhlbEFycmF5O1xuICB9XG5cbiAgLy8gU2VsZWN0cyBhIGNvbG9yIGJ1ZmZlciBhcyB0aGUgc291cmNlIGZvciBwaXhlbHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgLy8gY29weVRleEltYWdlMkQsIGNvcHlUZXhTdWJJbWFnZTJELCBjb3B5VGV4U3ViSW1hZ2UzRCBvciByZWFkUGl4ZWxzLlxuICAvLyBzcmNcbiAgLy8gIGdsLkJBQ0s6IFJlYWRzIGZyb20gdGhlIGJhY2sgY29sb3IgYnVmZmVyLlxuICAvLyAgZ2wuTk9ORTogUmVhZHMgZnJvbSBubyBjb2xvciBidWZmZXIuXG4gIC8vICBnbC5DT0xPUl9BVFRBQ0hNRU5UezAtMTV9OiBSZWFkcyBmcm9tIG9uZSBvZiAxNiBjb2xvciBhdHRhY2htZW50IGJ1ZmZlcnMuXG4gIHJlYWRCdWZmZXIoe3NyY30pIHtcbiAgICBhc3NlcnRXZWJHTENvbnRleHQodGhpcy5nbCk7XG4gICAgdGhpcy5nbC5yZWFkQnVmZmVyKHNyYyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBXRUJHTDIgSU5URVJGQUNFXG5cbiAgLy8gQ29waWVzIGEgcmVjdGFuZ2xlIG9mIHBpeGVscyBiZXR3ZWVuIGZyYW1lYnVmZmVyc1xuICBibGl0KHtcbiAgICBzcmNGcmFtZWJ1ZmZlcixcbiAgICBzcmNYMCwgc3JjWTAsIHNyY1gxLCBzcmNZMSxcbiAgICBkc3RYMCwgZHN0WTAsIGRzdFgxLCBkc3RZMSxcbiAgICBtYXNrLFxuICAgIGZpbHRlciA9IEdMLk5FQVJFU1RcbiAgfSkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzO1xuICAgIGFzc2VydFdlYkdMMkNvbnRleHQoZ2wpO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0RSQVdfRlJBTUVCVUZGRVIsIHRoaXMuaGFuZGxlKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfUkVBRF9GUkFNRUJVRkZFUiwgc3JjRnJhbWVidWZmZXIuaGFuZGxlKTtcbiAgICBnbC5ibGl0RnJhbWVidWZmZXIoXG4gICAgICBzcmNYMCwgc3JjWTAsIHNyY1gxLCBzcmNZMSxcbiAgICAgIGRzdFgwLCBkc3RZMCwgZHN0WDEsIGRzdFkxLFxuICAgICAgbWFzayxcbiAgICAgIGZpbHRlclxuICAgICk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0RSQVdfRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9SRUFEX0ZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNpZ25hbHMgdG8gdGhlIEdMIHRoYXQgaXQgbmVlZCBub3QgcHJlc2VydmUgYWxsIHBpeGVscyBvZiBhIHNwZWNpZmllZCByZWdpb25cbiAgLy8gb2YgdGhlIGZyYW1lYnVmZmVyXG4gIGludmFsaWRhdGUoe1xuICAgIGF0dGFjaG1lbnRzID0gW10sXG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBhc3NlcnRXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLmhhbmRsZSk7XG4gICAgY29uc3QgaW52YWxpZGF0ZUFsbCA9IHggPT09IDAgJiYgeSA9PT0gMCAmJiB3aWR0aCA9PT0gdW5kZWZpbmVkICYmIGhlaWdodCA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChpbnZhbGlkYXRlQWxsKSB7XG4gICAgICBnbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoR0xfUkVBRF9GUkFNRUJVRkZFUiwgYXR0YWNobWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdsLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihHTF9SRUFEX0ZSQU1FQlVGRkVSLCBhdHRhY2htZW50cywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9SRUFEX0ZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIHRoZSBwYXNzZWQgcG5hbWUgZ2l2ZW4gdGhlIHRhcmdldCBhbmQgYXR0YWNobWVudC5cbiAgLy8gVGhlIHR5cGUgcmV0dXJuZWQgaXMgdGhlIG5hdHVyYWwgdHlwZSBmb3IgdGhlIHJlcXVlc3RlZCBwbmFtZTpcbiAgLy8gcG5hbWUgcmV0dXJuZWQgdHlwZVxuICAvLyBJZiBhbiBPcGVuR0wgZXJyb3IgaXMgZ2VuZXJhdGVkLCByZXR1cm5zIG51bGwuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgZ2V0QXR0YWNobWVudFBhcmFtZXRlcih7XG4gICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgYXR0YWNobWVudCA9IEdMX0NPTE9SX0FUVEFDSE1FTlQwLFxuICAgIHBuYW1lXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGNhcHMgPSBnZXRDb250ZXh0Q2Fwcyh0aGlzLmdsKTtcblxuICAgIHN3aXRjaCAocG5hbWUpIHtcbiAgICAvLyBFWFRfc1JHQiBvciBXZWJHTDJcbiAgICBjYXNlIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkc6XG4gICAgICBpZiAoIWNhcHMuRVhUX3NSR0IpIHtcbiAgICAgICAgcmV0dXJuIEdMLkxJTkVBUjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIFdlYkdMMlxuICAgIGNhc2UgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSOiAvLyBHTGludFxuICAgIGNhc2UgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9SRURfU0laRTogLy8gR0xpbnRcbiAgICBjYXNlIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfR1JFRU5fU0laRTogLy8gR0xpbnRcbiAgICBjYXNlIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFOiAvLyBHTGludFxuICAgIGNhc2UgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9BTFBIQV9TSVpFOiAvLyBHTGludFxuICAgIGNhc2UgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9ERVBUSF9TSVpFOiAvLyBHTGludFxuICAgIGNhc2UgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkU6IC8vIEdMaW50XG4gICAgICBpZiAoIWNhcHMud2ViZ2wyKSB7XG4gICAgICAgIHJldHVybiA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHTC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFOlxuICAgICAgLy8gR0wuRkxPQVQsIEdMLklOVCwgR0wuVU5TSUdORURfSU5ULCBHTC5TSUdORURfTk9STUFMSVpFRCwgT1IgR0wuVU5TSUdORURfTk9STUFMSVpFRC5cbiAgICAgIGlmICghY2Fwcy53ZWJnbDIpIHtcbiAgICAgICAgcmV0dXJuIEdMLlVOU0lHTkVEX0lOVDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbC5nZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXIodGFyZ2V0LCBhdHRhY2htZW50LCBwbmFtZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgZ2V0QXR0YWNobWVudFBhcmFtZXRlcnMoXG4gICAgYXR0YWNobWVudCA9IEdMX0NPTE9SX0FUVEFDSE1FTlQwLFxuICAgIHBhcmFtZXRlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVEFDSE1FTlRfUEFSQU1FVEVSUyB8fCB7fVxuICApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBuYW1lIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhbHVlc1twbmFtZV0gPSB0aGlzLmdldFBhcmFtZXRlcihwbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gV0VCR0wgSU5URVJGQUNFXG5cbiAgYmluZCh7dGFyZ2V0ID0gR0xfRlJBTUVCVUZGRVJ9ID0ge30pIHtcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVuYmluZCh7dGFyZ2V0ID0gR0xfRlJBTUVCVUZGRVJ9ID0ge30pIHtcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgX2NyZWF0ZURlZmF1bHRBdHRhY2htZW50cyh7Y29sb3IsIGRlcHRoLCBzdGVuY2lsLCB3aWR0aCwgaGVpZ2h0fSkge1xuICAgIGNvbnN0IGRlZmF1bHRBdHRhY2htZW50cyA9IHt9O1xuXG4gICAgLy8gQWRkIGEgY29sb3IgYnVmZmVyIGlmIHJlcXVlc3RlZCBhbmQgbm90IHN1cHBsaWVkXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBkZWZhdWx0QXR0YWNobWVudHNbR0xfQ09MT1JfQVRUQUNITUVOVDBdID0gbmV3IFRleHR1cmUyRCh0aGlzLmdsLCB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGZvcm1hdDogR0wuUkdCQSxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgIFtHTC5URVhUVVJFX01JTl9GSUxURVJdOiBHTC5ORUFSRVNULFxuICAgICAgICAgIFtHTC5URVhUVVJFX01BR19GSUxURVJdOiBHTC5ORUFSRVNUXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBhIGRlcHRoIGJ1ZmZlciBpZiByZXF1ZXN0ZWQgYW5kIG5vdCBzdXBwbGllZFxuICAgIGlmIChkZXB0aCkge1xuICAgICAgZGVmYXVsdEF0dGFjaG1lbnRzW0dMX0RFUFRIX0FUVEFDSE1FTlRdID0gbmV3IFJlbmRlcmJ1ZmZlcih0aGlzLmdsLCB7XG4gICAgICAgIGZvcm1hdDogR0wuREVQVEhfQ09NUE9ORU5UMTYsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBoYW5kbGUgc3RlbmNpbCBhbmQgY29tYmluZWQgZGVwdGggYW5kIHN0ZW5jaWxcblxuICAgIHJldHVybiBkZWZhdWx0QXR0YWNobWVudHM7XG4gIH1cblxuICBfdW5hdHRhY2goe2F0dGFjaG1lbnR9KSB7XG4gICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgdGhpcy5oYW5kbGUpO1xuICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoR0xfRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIEdMX1JFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgZGVsZXRlIHRoaXMuYXR0YWNobWVudHNbYXR0YWNobWVudF07XG4gIH1cblxuICBfYXR0YWNoUmVuZGVyYnVmZmVyKHthdHRhY2htZW50ID0gR0xfQ09MT1JfQVRUQUNITUVOVDAsIHJlbmRlcmJ1ZmZlcn0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICAvLyBUT0RPIC0gaXMgdGhlIGJpbmQgbmVlZGVkP1xuICAgIC8vIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIuaGFuZGxlKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihHTF9GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgR0xfUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIuaGFuZGxlKTtcbiAgICAvLyBUT0RPIC0gaXMgdGhlIHVuYmluZCBuZWVkZWQ/XG4gICAgLy8gZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIG51bGwpO1xuXG4gICAgdGhpcy5hdHRhY2htZW50c1thdHRhY2htZW50XSA9IHJlbmRlcmJ1ZmZlcjtcbiAgfVxuXG4gIC8vIGxheWVyID0gMCAtIGluZGV4IGludG8gVGV4dHVyZTJEQXJyYXkgYW5kIFRleHR1cmUzRCBvciBmYWNlIGZvciBgVGV4dHVyZUN1YmVNYXBgXG4gIC8vIGxldmVsID0gMCAtIG1pcG1hcExldmVsIChtdXN0IGJlIDAgaW4gV2ViR0wxKVxuICBfYXR0YWNoVGV4dHVyZSh7YXR0YWNobWVudCA9IEdMX0NPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlLCBsYXllciwgbGV2ZWx9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG4gICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIHRleHR1cmUuaGFuZGxlKTtcblxuICAgIHN3aXRjaCAodGV4dHVyZS50YXJnZXQpIHtcbiAgICBjYXNlIEdMX1RFWFRVUkVfMkRfQVJSQVk6XG4gICAgY2FzZSBHTF9URVhUVVJFXzNEOlxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoR0xfRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIHRleHR1cmUudGFyZ2V0LCBsZXZlbCwgbGF5ZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEdMX1RFWFRVUkVfQ1VCRV9NQVA6XG4gICAgICAvLyBsYXllciBtdXN0IGJlIGEgY3ViZW1hcCBmYWNlIChvciBpZiBpbmRleCwgY29udmVydGVkIHRvIGN1YmUgbWFwIGZhY2UpXG4gICAgICBjb25zdCBmYWNlID0gbWFwSW5kZXhUb0N1YmVNYXBGYWNlKGxheWVyKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKEdMX0ZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBmYWNlLCB0ZXh0dXJlLmhhbmRsZSwgbGV2ZWwpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEdMX1RFWFRVUkVfMkQ6XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChHTF9GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgR0xfVEVYVFVSRV8yRCwgdGV4dHVyZS5oYW5kbGUsIGxldmVsKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydChmYWxzZSwgJ0lsbGVnYWwgdGV4dHVyZSB0eXBlJyk7XG4gICAgfVxuXG4gICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIG51bGwpO1xuICAgIHRoaXMuYXR0YWNobWVudHNbYXR0YWNobWVudF0gPSB0ZXh0dXJlO1xuICB9XG5cbiAgLy8gUkVTT1VSQ0UgTUVUSE9EU1xuXG4gIF9jcmVhdGVIYW5kbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgfVxuXG4gIF9kZWxldGVIYW5kbGUoKSB7XG4gICAgdGhpcy5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmhhbmRsZSk7XG4gIH1cbn1cblxuLy8gTWFwIGFuIGluZGV4IHRvIGEgY3ViZSBtYXAgZmFjZSBjb25zdGFudFxuZnVuY3Rpb24gbWFwSW5kZXhUb0N1YmVNYXBGYWNlKGxheWVyKSB7XG4gIC8vIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCBpcyBhIGJpZyB2YWx1ZSAoMHg4NTE1KVxuICAvLyBpZiBzbWFsbGVyIGFzc3VtZSBsYXllciBpcyBpbmRleCwgb3RoZXJ3aXNlIGFzc3VtZSBpdCBpcyBhbHJlYWR5IGEgY3ViZSBtYXAgZmFjZSBjb25zdGFudFxuICByZXR1cm4gbGF5ZXIgPCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggP1xuICAgIGxheWVyICsgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIDpcbiAgICBsYXllcjtcbn1cblxuLy8gUmV0dXJucyBudW1iZXIgb2YgY29tcG9uZW50cyBpbiBhIHNwZWNpZmljIFdlYkdMIGZvcm1hdFxuZnVuY3Rpb24gZ2xGb3JtYXRUb0NvbXBvbmVudHMoZm9ybWF0KSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gIGNhc2UgR0wuQUxQSEE6IHJldHVybiAxO1xuICBjYXNlIEdMLlJHQjogcmV0dXJuIDM7XG4gIGNhc2UgR0wuUkdCQTogcmV0dXJuIDQ7XG4gIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biBmb3JtYXQnKTtcbiAgfVxufVxuXG4vLyBHZXQgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZnJhbWVidWZmZXIgZXJyb3IgaWYgaW5zdGFsbGVkXG5mdW5jdGlvbiBfZ2V0RnJhbWVCdWZmZXJTdGF0dXMoc3RhdHVzKSB7XG4gIC8vIFVzZSBlcnJvciBtYXBwaW5nIGlmIGluc3RhbGxlZFxuICBjb25zdCBTVEFUVVMgPSBGcmFtZWJ1ZmZlci5TVEFUVVMgfHwge307XG4gIHJldHVybiBTVEFUVVNbc3RhdHVzXSB8fCBgRnJhbWVidWZmZXIgZXJyb3IgJHtzdGF0dXN9YDtcbn1cbiJdfQ==

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-inline-comments */




// Local constants for optimal minification
var GL_RENDERBUFFER = 0x8D41;
var GL_SAMPLES = 0x80A9;
var GL_RENDERBUFFER_WIDTH = 0x8D42;
var GL_RENDERBUFFER_HEIGHT = 0x8D43;
var GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
var GL_RENDERBUFFER_SAMPLES = 0x8CAB;

var Renderbuffer = function (_Resource) {
  _inherits(Renderbuffer, _Resource);

  _createClass(Renderbuffer, null, [{
    key: 'getSamplesForFormat',
    value: function getSamplesForFormat(_ref) {
      var format = _ref.format;

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(this.gl) ? this.gl.getInternalformatParameter(GL_RENDERBUFFER, format, GL_SAMPLES) : [0];
    }
  }]);

  function Renderbuffer(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Renderbuffer);

    var _this = _possibleConstructorReturn(this, (Renderbuffer.__proto__ || Object.getPrototypeOf(Renderbuffer)).call(this, gl, opts));

    _this.initialize(opts);
    Object.seal(_this);
    return _this;
  }

  // Creates and initializes a renderbuffer object's data store


  _createClass(Renderbuffer, [{
    key: 'initialize',
    value: function initialize(_ref2) {
      var format = _ref2.format,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$samples = _ref2.samples,
          samples = _ref2$samples === undefined ? 0 : _ref2$samples;

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(format, 'Needs format');
      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);

      if (samples !== 0 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(this.gl)) {
        this.gl.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(GL_RENDERBUFFER, format, width, height);
      }

      // this.gl.bindRenderbuffer(GL_RENDERBUFFER, null);

      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;

      return this;
    }
  }, {
    key: 'resize',
    value: function resize(_ref3) {
      var width = _ref3.width,
          height = _ref3.height;

      // Don't resize if width/height haven't changed
      if (width === this.width && height === this.height) {
        return this;
      }
      return this.initialize({ format: this.format, width: width, height: height, samples: this.samples });
    }

    // PRIVATE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createRenderbuffer();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
    }
  }, {
    key: '_syncHandle',
    value: function _syncHandle(handle) {
      this.format = this.getParameter(GL_RENDERBUFFER_INTERNAL_FORMAT);
      this.width = this.getParameter(GL_RENDERBUFFER_WIDTH);
      this.height = this.getParameter(GL_RENDERBUFFER_HEIGHT);
      this.samples = this.getParameter(GL_RENDERBUFFER_SAMPLES);
    }

    // @param {Boolean} opt.autobind=true - method call will bind/unbind object
    // @returns {GLenum|GLint} - depends on pname

  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);
      var value = this.gl.getRenderbufferParameter(GL_RENDERBUFFER, pname);
      // this.gl.bindRenderbuffer(GL_RENDERBUFFER, null);
      return value;
    }
  }]);

  return Renderbuffer;
}(__WEBPACK_IMPORTED_MODULE_1__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Renderbuffer);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9yZW5kZXJidWZmZXIuanMiXSwibmFtZXMiOlsiaXNXZWJHTDJDb250ZXh0IiwiUmVzb3VyY2UiLCJhc3NlcnQiLCJHTF9SRU5ERVJCVUZGRVIiLCJHTF9TQU1QTEVTIiwiR0xfUkVOREVSQlVGRkVSX1dJRFRIIiwiR0xfUkVOREVSQlVGRkVSX0hFSUdIVCIsIkdMX1JFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQiLCJHTF9SRU5ERVJCVUZGRVJfU0FNUExFUyIsIlJlbmRlcmJ1ZmZlciIsImZvcm1hdCIsImdsIiwiZ2V0SW50ZXJuYWxmb3JtYXRQYXJhbWV0ZXIiLCJvcHRzIiwiaW5pdGlhbGl6ZSIsIk9iamVjdCIsInNlYWwiLCJ3aWR0aCIsImhlaWdodCIsInNhbXBsZXMiLCJiaW5kUmVuZGVyYnVmZmVyIiwiaGFuZGxlIiwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlIiwicmVuZGVyYnVmZmVyU3RvcmFnZSIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsImRlbGV0ZVJlbmRlcmJ1ZmZlciIsImdldFBhcmFtZXRlciIsInBuYW1lIiwidmFsdWUiLCJnZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxTQUFRQSxlQUFSLFFBQThCLFdBQTlCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixZQUFyQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7QUFDQSxJQUFNQyxrQkFBa0IsTUFBeEI7QUFDQSxJQUFNQyxhQUFhLE1BQW5CO0FBQ0EsSUFBTUMsd0JBQXdCLE1BQTlCO0FBQ0EsSUFBTUMseUJBQXlCLE1BQS9CO0FBQ0EsSUFBTUMsa0NBQWtDLE1BQXhDO0FBQ0EsSUFBTUMsMEJBQTBCLE1BQWhDOztJQUVxQkMsWTs7Ozs7OENBRWtCO0FBQUEsVUFBVEMsTUFBUyxRQUFUQSxNQUFTOztBQUNuQyxhQUFPVixnQkFBZ0IsS0FBS1csRUFBckIsSUFDTCxLQUFLQSxF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c2FibGUgbm8taW5saW5lLWNvbW1lbnRzICovXG5pbXBvcnQge2lzV2ViR0wyQ29udGV4dH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gTG9jYWwgY29uc3RhbnRzIGZvciBvcHRpbWFsIG1pbmlmaWNhdGlvblxuY29uc3QgR0xfUkVOREVSQlVGRkVSID0gMHg4RDQxO1xuY29uc3QgR0xfU0FNUExFUyA9IDB4ODBBOTtcbmNvbnN0IEdMX1JFTkRFUkJVRkZFUl9XSURUSCA9IDB4OEQ0MjtcbmNvbnN0IEdMX1JFTkRFUkJVRkZFUl9IRUlHSFQgPSAweDhENDM7XG5jb25zdCBHTF9SRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUID0gMHg4RDQ0O1xuY29uc3QgR0xfUkVOREVSQlVGRkVSX1NBTVBMRVMgPSAweDhDQUI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmJ1ZmZlciBleHRlbmRzIFJlc291cmNlIHtcblxuICBzdGF0aWMgZ2V0U2FtcGxlc0ZvckZvcm1hdCh7Zm9ybWF0fSkge1xuICAgIHJldHVybiBpc1dlYkdMMkNvbnRleHQodGhpcy5nbCkgP1xuICAgICAgdGhpcy5nbC5nZXRJbnRlcm5hbGZvcm1hdFBhcmFtZXRlcihHTF9SRU5ERVJCVUZGRVIsIGZvcm1hdCwgR0xfU0FNUExFUykgOlxuICAgICAgWzBdO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZ2wsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKGdsLCBvcHRzKTtcbiAgICB0aGlzLmluaXRpYWxpemUob3B0cyk7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvLyBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIHJlbmRlcmJ1ZmZlciBvYmplY3QncyBkYXRhIHN0b3JlXG4gIGluaXRpYWxpemUoe2Zvcm1hdCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBzYW1wbGVzID0gMH0pIHtcbiAgICBhc3NlcnQoZm9ybWF0LCAnTmVlZHMgZm9ybWF0Jyk7XG4gICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgdGhpcy5oYW5kbGUpO1xuXG4gICAgaWYgKHNhbXBsZXMgIT09IDAgJiYgaXNXZWJHTDJDb250ZXh0KHRoaXMuZ2wpKSB7XG4gICAgICB0aGlzLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShHTF9SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgbnVsbCk7XG5cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zYW1wbGVzID0gc2FtcGxlcztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVzaXplKHt3aWR0aCwgaGVpZ2h0fSkge1xuICAgIC8vIERvbid0IHJlc2l6ZSBpZiB3aWR0aC9oZWlnaHQgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplKHtmb3JtYXQ6IHRoaXMuZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzOiB0aGlzLnNhbXBsZXN9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICB9XG5cbiAgX2RlbGV0ZUhhbmRsZSgpIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLmhhbmRsZSk7XG4gIH1cblxuICBfc3luY0hhbmRsZShoYW5kbGUpIHtcbiAgICB0aGlzLmZvcm1hdCA9IHRoaXMuZ2V0UGFyYW1ldGVyKEdMX1JFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmdldFBhcmFtZXRlcihHTF9SRU5ERVJCVUZGRVJfV0lEVEgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5nZXRQYXJhbWV0ZXIoR0xfUkVOREVSQlVGRkVSX0hFSUdIVCk7XG4gICAgdGhpcy5zYW1wbGVzID0gdGhpcy5nZXRQYXJhbWV0ZXIoR0xfUkVOREVSQlVGRkVSX1NBTVBMRVMpO1xuICB9XG5cbiAgLy8gQHBhcmFtIHtCb29sZWFufSBvcHQuYXV0b2JpbmQ9dHJ1ZSAtIG1ldGhvZCBjYWxsIHdpbGwgYmluZC91bmJpbmQgb2JqZWN0XG4gIC8vIEByZXR1cm5zIHtHTGVudW18R0xpbnR9IC0gZGVwZW5kcyBvbiBwbmFtZVxuICBfZ2V0UGFyYW1ldGVyKHBuYW1lKSB7XG4gICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgdGhpcy5oYW5kbGUpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nbC5nZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXIoR0xfUkVOREVSQlVGRkVSLCBwbmFtZSk7XG4gICAgLy8gdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4iXX0=

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__effect__ = __webpack_require__(135);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__effect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effect_manager__ = __webpack_require__(134);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__effect_manager__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvbGliL2luZGV4LmpzIl0sIm5hbWVzIjpbImRlZmF1bHQiLCJFZmZlY3QiLCJFZmZlY3RNYW5hZ2VyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxXQUFXQyxNQUFuQixRQUFnQyxVQUFoQztBQUNBLFNBQVFELFdBQVdFLGFBQW5CLFFBQXVDLGtCQUF2QyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQge2RlZmF1bHQgYXMgRWZmZWN0fSBmcm9tICcuL2VmZmVjdCc7XG5leHBvcnQge2RlZmF1bHQgYXMgRWZmZWN0TWFuYWdlcn0gZnJvbSAnLi9lZmZlY3QtbWFuYWdlcic7XG4iXX0=

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__path_layer_vertex_glsl__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__path_layer_vertex_64_glsl__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__ = __webpack_require__(160);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [0, 0, 0, 255];

var defaultProps = {
  widthScale: 1, // stroke width in meters
  widthMinPixels: 0, //  min stroke width in pixels
  widthMaxPixels: Number.MAX_SAFE_INTEGER, // max stroke width in pixels
  rounded: false,
  miterLimit: 4,
  fp64: false,

  getPath: function getPath(object) {
    return object.path;
  },
  getColor: function getColor(object) {
    return object.color || DEFAULT_COLOR;
  },
  getWidth: function getWidth(object) {
    return object.width || 1;
  }
};

var isClosed = function isClosed(path) {
  var firstPoint = path[0];
  var lastPoint = path[path.length - 1];
  return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];
};

var PathLayer = function (_Layer) {
  _inherits(PathLayer, _Layer);

  function PathLayer() {
    _classCallCheck(this, PathLayer);

    return _possibleConstructorReturn(this, (PathLayer.__proto__ || Object.getPrototypeOf(PathLayer)).apply(this, arguments));
  }

  _createClass(PathLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__path_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__path_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      var attributeManager = this.state.attributeManager;
      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instanceStartPositions: { size: 3, update: this.calculateStartPositions },
        instanceEndPositions: { size: 3, update: this.calculateEndPositions },
        instanceLeftDeltas: { size: 3, update: this.calculateLeftDeltas },
        instanceRightDeltas: { size: 3, update: this.calculateRightDeltas },
        instanceStrokeWidths: { size: 1, accessor: 'getWidth', update: this.calculateStrokeWidths },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors },
        instancePickingColors: { size: 3, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, update: this.calculatePickingColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instanceStartEndPositions64xyLow: {
              size: 4,
              update: this.calculateInstanceStartEndPositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instanceStartEndPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;

      _get(PathLayer.prototype.__proto__ || Object.getPrototypeOf(PathLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });

      var getPath = this.props.getPath;
      var attributeManager = this.state.attributeManager;

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });

      if (changeFlags.dataChanged) {
        // this.state.paths only stores point positions in each path
        var paths = props.data.map(getPath);
        var numInstances = paths.reduce(function (count, path) {
          return count + path.length - 1;
        }, 0);

        this.setState({ paths: paths, numInstances: numInstances });
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var _props = this.props,
          rounded = _props.rounded,
          miterLimit = _props.miterLimit,
          widthScale = _props.widthScale,
          widthMinPixels = _props.widthMinPixels,
          widthMaxPixels = _props.widthMaxPixels;


      this.state.model.render(Object.assign({}, uniforms, {
        jointType: Number(rounded),
        widthScale: widthScale,
        miterLimit: miterLimit,
        widthMinPixels: widthMinPixels,
        widthMaxPixels: widthMaxPixels
      }));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());
      /*
       *       _
       *        "-_ 1                   3                       5
       *     _     "o---------------------o-------------------_-o
       *       -   / ""--..__              '.             _.-' /
       *   _     "@- - - - - ""--..__- - - - x - - - -_.@'    /
       *    "-_  /                   ""--..__ '.  _,-` :     /
       *       "o----------------------------""-o'    :     /
       *      0,2                            4 / '.  :     /
       *                                      /   '.:     /
       *                                     /     :'.   /
       *                                    /     :  ', /
       *                                   /     :     o
       */

      var SEGMENT_INDICES = [
      // start corner
      0, 2, 1,
      // body
      1, 2, 4, 1, 4, 3,
      // end corner
      3, 4, 5];

      // [0] position on segment - 0: start, 1: end
      // [1] side of path - -1: left, 0: center, 1: right
      // [2] role - 0: offset point 1: joint point
      var SEGMENT_POSITIONS = [
      // bevel start corner
      0, 0, 1,
      // start inner corner
      0, -1, 0,
      // start outer corner
      0, 1, 0,
      // end inner corner
      1, -1, 0,
      // end outer corner
      1, 1, 0,
      // bevel end corner
      1, 0, 1];

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        fs: shaders.fs,
        vs: shaders.vs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLES,
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: new Float32Array(SEGMENT_POSITIONS)
          }
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'calculateStartPositions',
    value: function calculateStartPositions(attribute) {
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path) {
        var numSegments = path.length - 1;
        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {
          var point = path[ptIndex];
          value[i++] = point[0];
          value[i++] = point[1];
          value[i++] = point[2] || 0;
        }
      });
    }
  }, {
    key: 'calculateEndPositions',
    value: function calculateEndPositions(attribute) {
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path) {
        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          var point = path[ptIndex];
          value[i++] = point[0];
          value[i++] = point[1];
          value[i++] = point[2] || 0;
        }
      });
    }
  }, {
    key: 'calculateInstanceStartEndPositions64xyLow',
    value: function calculateInstanceStartEndPositions64xyLow(attribute) {
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path) {
        var numSegments = path.length - 1;
        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {
          var startPoint = path[ptIndex];
          var endPoint = path[ptIndex + 1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(startPoint[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(startPoint[1])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(endPoint[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(endPoint[1])[1];
        }
      });
    }
  }, {
    key: 'calculateLeftDeltas',
    value: function calculateLeftDeltas(attribute) {
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path) {
        var numSegments = path.length - 1;
        var prevPoint = isClosed(path) ? path[path.length - 2] : path[0];

        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {
          var point = path[ptIndex];
          value[i++] = point[0] - prevPoint[0];
          value[i++] = point[1] - prevPoint[1];
          value[i++] = point[2] - prevPoint[2] || 0;
          prevPoint = point;
        }
      });
    }
  }, {
    key: 'calculateRightDeltas',
    value: function calculateRightDeltas(attribute) {
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path) {
        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          var point = path[ptIndex];
          var nextPoint = path[ptIndex + 1];
          if (!nextPoint) {
            nextPoint = isClosed(path) ? path[1] : point;
          }

          value[i++] = nextPoint[0] - point[0];
          value[i++] = nextPoint[1] - point[1];
          value[i++] = nextPoint[2] - point[2] || 0;
        }
      });
    }
  }, {
    key: 'calculateStrokeWidths',
    value: function calculateStrokeWidths(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getWidth = _props2.getWidth;
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path, index) {
        var width = getWidth(data[index], index);
        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          value[i++] = width;
        }
      });
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getColor = _props3.getColor;
      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path, index) {
        var pointColor = getColor(data[index], index);
        if (isNaN(pointColor[3])) {
          pointColor[3] = 255;
        }
        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          value[i++] = pointColor[0];
          value[i++] = pointColor[1];
          value[i++] = pointColor[2];
          value[i++] = pointColor[3];
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this2 = this;

      var paths = this.state.paths;
      var value = attribute.value;


      var i = 0;
      paths.forEach(function (path, index) {
        var pickingColor = _this2.encodePickingColor(index);
        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          value[i++] = pickingColor[0];
          value[i++] = pickingColor[1];
          value[i++] = pickingColor[2];
        }
      });
    }
  }]);

  return PathLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (PathLayer);


PathLayer.layerName = 'PathLayer';
PathLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJHTCIsIk1vZGVsIiwiR2VvbWV0cnkiLCJmcDY0aWZ5IiwiZW5hYmxlNjRiaXRTdXBwb3J0IiwiQ09PUkRJTkFURV9TWVNURU0iLCJwYXRoVmVydGV4IiwicGF0aFZlcnRleDY0IiwicGF0aEZyYWdtZW50IiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsIndpZHRoU2NhbGUiLCJ3aWR0aE1pblBpeGVscyIsIndpZHRoTWF4UGl4ZWxzIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJvdW5kZWQiLCJtaXRlckxpbWl0IiwiZnA2NCIsImdldFBhdGgiLCJvYmplY3QiLCJwYXRoIiwiZ2V0Q29sb3IiLCJjb2xvciIsImdldFdpZHRoIiwid2lkdGgiLCJpc0Nsb3NlZCIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJsZW5ndGgiLCJQYXRoTGF5ZXIiLCJwcm9wcyIsInZzIiwiZnMiLCJtb2R1bGVzIiwic2hhZGVyQ2FjaGUiLCJjb250ZXh0IiwiZ2wiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiX2dldE1vZGVsIiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VTdGFydFBvc2l0aW9ucyIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVTdGFydFBvc2l0aW9ucyIsImluc3RhbmNlRW5kUG9zaXRpb25zIiwiY2FsY3VsYXRlRW5kUG9zaXRpb25zIiwiaW5zdGFuY2VMZWZ0RGVsdGFzIiwiY2FsY3VsYXRlTGVmdERlbHRhcyIsImluc3RhbmNlUmlnaHREZWx0YXMiLCJjYWxjdWxhdGVSaWdodERlbHRhcyIsImluc3RhbmNlU3Ryb2tlV2lkdGhzIiwiYWNjZXNzb3IiLCJjYWxjdWxhdGVTdHJva2VXaWR0aHMiLCJpbnN0YW5jZUNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlQ29sb3JzIiwiaW5zdGFuY2VQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlUGlja2luZ0NvbG9ycyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJpbnZhbGlkYXRlQWxsIiwicHJvamVjdGlvbk1vZGUiLCJMTkdMQVQiLCJpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdyIsImNhbGN1bGF0ZUluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93IiwicmVtb3ZlIiwidXBkYXRlQXR0cmlidXRlIiwiZGF0YUNoYW5nZWQiLCJwYXRocyIsImRhdGEiLCJtYXAiLCJudW1JbnN0YW5jZXMiLCJyZWR1Y2UiLCJjb3VudCIsInVuaWZvcm1zIiwicmVuZGVyIiwiT2JqZWN0IiwiYXNzaWduIiwiam9pbnRUeXBlIiwic2hhZGVycyIsImdldFNoYWRlcnMiLCJTRUdNRU5UX0lORElDRVMiLCJTRUdNRU5UX1BPU0lUSU9OUyIsImlkIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIlRSSUFOR0xFUyIsImF0dHJpYnV0ZXMiLCJpbmRpY2VzIiwiVWludDE2QXJyYXkiLCJwb3NpdGlvbnMiLCJGbG9hdDMyQXJyYXkiLCJpc0luc3RhbmNlZCIsImF0dHJpYnV0ZSIsInZhbHVlIiwiaSIsImZvckVhY2giLCJudW1TZWdtZW50cyIsInB0SW5kZXgiLCJwb2ludCIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInByZXZQb2ludCIsIm5leHRQb2ludCIsImluZGV4IiwicG9pbnRDb2xvciIsImlzTmFOIiwicGlja2luZ0NvbG9yIiwiZW5jb2RlUGlja2luZ0NvbG9yIiwibGF5ZXJOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsS0FBUixRQUFvQixjQUFwQjtBQUNBLFNB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QTZDMEUsU0FBN0MsRUFBd0Q7QUFDdERKLGdCQUFNQyxHQUFOLElBQWFVLFdBQVcsQ0FBWCxDQUFiO0FBQ0FYLGdCQUFNQyxHQUFOLElBQWFVLFdBQVcsQ0FBWCxDQUFiO0FBQ0FYLGdCQUFNQyxHQUFOLElBQWFVLFdBQVcsQ0FBWCxDQUFiO0FBQ0FYLGdCQUFNQyxHQUFOLElBQWFVLFdBQVcsQ0FBWCxDQUFiO0FBQ0Q7QUFDRixPQVhEO0FBWUQ7O0FBRUQ7Ozs7MkNBQ3VCWixTLEVBQVc7QUFBQTs7QUFBQSxVQUN6QnpCLEtBRHlCLEdBQ2hCLEtBQUsvQixLQURXLENBQ3pCK0IsS0FEeUI7QUFBQSxVQUV6QjBCLEtBRnlCLEdBRWhCRCxTQUZnQixDQUV6QkMsS0FGeUI7OztBQUloQyxVQUFJQyxJQUFJLENBQVI7QUFDQTNCLFlBQU00QixPQUFOLENBQWMsVUFBQ2hGLElBQUQsRUFBT3dGLEtBQVAsRUFBaUI7QUFDN0IsWUFBTUcsZUFBZSxPQUFLQyxrQkFBTCxDQUF3QkosS0FBeEIsQ0FBckI7QUFDQSxhQUFLLElBQUlOLFVBQVUsQ0FBbkIsRUFBc0JBLFVBQVVsRixLQUFLUSxNQUFyQyxFQUE2QzBFLFNBQTdDLEVBQXdEO0FBQ3RESixnQkFBTUMsR0FBTixJQUFhWSxhQUFhLENBQWIsQ0FBYjtBQUNBYixnQkFBTUMsR0FBTixJQUFhWSxhQUFhLENBQWIsQ0FBYjtBQUNBYixnQkFBTUMsR0FBTixJQUFhWSxhQUFhLENBQWIsQ0FBYjtBQUNEO0FBQ0YsT0FQRDtBQVFEOzs7O0VBNVJvQ2xILEs7O2VBQWxCZ0MsUzs7O0FBZ1NyQkEsVUFBVW9GLFNBQVYsR0FBc0IsV0FBdEI7QUFDQXBGLFVBQVVwQixZQUFWLEdBQXlCQSxZQUF6QiIsImZpbGUiOiJwYXRoLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vLi4vbGliJztcblxuaW1wb3J0IHBhdGhWZXJ0ZXggZnJvbSAnLi9wYXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBwYXRoVmVydGV4NjQgZnJvbSAnLi9wYXRoLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBwYXRoRnJhZ21lbnQgZnJvbSAnLi9wYXRoLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgd2lkdGhTY2FsZTogMSwgLy8gc3Ryb2tlIHdpZHRoIGluIG1ldGVyc1xuICB3aWR0aE1pblBpeGVsczogMCwgLy8gIG1pbiBzdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIHdpZHRoTWF4UGl4ZWxzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgLy8gbWF4IHN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcbiAgcm91bmRlZDogZmFsc2UsXG4gIG1pdGVyTGltaXQ6IDQsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFBhdGg6IG9iamVjdCA9PiBvYmplY3QucGF0aCxcbiAgZ2V0Q29sb3I6IG9iamVjdCA9PiBvYmplY3QuY29sb3IgfHwgREVGQVVMVF9DT0xPUixcbiAgZ2V0V2lkdGg6IG9iamVjdCA9PiBvYmplY3Qud2lkdGggfHwgMVxufTtcblxuY29uc3QgaXNDbG9zZWQgPSBwYXRoID0+IHtcbiAgY29uc3QgZmlyc3RQb2ludCA9IHBhdGhbMF07XG4gIGNvbnN0IGxhc3RQb2ludCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGZpcnN0UG9pbnRbMF0gPT09IGxhc3RQb2ludFswXSAmJiBmaXJzdFBvaW50WzFdID09PSBsYXN0UG9pbnRbMV0gJiZcbiAgICBmaXJzdFBvaW50WzJdID09PSBsYXN0UG9pbnRbMl07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKSA/IHtcbiAgICAgIHZzOiBwYXRoVmVydGV4NjQsXG4gICAgICBmczogcGF0aEZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH0gOiB7XG4gICAgICB2czogcGF0aFZlcnRleCxcbiAgICAgIGZzOiBwYXRoRnJhZ21lbnQsXG4gICAgICBtb2R1bGVzOiBbXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VTdGFydFBvc2l0aW9uczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVTdGFydFBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZUVuZFBvc2l0aW9uczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVFbmRQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VMZWZ0RGVsdGFzOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUxlZnREZWx0YXN9LFxuICAgICAgaW5zdGFuY2VSaWdodERlbHRhczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVSaWdodERlbHRhc30sXG4gICAgICBpbnN0YW5jZVN0cm9rZVdpZHRoczoge3NpemU6IDEsIGFjY2Vzc29yOiAnZ2V0V2lkdGgnLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlU3Ryb2tlV2lkdGhzfSxcbiAgICAgIGluc3RhbmNlQ29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnN9LFxuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7c2l6ZTogMywgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnN9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcblxuICAgICAgaWYgKHByb3BzLmZwNjQgJiYgcHJvcHMucHJvamVjdGlvbk1vZGUgPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgICAgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGNvbnN0IHtnZXRQYXRofSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgLy8gdGhpcy5zdGF0ZS5wYXRocyBvbmx5IHN0b3JlcyBwb2ludCBwb3NpdGlvbnMgaW4gZWFjaCBwYXRoXG4gICAgICBjb25zdCBwYXRocyA9IHByb3BzLmRhdGEubWFwKGdldFBhdGgpO1xuICAgICAgY29uc3QgbnVtSW5zdGFuY2VzID0gcGF0aHMucmVkdWNlKChjb3VudCwgcGF0aCkgPT4gY291bnQgKyBwYXRoLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtwYXRocywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7XG4gICAgICByb3VuZGVkLCBtaXRlckxpbWl0LCB3aWR0aFNjYWxlLCB3aWR0aE1pblBpeGVscywgd2lkdGhNYXhQaXhlbHNcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICBqb2ludFR5cGU6IE51bWJlcihyb3VuZGVkKSxcbiAgICAgIHdpZHRoU2NhbGUsXG4gICAgICBtaXRlckxpbWl0LFxuICAgICAgd2lkdGhNaW5QaXhlbHMsXG4gICAgICB3aWR0aE1heFBpeGVsc1xuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcbiAgICAvKlxuICAgICAqICAgICAgIF9cbiAgICAgKiAgICAgICAgXCItXyAxICAgICAgICAgICAgICAgICAgIDMgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgKiAgICAgXyAgICAgXCJvLS0tLS0tLS0tLS0tLS0tLS0tLS0tby0tLS0tLS0tLS0tLS0tLS0tLS1fLW9cbiAgICAgKiAgICAgICAtICAgLyBcIlwiLS0uLl9fICAgICAgICAgICAgICAnLiAgICAgICAgICAgICBfLi0nIC9cbiAgICAgKiAgIF8gICAgIFwiQC0gLSAtIC0gLSBcIlwiLS0uLl9fLSAtIC0gLSB4IC0gLSAtIC1fLkAnICAgIC9cbiAgICAgKiAgICBcIi1fICAvICAgICAgICAgICAgICAgICAgIFwiXCItLS4uX18gJy4gIF8sLWAgOiAgICAgL1xuICAgICAqICAgICAgIFwiby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIlwiLW8nICAgIDogICAgIC9cbiAgICAgKiAgICAgIDAsMiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IC8gJy4gIDogICAgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICcuOiAgICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgIDonLiAgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgIDogICcsIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgOiAgICAgb1xuICAgICAqL1xuXG4gICAgY29uc3QgU0VHTUVOVF9JTkRJQ0VTID0gW1xuICAgICAgLy8gc3RhcnQgY29ybmVyXG4gICAgICAwLCAyLCAxLFxuICAgICAgLy8gYm9keVxuICAgICAgMSwgMiwgNCwgMSwgNCwgMyxcbiAgICAgIC8vIGVuZCBjb3JuZXJcbiAgICAgIDMsIDQsIDVcbiAgICBdO1xuXG4gICAgLy8gWzBdIHBvc2l0aW9uIG9uIHNlZ21lbnQgLSAwOiBzdGFydCwgMTogZW5kXG4gICAgLy8gWzFdIHNpZGUgb2YgcGF0aCAtIC0xOiBsZWZ0LCAwOiBjZW50ZXIsIDE6IHJpZ2h0XG4gICAgLy8gWzJdIHJvbGUgLSAwOiBvZmZzZXQgcG9pbnQgMTogam9pbnQgcG9pbnRcbiAgICBjb25zdCBTRUdNRU5UX1BPU0lUSU9OUyA9IFtcbiAgICAgIC8vIGJldmVsIHN0YXJ0IGNvcm5lclxuICAgICAgMCwgMCwgMSxcbiAgICAgIC8vIHN0YXJ0IGlubmVyIGNvcm5lclxuICAgICAgMCwgLTEsIDAsXG4gICAgICAvLyBzdGFydCBvdXRlciBjb3JuZXJcbiAgICAgIDAsIDEsIDAsXG4gICAgICAvLyBlbmQgaW5uZXIgY29ybmVyXG4gICAgICAxLCAtMSwgMCxcbiAgICAgIC8vIGVuZCBvdXRlciBjb3JuZXJcbiAgICAgIDEsIDEsIDAsXG4gICAgICAvLyBiZXZlbCBlbmQgY29ybmVyXG4gICAgICAxLCAwLCAxXG4gICAgXTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFUyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGluZGljZXM6IG5ldyBVaW50MTZBcnJheShTRUdNRU5UX0lORElDRVMpLFxuICAgICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShTRUdNRU5UX1BPU0lUSU9OUylcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlU3RhcnRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgbnVtU2VnbWVudHMgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMDsgcHRJbmRleCA8IG51bVNlZ21lbnRzOyBwdEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoW3B0SW5kZXhdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzJdIHx8IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVFbmRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgZm9yIChsZXQgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzBdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMV07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsyXSB8fCAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgbnVtU2VnbWVudHMgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMDsgcHRJbmRleCA8IG51bVNlZ21lbnRzOyBwdEluZGV4KyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IHBhdGhbcHRJbmRleF07XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gcGF0aFtwdEluZGV4ICsgMV07XG4gICAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHN0YXJ0UG9pbnRbMF0pWzFdO1xuICAgICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShzdGFydFBvaW50WzFdKVsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkoZW5kUG9pbnRbMF0pWzFdO1xuICAgICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShlbmRQb2ludFsxXSlbMV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVMZWZ0RGVsdGFzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtwYXRoc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGNvbnN0IG51bVNlZ21lbnRzID0gcGF0aC5sZW5ndGggLSAxO1xuICAgICAgbGV0IHByZXZQb2ludCA9IGlzQ2xvc2VkKHBhdGgpID8gcGF0aFtwYXRoLmxlbmd0aCAtIDJdIDogcGF0aFswXTtcblxuICAgICAgZm9yIChsZXQgcHRJbmRleCA9IDA7IHB0SW5kZXggPCBudW1TZWdtZW50czsgcHRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzBdIC0gcHJldlBvaW50WzBdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMV0gLSBwcmV2UG9pbnRbMV07XG4gICAgICAgIHZhbHVlW2krK10gPSAocG9pbnRbMl0gLSBwcmV2UG9pbnRbMl0pIHx8IDA7XG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlUmlnaHREZWx0YXMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgZm9yIChsZXQgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgbGV0IG5leHRQb2ludCA9IHBhdGhbcHRJbmRleCArIDFdO1xuICAgICAgICBpZiAoIW5leHRQb2ludCkge1xuICAgICAgICAgIG5leHRQb2ludCA9IGlzQ2xvc2VkKHBhdGgpID8gcGF0aFsxXSA6IHBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVbaSsrXSA9IG5leHRQb2ludFswXSAtIHBvaW50WzBdO1xuICAgICAgICB2YWx1ZVtpKytdID0gbmV4dFBvaW50WzFdIC0gcG9pbnRbMV07XG4gICAgICAgIHZhbHVlW2krK10gPSAobmV4dFBvaW50WzJdIC0gcG9pbnRbMl0pIHx8IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVTdHJva2VXaWR0aHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFdpZHRofSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaWR0aChkYXRhW2luZGV4XSwgaW5kZXgpO1xuICAgICAgZm9yIChsZXQgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgIHZhbHVlW2krK10gPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludENvbG9yID0gZ2V0Q29sb3IoZGF0YVtpbmRleF0sIGluZGV4KTtcbiAgICAgIGlmIChpc05hTihwb2ludENvbG9yWzNdKSkge1xuICAgICAgICBwb2ludENvbG9yWzNdID0gMjU1O1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzBdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRDb2xvclsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50Q29sb3JbMl07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzNdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cbiAgY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpbmRleCk7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMTsgcHRJbmRleCA8IHBhdGgubGVuZ3RoOyBwdEluZGV4KyspIHtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBpY2tpbmdDb2xvclswXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBpY2tpbmdDb2xvclsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cblBhdGhMYXllci5sYXllck5hbWUgPSAnUGF0aExheWVyJztcblBhdGhMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isSimple */
/* harmony export (immutable) */ __webpack_exports__["a"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["b"] = getVertexCount;
/* harmony export (immutable) */ __webpack_exports__["c"] = getTriangleCount;
/* harmony export (immutable) */ __webpack_exports__["d"] = forEachVertex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(7);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



// Basic polygon support
//
// Handles simple and complex polygons
// Simple polygons are arrays of vertices, implicitly "closed"
// Complex polygons are arrays of simple polygons, with the first polygon
// representing the outer hull and other polygons representing holes

/**
 * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)
 * @param {Array} polygon - either a complex or simple polygon
 * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)
 */
function isSimple(polygon) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["e" /* count */])(polygon) >= 1 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["e" /* count */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(polygon, 0)) >= 2 && Number.isFinite(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(polygon, 0), 0));
}

/**
 * Normalize to ensure that all polygons in a list are complex - simplifies processing
 * @param {Array} polygon - either a complex or a simple polygon
 * @param {Object} opts
 * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed
 * @return {Array} - returns a complex polygons
 */
function normalize(polygon) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$dimensions = _ref.dimensions,
      dimensions = _ref$dimensions === undefined ? 3 : _ref$dimensions;

  return isSimple(polygon) ? [polygon] : polygon;
}

/**
 * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)
 * @param {Array} polygon - either a complex or simple polygon
 * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)
 */
function getVertexCount(polygon) {
  return isSimple(polygon) ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["e" /* count */])(polygon) : polygon.reduce(function (length, simplePolygon) {
    return length + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["e" /* count */])(simplePolygon);
  }, 0);
}

// Return number of triangles needed to tesselate the polygon
function getTriangleCount(polygon) {
  var triangleCount = 0;
  var first = true;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = normalize(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var simplePolygon = _step.value;

      var size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["e" /* count */])(simplePolygon);
      if (first) {
        triangleCount += size >= 3 ? size - 2 : 0;
      } else {
        triangleCount += size + 1;
      }
      first = false;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return triangleCount;
}

function forEachVertex(polygon, visitor) {
  if (isSimple(polygon)) {
    polygon.forEach(visitor);
    return;
  }

  var vertexIndex = 0;
  polygon.forEach(function (simplePolygon) {
    simplePolygon.forEach(function (v, i, p) {
      return visitor(v, vertexIndex, polygon);
    });
    vertexIndex++;
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24uanMiXSwibmFtZXMiOlsiZ2V0IiwiY291bnQiLCJpc1NpbXBsZSIsInBvbHlnb24iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm5vcm1hbGl6ZSIsImRpbWVuc2lvbnMiLCJnZXRWZXJ0ZXhDb3VudCIsInJlZHVjZSIsImxlbmd0aCIsInNpbXBsZVBvbHlnb24iLCJnZXRUcmlhbmdsZUNvdW50IiwidHJpYW5nbGVDb3VudCIsImZpcnN0Iiwic2l6ZSIsImZvckVhY2hWZXJ0ZXgiLCJ2aXNpdG9yIiwiZm9yRWFjaCIsInZlcnRleEluZGV4IiwidiIsImkiLCJwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxHQUFSLEVBQWFDLEtBQWIsUUFBeUIsb0JBQXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQSxPQUFPLFNBQVNDLFFBQVQsQ0FBa0JDLE9BQWxCLEVBQTJCO0FBQ2hDLFNBQU9GLE1BQU1FLE9BQU4sS0FBa0IsQ0FBbEIsSUFDTEYsTUFBTUQsSUFBSUcsT0FBSixFQUFhLENBQWIsQ0FBTixLQUEwQixDQURyQixJQUVMQyxPQUFPQyxRQUFQLENBQWdCTCxJQUFJQSxJQUFJRyxPQUFKLEVBQWEsQ0FBYixDQUFKLEVBQXFCLENBQXJCLENBQWhCLENBRkY7QUFHRDs7QUFFRDs7Ozs7OztBQU9BLE9BQU8sU0FBU0csU0FBVCxDQUFtQkgsT0FBbkIsRUFBbUQ7QUFBQSxpRkFBSixFQUFJO0FBQUEsNkJBQXRCSSxVQUFzQjtBQUFBLE1BQXRCQSxVQUFzQixtQ0FBVCxDQUFTOztBQUN4RCxTQUFPTCxTQUFTQyxPQUFULElBQW9CLENBQUNBLE9BQUQsQ0FBcEIsR0FBZ0NBLE9BQXZDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsT0FBTyxTQUFTSyxjQUFULENBQXdCTCxPQUF4QixFQUFpQztBQUN0QyxTQUFPRCxTQUFTQyxPQUFULElBQ0xGLE1BQU1FLE9BQU4sQ0FESyxHQUVMQSxRQUFRTSxNQUFSLENBQWUsVUFBQ0MsTUFBRCxFQUFTQyxhQUFUO0FBQUEsV0FBMkJELFNBQVNULE1BQU1VLGFBQU4sQ0FBcEM7QUFBQSxHQUFmLEVBQXlFLENBQXpFLENBRkY7QUFHRDs7QUFFRDtBQUNBLE9BQU8sU0FBU0MsZ0JBQVQsQ0FBMEJULE9BQTFCLEVBQW1DO0FBQ3hDLE1BQUlVLGdCQUFnQixDQUFwQjtBQUNBLE1BQUlDLFFBQVEsSUFBWjtBQUZ3QztBQUFBO0FBQUE7O0FBQUE7QUFHeEMseUJBQTRCUixVQUFVSCxPQUFWLENBQTVCLDhIQUFnRDtBQUFBLFVBQXJDUSxhQUFxQzs7QUFDOUMsVUFBTUksT0FBT2QsTUFBTVUsYUFBTixDQUFiO0FBQ0EsVUFBSUcsS0FBSixFQUFXO0FBQ1RELHlCQUFpQkUsUUFBUSxDQUFSLEdBQVlBLE9BQU8sQ0FBbkIsR0FBdUIsQ0FBeEM7QUFDRCxPQUZELE1BRU87QUFDTEYseUJBQWlCRSxPQUFPLENBQXhCO0FBQ0Q7QUFDREQsY0FBUSxLQUFSO0FBQ0Q7QUFYdUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZeEMsU0FBT0QsYUFBUDtBQUNEOztBQUVELE9BQU8sU0FBU0csYUFBVCxDQUF1QmIsT0FBdkIsRUFBZ0NjLE9BQWhDLEVBQXlDO0FBQzlDLE1BQUlmLFNBQVNDLE9BQVQsQ0FBSixFQUF1QjtBQUNyQkEsWUFBUWUsT0FBUixDQUFnQkQsT0FBaEI7QUFDQTtBQUNEOztBQUVELE1BQUlFLGNBQWMsQ0FBbEI7QUFDQWhCLFVBQVFlLE9BQVIsQ0FBZ0IseUJBQWlCO0FBQy9CUCxrQkFBY08sT0FBZCxDQUFzQixVQUFDRSxDQUFELEVBQUlDLENBQUosRUFBT0MsQ0FBUDtBQUFBLGFBQWFMLFFBQVFHLENBQVIsRUFBV0QsV0FBWCxFQUF3QmhCLE9BQXhCLENBQWI7QUFBQSxLQUF0QjtBQUNBZ0I7QUFDRCxHQUhEO0FBSUQiLCJmaWxlIjoicG9seWdvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2dldCwgY291bnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbi8vIEJhc2ljIHBvbHlnb24gc3VwcG9ydFxuLy9cbi8vIEhhbmRsZXMgc2ltcGxlIGFuZCBjb21wbGV4IHBvbHlnb25zXG4vLyBTaW1wbGUgcG9seWdvbnMgYXJlIGFycmF5cyBvZiB2ZXJ0aWNlcywgaW1wbGljaXRseSBcImNsb3NlZFwiXG4vLyBDb21wbGV4IHBvbHlnb25zIGFyZSBhcnJheXMgb2Ygc2ltcGxlIHBvbHlnb25zLCB3aXRoIHRoZSBmaXJzdCBwb2x5Z29uXG4vLyByZXByZXNlbnRpbmcgdGhlIG91dGVyIGh1bGwgYW5kIG90aGVyIHBvbHlnb25zIHJlcHJlc2VudGluZyBob2xlc1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgaXMgYSBub24tbmVzdGVkIHBvbHlnb24gKGkuZS4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYSBudW1iZXIpXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gZWl0aGVyIGEgY29tcGxleCBvciBzaW1wbGUgcG9seWdvblxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBwb2x5Z29uIGlzIGEgc2ltcGxlIHBvbHlnb24gKGkuZS4gbm90IGFuIGFycmF5IG9mIHBvbHlnb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGUocG9seWdvbikge1xuICByZXR1cm4gY291bnQocG9seWdvbikgPj0gMSAmJlxuICAgIGNvdW50KGdldChwb2x5Z29uLCAwKSkgPj0gMiAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShnZXQoZ2V0KHBvbHlnb24sIDApLCAwKSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRvIGVuc3VyZSB0aGF0IGFsbCBwb2x5Z29ucyBpbiBhIGxpc3QgYXJlIGNvbXBsZXggLSBzaW1wbGlmaWVzIHByb2Nlc3NpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBvbHlnb24gLSBlaXRoZXIgYSBjb21wbGV4IG9yIGEgc2ltcGxlIHBvbHlnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kaW1lbnNpb25zIC0gaWYgMywgdGhlIGNvb3JkcyB3aWxsIGJlIHBhZGRlZCB3aXRoIDAncyBpZiBuZWVkZWRcbiAqIEByZXR1cm4ge0FycmF5fSAtIHJldHVybnMgYSBjb21wbGV4IHBvbHlnb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocG9seWdvbiwge2RpbWVuc2lvbnMgPSAzfSA9IHt9KSB7XG4gIHJldHVybiBpc1NpbXBsZShwb2x5Z29uKSA/IFtwb2x5Z29uXSA6IHBvbHlnb247XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIG5vbi1uZXN0ZWQgcG9seWdvbiAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBhIG51bWJlcilcbiAqIEBwYXJhbSB7QXJyYXl9IHBvbHlnb24gLSBlaXRoZXIgYSBjb21wbGV4IG9yIHNpbXBsZSBwb2x5Z29uXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIHBvbHlnb24gaXMgYSBzaW1wbGUgcG9seWdvbiAoaS5lLiBub3QgYW4gYXJyYXkgb2YgcG9seWdvbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0ZXhDb3VudChwb2x5Z29uKSB7XG4gIHJldHVybiBpc1NpbXBsZShwb2x5Z29uKSA/XG4gICAgY291bnQocG9seWdvbikgOlxuICAgIHBvbHlnb24ucmVkdWNlKChsZW5ndGgsIHNpbXBsZVBvbHlnb24pID0+IGxlbmd0aCArIGNvdW50KHNpbXBsZVBvbHlnb24pLCAwKTtcbn1cblxuLy8gUmV0dXJuIG51bWJlciBvZiB0cmlhbmdsZXMgbmVlZGVkIHRvIHRlc3NlbGF0ZSB0aGUgcG9seWdvblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyaWFuZ2xlQ291bnQocG9seWdvbikge1xuICBsZXQgdHJpYW5nbGVDb3VudCA9IDA7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGZvciAoY29uc3Qgc2ltcGxlUG9seWdvbiBvZiBub3JtYWxpemUocG9seWdvbikpIHtcbiAgICBjb25zdCBzaXplID0gY291bnQoc2ltcGxlUG9seWdvbik7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICB0cmlhbmdsZUNvdW50ICs9IHNpemUgPj0gMyA/IHNpemUgLSAyIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpYW5nbGVDb3VudCArPSBzaXplICsgMTtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJpYW5nbGVDb3VudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hWZXJ0ZXgocG9seWdvbiwgdmlzaXRvcikge1xuICBpZiAoaXNTaW1wbGUocG9seWdvbikpIHtcbiAgICBwb2x5Z29uLmZvckVhY2godmlzaXRvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHZlcnRleEluZGV4ID0gMDtcbiAgcG9seWdvbi5mb3JFYWNoKHNpbXBsZVBvbHlnb24gPT4ge1xuICAgIHNpbXBsZVBvbHlnb24uZm9yRWFjaCgodiwgaSwgcCkgPT4gdmlzaXRvcih2LCB2ZXJ0ZXhJbmRleCwgcG9seWdvbikpO1xuICAgIHZlcnRleEluZGV4Kys7XG4gIH0pO1xufVxuIl19

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TEST_EXPORTS */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attribute_manager__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__debug_seer_integration__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */







var LOG_PRIORITY_UPDATE = 2;

var noop = function noop() {};

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  dataComparator: null,
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: 0.8,
  onHover: noop,
  onClick: noop,
  onDragStart: noop,
  onDragMove: noop,
  onDragEnd: noop,
  onDragCancel: noop,
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },
  // Update triggers: a key change detection mechanism in deck.gl
  // See layer documentation
  updateTriggers: {},
  projectionMode: __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* COORDINATE_SYSTEM */].LNGLAT
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = getDefaultProps(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    props.data = props.data || [];
    // Get the overrides from the extension if it's active
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__debug_seer_integration__["d" /* getOverrides */])(props);
    // Props are immutable
    Object.freeze(props);

    // Define all members and freeze layer
    this.id = props.id;
    this.props = props;
    this.oldProps = null;
    this.state = null;
    this.context = null;
    this.parentLayer = null;
    this.count = counter++;
    this.lifecycle = __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* LIFECYCLE */].NO_STATE;
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      return changeFlags.somethingChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref4) {
      var _ref4$uniforms = _ref4.uniforms,
          uniforms = _ref4$uniforms === undefined ? {} : _ref4$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var color = info.color,
          index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      // TODO - move to the JS part of a shader picking shader package
      if (mode === 'hover') {
        var selectedPickingColor = new Float32Array(3);
        selectedPickingColor[0] = color[0];
        selectedPickingColor[1] = color[1];
        selectedPickingColor[2] = color[2];
        this.setUniforms({ selectedPickingColor: selectedPickingColor });
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      // Figure out data length
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      __WEBPACK_IMPORTED_MODULE_5_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      __WEBPACK_IMPORTED_MODULE_5_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      __WEBPACK_IMPORTED_MODULE_5_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      __WEBPACK_IMPORTED_MODULE_5_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      __WEBPACK_IMPORTED_MODULE_5_assert___default()(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["e" /* count */])(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      __WEBPACK_IMPORTED_MODULE_5_assert___default()(this.context.gl, 'Layer context missing gl');
      __WEBPACK_IMPORTED_MODULE_5_assert___default()(!this.state, 'Layer missing state');

      this.state = {};

      // Initialize state only once
      this.setState({
        attributeManager: new __WEBPACK_IMPORTED_MODULE_1__attribute_manager__["a" /* default */]({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].once(0, 'deck.gl v3 ' + this + ': "shouldUpdate" deprecated, renamed to "shouldUpdateState"');
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms;
      var gl = this.context.gl;
      var getPolygonOffset = this.props.getPolygonOffset;

      // Apply polygon offset to avoid z-fighting

      var offset = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      gl.polygonOffset(offset[0], offset[1]);

      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["j" /* compareProps */])({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      } else {
        __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].log(2, 'dataChanged: ' + dataChanged);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason
      };
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["j" /* compareProps */])({
          oldProps: oldTriggers,
          newProps: newTriggers
        });
        if (diffReason) {
          if (propName === 'all') {
            __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */])(3, 'layer.setUniforms', uniformMap);
    }
  }]);

  return Layer;
}();

/* harmony default export */ __webpack_exports__["a"] = (Layer);


Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}
/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk the prototype chain and merge all default props
 */
function mergeDefaultProps(layer) {
  var subClassConstructor = layer.constructor;
  var layerName = getOwnProperty(subClassConstructor, 'layerName');
  if (!layerName) {
    __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].once(0, 'layer ' + layer.constructor.name + ' does not specify a "layerName"');
  }
  var mergedDefaultProps = {
    id: layerName || layer.constructor.name
  };

  while (layer) {
    var layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');
    Object.freeze(layerDefaultProps);
    if (layerDefaultProps) {
      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);
    }
    layer = Object.getPrototypeOf(layer);
  }
  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;
  return mergedDefaultProps;
}

var TEST_EXPORTS = {
  mergeDefaultProps: mergeDefaultProps
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiQ09PUkRJTkFURV9TWVNURU0iLCJMSUZFQ1lDTEUiLCJBdHRyaWJ1dGVNYW5hZ2VyIiwibG9nIiwiY29tcGFyZVByb3BzIiwiY291bnQiLCJnZXRPdmVycmlkZXMiLCJHTCIsImFzc2VydCIsIkxPR19QUklPUklUWV9VUERBVEUiLCJub29wIiwiZGVmYXVsdFByb3BzIiwiZGF0YUNvbXBhcmF0b3IiLCJudW1JbnN0YW5jZXMiLCJ1bmRlZmluZWQiLCJ2aXNpYmxlIiwicGlja2FibGUiLCJvcGFjaXR5Iiwib25Ib3ZlciIsIm9uQ2xpY2siLCJvbkRyYWdTdGFydCIsIm9uRHJhZ01vdmUiLCJvbkRyYWdFbmQiLCJvbkRyYWdDYW5jZWwiLCJnZXRQb2x5Z29uT2Zmc2V0IiwibGF5ZXJJbmRleCIsInVwZGF0ZVRyaWdnZXJzIiwicHJvamVjdGlvbk1vZGUiLCJMTkdMQVQiLCJjb3VudGVyIiwiTGF5ZXIiLCJwcm9wcyIsIm1lcmdlZERlZmF1bHRQcm9wcyIsImdldERlZmF1bHRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsImRhdGEiLCJmcmVlemUiLCJpZCIsIm9sZFByb3BzIiwic3RhdGUiLCJjb250ZXh0IiwicGFyZW50TGF5ZXIiLCJsaWZlY3ljbGUiLCJOT19TVEFURSIsInNlYWwiLCJjbGFzc05hbWUiLCJjb25zdHJ1Y3RvciIsImxheWVyTmFtZSIsIm5hbWUiLCJFcnJvciIsIm9sZENvbnRleHQiLCJjaGFuZ2VGbGFncyIsInNvbWV0aGluZ0NoYW5nZWQiLCJkYXRhQ2hhbmdlZCIsImludmFsaWRhdGVBdHRyaWJ1dGUiLCJ1bmlmb3JtcyIsIm1vZGVsIiwicmVuZGVyIiwiaW5mbyIsIm1vZGUiLCJjb2xvciIsImluZGV4IiwiQXJyYXkiLCJpc0FycmF5Iiwib2JqZWN0Iiwic2VsZWN0ZWRQaWNraW5nQ29sb3IiLCJGbG9hdDMyQXJyYXkiLCJzZXRVbmlmb3JtcyIsImF0dHJpYnV0ZU1hbmFnZXIiLCJpbnZhbGlkYXRlQWxsIiwiaW52YWxpZGF0ZSIsImdldE51bUluc3RhbmNlcyIsInVwZGF0ZSIsImJ1ZmZlcnMiLCJpZ25vcmVVbmtub3duQXR0cmlidXRlcyIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMiLCJjbGVhckNoYW5nZWRGbGFncyIsInNldEF0dHJpYnV0ZXMiLCJ1cGRhdGVPYmplY3QiLCJuZWVkc1JlZHJhdyIsInJlZHJhdyIsImxuZ0xhdCIsInZpZXdwb3J0IiwicHJvamVjdCIsInh5IiwidW5wcm9qZWN0IiwicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0Iiwic2NyZWVuUGl4ZWxzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImkiLCJVaW50OEFycmF5IiwiaTEiLCJpMiIsImkzIiwiYXR0cmlidXRlIiwidmFsdWUiLCJzaXplIiwicGlja2luZ0NvbG9yIiwiZW5jb2RlUGlja2luZ0NvbG9yIiwidXBkYXRlUGFyYW1zIiwiZ2wiLCJzZXRTdGF0ZSIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlUGlja2luZ0NvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzIiwiaW5pdGlhbGl6ZVN0YXRlIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiX3VwZGF0ZUJhc2VVbmlmb3JtcyIsInNldEluc3RhbmNlQ291bnQiLCJwcm9ncmFtIiwiZ2VvbWV0cnkiLCJnZXRBdHRyaWJ1dGVzIiwic2hvdWxkVXBkYXRlIiwib25jZSIsInN0YXRlTmVlZHNVcGRhdGUiLCJzaG91bGRVcGRhdGVTdGF0ZSIsImZpbmFsaXplU3RhdGUiLCJvZmZzZXQiLCJwb2x5Z29uT2Zmc2V0IiwiZHJhdyIsIm9wdHMiLCJnZXRQaWNraW5nSW5mbyIsIm5ld1Byb3BzIiwicHJvcHNDaGFuZ2VkUmVhc29uIiwiaWdub3JlUHJvcHMiLCJkYXRhQ2hhbmdlZFJlYXNvbiIsIl9kaWZmRGF0YVByb3BzIiwicHJvcHNDaGFuZ2VkIiwiQm9vbGVhbiIsInZpZXdwb3J0Q2hhbmdlZCIsIl9kaWZmVXBkYXRlVHJpZ2dlcnMiLCJyZWFzb24iLCJjbGVhclJlZHJhd0ZsYWdzIiwiZ2V0TmVlZHNSZWRyYXciLCJjaGFuZ2UiLCJwcm9wTmFtZSIsIm9sZFRyaWdnZXJzIiwibmV3VHJpZ2dlcnMiLCJkaWZmUmVhc29uIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwib2xkUHJvcCIsIm5ld1Byb3AiLCJtZXNzYWdlIiwiTWF0aCIsInBvdyIsIk9ORSIsInVuaWZvcm1NYXAiLCJnZXRPd25Qcm9wZXJ0eSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImxheWVyIiwibWVyZ2VEZWZhdWx0UHJvcHMiLCJzdWJDbGFzc0NvbnN0cnVjdG9yIiwibGF5ZXJEZWZhdWx0UHJvcHMiLCJnZXRQcm90b3R5cGVPZiIsIlRFU1RfRVhQT1JUUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRQSxpQkFBUixFQUEyQkMsU0FBM0IsUUFBMkMsYUFBM0M7QUFDQSxPQUFPQyxnQkFBUCxNQUE2QixxQkFBN0I7QUFDQSxTQUFRQyxHQUFSLEVBQWFDLFlBQWIsRUFBMkJDLEtBQTNCLFFBQXVDLFNBQXZDO0FBQ0EsU0FBUUMsWUFBUixRQUEyQiwyQkFBM0I7QUFDQSxTQUFRQyxFQUFSLFFBQWlCLFNBQWpCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQSxJQUFNQyxzQkFBc0IsQ0FBNUI7O0FBRUEsSUFBTUMsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjs7QUFFQTs7Ozs7QUFLQSxJQUFNQyxlQUFlO0FBQ25CQyxrQkFBZ0IsSUFERztBQUVuQkMsZ0JBQWNDLFNBRks7QUFHbkJDLFdBQVMsSUFIVTtBQUluQkMsWUFBVSxLQUpTO0FB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KSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU0sIExJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IEF0dHJpYnV0ZU1hbmFnZXIgZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5pbXBvcnQge2xvZywgY29tcGFyZVByb3BzLCBjb3VudH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2dldE92ZXJyaWRlc30gZnJvbSAnLi4vZGVidWcvc2Vlci1pbnRlZ3JhdGlvbic7XG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTE9HX1BSSU9SSVRZX1VQREFURSA9IDI7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLypcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5pZCAtIGxheWVyIG5hbWVcbiAqIEBwYXJhbSB7YXJyYXl9ICBwcm9wcy5kYXRhIC0gYXJyYXkgb2YgZGF0YSBpbnN0YW5jZXNcbiAqIEBwYXJhbSB7Ym9vbH0gcHJvcHMub3BhY2l0eSAtIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gKi9cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZGF0YUNvbXBhcmF0b3I6IG51bGwsXG4gIG51bUluc3RhbmNlczogdW5kZWZpbmVkLFxuICB2aXNpYmxlOiB0cnVlLFxuICBwaWNrYWJsZTogZmFsc2UsXG4gIG9wYWNpdHk6IDAuOCxcbiAgb25Ib3Zlcjogbm9vcCxcbiAgb25DbGljazogbm9vcCxcbiAgb25EcmFnU3RhcnQ6IG5vb3AsXG4gIG9uRHJhZ01vdmU6IG5vb3AsXG4gIG9uRHJhZ0VuZDogbm9vcCxcbiAgb25EcmFnQ2FuY2VsOiBub29wLFxuICAvLyBPZmZzZXQgZGVwdGggYmFzZWQgb24gbGF5ZXIgaW5kZXggdG8gYXZvaWQgei1maWdodGluZy5cbiAgLy8gTmVnYXRpdmUgdmFsdWVzIHB1bGwgbGF5ZXIgdG93YXJkcyB0aGUgY2FtZXJhXG4gIC8vIGh0dHBzOi8vd3d3Lm9wZW5nbC5vcmcvYXJjaGl2ZXMvcmVzb3VyY2VzL2ZhcS90ZWNobmljYWwvcG9seWdvbm9mZnNldC5odG1cbiAgZ2V0UG9seWdvbk9mZnNldDogKHtsYXllckluZGV4fSkgPT4gWzAsIC1sYXllckluZGV4ICogMTAwXSxcbiAgLy8gVXBkYXRlIHRyaWdnZXJzOiBhIGtleSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIC8vIFNlZSBsYXllciBkb2N1bWVudGF0aW9uXG4gIHVwZGF0ZVRyaWdnZXJzOiB7fSxcbiAgcHJvamVjdGlvbk1vZGU6IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVFxufTtcblxubGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gU2VlIGRvY3MgYW5kIGRlZmF1bHRzIGFib3ZlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIC8vIElmIHN1YmxheWVyIGhhcyBzdGF0aWMgZGVmYXVsdFByb3BzIG1lbWJlciwgZ2V0RGVmYXVsdFByb3BzIHdpbGwgcmV0dXJuIGl0XG4gICAgY29uc3QgbWVyZ2VkRGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKHRoaXMpO1xuICAgIC8vIE1lcmdlIHN1cHBsaWVkIHByb3BzIHdpdGggcHJlLW1lcmdlZCBkZWZhdWx0IHByb3BzXG4gICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtZXJnZWREZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBBY2NlcHQgbnVsbCBhcyBkYXRhIC0gb3RoZXJ3aXNlIGFwcHMgYW5kIGxheWVycyBuZWVkIHRvIGFkZCB1Z2x5IGNoZWNrc1xuICAgIHByb3BzLmRhdGEgPSBwcm9wcy5kYXRhIHx8IFtdO1xuICAgIC8vIEdldCB0aGUgb3ZlcnJpZGVzIGZyb20gdGhlIGV4dGVuc2lvbiBpZiBpdCdzIGFjdGl2ZVxuICAgIGdldE92ZXJyaWRlcyhwcm9wcyk7XG4gICAgLy8gUHJvcHMgYXJlIGltbXV0YWJsZVxuICAgIE9iamVjdC5mcmVlemUocHJvcHMpO1xuXG4gICAgLy8gRGVmaW5lIGFsbCBtZW1iZXJzIGFuZCBmcmVlemUgbGF5ZXJcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMub2xkUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnRMYXllciA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKztcbiAgICB0aGlzLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5OT19TVEFURTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gY2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmlkID8gYDwke2NsYXNzTmFtZX06JyR7dGhpcy5wcm9wcy5pZH0nPmAgOiBgPCR7Y2xhc3NOYW1lfT5gO1xuICB9XG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTElGRUNZQ0xFIE1FVEhPRFMsIG92ZXJyaWRkZW4gYnkgdGhlIGxheWVyIHN1YmNsYXNzZXNcblxuICAvLyBDYWxsZWQgb25jZSB0byBzZXQgdXAgdGhlIGluaXRpYWwgc3RhdGVcbiAgLy8gQXBwIGNhbiBjcmVhdGUgV2ViR0wgcmVzb3VyY2VzXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyICR7dGhpc30gaGFzIG5vdCBkZWZpbmVkIGluaXRpYWxpemVTdGF0ZWApO1xuICB9XG5cbiAgLy8gTGV0J3MgbGF5ZXIgY29udHJvbCBpZiB1cGRhdGVTdGF0ZSBzaG91bGQgYmUgY2FsbGVkXG4gIHNob3VsZFVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIHJldHVybiBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgYWxsIGF0dHJpYnV0ZXMgd2lsbCBiZSBpbnZhbGlkYXRlZCBhbmQgdXBkYXRlZFxuICAvLyB3aGVuIGRhdGEgY2hhbmdlc1xuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBvbGRDb250ZXh0LCBjb250ZXh0LCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZSgnYWxsJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uY2Ugd2hlbiBsYXllciBpcyBubyBsb25nZXIgbWF0Y2hlZCBhbmQgc3RhdGUgd2lsbCBiZSBkaXNjYXJkZWRcbiAgLy8gQXBwIGNhbiBkZXN0cm95IFdlYkdMIHJlc291cmNlcyBoZXJlXG4gIGZpbmFsaXplU3RhdGUoKSB7XG4gIH1cblxuICAvLyBJZiBzdGF0ZSBoYXMgYSBtb2RlbCwgZHJhdyBpdCB3aXRoIHN1cHBsaWVkIHVuaWZvcm1zXG4gIGRyYXcoe3VuaWZvcm1zID0ge319KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxsZWQgdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBldmVudCBoYW5kbGVyXG4gIC8vIEByZXR1cm4gbnVsbCB0byBjYW5jZWwgZXZlbnRcbiAgZ2V0UGlja2luZ0luZm8oe2luZm8sIG1vZGV9KSB7XG4gICAgY29uc3Qge2NvbG9yLCBpbmRleH0gPSBpbmZvO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5kYXRhKSkge1xuICAgICAgICBpbmZvLm9iamVjdCA9IHRoaXMucHJvcHMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIG1vdmUgdG8gdGhlIEpTIHBhcnQgb2YgYSBzaGFkZXIgcGlja2luZyBzaGFkZXIgcGFja2FnZVxuICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFBpY2tpbmdDb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclswXSA9IGNvbG9yWzBdO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMV0gPSBjb2xvclsxXTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzJdID0gY29sb3JbMl07XG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHtzZWxlY3RlZFBpY2tpbmdDb2xvcn0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgLy8gRU5EIExJRkVDWUNMRSBNRVRIT0RTXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBhdHRyaWJ1dGUgaW52YWxpZGF0aW9uLCBjYW4gYmUgcmVkZWZpbmVcbiAgaW52YWxpZGF0ZUF0dHJpYnV0ZShuYW1lID0gJ2FsbCcpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlcywgY2FuIGJlIHJlZGVmaW5lZFxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gdGhpcy5nZXROdW1JbnN0YW5jZXMocHJvcHMpO1xuICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgcHJvcHMsXG4gICAgICBidWZmZXJzOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFN0YXRlKHVwZGF0ZU9iamVjdCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHJlZHJhdztcbiAgICB9XG4gIH1cblxuICAvLyBQUk9KRUNUSU9OIE1FVEhPRFNcblxuICAvKipcbiAgICogUHJvamVjdHMgYSBwb2ludCB3aXRoIGN1cnJlbnQgbWFwIHN0YXRlIChsYXQsIGxvbiwgem9vbSwgcGl0Y2gsIGJlYXJpbmcpXG4gICAqXG4gICAqIE5vdGU6IFBvc2l0aW9uIGNvbnZlcnNpb24gaXMgZG9uZSBpbiBzaGFkZXIsIHNvIGluIG1hbnkgY2FzZXMgdGhlcmUgaXMgbm8gbmVlZFxuICAgKiBmb3IgdGhpcyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGxuZ0xhdCAtIGxvbmcgYW5kIGxhdCB2YWx1ZXNcbiAgICogQHJldHVybiB7QXJyYXl8VHlwZWRBcnJheX0gLSB4LCB5IGNvb3JkaW5hdGVzXG4gICAqL1xuICBwcm9qZWN0KGxuZ0xhdCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdCh4eSk7XG4gIH1cblxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0RmxhdChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0RmxhdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdEZsYXQoeHkpO1xuICB9XG5cbiAgc2NyZWVuVG9EZXZpY2VQaXhlbHMoc2NyZWVuUGl4ZWxzKSB7XG4gICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICByZXR1cm4gc2NyZWVuUGl4ZWxzICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIGEgYmxhY2sgY29sb3JcbiAgICovXG4gIG51bGxQaWNraW5nQ29sb3IoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7aW50fSBpIC0gaW5kZXggdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBjb2xvclxuICAgKi9cbiAgZW5jb2RlUGlja2luZ0NvbG9yKGkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgKGkgKyAxKSAmIDI1NSxcbiAgICAgICgoaSArIDEpID4+IDgpICYgMjU1LFxuICAgICAgKCgoaSArIDEpID4+IDgpID4+IDgpICYgMjU1XG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gY29sb3IgLSBjb2xvciBhcnJheSB0byBiZSBkZWNvZGVkXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBkZWNvZGVkIHBpY2tpbmcgY29sb3JcbiAgICovXG4gIGRlY29kZVBpY2tpbmdDb2xvcihjb2xvcikge1xuICAgIGFzc2VydChjb2xvciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgIGNvbnN0IFtpMSwgaTIsIGkzXSA9IGNvbG9yO1xuICAgIC8vIDEgd2FzIGFkZGVkIHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgY29uc3QgaW5kZXggPSBpMSArIGkyICogMjU2ICsgaTMgKiA2NTUzNiAtIDE7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSwge251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIC8vIGFkZCAxIHRvIGluZGV4IHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnN0YW5jZXM7IGkrKykge1xuICAgICAgY29uc3QgcGlja2luZ0NvbG9yID0gdGhpcy5lbmNvZGVQaWNraW5nQ29sb3IoaSk7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAxXSA9IHBpY2tpbmdDb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMl0gPSBwaWNraW5nQ29sb3JbMl07XG4gICAgfVxuICB9XG5cbiAgLy8gREFUQSBBQ0NFU1MgQVBJXG4gIC8vIERhdGEgY2FuIHVzZSBpdGVyYXRvcnMgYW5kIG1heSBub3QgYmUgcmFuZG9tIGFjY2Vzc1xuXG4gIC8vIFVzZSBpdGVyYXRpb24gKHRoZSBvbmx5IHJlcXVpcmVkIGNhcGFiaWxpdHkgb24gZGF0YSkgdG8gZ2V0IGZpcnN0IGVsZW1lbnRcbiAgZ2V0Rmlyc3RPYmplY3QoKSB7XG4gICAgY29uc3Qge2RhdGF9ID0gdGhpcy5wcm9wcztcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICAvLyBEZWR1Y2VzIG51bWVyIG9mIGluc3RhbmNlcy4gSW50ZW50aW9uIGlzIHRvIHN1cHBvcnQ6XG4gIC8vIC0gRXhwbGljaXQgc2V0dGluZyBvZiBudW1JbnN0YW5jZXNcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgRVM2IGNvbnRhaW5lcnMgdGhhdCBkZWZpbmUgYSBzaXplIG1lbWJlclxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBDbGFzc2ljIEFycmF5cyB2aWEgdGhlIGJ1aWx0LWluIGxlbmd0aCBhdHRyaWJ1dGVcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiB2aWEgYXJyYXlzXG4gIGdldE51bUluc3RhbmNlcyhwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBsYXllciBoYXMgc2V0IGl0cyBvd24gdmFsdWVcbiAgICBpZiAodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYXBwIGhhcyBwcm92aWRlZCBhbiBleHBsaWNpdCB2YWx1ZVxuICAgIGlmIChwcm9wcy5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb3BzLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBVc2UgY29udGFpbmVyIGxpYnJhcnkgdG8gZ2V0IGEgY291bnQgZm9yIGFueSBFUzYgY29udGFpbmVyIG9yIG9iamVjdFxuICAgIGNvbnN0IHtkYXRhfSA9IHByb3BzO1xuICAgIHJldHVybiBjb3VudChkYXRhKTtcbiAgfVxuXG4gIC8vIExBWUVSIE1BTkFHRVIgQVBJXG4gIC8vIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSB0aGUgZGVjay5nbCBMYXllck1hbmFnZXIgY2xhc3NcblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGEgbmV3IGxheWVyIGlzIGZvdW5kXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIGluaXRpYWxpemVMYXllcih1cGRhdGVQYXJhbXMpIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LmdsLCAnTGF5ZXIgY29udGV4dCBtaXNzaW5nIGdsJyk7XG4gICAgYXNzZXJ0KCF0aGlzLnN0YXRlLCAnTGF5ZXIgbWlzc2luZyBzdGF0ZScpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzdGF0ZSBvbmx5IG9uY2VcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXI6IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKHtpZDogdGhpcy5wcm9wcy5pZH0pLFxuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBuZWVkc1JlZHJhdzogdHJ1ZSxcbiAgICAgIGRhdGFDaGFuZ2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgbW9kZWwuaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LXByb2dyYW1gO1xuICAgICAgbW9kZWwuZ2VvbWV0cnkuaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1nZW9tZXRyeWA7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuZ2V0QXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGV4aXN0aW5nIGxheWVyIGlzIGdldHRpbmcgbmV3IHByb3BzXG4gIHVwZGF0ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENoZWNrIGZvciBkZXByZWNhdGVkIG1ldGhvZFxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgdjMgJHt0aGlzfTogXCJzaG91bGRVcGRhdGVcIiBkZXByZWNhdGVkLCByZW5hbWVkIHRvIFwic2hvdWxkVXBkYXRlU3RhdGVcImApO1xuICAgIH1cblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIGNvbnN0IHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgIGlmIChzdGF0ZU5lZWRzVXBkYXRlKSB7XG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICAgIC8vIFJ1biB0aGUgYXR0cmlidXRlIHVwZGF0ZXJzXG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModXBkYXRlUGFyYW1zLnByb3BzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBDYWxsZWQgYnkgbWFuYWdlciB3aGVuIGxheWVyIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkXG4gIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuICBmaW5hbGl6ZUxheWVyKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZmluYWxpemVTdGF0ZSgpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHVuaWZvcm1zXG4gIGRyYXdMYXllcih7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHtnZXRQb2x5Z29uT2Zmc2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBBcHBseSBwb2x5Z29uIG9mZnNldCB0byBhdm9pZCB6LWZpZ2h0aW5nXG4gICAgY29uc3Qgb2Zmc2V0ID0gZ2V0UG9seWdvbk9mZnNldCAmJiBnZXRQb2x5Z29uT2Zmc2V0KHVuaWZvcm1zKSB8fCBbMCwgMF07XG4gICAgZ2wucG9seWdvbk9mZnNldChvZmZzZXRbMF0sIG9mZnNldFsxXSk7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmRyYXcoe3VuaWZvcm1zfSk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIHt1bmlmb3JtcyA9IHt9LCAuLi5vcHRzfVxuICBwaWNrTGF5ZXIob3B0cykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICBkaWZmUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgYW55IHByb3BzIGhhdmUgY2hhbmdlZCAoaWdub3JlIHByb3BzIHRoYXQgd2lsbCBiZSBleGFtaW5lZCBzZXBhcmF0ZWx5KVxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZFJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFByb3BzLFxuICAgICAgaWdub3JlUHJvcHM6IHtkYXRhOiBudWxsLCB1cGRhdGVUcmlnZ2VyczogbnVsbH1cbiAgICB9KTtcblxuICAgIC8vIE5vdyBjaGVjayBpZiBhbnkgZGF0YSByZWxhdGVkIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgIGNvbnN0IGRhdGFDaGFuZ2VkUmVhc29uID0gdGhpcy5fZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gQm9vbGVhbihwcm9wc0NoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IGRhdGFDaGFuZ2VkID0gQm9vbGVhbihkYXRhQ2hhbmdlZFJlYXNvbik7XG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gY29udGV4dC52aWV3cG9ydENoYW5nZWQ7XG4gICAgY29uc3Qgc29tZXRoaW5nQ2hhbmdlZCA9IHByb3BzQ2hhbmdlZCB8fCBkYXRhQ2hhbmdlZCB8fCB2aWV3cG9ydENoYW5nZWQ7XG5cbiAgICAvLyBDaGVjayB1cGRhdGUgdHJpZ2dlcnMgdG8gZGV0ZXJtaW5lIGlmIGFueSBhdHRyaWJ1dGVzIG5lZWQgcmVnZW5lcmF0aW9uXG4gICAgLy8gTm90ZSAtIGlmIGRhdGEgaGFzIGNoYW5nZWQsIGFsbCBhdHRyaWJ1dGVzIHdpbGwgbmVlZCByZWdlbmVyYXRpb24sIHNvIHNraXAgdGhpcyBzdGVwXG4gICAgaWYgKCFkYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coMiwgYGRhdGFDaGFuZ2VkOiAke2RhdGFDaGFuZ2VkfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0NoYW5nZWQsXG4gICAgICBkYXRhQ2hhbmdlZCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZCxcbiAgICAgIHNvbWV0aGluZ0NoYW5nZWQsXG4gICAgICByZWFzb246IGRhdGFDaGFuZ2VkUmVhc29uIHx8IHByb3BzQ2hhbmdlZFJlYXNvblxuICAgIH07XG4gIH1cblxuICAvLyBDaGVja3Mgc3RhdGUgb2YgYXR0cmlidXRlcyBhbmQgbW9kZWxcbiAgLy8gVE9ETyAtIGlzIGF0dHJpYnV0ZSBtYW5hZ2VyIG5lZWRlZD8gLSBNb2RlbCBzaG91bGQgYmUgZW5vdWdoLlxuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgLy8gdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBieSB0aGUgcmVuZGVyIGxvb3AgYXMgc29vbiBhIHRoZSBsYXllclxuICAgIC8vIGhhcyBiZWVuIGNyZWF0ZWQsIHNvIGd1YXJkIGFnYWluc3QgdW5pbml0aWFsaXplZCBzdGF0ZVxuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdztcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAoYXR0cmlidXRlTWFuYWdlciAmJiBhdHRyaWJ1dGVNYW5hZ2VyLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAobW9kZWwgJiYgbW9kZWwuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KSk7XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gVGhlIGNvbXBhcmlzb24gb2YgdGhlIGRhdGEgcHJvcCByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIC8vIHRoZSBkYXRhQ29tcGFyYXRvciBzaG91bGQgYmUgdXNlZCBpZiBzdXBwbGllZFxuICBfZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBTdXBwb3J0IG9wdGlvbmFsIGFwcCBkZWZpbmVkIGNvbXBhcmlzb24gb2YgZGF0YVxuICAgIGNvbnN0IHtkYXRhQ29tcGFyYXRvcn0gPSBuZXdQcm9wcztcbiAgICBpZiAoZGF0YUNvbXBhcmF0b3IpIHtcbiAgICAgIGlmICghZGF0YUNvbXBhcmF0b3IobmV3UHJvcHMuZGF0YSwgb2xkUHJvcHMuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdEYXRhIGNvbXBhcmF0b3IgZGV0ZWN0ZWQgYSBjaGFuZ2UnO1xuICAgICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZG8gYSBzaGFsbG93IGVxdWFsIG9uIHByb3BzXG4gICAgfSBlbHNlIGlmIChuZXdQcm9wcy5kYXRhICE9PSBvbGRQcm9wcy5kYXRhKSB7XG4gICAgICByZXR1cm4gJ0EgbmV3IGRhdGEgY29udGFpbmVyIHdhcyBzdXBwbGllZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaGVja3MgaWYgYW55IHVwZGF0ZSB0cmlnZ2VycyBoYXZlIGNoYW5nZWQsIGFuZCBpbnZhbGlkYXRlXG4gIC8vIGF0dHJpYnV0ZXMgYWNjb3JkaW5nbHkuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBjb25zdCB1cGRhdGVUcmlnZ2VyTWFwID0gYXR0cmlidXRlTWFuYWdlci5nZXRVcGRhdGVUcmlnZ2VyTWFwKCk7XG5cbiAgICBsZXQgY2hhbmdlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgICBjb25zdCBvbGRUcmlnZ2VycyA9IG9sZFByb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IG5ld1RyaWdnZXJzID0gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdIHx8IHt9O1xuICAgICAgY29uc3QgZGlmZlJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICAgIG9sZFByb3BzOiBvbGRUcmlnZ2VycyxcbiAgICAgICAgbmV3UHJvcHM6IG5ld1RyaWdnZXJzXG4gICAgICB9KTtcbiAgICAgIGlmIChkaWZmUmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsXG4gICAgICAgICAgICBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGFsbCBhdHRyaWJ1dGVzOiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSxcbiAgICAgICAgICAgIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYXR0cmlidXRlICR7cHJvcE5hbWV9OiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX2NoZWNrUmVxdWlyZWRQcm9wKHByb3BlcnR5TmFtZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHVuZGVmaW5lZCBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRW1pdHMgYSB3YXJuaW5nIGlmIGFuIG9sZCBwcm9wIGlzIHVzZWQsIG9wdGlvbmFsbHkgc3VnZ2VzdGluZyBhIHJlcGxhY2VtZW50XG4gIF9jaGVja1JlbW92ZWRQcm9wKG9sZFByb3AsIG5ld1Byb3AgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMucHJvcHNbb2xkUHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGxldCBtZXNzYWdlID0gYCR7bGF5ZXJOYW1lfSBubyBsb25nZXIgYWNjZXB0cyBwcm9wcy4ke29sZFByb3B9IGluIHRoaXMgdmVyc2lvbiBvZiBkZWNrLmdsLmA7XG4gICAgICBpZiAobmV3UHJvcCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5QbGVhc2UgdXNlIHByb3BzLiR7bmV3UHJvcH0gaW5zdGVhZC5gO1xuICAgICAgfVxuICAgICAgbG9nLm9uY2UoMCwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFVuaWZvcm1zKHVuaWZvcm1NYXApIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG4gICAgLy8gVE9ETyAtIHNldCBuZWVkc1JlZHJhdyBvbiB0aGUgbW9kZWw/XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgbG9nKDMsICdsYXllci5zZXRVbmlmb3JtcycsIHVuaWZvcm1NYXApO1xuICB9XG59XG5cbkxheWVyLmxheWVyTmFtZSA9ICdMYXllcic7XG5MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIEhFTFBFUlNcblxuLy8gQ29uc3RydWN0b3JzIGhhdmUgdGhlaXIgc3VwZXIgY2xhc3MgY29uc3RydWN0b3JzIGFzIHByb3RvdHlwZXNcbmZ1bmN0aW9uIGdldE93blByb3BlcnR5KG9iamVjdCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmIG9iamVjdFtwcm9wXTtcbn1cbi8qXG4gKiBSZXR1cm4gbWVyZ2VkIGRlZmF1bHQgcHJvcHMgc3RvcmVkIG9uIGxheWVycyBjb25zdHJ1Y3RvciwgY3JlYXRlIHRoZW0gaWYgbmVlZGVkXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ21lcmdlZERlZmF1bHRQcm9wcycpO1xuICBpZiAobWVyZ2VkRGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlZERlZmF1bHRQcm9wcztcbiAgfVxuICByZXR1cm4gbWVyZ2VEZWZhdWx0UHJvcHMobGF5ZXIpO1xufVxuXG4vKlxuICogV2FsayB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wc1xuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBzdWJDbGFzc0NvbnN0cnVjdG9yID0gbGF5ZXIuY29uc3RydWN0b3I7XG4gIGNvbnN0IGxheWVyTmFtZSA9IGdldE93blByb3BlcnR5KHN1YkNsYXNzQ29uc3RydWN0b3IsICdsYXllck5hbWUnKTtcbiAgaWYgKCFsYXllck5hbWUpIHtcbiAgICBsb2cub25jZSgwLCBgbGF5ZXIgJHtsYXllci5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBzcGVjaWZ5IGEgXCJsYXllck5hbWVcImApO1xuICB9XG4gIGxldCBtZXJnZWREZWZhdWx0UHJvcHMgPSB7XG4gICAgaWQ6IGxheWVyTmFtZSB8fCBsYXllci5jb25zdHJ1Y3Rvci5uYW1lXG4gIH07XG5cbiAgd2hpbGUgKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJEZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRQcm9wcycpO1xuICAgIE9iamVjdC5mcmVlemUobGF5ZXJEZWZhdWx0UHJvcHMpO1xuICAgIGlmIChsYXllckRlZmF1bHRQcm9wcykge1xuICAgICAgbWVyZ2VkRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXJEZWZhdWx0UHJvcHMsIG1lcmdlZERlZmF1bHRQcm9wcyk7XG4gICAgfVxuICAgIGxheWVyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGxheWVyKTtcbiAgfVxuICAvLyBTdG9yZSBmb3IgcXVpY2sgbG9va3VwXG4gIHN1YkNsYXNzQ29uc3RydWN0b3IubWVyZ2VkRGVmYXVsdFByb3BzID0gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xufVxuXG5leHBvcnQgY29uc3QgVEVTVF9FWFBPUlRTID0ge1xuICBtZXJnZURlZmF1bHRQcm9wc1xufTtcbiJdfQ==

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = get;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Access properties of nested containers using dot-path notation
 * - Supports plain objects and arrays, as well as classes with `get` methods
 *   such as ES6 Maps, Immutable.js objects etc
 * - Returns undefined if any container is not valid, instead of throwing
 *
 * @param {Object} container - container that supports get
 * @param {String|*} compositeKey - key to access, can be '.'-separated string
 * @return {*} - value in the final key of the nested container
 */
function get(container, compositeKey) {
  // Split the key into subkeys
  var keyList = getKeys(compositeKey);
  // Recursively get the value of each key;
  var value = container;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keyList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      // If any intermediate subfield is not a container, return undefined
      if (!isObject(value)) {
        return undefined;
      }
      // Get the `getter` for this container
      var getter = getGetter(value);
      // Use the getter to get the value for the key
      value = getter(value, key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return value;
}

/**
 * Checks if argument is an indexable object (not a primitive value, nor null)
 * @param {*} value - JavaScript value to be tested
 * @return {Boolean} - true if argument is a JavaScript object
 */
function isObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

// Default getter is container indexing
var squareBracketGetter = function squareBracketGetter(container, key) {
  return container[key];
};
var getMethodGetter = function getMethodGetter(obj, key) {
  return obj.get(key);
};
// Cache key to key arrays for speed
var keyMap = {};

// Looks for a `get` function on the prototype
// TODO - follow prototype chain?
// @private
// @return {Function} - get function: (container, key) => value
function getGetter(container) {
  // Check if container has a special get method
  var prototype = Object.getPrototypeOf(container);
  return prototype.get ? getMethodGetter : squareBracketGetter;
}

// Takes a string of '.' separated keys and returns an array of keys
// E.g. 'feature.geometry.type' => 'feature', 'geometry', 'type'
// @private
function getKeys(compositeKey) {
  if (typeof compositeKey === 'string') {
    // else assume string and split around dots
    var keyList = keyMap[compositeKey];
    if (!keyList) {
      keyList = compositeKey.split('.');
      keyMap[compositeKey] = keyList;
    }
    return keyList;
  }
  // Wrap in array if needed
  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZ2V0LmpzIl0sIm5hbWVzIjpbImdldCIsImNvbnRhaW5lciIsImNvbXBvc2l0ZUtleSIsImtleUxpc3QiLCJnZXRLZXlzIiwidmFsdWUiLCJrZXkiLCJpc09iamVjdCIsInVuZGVmaW5lZCIsImdldHRlciIsImdldEdldHRlciIsInNxdWFyZUJyYWNrZXRHZXR0ZXIiLCJnZXRNZXRob2RHZXR0ZXIiLCJvYmoiLCJrZXlNYXAiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNwbGl0IiwiQXJyYXkiLCJpc0FycmF5Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUEsT0FBTyxTQUFTQSxHQUFULENBQWFDLFNBQWIsRUFBd0JDLFlBQXhCLEVBQXNDO0FBQzNDO0FBQ0EsTUFBTUMsVUFBVUMsUUFBUUYsWUFBUixDQUFoQjtBQUNBO0FBQ0EsTUFBSUcsUUFBUUosU0FBWjtBQUoyQztBQUFBO0FBQUE7O0FBQUE7QUFLM0MseUJBQWtCRSxPQUFsQiw4SEFBMkI7QUFBQSxVQUFoQkcsR0FBZ0I7O0FBQ3pCO0FBQ0EsVUFBSSxDQUFDQyxTQUFTRixLQUFULENBQUwsRUFBc0I7QUFDcEIsZUFBT0csU0FBUDtBQUNEO0FBQ0Q7QUFDQSxVQUFNQyxTQUFTQyxVQUFVTCxLQUFWLENBQWY7QUFDQTtBQUNBQSxjQUFRSSxPQUFPSixLQUFQLEVBQWNDLEdBQWQsQ0FBUjtBQUNEO0FBZDBDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZTNDLFNBQU9ELEtBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTRSxRQUFULENBQWtCRixLQUFsQixFQUF5QjtBQUN2QixTQUFPQSxVQUFVLElBQVYsSUFBa0IsUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUExQztBQUNEOztBQUVEO0FBQ0EsSUFBTU0sc0JBQXNCLFNBQXRCQSxtQkFBc0IsQ0FBQ1YsU0FBRCxFQUFZSyxHQUFaO0FBQUEsU0FBb0JMLFVBQVVLLEdBQVYsQ0FBcEI7QUFBQSxDQUE1QjtBQUNBLElBQU1NLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBQ0MsR0FBRCxFQUFNUCxHQUFOO0FBQUEsU0FBY08sSUFBSWIsR0FBSixDQUFRTSxHQUFSLENBQWQ7QUFBQSxDQUF4QjtBQUNBO0FBQ0EsSUFBTVEsU0FBUyxFQUFmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0osU0FBVCxDQUFtQlQsU0FBbkIsRUFBOEI7QUFDNUI7QUFDQSxNQUFNYyxZQUFZQyxPQUFPQyxjQUFQLENBQXNCaEIsU0FBdEIsQ0FBbEI7QUFDQSxTQUFPYyxVQUFVZixHQUFWLEdBQWdCWSxlQUFoQixHQUFrQ0QsbUJBQXpDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBU1AsT0FBVCxDQUFpQkYsWUFBakIsRUFBK0I7QUFDN0IsTUFBSSxPQUFPQSxZQUFQLEtBQXdCLFFBQTVCLEVBQXNDO0FBQ3BDO0FBQ0EsUUFBSUMsVUFBVVcsT0FBT1osWUFBUCxDQUFkO0FBQ0EsUUFBSSxDQUFDQyxPQUFMLEVBQWM7QUFDWkEsZ0JBQVVELGFBQWFnQixLQUFiLENBQW1CLEdBQW5CLENBQVY7QUFDQUosYUFBT1osWUFBUCxJQUF1QkMsT0FBdkI7QUFDRDtBQUNELFdBQU9BLE9BQVA7QUFDRDtBQUNEO0FBQ0EsU0FBT2dCLE1BQU1DLE9BQU4sQ0FBY2xCLFlBQWQsSUFBOEJBLFlBQTlCLEdBQTZDLENBQUNBLFlBQUQsQ0FBcEQ7QUFDRCIsImZpbGUiOiJnZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBBY2Nlc3MgcHJvcGVydGllcyBvZiBuZXN0ZWQgY29udGFpbmVycyB1c2luZyBkb3QtcGF0aCBub3RhdGlvblxuICogLSBTdXBwb3J0cyBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMsIGFzIHdlbGwgYXMgY2xhc3NlcyB3aXRoIGBnZXRgIG1ldGhvZHNcbiAqICAgc3VjaCBhcyBFUzYgTWFwcywgSW1tdXRhYmxlLmpzIG9iamVjdHMgZXRjXG4gKiAtIFJldHVybnMgdW5kZWZpbmVkIGlmIGFueSBjb250YWluZXIgaXMgbm90IHZhbGlkLCBpbnN0ZWFkIG9mIHRocm93aW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lciAtIGNvbnRhaW5lciB0aGF0IHN1cHBvcnRzIGdldFxuICogQHBhcmFtIHtTdHJpbmd8Kn0gY29tcG9zaXRlS2V5IC0ga2V5IHRvIGFjY2VzcywgY2FuIGJlICcuJy1zZXBhcmF0ZWQgc3RyaW5nXG4gKiBAcmV0dXJuIHsqfSAtIHZhbHVlIGluIHRoZSBmaW5hbCBrZXkgb2YgdGhlIG5lc3RlZCBjb250YWluZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChjb250YWluZXIsIGNvbXBvc2l0ZUtleSkge1xuICAvLyBTcGxpdCB0aGUga2V5IGludG8gc3Via2V5c1xuICBjb25zdCBrZXlMaXN0ID0gZ2V0S2V5cyhjb21wb3NpdGVLZXkpO1xuICAvLyBSZWN1cnNpdmVseSBnZXQgdGhlIHZhbHVlIG9mIGVhY2gga2V5O1xuICBsZXQgdmFsdWUgPSBjb250YWluZXI7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleUxpc3QpIHtcbiAgICAvLyBJZiBhbnkgaW50ZXJtZWRpYXRlIHN1YmZpZWxkIGlzIG5vdCBhIGNvbnRhaW5lciwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGBnZXR0ZXJgIGZvciB0aGlzIGNvbnRhaW5lclxuICAgIGNvbnN0IGdldHRlciA9IGdldEdldHRlcih2YWx1ZSk7XG4gICAgLy8gVXNlIHRoZSBnZXR0ZXIgdG8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIGtleVxuICAgIHZhbHVlID0gZ2V0dGVyKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYXJndW1lbnQgaXMgYW4gaW5kZXhhYmxlIG9iamVjdCAobm90IGEgcHJpbWl0aXZlIHZhbHVlLCBub3IgbnVsbClcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBKYXZhU2NyaXB0IHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGFyZ3VtZW50IGlzIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8vIERlZmF1bHQgZ2V0dGVyIGlzIGNvbnRhaW5lciBpbmRleGluZ1xuY29uc3Qgc3F1YXJlQnJhY2tldEdldHRlciA9IChjb250YWluZXIsIGtleSkgPT4gY29udGFpbmVyW2tleV07XG5jb25zdCBnZXRNZXRob2RHZXR0ZXIgPSAob2JqLCBrZXkpID0+IG9iai5nZXQoa2V5KTtcbi8vIENhY2hlIGtleSB0byBrZXkgYXJyYXlzIGZvciBzcGVlZFxuY29uc3Qga2V5TWFwID0ge307XG5cbi8vIExvb2tzIGZvciBhIGBnZXRgIGZ1bmN0aW9uIG9uIHRoZSBwcm90b3R5cGVcbi8vIFRPRE8gLSBmb2xsb3cgcHJvdG90eXBlIGNoYWluP1xuLy8gQHByaXZhdGVcbi8vIEByZXR1cm4ge0Z1bmN0aW9ufSAtIGdldCBmdW5jdGlvbjogKGNvbnRhaW5lciwga2V5KSA9PiB2YWx1ZVxuZnVuY3Rpb24gZ2V0R2V0dGVyKGNvbnRhaW5lcikge1xuICAvLyBDaGVjayBpZiBjb250YWluZXIgaGFzIGEgc3BlY2lhbCBnZXQgbWV0aG9kXG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb250YWluZXIpO1xuICByZXR1cm4gcHJvdG90eXBlLmdldCA/IGdldE1ldGhvZEdldHRlciA6IHNxdWFyZUJyYWNrZXRHZXR0ZXI7XG59XG5cbi8vIFRha2VzIGEgc3RyaW5nIG9mICcuJyBzZXBhcmF0ZWQga2V5cyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBrZXlzXG4vLyBFLmcuICdmZWF0dXJlLmdlb21ldHJ5LnR5cGUnID0+ICdmZWF0dXJlJywgJ2dlb21ldHJ5JywgJ3R5cGUnXG4vLyBAcHJpdmF0ZVxuZnVuY3Rpb24gZ2V0S2V5cyhjb21wb3NpdGVLZXkpIHtcbiAgaWYgKHR5cGVvZiBjb21wb3NpdGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZWxzZSBhc3N1bWUgc3RyaW5nIGFuZCBzcGxpdCBhcm91bmQgZG90c1xuICAgIGxldCBrZXlMaXN0ID0ga2V5TWFwW2NvbXBvc2l0ZUtleV07XG4gICAgaWYgKCFrZXlMaXN0KSB7XG4gICAgICBrZXlMaXN0ID0gY29tcG9zaXRlS2V5LnNwbGl0KCcuJyk7XG4gICAgICBrZXlNYXBbY29tcG9zaXRlS2V5XSA9IGtleUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBrZXlMaXN0O1xuICB9XG4gIC8vIFdyYXAgaW4gYXJyYXkgaWYgbmVlZGVkXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNvbXBvc2l0ZUtleSkgPyBjb21wb3NpdGVLZXkgOiBbY29tcG9zaXRlS2V5XTtcbn1cbiJdfQ==

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window, global, document */
module.exports = {
  window: typeof window !== 'undefined' ? window : global,
  global: typeof global !== 'undefined' ? global : window,
  document: typeof document !== 'undefined' ? document : {}
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZ2xvYmFscy5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwid2luZG93IiwiZ2xvYmFsIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0FBLE9BQU9DLE9BQVAsR0FBaUI7QUFDZkMsVUFBUSxPQUFPQSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q0MsTUFEbEM7QUFFZkEsVUFBUSxPQUFPQSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q0QsTUFGbEM7QUFHZkUsWUFBVSxPQUFPQSxRQUFQLEtBQW9CLFdBQXBCLEdBQWtDQSxRQUFsQyxHQUE2QztBQUh4QyxDQUFqQiIsImZpbGUiOiJnbG9iYWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3csIGdsb2JhbCwgZG9jdW1lbnQgKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsLFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge31cbn07XG4iXX0=
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable no-console */
/* global console */


function log(priority) {
  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');
  if (priority <= log.priority) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // Node doesn't have console.debug, but using it looks better in browser consoles
    if (console.debug) {
      var _console;

      (_console = console).debug.apply(_console, args);
    } else {
      var _console2;

      (_console2 = console).info.apply(_console2, args);
    }
  }
}

var cache = {};

function once(priority, arg) {
  if (!cache[arg] && priority <= log.priority) {
    var _console3;

    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    (_console3 = console).warn.apply(_console3, [arg].concat(args));
    cache[arg] = true;
  }
}

// Logs a message with a time
function time(priority, label) {
  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');
  if (priority <= log.priority) {
    // In case the platform doesn't have console.time
    if (console.time) {
      console.time(label);
    } else {
      console.info(label);
    }
  }
}

function timeEnd(priority, label) {
  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');
  if (priority <= log.priority) {
    // In case the platform doesn't have console.timeEnd
    if (console.timeEnd) {
      console.timeEnd(label);
    } else {
      console.info(label);
    }
  }
}

log.priority = 0;
log.log = log;
log.once = once;
log.time = time;
log.timeEnd = timeEnd;

/* harmony default export */ __webpack_exports__["a"] = (log);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvbG9nLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsImxvZyIsInByaW9yaXR5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhcmdzIiwiY29uc29sZSIsImRlYnVnIiwiaW5mbyIsImNhY2hlIiwib25jZSIsImFyZyIsIndhcm4iLCJ0aW1lIiwibGFiZWwiLCJ0aW1lRW5kIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBT0EsTUFBUCxNQUFtQixRQUFuQjs7QUFFQSxTQUFTQyxHQUFULENBQWFDLFFBQWIsRUFBZ0M7QUFDOUJGLFNBQU9HLE9BQU9DLFFBQVAsQ0FBZ0JGLFFBQWhCLENBQVAsRUFBa0MsK0JBQWxDO0FBQ0EsTUFBSUEsWUFBWUQsSUFBSUMsUUFBcEIsRUFBOEI7QUFBQSxzQ0FGTkcsSUFFTTtBQUZOQSxVQUVNO0FBQUE7O0FBQzVCO0FBQ0EsUUFBSUMsUUFBUUMsS0FBWixFQUFtQjtBQUFBOztBQUNqQiwyQkFBUUEsS0FBUixpQkFBaUJGLElBQWpCO0FBQ0QsS0FGRCxNQUVPO0FBQUE7O0FBQ0wsNEJBQVFHLElBQVIsa0JBQWdCSCxJQUFoQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFNSSxRQUFRLEVBQWQ7O0FBRUEsU0FBU0MsSUFBVCxDQUFjUixRQUFkLEVBQXdCUyxHQUF4QixFQUFzQztBQUNwQyxNQUFJLENBQUNGLE1BQU1FLEdBQU4sQ0FBRCxJQUFlVCxZQUFZRCxJQUFJQyxRQUFuQyxFQUE2QztBQUFBOztBQUFBLHVDQURmRyxJQUNlO0FBRGZBLFVBQ2U7QUFBQTs7QUFDM0MsMEJBQVFPLElBQVIsbUJBQWlCRCxHQUFqQixTQUF5Qk4sSUFBekI7QUFDQUksVUFBTUUsR0FBTixJQUFhLElBQWI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBU0UsSUFBVCxDQUFjWCxRQUFkLEVBQXdCWSxLQUF4QixFQUErQjtBQUM3QmQsU0FBT0csT0FBT0MsUUFBUCxDQUFnQkYsUUFBaEIsQ0FBUCxFQUFrQywrQkFBbEM7QUFDQSxNQUFJQSxZQUFZRCxJQUFJQyxRQUFwQixFQUE4QjtBQUM1QjtBQUNBLFFBQUlJLFFBQVFPLElBQVosRUFBa0I7QUFDaEJQLGNBQVFPLElBQVIsQ0FBYUMsS0FBYjtBQUNELEtBRkQsTUFFTztBQUNMUixjQUFRRSxJQUFSLENBQWFNLEtBQWI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0MsT0FBVCxDQUFpQmIsUUFBakIsRUFBMkJZLEtBQTNCLEVBQWtDO0FBQ2hDZCxTQUFPRyxPQUFPQyxRQUFQLENBQWdCRixRQUFoQixDQUFQLEVBQWtDLCtCQUFsQztBQUNBLE1BQUlBLFlBQVlELElBQUlDLFFBQXBCLEVBQThCO0FBQzVCO0FBQ0EsUUFBSUksUUFBUVMsT0FBWixFQUFxQjtBQUNuQlQsY0FBUVMsT0FBUixDQUFnQkQsS0FBaEI7QUFDRCxLQUZELE1BRU87QUFDTFIsY0FBUUUsSUFBUixDQUFhTSxLQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUVEYixJQUFJQyxRQUFKLEdBQWUsQ0FBZjtBQUNBRCxJQUFJQSxHQUFKLEdBQVVBLEdBQVY7QUFDQUEsSUFBSVMsSUFBSixHQUFXQSxJQUFYO0FBQ0FULElBQUlZLElBQUosR0FBV0EsSUFBWDtBQUNBWixJQUFJYyxPQUFKLEdBQWNBLE9BQWQ7O0FBRUEsZUFBZWQsR0FBZiIsImZpbGUiOiJsb2cuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogZ2xvYmFsIGNvbnNvbGUgKi9cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuZnVuY3Rpb24gbG9nKHByaW9yaXR5LCAuLi5hcmdzKSB7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUocHJpb3JpdHkpLCAnbG9nIHByaW9yaXR5IG11c3QgYmUgYSBudW1iZXInKTtcbiAgaWYgKHByaW9yaXR5IDw9IGxvZy5wcmlvcml0eSkge1xuICAgIC8vIE5vZGUgZG9lc24ndCBoYXZlIGNvbnNvbGUuZGVidWcsIGJ1dCB1c2luZyBpdCBsb29rcyBiZXR0ZXIgaW4gYnJvd3NlciBjb25zb2xlc1xuICAgIGlmIChjb25zb2xlLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmluZm8oLi4uYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIG9uY2UocHJpb3JpdHksIGFyZywgLi4uYXJncykge1xuICBpZiAoIWNhY2hlW2FyZ10gJiYgcHJpb3JpdHkgPD0gbG9nLnByaW9yaXR5KSB7XG4gICAgY29uc29sZS53YXJuKC4uLlthcmcsIC4uLmFyZ3NdKTtcbiAgICBjYWNoZVthcmddID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBMb2dzIGEgbWVzc2FnZSB3aXRoIGEgdGltZVxuZnVuY3Rpb24gdGltZShwcmlvcml0eSwgbGFiZWwpIHtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShwcmlvcml0eSksICdsb2cgcHJpb3JpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICBpZiAocHJpb3JpdHkgPD0gbG9nLnByaW9yaXR5KSB7XG4gICAgLy8gSW4gY2FzZSB0aGUgcGxhdGZvcm0gZG9lc24ndCBoYXZlIGNvbnNvbGUudGltZVxuICAgIGlmIChjb25zb2xlLnRpbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZShsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhsYWJlbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQocHJpb3JpdHksIGxhYmVsKSB7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUocHJpb3JpdHkpLCAnbG9nIHByaW9yaXR5IG11c3QgYmUgYSBudW1iZXInKTtcbiAgaWYgKHByaW9yaXR5IDw9IGxvZy5wcmlvcml0eSkge1xuICAgIC8vIEluIGNhc2UgdGhlIHBsYXRmb3JtIGRvZXNuJ3QgaGF2ZSBjb25zb2xlLnRpbWVFbmRcbiAgICBpZiAoY29uc29sZS50aW1lRW5kKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmluZm8obGFiZWwpO1xuICAgIH1cbiAgfVxufVxuXG5sb2cucHJpb3JpdHkgPSAwO1xubG9nLmxvZyA9IGxvZztcbmxvZy5vbmNlID0gb25jZTtcbmxvZy50aW1lID0gdGltZTtcbmxvZy50aW1lRW5kID0gdGltZUVuZDtcblxuZXhwb3J0IGRlZmF1bHQgbG9nO1xuIl19

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(25);
/* unused harmony reexport default */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__viewport__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__perspective_viewport__ = __webpack_require__(78);
/* unused harmony reexport PerspectiveViewport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__orthographic_viewport__ = __webpack_require__(77);
/* unused harmony reexport OrthographicViewport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__web_mercator_viewport__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__web_mercator_viewport__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.






//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL2luZGV4LmpzIl0sIm5hbWVzIjpbImRlZmF1bHQiLCJWaWV3cG9ydCIsIlBlcnNwZWN0aXZlVmlld3BvcnQiLCJPcnRob2dyYXBoaWNWaWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLE9BQVIsUUFBaUMsWUFBakM7QUFDQSxTQUFRQSxXQUFXQyxRQUFuQixRQUFrQyxZQUFsQztBQUNBLFNBQVFELFdBQVdFLG1CQUFuQixRQUE2Qyx3QkFBN0M7QUFDQSxTQUFRRixXQUFXRyxvQkFBbkIsUUFBOEMseUJBQTlDO0FBQ0EsU0FBUUgsV0FBV0ksbUJBQW5CLFFBQTZDLHlCQUE3QyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQge2RlZmF1bHQgYXMgZGVmYXVsdH0gZnJvbSAnLi92aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgVmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBlcnNwZWN0aXZlVmlld3BvcnR9IGZyb20gJy4vcGVyc3BlY3RpdmUtdmlld3BvcnQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE9ydGhvZ3JhcGhpY1ZpZXdwb3J0fSBmcm9tICcuL29ydGhvZ3JhcGhpYy12aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuIl19

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object3d = __webpack_require__(50);

var _object3d2 = _interopRequireDefault(_object3d);

var _assert = __webpack_require__(0);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// TODO - FIX
var Matrix4 = function () {
  function Matrix4() {
    _classCallCheck(this, Matrix4);
  }

  _createClass(Matrix4, [{
    key: 'mulMat4',
    value: function mulMat4() {
      return this;
    }
  }]);

  return Matrix4;
}();

var Group = function (_Object3D) {
  _inherits(Group, _Object3D);

  function Group() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Group);

    var _opts$children = opts.children,
        children = _opts$children === undefined ? [] : _opts$children;

    children.every(function (child) {
      return (0, _assert2.default)(child instanceof _object3d2.default);
    });

    var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, opts));

    _this.children = children;
    return _this;
  }

  // Unpacks arrays and nested arrays of children


  _createClass(Group, [{
    key: 'add',
    value: function add() {
      for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          if (Array.isArray(child)) {
            this.add.apply(this, _toConsumableArray(child));
          } else {
            this.children.push(child);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
  }, {
    key: 'remove',
    value: function remove(child) {
      var children = this.children;
      var indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
  }, {
    key: 'removeAll',
    value: function removeAll() {
      this.children = [];
      return this;
    }

    // If visitor returns a truthy value, traversal will be aborted and that value
    // will be returned from `traverse`. Otherwise `traverse` will return null.

  }, {
    key: 'traverse',
    value: function traverse(visitor) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$viewMatrix = _ref.viewMatrix,
          viewMatrix = _ref$viewMatrix === undefined ? new Matrix4() : _ref$viewMatrix;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;
          var matrix = child.matrix;

          var worldMatrix = viewMatrix.mulMat4(matrix);
          var result = void 0;
          if (child instanceof Group) {
            result = child.traverse({ matrix: matrix, worldMatrix: worldMatrix, visitor: visitor });
          } else {
            if (child.program) {
              child.program.use();
              child.program.setUniforms({ worldMatrix: worldMatrix });
            }
            result = visitor(child, {});
          }
          // Abort if a result was returned
          if (result) {
            return result;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }

    // If visitor returns a truthy value, traversal will be aborted and that value
    // will be returned from `traverseReverse`. Otherwise `traverseReverse` will return null.

  }, {
    key: 'traverseReverse',
    value: function traverseReverse(visitor) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$viewMatrix = _ref2.viewMatrix,
          viewMatrix = _ref2$viewMatrix === undefined ? new Matrix4() : _ref2$viewMatrix;

      for (var i = this.children.length - 1; i >= 0; --i) {
        var child = this.children[i];
        var matrix = child.matrix;

        var worldMatrix = viewMatrix.mulMat4(matrix);
        var result = void 0;
        if (child instanceof Group) {
          result = child.traverse({ matrix: matrix, worldMatrix: worldMatrix, visitor: visitor });
        } else {
          if (child.program) {
            child.program.use();
            child.program.setUniforms({ worldMatrix: worldMatrix });
          }
          result = visitor(child, {});
        }
        // Abort if a result was returned
        if (result) {
          return result;
        }
      }
      return null;
    }
  }]);

  return Group;
}(_object3d2.default);

exports.default = Group;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NjZW5lZ3JhcGgvZ3JvdXAuanMiXSwibmFtZXMiOlsiTWF0cml4NCIsIkdyb3VwIiwib3B0cyIsImNoaWxkcmVuIiwiZXZlcnkiLCJjaGlsZCIsIkFycmF5IiwiaXNBcnJheSIsImFkZCIsInB1c2giLCJpbmRleE9mIiwic3BsaWNlIiwidmlzaXRvciIsInZpZXdNYXRyaXgiLCJtYXRyaXgiLCJ3b3JsZE1hdHJpeCIsIm11bE1hdDQiLCJyZXN1bHQiLCJ0cmF2ZXJzZSIsInByb2dyYW0iLCJ1c2UiLCJzZXRVbmlmb3JtcyIsImkiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTtJQUNNQSxPOzs7Ozs7OzhCQUNNO0FBQ1IsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztJQUdrQkMsSzs7O0FBQ25CLG1CQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSx5QkFDR0EsSUFESCxDQUNkQyxRQURjO0FBQUEsUUFDZEEsUUFEYyxrQ0FDSCxFQURHOztBQUVyQkEsYUFBU0MsS0FBVCxDQUFlO0FBQUEsYUFBUyxzQkFBT0MsbUNBQVAsQ0FBVDtBQUFBLEtBQWY7O0FBRnFCLDhHQUdmSCxJQUhlOztBQUlyQixVQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUpxQjtBQUt0Qjs7QUFFRDs7Ozs7MEJBQ2lCO0FBQUEsd0NBQVZBLFFBQVU7QUFBVkEsZ0JBQVU7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDZiw2QkFBb0JBLFFBQXBCLDhIQUE4QjtBQUFBLGNBQW5CRSxLQUFtQjs7QUFDNUIsY0FBSUMsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUosRUFBMEI7QUFDeEIsaUJBQUtHLEdBQUwsZ0NBQVlILEtBQVo7QUFDRCxXQUZELE1BRU87QUFDTCxpQkFBS0YsUUFBTCxDQUFjTSxJQUFkLENBQW1CSixLQUFuQjtBQUNEO0FBQ0Y7QUFQYztB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Imdyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vb2JqZWN0LTNkJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gVE9ETyAtIEZJWFxuY2xhc3MgTWF0cml4NCB7XG4gIG11bE1hdDQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdXAgZXh0ZW5kcyBPYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtjaGlsZHJlbiA9IFtdfSA9IG9wdHM7XG4gICAgY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gYXNzZXJ0KGNoaWxkIGluc3RhbmNlb2YgT2JqZWN0M0QpKTtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH1cblxuICAvLyBVbnBhY2tzIGFycmF5cyBhbmQgbmVzdGVkIGFycmF5cyBvZiBjaGlsZHJlblxuICBhZGQoLi4uY2hpbGRyZW4pIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdGhpcy5hZGQoLi4uY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmUoY2hpbGQpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgY29uc3QgaW5kZXhPZiA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleE9mID4gLTEpIHtcbiAgICAgIGNoaWxkcmVuLnNwbGljZShpbmRleE9mLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gSWYgdmlzaXRvciByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLCB0cmF2ZXJzYWwgd2lsbCBiZSBhYm9ydGVkIGFuZCB0aGF0IHZhbHVlXG4gIC8vIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSBgdHJhdmVyc2VgLiBPdGhlcndpc2UgYHRyYXZlcnNlYCB3aWxsIHJldHVybiBudWxsLlxuICB0cmF2ZXJzZSh2aXNpdG9yLCB7dmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KCl9ID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHttYXRyaXh9ID0gY2hpbGQ7XG4gICAgICBjb25zdCB3b3JsZE1hdHJpeCA9IHZpZXdNYXRyaXgubXVsTWF0NChtYXRyaXgpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIHJlc3VsdCA9IGNoaWxkLnRyYXZlcnNlKHttYXRyaXgsIHdvcmxkTWF0cml4LCB2aXNpdG9yfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2hpbGQucHJvZ3JhbSkge1xuICAgICAgICAgIGNoaWxkLnByb2dyYW0udXNlKCk7XG4gICAgICAgICAgY2hpbGQucHJvZ3JhbS5zZXRVbmlmb3Jtcyh7d29ybGRNYXRyaXh9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2aXNpdG9yKGNoaWxkLCB7fSk7XG4gICAgICB9XG4gICAgICAvLyBBYm9ydCBpZiBhIHJlc3VsdCB3YXMgcmV0dXJuZWRcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB2aXNpdG9yIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIHRyYXZlcnNhbCB3aWxsIGJlIGFib3J0ZWQgYW5kIHRoYXQgdmFsdWVcbiAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIGB0cmF2ZXJzZVJldmVyc2VgLiBPdGhlcndpc2UgYHRyYXZlcnNlUmV2ZXJzZWAgd2lsbCByZXR1cm4gbnVsbC5cbiAgdHJhdmVyc2VSZXZlcnNlKHZpc2l0b3IsIHt2aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQoKX0gPSB7fSkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBjb25zdCB7bWF0cml4fSA9IGNoaWxkO1xuICAgICAgY29uc3Qgd29ybGRNYXRyaXggPSB2aWV3TWF0cml4Lm11bE1hdDQobWF0cml4KTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICByZXN1bHQgPSBjaGlsZC50cmF2ZXJzZSh7bWF0cml4LCB3b3JsZE1hdHJpeCwgdmlzaXRvcn0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoaWxkLnByb2dyYW0pIHtcbiAgICAgICAgICBjaGlsZC5wcm9ncmFtLnVzZSgpO1xuICAgICAgICAgIGNoaWxkLnByb2dyYW0uc2V0VW5pZm9ybXMoe3dvcmxkTWF0cml4fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmlzaXRvcihjaGlsZCwge30pO1xuICAgICAgfVxuICAgICAgLy8gQWJvcnQgaWYgYSByZXN1bHQgd2FzIHJldHVybmVkXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXX0=

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(4);

var _math = __webpack_require__(51);

var _assert = __webpack_require__(0);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Object3D = function () {
  function Object3D(_ref) {
    var id = _ref.id,
        _ref$display = _ref.display,
        display = _ref$display === undefined ? true : _ref$display;

    _classCallCheck(this, Object3D);

    // model position, rotation, scale and all in all matrix
    this.position = new _math.Vector3();
    this.rotation = new _math.Vector3();
    this.scale = new _math.Vector3(1, 1, 1);
    this.matrix = new _math.Matrix4();

    // whether to display the object at all
    this.id = id || (0, _utils.uid)(this.constructor.name);
    this.display = true;
    this.userData = {};
  }

  _createClass(Object3D, [{
    key: 'setPosition',
    value: function setPosition(position) {
      (0, _assert2.default)(position.length === 3, 'setPosition requires vector argument');
      this.position = position;
      return this;
    }
  }, {
    key: 'setRotation',
    value: function setRotation(rotation) {
      (0, _assert2.default)(rotation.length === 3, 'setRotation requires vector argument');
      this.rotation = rotation;
      return this;
    }
  }, {
    key: 'setScale',
    value: function setScale(scale) {
      (0, _assert2.default)(scale.length === 3, 'setScale requires vector argument');
      this.scale = scale;
      return this;
    }
  }, {
    key: 'setMatrixComponents',
    value: function setMatrixComponents(_ref2) {
      var position = _ref2.position,
          rotation = _ref2.rotation,
          scale = _ref2.scale,
          _ref2$update = _ref2.update,
          update = _ref2$update === undefined ? true : _ref2$update;

      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale) {
        this.setScale(scale);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
  }, {
    key: 'updateMatrix',
    value: function updateMatrix() {
      var pos = this.position;
      var rot = this.rotation;
      var scale = this.scale;

      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale);
      return this;
    }
  }, {
    key: 'update',
    value: function update() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          position = _ref3.position,
          rotation = _ref3.rotation,
          scale = _ref3.scale;

      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale) {
        this.setScale(scale);
      }
      this.updateMatrix();
      return this;
    }
  }, {
    key: 'getCoordinateUniforms',
    value: function getCoordinateUniforms(viewMatrix, modelMatrix) {
      // TODO - solve multiple class problem
      // assert(viewMatrix instanceof Matrix4);
      (0, _assert2.default)(viewMatrix);
      modelMatrix = modelMatrix || this.matrix;
      var worldMatrix = new _math.Matrix4(viewMatrix).multiplyRight(modelMatrix);
      var worldInverse = worldMatrix.invert();
      var worldInverseTranspose = worldInverse.transpose();

      return {
        viewMatrix: viewMatrix,
        modelMatrix: modelMatrix,
        objectMatrix: modelMatrix,
        worldMatrix: worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }

    // TODO - copied code, not yet vetted

  }, {
    key: 'transform',
    value: function transform() {

      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        var parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }

      var ch = this.children;
      for (var i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }

      return this;
    }
  }]);

  return Object3D;
}();

exports.default = Object3D;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NjZW5lZ3JhcGgvb2JqZWN0LTNkLmpzIl0sIm5hbWVzIjpbIk9iamVjdDNEIiwiaWQiLCJkaXNwbGF5IiwicG9zaXRpb24iLCJyb3RhdGlvbiIsInNjYWxlIiwibWF0cml4IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidXNlckRhdGEiLCJsZW5ndGgiLCJ1cGRhdGUiLCJzZXRQb3NpdGlvbiIsInNldFJvdGF0aW9uIiwic2V0U2NhbGUiLCJ1cGRhdGVNYXRyaXgiLCJwb3MiLCJyb3QiLCJpZGVudGl0eSIsInRyYW5zbGF0ZSIsInJvdGF0ZVhZWiIsInZpZXdNYXRyaXgiLCJtb2RlbE1hdHJpeCIsIndvcmxkTWF0cml4IiwibXVsdGlwbHlSaWdodCIsIndvcmxkSW52ZXJzZSIsImludmVydCIsIndvcmxkSW52ZXJzZVRyYW5zcG9zZSIsInRyYW5zcG9zZSIsIm9iamVjdE1hdHJpeCIsIndvcmxkSW52ZXJzZU1hdHJpeCIsIndvcmxkSW52ZXJzZVRyYW5zcG9zZU1hdHJpeCIsInBhcmVudCIsImVuZFBvc2l0aW9uIiwic2V0IiwiZW5kUm90YXRpb24iLCJlbmRTY2FsZSIsImFkZCIsImNoIiwiY2hpbGRyZW4iLCJpIiwidHJhbnNmb3JtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7OztJQUVxQkEsUTtBQUVuQiwwQkFBa0M7QUFBQSxRQUFyQkMsRUFBcUIsUUFBckJBLEVBQXFCO0FBQUEsNEJBQWpCQyxPQUFpQjtBQUFBLFFBQWpCQSxPQUFpQixnQ0FBUCxJQUFPOztBQUFBOztBQUNoQztBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsbUJBQWhCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixtQkFBaEI7QUFDQSxTQUFLQyxLQUFMLEdBQWEsa0JBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBYjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxtQkFBZDs7QUFFQTtBQUNBLFNBQUtMLEVBQUws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QUFqQixDQUFxQixLQUFLL0IsUUFBMUI7QUFDQSxhQUFLZ0MsV0FBTCxDQUFpQkQsR0FBakIsQ0FBcUIsS0FBSzlCLFFBQTFCO0FBQ0EsYUFBS2dDLFFBQUwsQ0FBY0YsR0FBZCxDQUFrQixLQUFLN0IsS0FBdkI7QUFDRCxPQUpELE1BSU87QUFDTCxZQUFNMkIsU0FBUyxLQUFLQSxNQUFwQjtBQUNBLGFBQUtDLFdBQUwsQ0FBaUJDLEdBQWpCLENBQXFCLEtBQUsvQixRQUFMLENBQWNrQyxHQUFkLENBQWtCTCxPQUFPQyxXQUF6QixDQUFyQjtBQUNBLGFBQUtFLFdBQUwsQ0FBaUJELEdBQWpCLENBQXFCLEtBQUs5QixRQUFMLENBQWNpQyxHQUFkLENBQWtCTCxPQUFPRyxXQUF6QixDQUFyQjtBQUNBLGFBQUtDLFFBQUwsQ0FBY0YsR0FBZCxDQUFrQixLQUFLN0IsS0FBTCxDQUFXZ0MsR0FBWCxDQUFlTCxPQUFPSSxRQUF0QixDQUFsQjtBQUNEOztBQUVELFVBQU1FLEtBQUssS0FBS0MsUUFBaEI7QUFDQSxXQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsR0FBRzVCLE1BQXZCLEVBQStCLEVBQUU4QixDQUFqQyxFQUFvQztBQUNsQ0YsV0FBR0UsQ0FBSCxFQUFNQyxTQUFOO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztrQkFsSGtCekMsUSIsImZpbGUiOiJvYmplY3QtM2QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VpZH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHtWZWN0b3IzLCBNYXRyaXg0fSBmcm9tICcuLi8uLi9wYWNrYWdlcy9tYXRoJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0M0Qge1xuXG4gIGNvbnN0cnVjdG9yKHtpZCwgZGlzcGxheSA9IHRydWV9KSB7XG4gICAgLy8gbW9kZWwgcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSBhbmQgYWxsIGluIGFsbCBtYXRyaXhcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgLy8gd2hldGhlciB0byBkaXNwbGF5IHRoZSBvYmplY3QgYXQgYWxsXG4gICAgdGhpcy5pZCA9IGlkIHx8IHVpZCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICB9XG5cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBhc3NlcnQocG9zaXRpb24ubGVuZ3RoID09PSAzLCAnc2V0UG9zaXRpb24gcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICBhc3NlcnQocm90YXRpb24ubGVuZ3RoID09PSAzLCAnc2V0Um90YXRpb24gcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICBhc3NlcnQoc2NhbGUubGVuZ3RoID09PSAzLCAnc2V0U2NhbGUgcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TWF0cml4Q29tcG9uZW50cyh7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSwgdXBkYXRlID0gdHJ1ZX0pIHtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgIHRoaXMuc2V0U2NhbGUoc2NhbGUpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuICAgIGNvbnN0IHJvdCA9IHRoaXMucm90YXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB0aGlzLm1hdHJpeC50cmFuc2xhdGUocG9zKTtcbiAgICB0aGlzLm1hdHJpeC5yb3RhdGVYWVoocm90KTtcbiAgICB0aGlzLm1hdHJpeC5zY2FsZShzY2FsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGUoe3Bvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGV9ID0ge30pIHtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgIHRoaXMuc2V0U2NhbGUoc2NhbGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q29vcmRpbmF0ZVVuaWZvcm1zKHZpZXdNYXRyaXgsIG1vZGVsTWF0cml4KSB7XG4gICAgLy8gVE9ETyAtIHNvbHZlIG11bHRpcGxlIGNsYXNzIHByb2JsZW1cbiAgICAvLyBhc3NlcnQodmlld01hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeDQpO1xuICAgIGFzc2VydCh2aWV3TWF0cml4KTtcbiAgICBtb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4IHx8IHRoaXMubWF0cml4O1xuICAgIGNvbnN0IHdvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeCkubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgY29uc3Qgd29ybGRJbnZlcnNlID0gd29ybGRNYXRyaXguaW52ZXJ0KCk7XG4gICAgY29uc3Qgd29ybGRJbnZlcnNlVHJhbnNwb3NlID0gd29ybGRJbnZlcnNlLnRyYW5zcG9zZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdNYXRyaXgsXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIG9iamVjdE1hdHJpeDogbW9kZWxNYXRyaXgsXG4gICAgICB3b3JsZE1hdHJpeCxcbiAgICAgIHdvcmxkSW52ZXJzZU1hdHJpeDogd29ybGRJbnZlcnNlLFxuICAgICAgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4OiB3b3JsZEludmVyc2VUcmFuc3Bvc2VcbiAgICB9O1xuICB9XG5cbiAgLy8gVE9ETyAtIGNvcGllZCBjb2RlLCBub3QgeWV0IHZldHRlZFxuICB0cmFuc2Zvcm0oKSB7XG5cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLmVuZFBvc2l0aW9uLnNldCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuZW5kUm90YXRpb24uc2V0KHRoaXMucm90YXRpb24pO1xuICAgICAgdGhpcy5lbmRTY2FsZS5zZXQodGhpcy5zY2FsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgdGhpcy5lbmRQb3NpdGlvbi5zZXQodGhpcy5wb3NpdGlvbi5hZGQocGFyZW50LmVuZFBvc2l0aW9uKSk7XG4gICAgICB0aGlzLmVuZFJvdGF0aW9uLnNldCh0aGlzLnJvdGF0aW9uLmFkZChwYXJlbnQuZW5kUm90YXRpb24pKTtcbiAgICAgIHRoaXMuZW5kU2NhbGUuc2V0KHRoaXMuc2NhbGUuYWRkKHBhcmVudC5lbmRTY2FsZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICBjaFtpXS50cmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIl19

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(17);

Object.keys(_common).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _common[key];
    }
  });
});

var _vector = __webpack_require__(54);

Object.defineProperty(exports, 'Vector2', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_vector).default;
  }
});

var _vector2 = __webpack_require__(34);

Object.defineProperty(exports, 'Vector3', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_vector2).default;
  }
});

var _vector3 = __webpack_require__(55);

Object.defineProperty(exports, 'Vector4', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_vector3).default;
  }
});

var _matrix = __webpack_require__(52);

Object.defineProperty(exports, 'Matrix4', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_matrix).default;
  }
});

var _quaternion = __webpack_require__(53);

Object.defineProperty(exports, 'Quaternion', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_quaternion).default;
  }
});

var _euler = __webpack_require__(104);

Object.defineProperty(exports, 'Euler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_euler).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL2luZGV4LmpzIl0sIm5hbWVzIjpbImRlZmF1bHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OzJDQUNRQSxPOzs7Ozs7Ozs7NENBQ0FBLE87Ozs7Ozs7Ozs0Q0FDQUEsTzs7Ozs7Ozs7OzJDQUNBQSxPOzs7Ozs7Ozs7K0NBQ0FBLE87Ozs7Ozs7OzswQ0FDQUEsTyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vc3JjL2NvbW1vbic7XG5leHBvcnQge2RlZmF1bHQgYXMgVmVjdG9yMn0gZnJvbSAnLi9zcmMvdmVjdG9yMic7XG5leHBvcnQge2RlZmF1bHQgYXMgVmVjdG9yM30gZnJvbSAnLi9zcmMvdmVjdG9yMyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVmVjdG9yNH0gZnJvbSAnLi9zcmMvdmVjdG9yNCc7XG5leHBvcnQge2RlZmF1bHQgYXMgTWF0cml4NH0gZnJvbSAnLi9zcmMvbWF0cml4NCc7XG5leHBvcnQge2RlZmF1bHQgYXMgUXVhdGVybmlvbn0gZnJvbSAnLi9zcmMvcXVhdGVybmlvbic7XG5leHBvcnQge2RlZmF1bHQgYXMgRXVsZXJ9IGZyb20gJy4vc3JjL2V1bGVyJztcbiJdfQ==

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _vector = __webpack_require__(54);

var _vector2 = _interopRequireDefault(_vector);

var _vector3 = __webpack_require__(34);

var _vector4 = _interopRequireDefault(_vector3);

var _vector5 = __webpack_require__(55);

var _vector6 = _interopRequireDefault(_vector5);

var _glMatrix = __webpack_require__(9);

var _validators = __webpack_require__(249);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Matrix4 = function (_MathArray) {
  _inherits(Matrix4, _MathArray);

  function Matrix4() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _classCallCheck(this, Matrix4);

    var _this = _possibleConstructorReturn(this, (Matrix4.__proto__ || Object.getPrototypeOf(Matrix4)).call(this));

    if (Array.isArray(args[0]) && arguments.length === 1) {
      _this.copy(args[0]);
    } else {
      _this.identity();
    }
    return _this;
  }

  _createClass(Matrix4, [{
    key: 'setRowMajor',


    /* eslint-disable max-params */
    value: function setRowMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m30 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m01 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m21 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m31 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m02 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m12 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m32 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m03 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m13 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m23 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;

      _glMatrix.mat4.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      this.check();
      return this;
    }
  }, {
    key: 'setColumnMajor',
    value: function setColumnMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m03 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m10 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m12 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m13 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m20 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m21 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m23 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m30 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m31 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m32 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;

      _glMatrix.mat4.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      this.check();
      return this;
    }
    /* eslint-enable max-params */

  }, {
    key: 'equals',
    value: function equals(a) {
      return _glMatrix.mat4.equals(this, a);
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(a) {
      return _glMatrix.mat4.exactEquals(this, a);
    }
  }, {
    key: 'determinant',

    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

    // Accessors

    value: function determinant() {
      return _glMatrix.mat4.determinant(this);
    }
  }, {
    key: 'getRotation',
    value: function getRotation() {
      throw new Error('Not implemented');
    }

    // Constructors

  }, {
    key: 'identity',
    value: function identity() {
      _glMatrix.mat4.identity(this);
      this.check();
      return this;
    }

    // Generates a frustum matrix with the given bounds
    // left  Number  Left bound of the frustum
    // right Number  Right bound of the frustum
    // bottom  Number  Bottom bound of the frustum
    // top Number  Top bound of the frustum
    // near  Number  Near bound of the frustum
    // far Number  Far bound of the frustum

  }, {
    key: 'frustum',
    value: function frustum(_ref) {
      var left = _ref.left,
          right = _ref.right,
          bottom = _ref.bottom,
          top = _ref.top,
          near = _ref.near,
          far = _ref.far;

      _glMatrix.mat4.frustum(this, left, right, bottom, top, near, far);
      this.check();
      return this;
    }
  }, {
    key: 'lookAt',


    // Generates a look-at matrix with the given eye position, focal point,
    // and up axis
    // eye vec3  Position of the viewer
    // center  vec3  Point the viewer is looking at
    // up  vec3  vec3 pointing up
    value: function lookAt() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          eye = _ref2.eye,
          _ref2$center = _ref2.center,
          center = _ref2$center === undefined ? [0, 0, 0] : _ref2$center,
          _ref2$up = _ref2.up,
          up = _ref2$up === undefined ? [0, 1, 0] : _ref2$up;

      _glMatrix.mat4.lookAt(this, eye, center, up);
      this.check();
      return this;
    }
  }, {
    key: 'ortho',


    // Generates a orthogonal projection matrix with the given bounds
    // left  number  Left bound of the frustum
    // right number  Right bound of the frustum
    // bottom  number  Bottom bound of the frustum
    // top number  Top bound of the frustum
    // near  number  Near bound of the frustum
    // far number  Far bound of the frustum
    value: function ortho(_ref3) {
      var left = _ref3.left,
          right = _ref3.right,
          bottom = _ref3.bottom,
          top = _ref3.top,
          _ref3$near = _ref3.near,
          near = _ref3$near === undefined ? 0.1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === undefined ? 500 : _ref3$far;

      _glMatrix.mat4.ortho(this, left, right, bottom, top, near, far);
      this.check();
      return this;
    }
  }, {
    key: 'perspective',


    // Generates a perspective projection matrix with the given bounds
    // fovy  number  Vertical field of view in radians
    // aspect  number  Aspect ratio. typically viewport width/height
    // near  number  Near bound of the frustum
    // far number  Far bound of the frustum
    value: function perspective() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$fov = _ref4.fov,
          fov = _ref4$fov === undefined ? 45 * Math.PI / 180 : _ref4$fov,
          _ref4$aspect = _ref4.aspect,
          aspect = _ref4$aspect === undefined ? 1 : _ref4$aspect,
          _ref4$near = _ref4.near,
          near = _ref4$near === undefined ? 0.1 : _ref4$near,
          _ref4$far = _ref4.far,
          far = _ref4$far === undefined ? 500 : _ref4$far;

      if (fov > Math.PI * 2) {
        throw Error('radians');
      }
      _glMatrix.mat4.perspective(this, fov, aspect, near, far);
      this.check();
      return this;
    }
  }, {
    key: 'perspectiveFromFieldOfView',


    // Generates a perspective projection matrix with the given field of view.
    // This is primarily useful for generating projection matrices to be used
    // with the still experiemental WebVR API.
    // fov Object  Object containing the following values:
    //   upDegrees, downDegrees, leftDegrees, rightDegrees
    // near  number  Near bound of the frustum
    // far number  Far bound of the frustum
    value: function perspectiveFromFieldOfView(out, fov, near, far) {
      _glMatrix.mat4.perspectiveFromFieldOfView(out, fov, near, far);
      this.check();
      return this;
    }
  }, {
    key: 'fromQuaternion',


    // Calculates a 4x4 matrix from the given quaternion
    // q quat  Quaternion to create matrix from
    value: function fromQuaternion(q) {
      _glMatrix.mat4.fromQuat(this, q);
      this.check();
      return this;
    }
  }, {
    key: 'fromRotation',


    // Creates a matrix from a given angle around a given axis
    // his is equivalent to (but much faster than): mat4.identity(dest);
    // mat4.rotate(dest, dest, rad, axis);
    // rad Number  the angle to rotate the matrix by
    // axis  vec3  the axis to rotate around
    value: function fromRotation(rad, axis) {
      _glMatrix.mat4.fromRotation(this, rad, axis);
      this.check();
      return this;
    }

    // Creates a matrix from a quaternion rotation and vector translation
    // This is equivalent to (but much faster than): mat4.identity(dest);
    // mat4.translate(dest, vec);
    // var quatMat = mat4.create();
    // quat4.toMat4(quat, quatMat);
    // mat4.multiply(dest, quatMat);
    // q quat4 Rotation quaternion
    // v vec3  Translation vector

  }, {
    key: 'fromRotationTranslation',
    value: function fromRotationTranslation(q, v) {
      _glMatrix.mat4.fromRotationTranslation(this, q, v);
      this.check();
      return this;
    }

    // Creates a matrix from a quaternion rotation,
    // vector translation and vector scale
    // This is equivalent to (but much faster than):
    // mat4.identity(dest);
    // mat4.translate(dest, vec);
    // var quatMat = mat4.create();
    // quat4.toMat4(quat, quatMat);
    // mat4.multiply(dest, quatMat);
    // mat4.scale(dest, scale)
    // q quat4 Rotation quaternion
    // v vec3  Translation vector
    // s vec3  Scaling vector

  }, {
    key: 'fromRotationTranslationScale',
    value: function fromRotationTranslationScale(q, v, s) {
      _glMatrix.mat4.fromRotationTranslationScale(this, q, v, s);
      this.check();
      return this;
    }

    // Creates a matrix from a quaternion rotation, vector translation and
    // vector scale, rotating and scaling around the given origin
    // This is equivalent to (but much faster than):
    // mat4.identity(dest);
    // mat4.translate(dest, vec);
    // mat4.translate(dest, origin);
    // var quatMat = mat4.create();
    // quat4.toMat4(quat, quatMat);
    // mat4.multiply(dest, quatMat);
    // mat4.scale(dest, scale)
    // mat4.translate(dest, negativeOrigin);
    // q quat4 Rotation quaternion
    // v vec3  Translation vector
    // s vec3  Scaling vector
    // o vec3  The origin vector around which to scale and rotate

  }, {
    key: 'fromRotationTranslationScaleOrigin',
    value: function fromRotationTranslationScaleOrigin(q, v, s, o) {
      _glMatrix.mat4.fromRotationTranslationScaleOrigin(this, q, v, s, o);
      this.check();
      return this;
    }

    // Creates a matrix from a vector scaling This is equivalent to
    // (but much faster than):
    // mat4.identity(dest); mat4.scale(dest, dest, vec);
    // v vec3  Scaling vector

  }, {
    key: 'fromScaling',
    value: function fromScaling(v) {
      _glMatrix.mat4.fromScaling(this, v);
      this.check();
      return this;
    }

    // Creates a matrix from a vector translation
    // This is equivalent to (but much faster than):
    // mat4.identity(dest); mat4.translate(dest, dest, vec);
    // v vec3  Translation vector

  }, {
    key: 'fromTranslation',
    value: function fromTranslation(v) {
      _glMatrix.mat4.fromTranslation(this, v);
      this.check();
      return this;
    }

    // Create a new mat4 with the given values
    // m00 Number  Component in column 0, row 0 position (index 0)
    // m01 Number  Component in column 0, row 1 position (index 1)
    // m02 Number  Component in column 0, row 2 position (index 2)
    // m03 Number  Component in column 0, row 3 position (index 3)
    // m10 Number  Component in column 1, row 0 position (index 4)
    // m11 Number  Component in column 1, row 1 position (index 5)
    // m12 Number  Component in column 1, row 2 position (index 6)
    // m13 Number  Component in column 1, row 3 position (index 7)
    // m20 Number  Component in column 2, row 0 position (index 8)
    // m21 Number  Component in column 2, row 1 position (index 9)
    // m22 Number  Component in column 2, row 2 position (index 10)
    // m23 Number  Component in column 2, row 3 position (index 11)
    // m30 Number  Component in column 3, row 0 position (index 12)
    // m31 Number  Component in column 3, row 1 position (index 13)
    // m32 Number  Component in column 3, row 2 position (index 14)
    // m33 Number  Component in column 3, row 3 position (index 15)
    // fromValues(m00, m01, m02, m03, m10, m11, m12, m13,
    //   m20, m21, m22, m23, m30, m31, m32, m33) {mat4}

    // Creates a matrix from the given angle around the X axis
    // This is equivalent to (but much faster than):
    // mat4.identity(dest);
    // mat4.rotateX(dest, dest, rad);
    // rad Number  the angle to rotate the matrix by

  }, {
    key: 'fromXRotation',
    value: function fromXRotation(rad) {
      _glMatrix.mat4.fromXRotation(this, rad);
      this.check();
      return this;
    }

    // Creates a matrix from the given angle around the Y axis
    // This is equivalent to (but much faster than):
    // mat4.identity(dest);
    // mat4.rotateY(dest, dest, rad);
    // rad Number  the angle to rotate the matrix by

  }, {
    key: 'fromYRotation',
    value: function fromYRotation(rad) {
      _glMatrix.mat4.fromYRotation(this, rad);
      this.check();
      return this;
    }

    // Creates a matrix from the given angle around the Z axis
    // This is equivalent to (but much faster than):
    // mat4.identity(dest);
    // mat4.rotateZ(dest, dest, rad);
    // rad Number  the angle to rotate the matrix by

  }, {
    key: 'fromZRotation',
    value: function fromZRotation(rad) {
      _glMatrix.mat4.fromZRotation(this, rad);
      this.check();
      return this;
    }

    // Modifiers

  }, {
    key: 'transpose',
    value: function transpose() {
      _glMatrix.mat4.transpose(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'invert',
    value: function invert() {
      _glMatrix.mat4.invert(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'adjoint',
    value: function adjoint() {
      _glMatrix.mat4.adjoint(this, this);
      this.check();
      return this;
    }

    // Operations

  }, {
    key: 'add',
    value: function add(a, b) {
      _glMatrix.mat4.add(this, this, a);
      this.check();
      return this;
    }
  }, {
    key: 'multiplyLeft',
    value: function multiplyLeft(a) {
      _glMatrix.mat4.multiply(this, a, this);
      this.check();
      return this;
    }
  }, {
    key: 'multiplyRight',
    value: function multiplyRight(a) {
      _glMatrix.mat4.multiply(this, this, a);
      this.check();
      return this;
    }

    // Rotates a matrix by the given angle around the X axis
    // uses SIMD if available and enabled

  }, {
    key: 'rotateX',
    value: function rotateX(radians) {
      _glMatrix.mat4.rotateX(this, this, radians);
      this.check();
      return this;
    }

    // Rotates a matrix by the given angle around the Y axis.
    // Uses SIMD if available and enabled

  }, {
    key: 'rotateY',
    value: function rotateY(radians) {
      _glMatrix.mat4.rotateY(this, this, radians);
      this.check();
      return this;
    }

    // Rotates a matrix by the given angle around the Z axis.
    // Uses SIMD if available and enabled

  }, {
    key: 'rotateZ',
    value: function rotateZ(radians) {
      _glMatrix.mat4.rotateZ(this, this, radians);
      this.check();
      return this;
    }

    // TODO - may not be needed
    /* eslint-disable max-statements */

  }, {
    key: 'rotateXYZ',
    value: function rotateXYZ(_ref5) {
      var _ref6 = _slicedToArray(_ref5, 3),
          rx = _ref6[0],
          ry = _ref6[1],
          rz = _ref6[2];

      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
    }
    /* eslint-enable max-statements */

  }, {
    key: 'rotateAxis',
    value: function rotateAxis(theta, axis) {
      _glMatrix.mat4.rotate(this, this, theta, axis);
      this.check();
      return this;
    }
  }, {
    key: 'scale',
    value: function scale(vec) {
      _glMatrix.mat4.scale(this, this, vec);
      this.check();
      return this;
    }
  }, {
    key: 'translate',
    value: function translate(vec) {
      _glMatrix.mat4.translate(this, this, vec);
      this.check();
      return this;
    }
  }, {
    key: 'transformVector2',
    value: function transformVector2(vector, out) {
      out = out || new _vector2.default();
      _glMatrix.vec2.transformMat4(out, vector, this);
      (0, _validators.checkVector2)(out);
      return out;
    }
  }, {
    key: 'transformVector3',
    value: function transformVector3(vector) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _vector4.default();

      out = out || new _vector4.default();
      _glMatrix.vec3.transformMat4(out, vector, this);
      (0, _validators.checkVector3)(out);
      return out;
    }
  }, {
    key: 'transformVector4',
    value: function transformVector4(vector) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _vector6.default();

      out = out || new _vector6.default();
      _glMatrix.vec4.transformMat4(out, vector, this);
      (0, _validators.checkVector4)(out);
      return out;
    }

    // Transforms any 2, 3 or 4 element vector
    // returns a newly minted Vector2, Vector3 or Vector4

  }, {
    key: 'transformVector',
    value: function transformVector(vector, out) {
      switch (vector.length) {
        case 2:
          return this.transformVector2(vector, out);
        case 3:
          return this.transformVector3(vector, out);
        case 4:
          return this.transformVector4(vector, out);
        default:
          throw new Error('Illegal vector');
      }
    }
  }, {
    key: 'ELEMENTS',
    get: function get() {
      return 16;
    }
  }, {
    key: 'm00',


    // toString() {
    //   if (glMatrix.printRowMajor) {
    //     mat4.str(this);
    //   } else {
    //     mat4.str(this);
    //   }
    // }

    // Row major setters and getters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm01',
    get: function get() {
      return this[4];
    },
    set: function set(value) {
      return this[4] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm02',
    get: function get() {
      return this[8];
    },
    set: function set(value) {
      return this[8] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm03',
    get: function get() {
      return this[12];
    },
    set: function set(value) {
      return this[12] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm10',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm11',
    get: function get() {
      return this[5];
    },
    set: function set(value) {
      return this[5] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm12',
    get: function get() {
      return this[9];
    },
    set: function set(value) {
      return this[9] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm13',
    get: function get() {
      return this[13];
    },
    set: function set(value) {
      return this[13] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm20',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm21',
    get: function get() {
      return this[6];
    },
    set: function set(value) {
      return this[6] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm22',
    get: function get() {
      return this[10];
    },
    set: function set(value) {
      return this[10] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm23',
    get: function get() {
      return this[14];
    },
    set: function set(value) {
      return this[14] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm30',
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm31',
    get: function get() {
      return this[7];
    },
    set: function set(value) {
      return this[7] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm32',
    get: function get() {
      return this[11];
    },
    set: function set(value) {
      return this[11] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'm33',
    get: function get() {
      return this[15];
    },
    set: function set(value) {
      return this[15] = (0, _common.checkNumber)(value);
    }
  }], [{
    key: 'equals',
    value: function equals(a, b) {
      return _glMatrix.mat4.equals(a, b);
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(a, b) {
      return _glMatrix.mat4.exactEquals(a, b);
    }
  }, {
    key: 'determinant',
    value: function determinant(m) {
      return _glMatrix.mat4.determinant(m);
    }
  }, {
    key: 'frustum',
    value: function frustum(opts) {
      return new Matrix4().frustum(opts);
    }
  }, {
    key: 'lookAt',
    value: function lookAt(opts) {
      return new Matrix4().lookAt(opts);
    }
  }, {
    key: 'ortho',
    value: function ortho(opts) {
      return new Matrix4().ortho(opts);
    }
  }, {
    key: 'perspective',
    value: function perspective(opts) {
      return new Matrix4().perspective(opts);
    }
  }, {
    key: 'perspectiveFromFieldOfView',
    value: function perspectiveFromFieldOfView(opts) {
      return new Matrix4().perspectiveFromFieldOfView(opts);
    }
  }, {
    key: 'fromQuaternion',
    value: function fromQuaternion(q) {
      return new Matrix4().fromQuaternion(q);
    }
  }]);

  return Matrix4;
}(_mathArray2.default);

exports.default = Matrix4;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy9tYXRyaXg0LmpzIl0sIm5hbWVzIjpbIk1hdHJpeDQiLCJhcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY29weSIsImlkZW50aXR5IiwibTAwIiwibTEwIiwibTIwIiwibTMwIiwibTAxIiwibTExIiwibTIxIiwibTMxIiwibTAyIiwibTEyIiwibTIyIiwibTMyIiwibTAzIiwibTEzIiwibTIzIiwibTMzIiwic2V0IiwiY2hlY2siLCJhIiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJkZXRlcm1pbmFudCIsIkVycm9yIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwibmVhciIsImZhciIsImZydXN0dW0iLCJleWUiLCJjZW50ZXIiLCJ1cCIsImxvb2tBdCIsIm9ydGhvIiwiZm92IiwiTWF0aCIsIlBJIiwiYXNwZWN0IiwicGVyc3BlY3RpdmUiLCJvdXQiLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsInEiLCJmcm9tUXVhdCIsInJhZCIsImF4aXMiLCJmcm9tUm90YXRpb24iLCJ2IiwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLCJzIiwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSIsIm8iLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luIiwiZnJvbVNjYWxpbmciLCJmcm9tVHJhbnNsYXRpb24iLCJmcm9tWFJvdGF0aW9uIiwiZnJvbVlSb3RhdGlvbiIsImZyb21aUm90YXRpb24iLCJ0cmFuc3Bvc2UiLCJpbnZlcnQiLCJhZGpvaW50IiwiYiIsImFkZCIsIm11bHRpcGx5IiwicmFkaWFucyIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsInJ4IiwicnkiLCJyeiIsInRoZXRhIiwicm90YXRlIiwidmVjIiwic2NhbGUiLCJ0cmFuc2xhdGUiLCJ2ZWN0b3IiLCJ0cmFuc2Zvcm1NYXQ0IiwidHJhbnNmb3JtVmVjdG9yMiIsInRyYW5zZm9ybVZlY3RvcjMiLCJ0cmFuc2Zvcm1WZWN0b3I0IiwidmFsdWUiLCJtIiwib3B0cyIsImZyb21RdWF0ZXJuaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztJQUVxQkEsTzs7O0FBQ25CLHFCQUFxQjtBQUFBLHNDQUFOQyxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQTs7QUFBQTs7QUFFbkIsUUFBSUMsTUFBTUMsT0FBTixDQUFjRixLQUFLLENBQUwsQ0FBZCxLQUEwQkcsVUFBVUMsTUFBVixLQUFxQixDQUFuRCxFQUFzRDtBQUNwRCxZQUFLQyxJQUFMLENBQVVMLEtBQUssQ0FBTCxDQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBS00sUUFBTDtBQUNEO0FBTmtCO0FBT3BCOzs7Ozs7QUFNRDtrQ0FNRTtBQUFBLFVBSkFDLEdBSUEsdUVBSk0sQ0FJTjtBQUFBLFVBSlNDLEdBSVQsdUVBSmUsQ0FJZjtBQUFBLFVBSmtCQyxHQUlsQix1RUFKd0IsQ0FJeEI7QUFBQSxVQUoyQkMsR0FJM0IsdUVBSmlDLENBSWpDO0FBQUEsVUFIQUMsR0FHQSx1RUFITSxDQUdOO0FBQUEsVUFIU0MsR0FHVCx1RUFIZSxDQUdmO0FBQUEsVUFIa0JDLEdBR2xCLHVFQUh3QixDQUd4QjtBQUFBLFVBSDJCQyxHQUczQix1RUFIaUMsQ0FHakM7QUFBQSxVQUZBQyxHQUVBLHVFQUZNLENBRU47QUFBQSxVQUZTQyxHQUVULHVFQUZlLENBRWY7QUFBQSxVQUZrQkMsR0FFbEIsMEVBRndCLENBRXhCO0FBQUEsVUFGMkJDLEdBRTNCLDBFQUZpQyxDQUVqQztBQUFBLFVBREFDLEdBQ0EsMEVBRE0sQ0FDTjtBQUFBLFVBRFNDLEdBQ1QsMEVBRGUsQ0FDZjtBQUFBLFVBRGtCQyxHQUNsQiwwRUFEd0IsQ0FDeEI7QUFBQSxVQUQyQkMsR0FDM0IsMEVBRGlDLENBQ2pDOztBQUNBLHFCQUFLQyxHQUFMLENBQ0UsSUFE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LEdBQWN5QyxNQUFkLENBQXFCa0QsSUFBckIsQ0FBUDtBQUNEOzs7MEJBZVlBLEksRUFBTTtBQUNqQixhQUFPLElBQUkzRixPQUFKLEdBQWMwQyxLQUFkLENBQW9CaUQsSUFBcEIsQ0FBUDtBQUNEOzs7Z0NBcUJrQkEsSSxFQUFNO0FBQ3ZCLGFBQU8sSUFBSTNGLE9BQUosR0FBYytDLFdBQWQsQ0FBMEI0QyxJQUExQixDQUFQO0FBQ0Q7OzsrQ0FlaUNBLEksRUFBTTtBQUN0QyxhQUFPLElBQUkzRixPQUFKLEdBQWNpRCwwQkFBZCxDQUF5QzBDLElBQXpDLENBQVA7QUFDRDs7O21DQVVxQnpDLEMsRUFBRztBQUN2QixhQUFPLElBQUlsRCxPQUFKLEdBQWM0RixjQUFkLENBQTZCMUMsQ0FBN0IsQ0FBUDtBQUNEOzs7Ozs7a0JBM09rQmxELE8iLCJmaWxlIjoibWF0cml4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYXRoQXJyYXkgZnJvbSAnLi9tYXRoLWFycmF5JztcbmltcG9ydCB7Y2hlY2tOdW1iZXJ9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4vdmVjdG9yMic7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xuaW1wb3J0IFZlY3RvcjQgZnJvbSAnLi92ZWN0b3I0JztcbmltcG9ydCB7bWF0NCwgdmVjMiwgdmVjMywgdmVjNH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7Y2hlY2tWZWN0b3IyLCBjaGVja1ZlY3RvcjMsIGNoZWNrVmVjdG9yNH0gZnJvbSAnLi91dGlscy92YWxpZGF0b3JzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4NCBleHRlbmRzIE1hdGhBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weShhcmdzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZGVudGl0eSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBFTEVNRU5UUygpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtcGFyYW1zICovXG4gIHNldFJvd01ham9yKFxuICAgIG0wMCA9IDEsIG0xMCA9IDAsIG0yMCA9IDAsIG0zMCA9IDAsXG4gICAgbTAxID0gMCwgbTExID0gMSwgbTIxID0gMCwgbTMxID0gMCxcbiAgICBtMDIgPSAwLCBtMTIgPSAwLCBtMjIgPSAxLCBtMzIgPSAwLFxuICAgIG0wMyA9IDAsIG0xMyA9IDAsIG0yMyA9IDAsIG0zMyA9IDFcbiAgKSB7XG4gICAgbWF0NC5zZXQoXG4gICAgICB0aGlzLFxuICAgICAgbTAwLCBtMDEsIG0wMiwgbTAzLFxuICAgICAgbTEwLCBtMTEsIG0xMiwgbTEzLFxuICAgICAgbTIwLCBtMjEsIG0yMiwgbTIzLFxuICAgICAgbTMwLCBtMzEsIG0zMiwgbTMzXG4gICAgKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRDb2x1bW5NYWpvcihcbiAgICBtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMDMgPSAwLFxuICAgIG0xMCA9IDAsIG0xMSA9IDEsIG0xMiA9IDAsIG0xMyA9IDAsXG4gICAgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSwgbTIzID0gMCxcbiAgICBtMzAgPSAwLCBtMzEgPSAwLCBtMzIgPSAwLCBtMzMgPSAxXG4gICkge1xuICAgIG1hdDQuc2V0KFxuICAgICAgdGhpcyxcbiAgICAgIG0wMCwgbTAxLCBtMDIsIG0wMyxcbiAgICAgIG0xMCwgbTExLCBtMTIsIG0xMyxcbiAgICAgIG0yMCwgbTIxLCBtMjIsIG0yMyxcbiAgICAgIG0zMCwgbTMxLCBtMzIsIG0zM1xuICAgICk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXBhcmFtcyAqL1xuXG4gIGVxdWFscyhhKSB7XG4gICAgcmV0dXJuIG1hdDQuZXF1YWxzKHRoaXMsIGEpO1xuICB9XG5cbiAgZXhhY3RFcXVhbHMoYSkge1xuICAgIHJldHVybiBtYXQ0LmV4YWN0RXF1YWxzKHRoaXMsIGEpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIG1hdDQuZXF1YWxzKGEsIGIpO1xuICB9XG5cbiAgc3RhdGljIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gbWF0NC5leGFjdEVxdWFscyhhLCBiKTtcbiAgfVxuXG4gIC8vIHRvU3RyaW5nKCkge1xuICAvLyAgIGlmIChnbE1hdHJpeC5wcmludFJvd01ham9yKSB7XG4gIC8vICAgICBtYXQ0LnN0cih0aGlzKTtcbiAgLy8gICB9IGVsc2Uge1xuICAvLyAgICAgbWF0NC5zdHIodGhpcyk7XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gUm93IG1ham9yIHNldHRlcnMgYW5kIGdldHRlcnNcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzLCBicmFjZS1zdHlsZSwgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICBnZXQgbTAwKCkgICAgICB7IHJldHVybiB0aGlzWzBdOyB9XG4gIHNldCBtMDAodmFsdWUpIHsgcmV0dXJuIHRoaXNbMF0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IG0wMSgpICAgICAgeyByZXR1cm4gdGhpc1s0XTsgfVxuICBzZXQgbTAxKHZhbHVlKSB7IHJldHVybiB0aGlzWzRdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBtMDIoKSAgICAgIHsgcmV0dXJuIHRoaXNbOF07IH1cbiAgc2V0IG0wMih2YWx1ZSkgeyByZXR1cm4gdGhpc1s4XSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgbTAzKCkgICAgICB7IHJldHVybiB0aGlzWzEyXTsgfVxuICBzZXQgbTAzKHZhbHVlKSB7IHJldHVybiB0aGlzWzEyXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgbTEwKCkgICAgICB7IHJldHVybiB0aGlzWzFdOyB9XG4gIHNldCBtMTAodmFsdWUpIHsgcmV0dXJuIHRoaXNbMV0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IG0xMSgpICAgICAgeyByZXR1cm4gdGhpc1s1XTsgfVxuICBzZXQgbTExKHZhbHVlKSB7IHJldHVybiB0aGlzWzVdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBtMTIoKSAgICAgIHsgcmV0dXJuIHRoaXNbOV07IH1cbiAgc2V0IG0xMih2YWx1ZSkgeyByZXR1cm4gdGhpc1s5XSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgbTEzKCkgICAgICB7IHJldHVybiB0aGlzWzEzXTsgfVxuICBzZXQgbTEzKHZhbHVlKSB7IHJldHVybiB0aGlzWzEzXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgbTIwKCkgICAgICB7IHJldHVybiB0aGlzWzJdOyB9XG4gIHNldCBtMjAodmFsdWUpIHsgcmV0dXJuIHRoaXNbMl0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IG0yMSgpICAgICAgeyByZXR1cm4gdGhpc1s2XTsgfVxuICBzZXQgbTIxKHZhbHVlKSB7IHJldHVybiB0aGlzWzZdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBtMjIoKSAgICAgIHsgcmV0dXJuIHRoaXNbMTBdOyB9XG4gIHNldCBtMjIodmFsdWUpIHsgcmV0dXJuIHRoaXNbMTBdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBtMjMoKSAgICAgIHsgcmV0dXJuIHRoaXNbMTRdOyB9XG4gIHNldCBtMjModmFsdWUpIHsgcmV0dXJuIHRoaXNbMTRdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBtMzAoKSAgICAgIHsgcmV0dXJuIHRoaXNbM107IH1cbiAgc2V0IG0zMCh2YWx1ZSkgeyByZXR1cm4gdGhpc1szXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgbTMxKCkgICAgICB7IHJldHVybiB0aGlzWzddOyB9XG4gIHNldCBtMzEodmFsdWUpIHsgcmV0dXJuIHRoaXNbN10gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IG0zMigpICAgICAgeyByZXR1cm4gdGhpc1sxMV07IH1cbiAgc2V0IG0zMih2YWx1ZSkgeyByZXR1cm4gdGhpc1sxMV0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IG0zMygpICAgICAgeyByZXR1cm4gdGhpc1sxNV07IH1cbiAgc2V0IG0zMyh2YWx1ZSkgeyByZXR1cm4gdGhpc1sxNV0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1tdWx0aS1zcGFjZXMsIGJyYWNlLXN0eWxlLCBuby1yZXR1cm4tYXNzaWduICovXG5cbiAgLy8gQWNjZXNzb3JzXG5cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgcmV0dXJuIG1hdDQuZGV0ZXJtaW5hbnQodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5hbnQobSkge1xuICAgIHJldHVybiBtYXQ0LmRldGVybWluYW50KG0pO1xuICB9XG5cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8vIENvbnN0cnVjdG9yc1xuXG4gIGlkZW50aXR5KCkge1xuICAgIG1hdDQuaWRlbnRpdHkodGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gIC8vIGxlZnQgIE51bWJlciAgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAvLyByaWdodCBOdW1iZXIgIFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIC8vIGJvdHRvbSAgTnVtYmVyICBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgLy8gdG9wIE51bWJlciAgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIC8vIG5lYXIgIE51bWJlciAgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAvLyBmYXIgTnVtYmVyICBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgZnJ1c3R1bSh7bGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXJ9KSB7XG4gICAgbWF0NC5mcnVzdHVtKHRoaXMsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZnJ1c3R1bShvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJ1c3R1bShvcHRzKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsXG4gIC8vIGFuZCB1cCBheGlzXG4gIC8vIGV5ZSB2ZWMzICBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gIC8vIGNlbnRlciAgdmVjMyAgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gIC8vIHVwICB2ZWMzICB2ZWMzIHBvaW50aW5nIHVwXG4gIGxvb2tBdCh7XG4gICAgZXllLFxuICAgIGNlbnRlciA9IFswLCAwLCAwXSxcbiAgICB1cCA9IFswLCAxLCAwXVxuICB9ID0ge30pIHtcbiAgICBtYXQ0Lmxvb2tBdCh0aGlzLCBleWUsIGNlbnRlciwgdXApO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBsb29rQXQob3B0cykge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCgpLmxvb2tBdChvcHRzKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gIC8vIGxlZnQgIG51bWJlciAgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAvLyByaWdodCBudW1iZXIgIFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIC8vIGJvdHRvbSAgbnVtYmVyICBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgLy8gdG9wIG51bWJlciAgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIC8vIG5lYXIgIG51bWJlciAgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAvLyBmYXIgbnVtYmVyICBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgb3J0aG8oe2xlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciA9IDAuMSwgZmFyID0gNTAwfSkge1xuICAgIG1hdDQub3J0aG8odGhpcywgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBvcnRobyhvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkub3J0aG8ob3B0cyk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAgLy8gZm92eSAgbnVtYmVyICBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAgLy8gYXNwZWN0ICBudW1iZXIgIEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICAvLyBuZWFyICBudW1iZXIgIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgLy8gZmFyIG51bWJlciAgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIHBlcnNwZWN0aXZlKHtcbiAgICBmb3YgPSA0NSAqIE1hdGguUEkgLyAxODAsXG4gICAgYXNwZWN0ID0gMSxcbiAgICBuZWFyID0gMC4xLFxuICAgIGZhciA9IDUwMFxuICB9ID0ge30pIHtcbiAgICBpZiAoZm92ID4gTWF0aC5QSSAqIDIpIHtcbiAgICAgIHRocm93IEVycm9yKCdyYWRpYW5zJyk7XG4gICAgfVxuICAgIG1hdDQucGVyc3BlY3RpdmUodGhpcywgZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIHBlcnNwZWN0aXZlKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoKS5wZXJzcGVjdGl2ZShvcHRzKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gIC8vIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAgLy8gd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gIC8vIGZvdiBPYmplY3QgIE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAvLyAgIHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAgLy8gbmVhciAgbnVtYmVyICBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gIC8vIGZhciBudW1iZXIgIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgbWF0NC5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3B0cykge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCgpLnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG9wdHMpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICAvLyBxIHF1YXQgIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gIGZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICBtYXQ0LmZyb21RdWF0KHRoaXMsIHEpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUXVhdGVybmlvbihxKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbVF1YXRlcm5pb24ocSk7XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gIC8vIGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6IG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gIC8vIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gIC8vIHJhZCBOdW1iZXIgIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICAvLyBheGlzICB2ZWMzICB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gIGZyb21Sb3RhdGlvbihyYWQsIGF4aXMpIHtcbiAgICBtYXQ0LmZyb21Sb3RhdGlvbih0aGlzLCByYWQsIGF4aXMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTogbWF0NC5pZGVudGl0eShkZXN0KTtcbiAgLy8gbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAgLy8gdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAvLyBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gIC8vIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gIC8vIHEgcXVhdDQgUm90YXRpb24gcXVhdGVybmlvblxuICAvLyB2IHZlYzMgIFRyYW5zbGF0aW9uIHZlY3RvclxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihxLCB2KSB7XG4gICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbih0aGlzLCBxLCB2KTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLFxuICAvLyB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAgLy8gbWF0NC5pZGVudGl0eShkZXN0KTtcbiAgLy8gbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAgLy8gdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAvLyBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gIC8vIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gIC8vIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gIC8vIHEgcXVhdDQgUm90YXRpb24gcXVhdGVybmlvblxuICAvLyB2IHZlYzMgIFRyYW5zbGF0aW9uIHZlY3RvclxuICAvLyBzIHZlYzMgIFNjYWxpbmcgdmVjdG9yXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUocSwgdiwgcykge1xuICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSh0aGlzLCBxLCB2LCBzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kXG4gIC8vIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAgLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gIC8vIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gIC8vIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gIC8vIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gIC8vIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgLy8gcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICAvLyBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICAvLyBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICAvLyBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gIC8vIHEgcXVhdDQgUm90YXRpb24gcXVhdGVybmlvblxuICAvLyB2IHZlYzMgIFRyYW5zbGF0aW9uIHZlY3RvclxuICAvLyBzIHZlYzMgIFNjYWxpbmcgdmVjdG9yXG4gIC8vIG8gdmVjMyAgVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihxLCB2LCBzLCBvKSB7XG4gICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKHRoaXMsIHEsIHYsIHMsIG8pO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nIFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAvLyAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICAvLyBtYXQ0LmlkZW50aXR5KGRlc3QpOyBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gIC8vIHYgdmVjMyAgU2NhbGluZyB2ZWN0b3JcbiAgZnJvbVNjYWxpbmcodikge1xuICAgIG1hdDQuZnJvbVNjYWxpbmcodGhpcywgdik7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICAvLyBtYXQ0LmlkZW50aXR5KGRlc3QpOyBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICAvLyB2IHZlYzMgIFRyYW5zbGF0aW9uIHZlY3RvclxuICBmcm9tVHJhbnNsYXRpb24odikge1xuICAgIG1hdDQuZnJvbVRyYW5zbGF0aW9uKHRoaXMsIHYpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICAvLyBtMDAgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICAvLyBtMDEgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICAvLyBtMDIgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICAvLyBtMDMgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICAvLyBtMTAgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICAvLyBtMTEgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICAvLyBtMTIgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICAvLyBtMTMgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICAvLyBtMjAgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICAvLyBtMjEgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICAvLyBtMjIgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAgLy8gbTIzIE51bWJlciAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gIC8vIG0zMCBOdW1iZXIgIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICAvLyBtMzEgTnVtYmVyICBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAgLy8gbTMyIE51bWJlciAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gIC8vIG0zMyBOdW1iZXIgIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICAvLyBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLFxuICAvLyAgIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7bWF0NH1cblxuICAvLyBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICAvLyBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICAvLyBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAgLy8gcmFkIE51bWJlciAgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gIGZyb21YUm90YXRpb24ocmFkKSB7XG4gICAgbWF0NC5mcm9tWFJvdGF0aW9uKHRoaXMsIHJhZCk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAgLy8gbWF0NC5pZGVudGl0eShkZXN0KTtcbiAgLy8gbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gIC8vIHJhZCBOdW1iZXIgIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICBmcm9tWVJvdGF0aW9uKHJhZCkge1xuICAgIG1hdDQuZnJvbVlSb3RhdGlvbih0aGlzLCByYWQpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAgLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gIC8vIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gIC8vIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICAvLyByYWQgTnVtYmVyICB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAgZnJvbVpSb3RhdGlvbihyYWQpIHtcbiAgICBtYXQ0LmZyb21aUm90YXRpb24odGhpcywgcmFkKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBNb2RpZmllcnNcblxuICB0cmFuc3Bvc2UoKSB7XG4gICAgbWF0NC50cmFuc3Bvc2UodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW52ZXJ0KCkge1xuICAgIG1hdDQuaW52ZXJ0KHRoaXMsIHRoaXMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkam9pbnQoKSB7XG4gICAgbWF0NC5hZGpvaW50KHRoaXMsIHRoaXMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIE9wZXJhdGlvbnNcblxuICBhZGQoYSwgYikge1xuICAgIG1hdDQuYWRkKHRoaXMsIHRoaXMsIGEpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG11bHRpcGx5TGVmdChhKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLCBhLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWx0aXBseVJpZ2h0KGEpIHtcbiAgICBtYXQ0Lm11bHRpcGx5KHRoaXMsIHRoaXMsIGEpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gIC8vIHVzZXMgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAgcm90YXRlWChyYWRpYW5zKSB7XG4gICAgbWF0NC5yb3RhdGVYKHRoaXMsIHRoaXMsIHJhZGlhbnMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLlxuICAvLyBVc2VzIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gIHJvdGF0ZVkocmFkaWFucykge1xuICAgIG1hdDQucm90YXRlWSh0aGlzLCB0aGlzLCByYWRpYW5zKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcy5cbiAgLy8gVXNlcyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICByb3RhdGVaKHJhZGlhbnMpIHtcbiAgICBtYXQ0LnJvdGF0ZVoodGhpcywgdGhpcywgcmFkaWFucyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gVE9ETyAtIG1heSBub3QgYmUgbmVlZGVkXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIHJvdGF0ZVhZWihbcngsIHJ5LCByel0pIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVYKHJ4KS5yb3RhdGVZKHJ5KS5yb3RhdGVaKHJ6KTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgcm90YXRlQXhpcyh0aGV0YSwgYXhpcykge1xuICAgIG1hdDQucm90YXRlKHRoaXMsIHRoaXMsIHRoZXRhLCBheGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzY2FsZSh2ZWMpIHtcbiAgICBtYXQ0LnNjYWxlKHRoaXMsIHRoaXMsIHZlYyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNsYXRlKHZlYykge1xuICAgIG1hdDQudHJhbnNsYXRlKHRoaXMsIHRoaXMsIHZlYyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNmb3JtVmVjdG9yMih2ZWN0b3IsIG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgVmVjdG9yMigpO1xuICAgIHZlYzIudHJhbnNmb3JtTWF0NChvdXQsIHZlY3RvciwgdGhpcyk7XG4gICAgY2hlY2tWZWN0b3IyKG91dCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3RvcjModmVjdG9yLCBvdXQgPSBuZXcgVmVjdG9yMygpKSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KG91dCwgdmVjdG9yLCB0aGlzKTtcbiAgICBjaGVja1ZlY3RvcjMob3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdHJhbnNmb3JtVmVjdG9yNCh2ZWN0b3IsIG91dCA9IG5ldyBWZWN0b3I0KCkpIHtcbiAgICBvdXQgPSBvdXQgfHwgbmV3IFZlY3RvcjQoKTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQob3V0LCB2ZWN0b3IsIHRoaXMpO1xuICAgIGNoZWNrVmVjdG9yNChvdXQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvLyBUcmFuc2Zvcm1zIGFueSAyLCAzIG9yIDQgZWxlbWVudCB2ZWN0b3JcbiAgLy8gcmV0dXJucyBhIG5ld2x5IG1pbnRlZCBWZWN0b3IyLCBWZWN0b3IzIG9yIFZlY3RvcjRcbiAgdHJhbnNmb3JtVmVjdG9yKHZlY3Rvciwgb3V0KSB7XG4gICAgc3dpdGNoICh2ZWN0b3IubGVuZ3RoKSB7XG4gICAgY2FzZSAyOiByZXR1cm4gdGhpcy50cmFuc2Zvcm1WZWN0b3IyKHZlY3Rvciwgb3V0KTtcbiAgICBjYXNlIDM6IHJldHVybiB0aGlzLnRyYW5zZm9ybVZlY3RvcjModmVjdG9yLCBvdXQpO1xuICAgIGNhc2UgNDogcmV0dXJuIHRoaXMudHJhbnNmb3JtVmVjdG9yNCh2ZWN0b3IsIG91dCk7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHZlY3RvcicpO1xuICAgIH1cbiAgfVxufVxuIl19

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _glMatrix = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Quaternion = function (_MathArray) {
  _inherits(Quaternion, _MathArray);

  // Creates a new identity quat
  function Quaternion() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Quaternion);

    var _this = _possibleConstructorReturn(this, (Quaternion.__proto__ || Object.getPrototypeOf(Quaternion)).call(this));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }
    return _this;
  }

  // Creates a quaternion from the given 3x3 rotation matrix.
  // NOTE: The resultant quaternion is not normalized, so you should
  // be sure to renormalize the quaternion yourself where necessary.


  _createClass(Quaternion, [{
    key: 'fromMatrix3',
    value: function fromMatrix3(m) {
      _glMatrix.quat.fromMat3(this, m);
      this.check();
      return this;
    }

    // Creates a new quat initialized with the given values

  }, {
    key: 'fromValues',
    value: function fromValues(x, y, z, w) {
      return this.set(x, y, z, w);
    }

    // Set a quat to the identity quaternion

  }, {
    key: 'identity',
    value: function identity() {
      _glMatrix.quat.identity(this);
      this.check();
      return this;
    }
  }, {
    key: 'equals',
    value: function equals(quaternion) {
      return _glMatrix.quat.equals(this, quaternion);
    }

    // Returns whether or not the quaternions have exactly the same elements
    // in the same position (when compared with ===)

  }, {
    key: 'exactEquals',
    value: function exactEquals(quaternion) {
      return _glMatrix.quat.exactEquals(this, quaternion);
    }

    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

  }, {
    key: 'length',

    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

    // Calculates the length of a quat
    value: function length() {
      return _glMatrix.quat.length(this);
    }

    // Calculates the squared length of a quat

  }, {
    key: 'squaredLength',
    value: function squaredLength(a) {
      return _glMatrix.quat.squaredLength(this);
    }

    // Calculates the dot product of two quat's
    // @return {Number}

  }, {
    key: 'dot',
    value: function dot(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.dot only takes one argument');
      }
      return _glMatrix.quat.dot(this, a);
    }

    // Gets the rotation axis and angle for a given quaternion.
    // If a quaternion is created with setAxisAngle, this method will
    // return the same values as providied in the original parameter
    // list OR functionally equivalent values.
    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
    // is the same as the quaternion formed by [0, 0, 1] and 270.
    // This method favors the latter.
    // @return {{[x,y,z], Number}}

  }, {
    key: 'getAxisAngle',
    value: function getAxisAngle() {
      var axis = [];
      var angle = _glMatrix.quat.getAxisAngle(axis, this);
      return { axis: axis, angle: angle };
    }

    // MODIFIERS

    // Sets a quaternion to represent the shortest rotation from one vector
    // to another. Both vectors are assumed to be unit length.

  }, {
    key: 'rotationTo',
    value: function rotationTo(vectorA, vectorB) {
      _glMatrix.quat.rotationTo(this, vectorA, vectorB);
      this.check();
      return this;
    }

    // Sets the specified quaternion with values corresponding to the given axes.
    // Each axis is a vec3 and is expected to be unit length and perpendicular
    // to all other specified axes.
    // setAxes() {
    //   Number
    // }

    // Performs a spherical linear interpolation with two control points
    // sqlerp() {
    //   Number;
    // }

    // Adds two quat's

  }, {
    key: 'add',
    value: function add(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.add only takes one argument');
      }
      _glMatrix.quat.add(this, a);
      this.check();
      return this;
    }

    // Calculates the W component of a quat from the X, Y, and Z components.
    // Any existing W component will be ignored.

  }, {
    key: 'calculateW',
    value: function calculateW() {
      _glMatrix.quat.calculateW(this, this);
      this.check();
      return this;
    }

    // Calculates the conjugate of a quat If the quaternion is normalized,
    // this function is faster than quat.inverse and produces the same result.

  }, {
    key: 'conjugate',
    value: function conjugate() {
      _glMatrix.quat.conjugate(this, this);
      this.check();
      return this;
    }

    // Calculates the inverse of a quat

  }, {
    key: 'invert',
    value: function invert() {
      _glMatrix.quat.invert(this, this);
      this.check();
      return this;
    }

    // Performs a linear interpolation between two quat's

  }, {
    key: 'lerp',
    value: function lerp(a, b, t) {
      _glMatrix.quat.lerp(this, a, b, t);
      this.check();
      return this;
    }

    // Multiplies two quat's

  }, {
    key: 'multiply',
    value: function multiply(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.multiply only takes one argument');
      }
      _glMatrix.quat.multiply(this, this, b);
      this.check();
      return this;
    }

    // Normalize a quat

  }, {
    key: 'normalize',
    value: function normalize() {
      _glMatrix.quat.normalize(this, this);
      this.check();
      return this;
    }

    // Rotates a quaternion by the given angle about the X axis

  }, {
    key: 'rotateX',
    value: function rotateX(rad) {
      _glMatrix.quat.rotateX(this, this, rad);
      this.check();
      return this;
    }

    // Rotates a quaternion by the given angle about the Y axis

  }, {
    key: 'rotateY',
    value: function rotateY(rad) {
      _glMatrix.quat.rotateY(this, this, rad);
      this.check();
      return this;
    }

    // Rotates a quaternion by the given angle about the Z axis

  }, {
    key: 'rotateZ',
    value: function rotateZ(rad) {
      _glMatrix.quat.rotateZ(this, this, rad);
      this.check();
      return this;
    }

    // Scales a quat by a scalar number

  }, {
    key: 'scale',
    value: function scale(b) {
      _glMatrix.quat.scale(this, this, b);
      this.check();
      return this;
    }

    // Set the components of a quat to the given values

  }, {
    key: 'set',
    value: function set(i, j, k, l) {
      _glMatrix.quat.set(this, i, j, k, l);
      this.check();
      return this;
    }

    // Sets a quat from the given angle and rotation axis, then returns it.

  }, {
    key: 'setAxisAngle',
    value: function setAxisAngle(axis, rad) {
      _glMatrix.quat.setAxisAngle(this, axis, rad);
      this.check();
      return this;
    }

    // Performs a spherical linear interpolation between two quat

  }, {
    key: 'slerp',
    value: function slerp(a, b, t) {
      _glMatrix.quat.slerp(this, a, b, t);
      this.check();
      return this;
    }
  }, {
    key: 'ELEMENTS',
    get: function get() {
      return 4;
    }
  }, {
    key: 'x',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'y',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'z',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'w',
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);

  return Quaternion;
}(_mathArray2.default);

exports.default = Quaternion;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy9xdWF0ZXJuaW9uLmpzIl0sIm5hbWVzIjpbIlF1YXRlcm5pb24iLCJ4IiwieSIsInoiLCJ3IiwiQXJyYXkiLCJpc0FycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY29weSIsInNldCIsIm0iLCJmcm9tTWF0MyIsImNoZWNrIiwiaWRlbnRpdHkiLCJxdWF0ZXJuaW9uIiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhIiwic3F1YXJlZExlbmd0aCIsImIiLCJ1bmRlZmluZWQiLCJFcnJvciIsImRvdCIsImF4aXMiLCJhbmdsZSIsImdldEF4aXNBbmdsZSIsInZlY3RvckEiLCJ2ZWN0b3JCIiwicm90YXRpb25UbyIsImFkZCIsImNhbGN1bGF0ZVciLCJjb25qdWdhdGUiLCJpbnZlcnQiLCJ0IiwibGVycCIsIm11bHRpcGx5Iiwibm9ybWFsaXplIiwicmFkIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2NhbGUiLCJpIiwiaiIsImsiLCJsIiwic2V0QXhpc0FuZ2xlIiwic2xlcnAiLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7O0lBRXFCQSxVOzs7QUFDbkI7QUFDQSx3QkFBd0M7QUFBQSxRQUE1QkMsQ0FBNEIsdUVBQXhCLENBQXdCO0FBQUEsUUFBckJDLENBQXFCLHVFQUFqQixDQUFpQjtBQUFBLFFBQWRDLENBQWMsdUVBQVYsQ0FBVTtBQUFBLFFBQVBDLENBQU8sdUVBQUgsQ0FBRzs7QUFBQTs7QUFBQTs7QUFFdEMsUUFBSUMsTUFBTUMsT0FBTixDQUFjTCxDQUFkLEtBQW9CTSxVQUFVQyxNQUFWLEtBQXFCLENBQTdDLEVBQWdEO0FBQzlDLFlBQUtDLElBQUwsQ0FBVVIsQ0FBVjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQUtTLEdBQUwsQ0FBU1QsQ0FBVCxFQUFZQyxDQUFaLEVBQWVDLENBQWYsRUFBa0JDLENBQWxCO0FBQ0Q7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QixFQUF3QnZCLElBQXhCLEVBQThCYyxHQUE5QjtBQUNBLFdBQUt6QixLQUFMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7MEJBQ01LLEMsRUFBR0UsQyxFQUFHYyxDLEVBQUc7QUFDYixxQkFBS2MsS0FBTCxDQUFXLElBQVgsRUFBaUI5QixDQUFqQixFQUFvQkUsQ0FBcEIsRUFBdUJjLENBQXZCO0FBQ0EsV0FBS3JCLEtBQUw7QUFDQSxhQUFPLElBQVA7QUFDRDs7O3dCQTFLYztBQUFFLGFBQU8sQ0FBUDtBQUFXOzs7d0JBQ2Y7QUFBRSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQWlCLEs7c0JBQzFCb0MsSyxFQUFPO0FBQUUsYUFBTyxLQUFLLENBQUwsSUFBVSx5QkFBWUEsS0FBWixDQUFqQjtBQUFzQzs7O3dCQUN4QztBQUFFLGFBQU8sS0FBSyxDQUFMLENBQVA7QUFBaUIsSztzQkFDMUJBLEssRUFBTztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7Ozt3QkFDeEM7QUFBRSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQWlCLEs7c0JBQzFCQSxLLEVBQU87QUFBRSxhQUFPLEtBQUssQ0FBTCxJQUFVLHlCQUFZQSxLQUFaLENBQWpCO0FBQXNDOzs7d0JBQ3hDO0FBQUUsYUFBTyxLQUFLLENBQUwsQ0FBUDtBQUFpQixLO3NCQUMxQkEsSyxFQUFPO0FBQUUsYUFBTyxLQUFLLENBQUwsSUFBVSx5QkFBWUEsS0FBWixDQUFqQjtBQUFzQzs7Ozs7O2tCQXBEbENqRCxVIiwiZmlsZSI6InF1YXRlcm5pb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vbWF0aC1hcnJheSc7XG5pbXBvcnQge2NoZWNrTnVtYmVyfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge3F1YXR9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YXRlcm5pb24gZXh0ZW5kcyBNYXRoQXJyYXkge1xuICAvLyBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoeCwgeSwgeiwgdyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAgLy8gTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkXG4gIC8vIGJlIHN1cmUgdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICBmcm9tTWF0cml4MyhtKSB7XG4gICAgcXVhdC5mcm9tTWF0Myh0aGlzLCBtKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICAgIHJldHVybiB0aGlzLnNldCh4LCB5LCB6LCB3KTtcbiAgfVxuXG4gIC8vIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAgaWRlbnRpdHkoKSB7XG4gICAgcXVhdC5pZGVudGl0eSh0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlcXVhbHMocXVhdGVybmlvbikge1xuICAgIHJldHVybiBxdWF0LmVxdWFscyh0aGlzLCBxdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50c1xuICAvLyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAgZXhhY3RFcXVhbHMocXVhdGVybmlvbikge1xuICAgIHJldHVybiBxdWF0LmV4YWN0RXF1YWxzKHRoaXMsIHF1YXRlcm5pb24pO1xuICB9XG5cbiAgLy8gR2V0dGVycy9zZXR0ZXJzXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgYnJhY2Utc3R5bGUsIG5vLXJldHVybi1hc3NpZ24gKi9cbiAgZ2V0IEVMRU1FTlRTKCkgeyByZXR1cm4gNDsgfVxuICBnZXQgeCgpICAgICAgeyByZXR1cm4gdGhpc1swXTsgfVxuICBzZXQgeCh2YWx1ZSkgeyByZXR1cm4gdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeSgpICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgeSh2YWx1ZSkgeyByZXR1cm4gdGhpc1sxXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeigpICAgICAgeyByZXR1cm4gdGhpc1syXTsgfVxuICBzZXQgeih2YWx1ZSkgeyByZXR1cm4gdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgdygpICAgICAgeyByZXR1cm4gdGhpc1szXTsgfVxuICBzZXQgdyh2YWx1ZSkgeyByZXR1cm4gdGhpc1szXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLW11bHRpLXNwYWNlcywgYnJhY2Utc3R5bGUsIG5vLXJldHVybi1hc3NpZ24gKi9cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gcXVhdC5sZW5ndGgodGhpcyk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAgc3F1YXJlZExlbmd0aChhKSB7XG4gICAgcmV0dXJuIHF1YXQuc3F1YXJlZExlbmd0aCh0aGlzKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAgLy8gQHJldHVybiB7TnVtYmVyfVxuICBkb3QoYSwgYikge1xuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUXVhdGVybmlvbi5kb3Qgb25seSB0YWtlcyBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YXQuZG90KHRoaXMsIGEpO1xuICB9XG5cbiAgLy8gR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW4gcXVhdGVybmlvbi5cbiAgLy8gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aCBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGxcbiAgLy8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlclxuICAvLyBsaXN0IE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cbiAgLy8gRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZCBhbmdsZSAtOTBcbiAgLy8gaXMgdGhlIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IFswLCAwLCAxXSBhbmQgMjcwLlxuICAvLyBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cbiAgLy8gQHJldHVybiB7e1t4LHksel0sIE51bWJlcn19XG4gIGdldEF4aXNBbmdsZSgpIHtcbiAgICBjb25zdCBheGlzID0gW107XG4gICAgY29uc3QgYW5nbGUgPSBxdWF0LmdldEF4aXNBbmdsZShheGlzLCB0aGlzKTtcbiAgICByZXR1cm4ge2F4aXMsIGFuZ2xlfTtcbiAgfVxuXG4gIC8vIE1PRElGSUVSU1xuXG4gIC8vIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmUgdmVjdG9yXG4gIC8vIHRvIGFub3RoZXIuIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAgcm90YXRpb25Ubyh2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgcXVhdC5yb3RhdGlvblRvKHRoaXMsIHZlY3RvckEsIHZlY3RvckIpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGF4ZXMuXG4gIC8vIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZCBwZXJwZW5kaWN1bGFyXG4gIC8vIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAgLy8gc2V0QXhlcygpIHtcbiAgLy8gICBOdW1iZXJcbiAgLy8gfVxuXG4gIC8vIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gIC8vIHNxbGVycCgpIHtcbiAgLy8gICBOdW1iZXI7XG4gIC8vIH1cblxuICAvLyBBZGRzIHR3byBxdWF0J3NcbiAgYWRkKGEsIGIpIHtcbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1YXRlcm5pb24uYWRkIG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHF1YXQuYWRkKHRoaXMsIGEpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICAvLyBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICBjYWxjdWxhdGVXKCkge1xuICAgIHF1YXQuY2FsY3VsYXRlVyh0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0IElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsXG4gIC8vIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gIGNvbmp1Z2F0ZSgpIHtcbiAgICBxdWF0LmNvbmp1Z2F0ZSh0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICBpbnZlcnQoKSB7XG4gICAgcXVhdC5pbnZlcnQodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAgbGVycChhLCBiLCB0KSB7XG4gICAgcXVhdC5sZXJwKHRoaXMsIGEsIGIsIHQpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICBtdWx0aXBseShhLCBiKSB7XG4gICAgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWF0ZXJuaW9uLm11bHRpcGx5IG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHF1YXQubXVsdGlwbHkodGhpcywgdGhpcywgYik7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGEgcXVhdFxuICBub3JtYWxpemUoKSB7XG4gICAgcXVhdC5ub3JtYWxpemUodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAgcm90YXRlWChyYWQpIHtcbiAgICBxdWF0LnJvdGF0ZVgodGhpcywgdGhpcywgcmFkKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICByb3RhdGVZKHJhZCkge1xuICAgIHF1YXQucm90YXRlWSh0aGlzLCB0aGlzLCByYWQpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gIHJvdGF0ZVoocmFkKSB7XG4gICAgcXVhdC5yb3RhdGVaKHRoaXMsIHRoaXMsIHJhZCk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAgc2NhbGUoYikge1xuICAgIHF1YXQuc2NhbGUodGhpcywgdGhpcywgYik7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gIHNldChpLCBqLCBrLCBsKSB7XG4gICAgcXVhdC5zZXQodGhpcywgaSwgaiwgaywgbCk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsIHRoZW4gcmV0dXJucyBpdC5cbiAgc2V0QXhpc0FuZ2xlKGF4aXMsIHJhZCkge1xuICAgIHF1YXQuc2V0QXhpc0FuZ2xlKHRoaXMsIGF4aXMsIHJhZCk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICBzbGVycChhLCBiLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0aGlzLCBhLCBiLCB0KTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _glMatrix = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector2 = function (_MathArray) {
  _inherits(Vector2, _MathArray);

  // Creates a new, empty vec2
  function Vector2() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Vector2);

    var _this = _possibleConstructorReturn(this, (Vector2.__proto__ || Object.getPrototypeOf(Vector2)).call(this));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y);
    }
    return _this;
  }

  _createClass(Vector2, [{
    key: 'set',
    value: function set(x, y) {
      _glMatrix.vec2.set(this, x, y);
      this.check();
      return this;
    }
  }, {
    key: 'equals',
    value: function equals(vector) {
      return _glMatrix.vec2.equals(this, vector);
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(vector) {
      return _glMatrix.vec2.exactEquals(this, vector);
    }

    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

  }, {
    key: 'add',

    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

    value: function add() {
      for (var _len = arguments.length, vectors = Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = vectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vector = _step.value;

          _glMatrix.vec2.add(this, vector);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
  }, {
    key: 'ELEMENTS',
    get: function get() {
      return 2;
    }
  }, {
    key: 'x',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'y',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }]);

  return Vector2;
}(_mathArray2.default);

exports.default = Vector2;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy92ZWN0b3IyLmpzIl0sIm5hbWVzIjpbIlZlY3RvcjIiLCJ4IiwieSIsIkFycmF5IiwiaXNBcnJheSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNvcHkiLCJzZXQiLCJjaGVjayIsInZlY3RvciIsImVxdWFscyIsImV4YWN0RXF1YWxzIiwidmVjdG9ycyIsImFkZCIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7SUFFcUJBLE87OztBQUNuQjtBQUNBLHFCQUEwQjtBQUFBLFFBQWRDLENBQWMsdUVBQVYsQ0FBVTtBQUFBLFFBQVBDLENBQU8sdUVBQUgsQ0FBRzs7QUFBQTs7QUFBQTs7QUFFeEIsUUFBSUMsTUFBTUMsT0FBTixDQUFjSCxDQUFkLEtBQW9CSSxVQUFVQyxNQUFWLEtBQXFCLENBQTdDLEVBQWdEO0FBQzlDLFlBQUtDLElBQUwsQ0FBVU4sQ0FBVjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQUtPLEdBQUwsQ0FBU1AsQ0FBVCxFQUFZQyxDQUFaO0FBQ0Q7QUFOdUI7QUFPekI7Ozs7d0JBRUdELEMsRUFBR0MsQyxFQUFHO0FBQ1IscUJBQUtNLEdBQUwsQ0FBUyxJQUFULEVBQWVQLENBQWYsRUFBa0JDLENBQWxCO0FBQ0EsV0FBS08sS0FBTDtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7MkJBRU1DLE0sRUFBUTtBQUNiLGFBQU8sZUFBS0MsTUFBTCxDQUFZLElBQVosRUFBa0JELE1BQWxCLENBQVA7QUFDRDs7O2dDQUVXQSxNLEVBQVE7QUFDbEIsYUFBTyxlQUFLRSxXQUFMLENBQWlCLElBQWpCLEVBQXVCRixNQUF2QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTs7Ozs7QUFNQTs7MEJBRWdCO0FBQUEsd0NBQVRHLE9BQVM7QUFBVEEsZUFBUztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNkLDZCQUFxQkEsT0FBckIsOEhBQThCO0FBQUEsY0FBbkJILE1BQW1COztBQUM1Qix5QkFBS0ksR0FBTCxDQUFTLElBQVQsRUFBZUosTUFBZjtBQUNEO0FBSGE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJZCxhQUFPLElBQVA7QUFDRDs7O3dCQVpjO0FBQUUsYUFBTyxDQUFQO0FBQVc7Ozt3QkFDZjtBQUFFLGFBQU8sS0FBSyxDQUFMLENBQVA7QUFBaUIsSztzQkFDMUJLLEssRUFBTztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7Ozt3QkFDeEM7QUFBRSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQWlCLEs7c0JBQzFCQSxLLEVBQU87QUFBRSxhQUFPLEtBQUssQ0FBTCxJQUFVLHlCQUFZQSxLQUFaLENBQWpCO0FBQXNDOzs7Ozs7a0JBL0JsQ2YsTyIsImZpbGUiOiJ2ZWN0b3IyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdGhBcnJheSBmcm9tICcuL21hdGgtYXJyYXknO1xuaW1wb3J0IHtjaGVja051bWJlcn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHt2ZWMyfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3IyIGV4dGVuZHMgTWF0aEFycmF5IHtcbiAgLy8gQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHgsIHkpIHtcbiAgICB2ZWMyLnNldCh0aGlzLCB4LCB5KTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlcXVhbHModmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlYzIuZXF1YWxzKHRoaXMsIHZlY3Rvcik7XG4gIH1cblxuICBleGFjdEVxdWFscyh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjMi5leGFjdEVxdWFscyh0aGlzLCB2ZWN0b3IpO1xuICB9XG5cbiAgLy8gR2V0dGVycy9zZXR0ZXJzXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgYnJhY2Utc3R5bGUsIG5vLXJldHVybi1hc3NpZ24gKi9cbiAgZ2V0IEVMRU1FTlRTKCkgeyByZXR1cm4gMjsgfVxuICBnZXQgeCgpICAgICAgeyByZXR1cm4gdGhpc1swXTsgfVxuICBzZXQgeCh2YWx1ZSkgeyByZXR1cm4gdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeSgpICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgeSh2YWx1ZSkgeyByZXR1cm4gdGhpc1sxXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMsIGJyYWNlLXN0eWxlLCBuby1yZXR1cm4tYXNzaWduICovXG5cbiAgYWRkKC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICB2ZWMyLmFkZCh0aGlzLCB2ZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIl19

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _glMatrix = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Vector4 = function (_MathArray) {
  _inherits(Vector4, _MathArray);

  // Creates a new, empty vec4
  function Vector4() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Vector4);

    var _this = _possibleConstructorReturn(this, (Vector4.__proto__ || Object.getPrototypeOf(Vector4)).call(this));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }
    return _this;
  }

  _createClass(Vector4, [{
    key: 'set',
    value: function set(x, y, z, w) {
      _glMatrix.vec4.set(this, x, y, z, w);
      this.check();
      return this;
    }
  }, {
    key: 'equals',
    value: function equals(vector) {
      return _glMatrix.vec4.equals(this, vector);
    }
  }, {
    key: 'exactEquals',
    value: function exactEquals(vector) {
      return _glMatrix.vec4.exactEquals(this, vector);
    }

    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

  }, {
    key: 'distance',

    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

    value: function distance(vector) {
      return _glMatrix.vec4.distance(vector);
    }
  }, {
    key: 'dist',
    value: function dist(vector) {
      return _glMatrix.vec4.dist(vector);
    }
  }, {
    key: 'angle',
    value: function angle(vector) {
      return _glMatrix.vec4.angle(vector);
    }
  }, {
    key: 'add',
    value: function add() {
      for (var _len = arguments.length, vectors = Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = vectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vector = _step.value;

          _glMatrix.vec4.add(this, vector);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'subtract',
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = vectors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var vector = _step2.value;

          _glMatrix.vec4.subtract(this, vector);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'multiply',
    value: function multiply() {
      for (var _len3 = arguments.length, vectors = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        vectors[_key3] = arguments[_key3];
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = vectors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var vector = _step3.value;

          _glMatrix.vec4.multiply(this, vector);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'divide',
    value: function divide() {
      for (var _len4 = arguments.length, vectors = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        vectors[_key4] = arguments[_key4];
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = vectors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var vector = _step4.value;

          _glMatrix.vec4.divide(this, vector);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.check();
      return this;
    }
  }, {
    key: 'ceil',
    value: function ceil() {
      _glMatrix.vec4.ceil(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'floor',
    value: function floor() {
      _glMatrix.vec4.floor(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'min',
    value: function min() {
      _glMatrix.vec4.min(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'max',
    value: function max() {
      _glMatrix.vec4.max(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'scale',
    value: function scale(_scale) {
      _glMatrix.vec4.scale(this, this, _scale);
      this.check();
      return this;
    }
  }, {
    key: 'scaleAndAdd',
    value: function scaleAndAdd(vector, scale) {
      _glMatrix.vec4.scaleAndAdd(this, this, vector, scale);
      this.check();
      return this;
    }
  }, {
    key: 'negate',
    value: function negate() {
      _glMatrix.vec4.negate(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'inverse',
    value: function inverse() {
      _glMatrix.vec4.inverse(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      _glMatrix.vec4.normalize(this, this);
      this.check();
      return this;
    }
  }, {
    key: 'dot',
    value: function dot(scale) {
      _glMatrix.vec4.dot(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'cross',
    value: function cross(scale) {
      _glMatrix.vec4.cross(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'lerp',
    value: function lerp(scale) {
      _glMatrix.vec4.lerp(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'hermite',
    value: function hermite(scale) {
      _glMatrix.vec4.hermite(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'bezier',
    value: function bezier(scale) {
      _glMatrix.vec4.bezier(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'random',
    value: function random(scale) {
      _glMatrix.vec4.random(this, this, scale);
      this.check();
      return this;
    }
  }, {
    key: 'rotateX',
    value: function rotateX(origin, angle) {
      _glMatrix.vec4.rotateX(this, this, origin, angle);
      this.check();
      return this;
    }
  }, {
    key: 'rotateY',
    value: function rotateY(origin, angle) {
      _glMatrix.vec4.rotateY(this, this, origin, angle);
      this.check();
      return this;
    }
  }, {
    key: 'rotateZ',
    value: function rotateZ(origin, angle) {
      _glMatrix.vec4.rotateZ(this, this, origin, angle);
      this.check();
      return this;
    }
  }, {
    key: 'ELEMENTS',
    get: function get() {
      return 4;
    }
  }, {
    key: 'x',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'y',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'z',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'w',
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);

  return Vector4;
}(_mathArray2.default);

exports.default = Vector4;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy92ZWN0b3I0LmpzIl0sIm5hbWVzIjpbIlZlY3RvcjQiLCJ4IiwieSIsInoiLCJ3IiwiQXJyYXkiLCJpc0FycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY29weSIsInNldCIsImNoZWNrIiwidmVjdG9yIiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJkaXN0YW5jZSIsImRpc3QiLCJhbmdsZSIsInZlY3RvcnMiLCJhZGQiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwiZGl2aWRlIiwiY2VpbCIsImZsb29yIiwibWluIiwibWF4Iiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsIm5lZ2F0ZSIsImludmVyc2UiLCJub3JtYWxpemUiLCJkb3QiLCJjcm9zcyIsImxlcnAiLCJoZXJtaXRlIiwiYmV6aWVyIiwicmFuZG9tIiwib3JpZ2luIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztJQUVxQkEsTzs7O0FBQ25CO0FBQ0EscUJBQXdDO0FBQUEsUUFBNUJDLENBQTRCLHVFQUF4QixDQUF3QjtBQUFBLFFBQXJCQyxDQUFxQix1RUFBakIsQ0FBaUI7QUFBQSxRQUFkQyxDQUFjLHVFQUFWLENBQVU7QUFBQSxRQUFQQyxDQUFPLHVFQUFILENBQUc7O0FBQUE7O0FBQUE7O0FBRXRDLFFBQUlDLE1BQU1DLE9BQU4sQ0FBY0wsQ0FBZCxLQUFvQk0sVUFBVUMsTUFBVixLQUFxQixDQUE3QyxFQUFnRDtBQUM5QyxZQUFLQyxJQUFMLENBQVVSLENBQVY7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFLUyxHQUFMLENBQVNULENBQVQsRUFBWUMsQ0FBWixFQUFlQyxDQUFmLEVBQWtCQyxDQUFsQjtBQUNEO0FBTnFDO0FBT3ZDOzs7O3dCQUVHSCxDLEVBQUdDLEMsRUFBR0MsQyxFQUFHQyxDLEVBQUc7QUFDZCxxQkFBS00s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QUFMLENBQVA7QUFBaUIsSztzQkFDMUJBLEssRUFBTztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7Ozt3QkFDeEM7QUFBRSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQWlCLEs7c0JBQzFCQSxLLEVBQU87QUFBRSxhQUFPLEtBQUssQ0FBTCxJQUFVLHlCQUFZQSxLQUFaLENBQWpCO0FBQXNDOzs7Ozs7a0JBbkNsQzFDLE8iLCJmaWxlIjoidmVjdG9yNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYXRoQXJyYXkgZnJvbSAnLi9tYXRoLWFycmF5JztcbmltcG9ydCB7Y2hlY2tOdW1iZXJ9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7dmVjNH0gZnJvbSAnZ2wtbWF0cml4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yNCBleHRlbmRzIE1hdGhBcnJheSB7XG4gIC8vIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDApIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoeCwgeSwgeiwgdyk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB2ZWM0LnNldCh0aGlzLCB4LCB5LCB6LCB3KTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlcXVhbHModmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlYzQuZXF1YWxzKHRoaXMsIHZlY3Rvcik7XG4gIH1cblxuICBleGFjdEVxdWFscyh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjNC5leGFjdEVxdWFscyh0aGlzLCB2ZWN0b3IpO1xuICB9XG5cbiAgLy8gR2V0dGVycy9zZXR0ZXJzXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgYnJhY2Utc3R5bGUsIG5vLXJldHVybi1hc3NpZ24gKi9cbiAgZ2V0IEVMRU1FTlRTKCkgeyByZXR1cm4gNDsgfVxuICBnZXQgeCgpICAgICAgeyByZXR1cm4gdGhpc1swXTsgfVxuICBzZXQgeCh2YWx1ZSkgeyByZXR1cm4gdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeSgpICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgeSh2YWx1ZSkgeyByZXR1cm4gdGhpc1sxXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeigpICAgICAgeyByZXR1cm4gdGhpc1syXTsgfVxuICBzZXQgeih2YWx1ZSkgeyByZXR1cm4gdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgdygpICAgICAgeyByZXR1cm4gdGhpc1szXTsgfVxuICBzZXQgdyh2YWx1ZSkgeyByZXR1cm4gdGhpc1szXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLW11bHRpLXNwYWNlcywgYnJhY2Utc3R5bGUsIG5vLXJldHVybi1hc3NpZ24gKi9cblxuICBkaXN0YW5jZSh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjNC5kaXN0YW5jZSh2ZWN0b3IpO1xuICB9XG5cbiAgZGlzdCh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjNC5kaXN0KHZlY3Rvcik7XG4gIH1cblxuICBhbmdsZSh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjNC5hbmdsZSh2ZWN0b3IpO1xuICB9XG5cbiAgYWRkKC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICB2ZWM0LmFkZCh0aGlzLCB2ZWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdWJ0cmFjdCguLi52ZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCB2ZWN0b3Igb2YgdmVjdG9ycykge1xuICAgICAgdmVjNC5zdWJ0cmFjdCh0aGlzLCB2ZWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWx0aXBseSguLi52ZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCB2ZWN0b3Igb2YgdmVjdG9ycykge1xuICAgICAgdmVjNC5tdWx0aXBseSh0aGlzLCB2ZWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXZpZGUoLi4udmVjdG9ycykge1xuICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgIHZlYzQuZGl2aWRlKHRoaXMsIHZlY3Rvcik7XG4gICAgfVxuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNlaWwoKSB7XG4gICAgdmVjNC5jZWlsKHRoaXMsIHRoaXMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZsb29yKCkge1xuICAgIHZlYzQuZmxvb3IodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWluKCkge1xuICAgIHZlYzQubWluKHRoaXMsIHRoaXMpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1heCgpIHtcbiAgICB2ZWM0Lm1heCh0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzY2FsZShzY2FsZSkge1xuICAgIHZlYzQuc2NhbGUodGhpcywgdGhpcywgc2NhbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNjYWxlQW5kQWRkKHZlY3Rvciwgc2NhbGUpIHtcbiAgICB2ZWM0LnNjYWxlQW5kQWRkKHRoaXMsIHRoaXMsIHZlY3Rvciwgc2NhbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG5lZ2F0ZSgpIHtcbiAgICB2ZWM0Lm5lZ2F0ZSh0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbnZlcnNlKCkge1xuICAgIHZlYzQuaW52ZXJzZSh0aGlzLCB0aGlzKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBub3JtYWxpemUoKSB7XG4gICAgdmVjNC5ub3JtYWxpemUodGhpcywgdGhpcyk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZG90KHNjYWxlKSB7XG4gICAgdmVjNC5kb3QodGhpcywgdGhpcywgc2NhbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNyb3NzKHNjYWxlKSB7XG4gICAgdmVjNC5jcm9zcyh0aGlzLCB0aGlzLCBzY2FsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGVycChzY2FsZSkge1xuICAgIHZlYzQubGVycCh0aGlzLCB0aGlzLCBzY2FsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaGVybWl0ZShzY2FsZSkge1xuICAgIHZlYzQuaGVybWl0ZSh0aGlzLCB0aGlzLCBzY2FsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYmV6aWVyKHNjYWxlKSB7XG4gICAgdmVjNC5iZXppZXIodGhpcywgdGhpcywgc2NhbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJhbmRvbShzY2FsZSkge1xuICAgIHZlYzQucmFuZG9tKHRoaXMsIHRoaXMsIHNjYWxlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVYKG9yaWdpbiwgYW5nbGUpIHtcbiAgICB2ZWM0LnJvdGF0ZVgodGhpcywgdGhpcywgb3JpZ2luLCBhbmdsZSk7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlWShvcmlnaW4sIGFuZ2xlKSB7XG4gICAgdmVjNC5yb3RhdGVZKHRoaXMsIHRoaXMsIG9yaWdpbiwgYW5nbGUpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVoob3JpZ2luLCBhbmdsZSkge1xuICAgIHZlYzQucm90YXRlWih0aGlzLCB0aGlzLCBvcmlnaW4sIGFuZ2xlKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isBrowser; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// This function is needed in initialization stages,
// make sure it can be imported in isolation
/* global process */

var isNode = (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && String(process) === '[object process]' && !process.browser;

var isBrowser = !isNode;

/* harmony default export */ __webpack_exports__["c"] = (isBrowser);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9pcy1icm93c2VyLmpzIl0sIm5hbWVzIjpbImlzTm9kZSIsInByb2Nlc3MiLCJTdHJpbmciLCJicm93c2VyIiwiaXNCcm93c2VyIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLElBQU1BLFNBQ1gsUUFBT0MsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUNBQyxPQUFPRCxPQUFQLE1BQW9CLGtCQURwQixJQUVBLENBQUNBLFFBQVFFLE9BSEo7O0FBS1AsT0FBTyxJQUFNQyxZQUFZLENBQUNKLE1BQW5COztBQUVQLGVBQWVJLFNBQWYiLCJmaWxlIjoiaXMtYnJvd3Nlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZnVuY3Rpb24gaXMgbmVlZGVkIGluIGluaXRpYWxpemF0aW9uIHN0YWdlcyxcbi8vIG1ha2Ugc3VyZSBpdCBjYW4gYmUgaW1wb3J0ZWQgaW4gaXNvbGF0aW9uXG4vKiBnbG9iYWwgcHJvY2VzcyAqL1xuXG5leHBvcnQgY29uc3QgaXNOb2RlID1cbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIFN0cmluZyhwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmXG4gICFwcm9jZXNzLmJyb3dzZXI7XG5cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAhaXNOb2RlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0Jyb3dzZXI7XG4iXX0=
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(3)))

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatValue;
/* eslint-disable no-console */
/* global console */
var cache = {};

var _log = {
  priority: 0,
  table: function table(priority, _table) {
    if (priority <= _log.priority && _table) {
      console.table(_table);
    }
  },
  log: function log(priority) {
    if (priority <= _log.priority) {
      var _console;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_console = console).debug.apply(_console, args);
    }
  },
  info: function info(priority) {
    if (priority <= _log.priority) {
      var _console2;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_console2 = console).log.apply(_console2, args);
    }
  },
  warn: function warn(priority) {
    if (priority <= _log.priority) {
      var _console3;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      (_console3 = console).warn.apply(_console3, args);
    }
  },
  once: function once(priority, arg) {
    if (!cache[arg]) {
      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      _log.log.apply(_log, [priority, arg].concat(args));
    }
    cache[arg] = true;
  }
};

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === undefined ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === undefined ? 1 : _opts$size;

  var string = '[';
  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ',' + (i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], opts);
  }
  var terminator = v.length > maxElts ? '...' : ']';
  return '' + string + terminator;
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === undefined ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

/* harmony default export */ __webpack_exports__["b"] = (_log);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9sb2cuanMiXSwibmFtZXMiOlsiY2FjaGUiLCJsb2ciLCJwcmlvcml0eSIsInRhYmxlIiwiY29uc29sZSIsImFyZ3MiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwib25jZSIsImFyZyIsImZvcm1hdEFycmF5VmFsdWUiLCJ2Iiwib3B0cyIsIm1heEVsdHMiLCJzaXplIiwic3RyaW5nIiwiaSIsImxlbmd0aCIsImZvcm1hdFZhbHVlIiwidGVybWluYXRvciIsImlzSW50ZWdlciIsIkFycmF5IiwiaXNBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJTdHJpbmciLCJ0b0ZpeGVkIiwiTWF0aCIsImFicyIsInRvUHJlY2lzaW9uIiwiZGVjaW1hbCIsImluZGV4T2YiLCJzbGljZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLElBQU1BLFFBQVEsRUFBZDs7QUFFQSxJQUFNQyxPQUFNO0FBQ1ZDLFlBQVUsQ0FEQTtBQUVWQyxPQUZVLGlCQUVKRCxRQUZJLEVBRU1DLE1BRk4sRUFFYTtBQUNyQixRQUFJRCxZQUFZRCxLQUFJQyxRQUFoQixJQUE0QkMsTUFBaEMsRUFBdUM7QUFDckNDLGNBQVFELEtBQVIsQ0FBY0EsTUFBZDtBQUNEO0FBQ0YsR0FOUztBQU9WRixLQVBVLGVBT05DLFFBUE0sRUFPYTtBQUNyQixRQUFJQSxZQUFZRCxLQUFJQyxRQUFwQixFQUE4QjtBQUFBOztBQUFBLHdDQURmRyxJQUNlO0FBRGZBLFlBQ2U7QUFBQTs7QUFDNUIsMkJBQVFDLEtBQVIsaUJBQWlCRCxJQUFqQjtBQUNEO0FBQ0YsR0FYUztBQVlWRSxNQVpVLGdCQVlMTCxRQVpLLEVBWWM7QUFDdEIsUUFBSUEsWUFBWUQsS0FBSUMsUUFBcEIsRUFBOEI7QUFBQTs7QUFBQSx5Q0FEZEcsSUFDYztBQURkQSxZQUNjO0FBQUE7O0FBQzVCLDRCQUFRSixHQUFSLGtCQUFlSSxJQUFmO0FBQ0Q7QUFDRixHQWhCUztBQWlCVkcsTUFqQlUsZ0JBaUJMTixRQWpCSyxFQWlCYztBQUN0QixRQUFJQSxZQUFZRCxLQUFJQyxRQUFwQixFQUE4QjtBQUFBOztBQUFBLHlDQURkRyxJQUNjO0FBRGRBLFlBQ2M7QUFBQTs7QUFDNUIsNEJBQVFHLElBQVIsa0JBQWdCSCxJQUFoQjtBQUNEO0FBQ0YsR0FyQlM7QUFzQlZJLE1BdEJVLGdCQXNCTFAsUUF0QkssRUFzQktRLEdBdEJMLEVBc0JtQjtBQUMzQixRQUFJLENBQUNWLE1BQU1VLEdBQU4sQ0FBTCxFQUFpQjtBQUFBLHlDQURJTCxJQUNKO0FBRElBLFlBQ0o7QUFBQTs7QUFDZkosV0FBSUEsR0FBSixjQUFRQyxRQUFSLEVBQWtCUSxHQUFsQixTQUEwQkwsSUFBMUI7QUFDRDtBQUNETCxVQUFNVSxHQUFOLElBQWEsSUFBYjtBQUNEO0FBM0JTLENBQVo7O0FBOEJBLFNBQVNDLGdCQUFULENBQTBCQyxDQUExQixFQUE2QkMsSUFBN0IsRUFBbUM7QUFBQSxzQkFDQUEsSUFEQSxDQUMxQkMsT0FEMEI7QUFBQSxNQUMxQkEsT0FEMEIsaUNBQ2hCLEVBRGdCO0FBQUEsbUJBQ0FELElBREEsQ0FDWkUsSUFEWTtBQUFBLE1BQ1pBLElBRFksOEJBQ0wsQ0FESzs7QUFFakMsTUFBSUMsU0FBUyxHQUFiO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlMLEVBQUVNLE1BQU4sSUFBZ0JELElBQUlILE9BQXBDLEVBQTZDLEVBQUVHLENBQS9DLEVBQWtEO0FBQ2hELFFBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1RELHVCQUFlQyxJQUFJRixJQUFKLEtBQWEsQ0FBZCxHQUFtQixHQUFuQixHQUF5QixFQUF2QztBQUNEO0FBQ0RDLGNBQVVHLFlBQVlQLEVBQUVLLENBQUYsQ0FBWixFQUFrQkosSUFBbEIsQ0FBVjtBQUNEO0FBQ0QsTUFBTU8sYUFBYVIsRUFBRU0sTUFBRixHQUFXSixPQUFYLEdBQXFCLEtBQXJCLEdBQTZCLEdBQWhEO0FBQ0EsY0FBVUUsTUFBVixHQUFtQkksVUFBbkI7QUFDRDs7QUFFRCxPQUFPLFNBQVNELFdBQVQsQ0FBcUJQLENBQXJCLEVBQW1DO0FBQUEsTUFBWEMsSUFBVyx1RUFBSixFQUFJO0FBQUEsd0JBQ1pBLElBRFksQ0FDakNRLFNBRGlDO0FBQUEsTUFDakNBLFNBRGlDLG1DQUNyQixLQURxQjs7QUFFeEMsTUFBSUMsTUFBTUMsT0FBTixDQUFjWCxDQUFkLEtBQW9CWSxZQUFZQyxNQUFaLENBQW1CYixDQUFuQixDQUF4QixFQUErQztBQUM3QyxXQUFPRCxpQkFBaUJDLENBQWpCLEVBQW9CQyxJQUFwQixDQUFQO0FBQ0Q7QUFDRCxNQUFJLENBQUNhLE9BQU9DLFFBQVAsQ0FBZ0JmLENBQWhCLENBQUwsRUFBeUI7QUFDdkIsV0FBT2dCLE9BQU9oQixDQUFQLENBQVA7QUFDRDtBQUNELE1BQUlTLFNBQUosRUFBZTtBQUNiLFdBQU9ULEVBQUVpQixPQUFGLENBQVUsQ0FBVixDQUFQO0FBQ0Q7QUFDRCxNQUFJQyxLQUFLQyxHQUFMLENBQVNuQixDQUFULElBQWMsR0FBZCxJQUFxQmtCLEtBQUtDLEdBQUwsQ0FBU25CLENBQVQsSUFBYyxLQUF2QyxFQUE4QztBQUM1QyxXQUFPQSxFQUFFaUIsT0FBRixDQUFVLENBQVYsQ0FBUDtBQUNEO0FBQ0QsTUFBTWIsU0FBU0osRUFBRW9CLFdBQUYsQ0FBYyxDQUFkLENBQWY7QUFDQSxNQUFNQyxVQUFVakIsT0FBT2tCLE9BQVAsQ0FBZSxJQUFmLENBQWhCO0FBQ0EsU0FBT0QsWUFBWWpCLE9BQU9FLE1BQVAsR0FBZ0IsQ0FBNUIsR0FBZ0NGLE9BQU9tQixLQUFQLENBQWEsQ0FBYixFQUFnQixDQUFDLENBQWpCLENBQWhDLEdBQXNEbkIsTUFBN0Q7QUFDRDs7QUFFRCxlQUFlZixJQUFmIiwiZmlsZSI6ImxvZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qIGdsb2JhbCBjb25zb2xlICovXG5jb25zdCBjYWNoZSA9IHt9O1xuXG5jb25zdCBsb2cgPSB7XG4gIHByaW9yaXR5OiAwLFxuICB0YWJsZShwcmlvcml0eSwgdGFibGUpIHtcbiAgICBpZiAocHJpb3JpdHkgPD0gbG9nLnByaW9yaXR5ICYmIHRhYmxlKSB7XG4gICAgICBjb25zb2xlLnRhYmxlKHRhYmxlKTtcbiAgICB9XG4gIH0sXG4gIGxvZyhwcmlvcml0eSwgLi4uYXJncykge1xuICAgIGlmIChwcmlvcml0eSA8PSBsb2cucHJpb3JpdHkpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICBpbmZvKHByaW9yaXR5LCAuLi5hcmdzKSB7XG4gICAgaWYgKHByaW9yaXR5IDw9IGxvZy5wcmlvcml0eSkge1xuICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICB3YXJuKHByaW9yaXR5LCAuLi5hcmdzKSB7XG4gICAgaWYgKHByaW9yaXR5IDw9IGxvZy5wcmlvcml0eSkge1xuICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgb25jZShwcmlvcml0eSwgYXJnLCAuLi5hcmdzKSB7XG4gICAgaWYgKCFjYWNoZVthcmddKSB7XG4gICAgICBsb2cubG9nKHByaW9yaXR5LCBhcmcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBjYWNoZVthcmddID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2LCBvcHRzKSB7XG4gIGNvbnN0IHttYXhFbHRzID0gMTYsIHNpemUgPSAxfSA9IG9wdHM7XG4gIGxldCBzdHJpbmcgPSAnWyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdi5sZW5ndGggJiYgaSA8IG1heEVsdHM7ICsraSkge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgc3RyaW5nICs9IGAsJHsoaSAlIHNpemUgPT09IDApID8gJyAnIDogJyd9YDtcbiAgICB9XG4gICAgc3RyaW5nICs9IGZvcm1hdFZhbHVlKHZbaV0sIG9wdHMpO1xuICB9XG4gIGNvbnN0IHRlcm1pbmF0b3IgPSB2Lmxlbmd0aCA+IG1heEVsdHMgPyAnLi4uJyA6ICddJztcbiAgcmV0dXJuIGAke3N0cmluZ30ke3Rlcm1pbmF0b3J9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7aXNJbnRlZ2VyID0gZmFsc2V9ID0gb3B0cztcbiAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEFycmF5VmFsdWUodiwgb3B0cyk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHtcbiAgICByZXR1cm4gU3RyaW5nKHYpO1xuICB9XG4gIGlmIChpc0ludGVnZXIpIHtcbiAgICByZXR1cm4gdi50b0ZpeGVkKDApO1xuICB9XG4gIGlmIChNYXRoLmFicyh2KSA+IDEwMCAmJiBNYXRoLmFicyh2KSA8IDEwMDAwKSB7XG4gICAgcmV0dXJuIHYudG9GaXhlZCgwKTtcbiAgfVxuICBjb25zdCBzdHJpbmcgPSB2LnRvUHJlY2lzaW9uKDIpO1xuICBjb25zdCBkZWNpbWFsID0gc3RyaW5nLmluZGV4T2YoJy4wJyk7XG4gIHJldHVybiBkZWNpbWFsID09PSBzdHJpbmcubGVuZ3RoIC0gMiA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxvZztcbiJdfQ==

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ERR_DELETED = 'Query was deleted before result was available';
var ERR_CANCEL = 'Query was canceled before result was available';

var noop = function noop(x) {
  return x;
};

var QueryManager = function () {

  /**
   * Internal class that helps "asynchronous WebGL query objects" manage
   * pending requests (e.g. for EXT_disjoint_timer_query and WebGL2 queries)
   *
   * Creates and manages promises for the queries.
   * Tracks pending queries enabling polling.
   * Tracks pending queries enabling invalidation.
   * Encapsulates some standard error messages.
   *
   * Remarks:
   * - Maintains a minimal list of pending queries only to minimize GC impact
   * - Exported as a singleton class instance.
   */
  function QueryManager() {
    _classCallCheck(this, QueryManager);

    this.pendingQueries = new Set();
    this.invalidQueryType = null;
    this.invalidErrorMessage = '';
    this.checkInvalid = function () {
      return false;
    };
  }

  // API THAT SHOULD BE EXPOSED TO APPLICATION

  // Checks invalidation callback and then all pending queries for completion
  // Should only be called once per tick


  _createClass(QueryManager, [{
    key: 'poll',
    value: function poll(gl) {
      this.cancelInvalidQueries(gl);

      // Now check availability of results and resolve promises as appropriate
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.pendingQueries.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var query = _step.value;

          var resultAvailable = query.isResultAvailable();
          if (resultAvailable) {
            var result = query.getResult();
            this.resolveQuery(query, result);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // API FOR MANAGED QUERY CLASSES

    // Registers query invalidation method - used to detect disjoint timer queries

  }, {
    key: 'setInvalidator',
    value: function setInvalidator(_ref) {
      var queryType = _ref.queryType,
          errorMessage = _ref.errorMessage,
          checkInvalid = _ref.checkInvalid;

      this.invalidQueryType = queryType;
      this.invalidErrorMessage = errorMessage;
      this.checkInvalid = checkInvalid;
    }

    // Starts a query, sets up a new promise

  }, {
    key: 'beginQuery',
    value: function beginQuery(query) {
      var onComplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

      // Make sure disjoint state is cleared, so that this query starts fresh
      // Cancel other queries if needed
      this.cancelInvalidQueries(query.gl);

      // Cancel current promise - noop if already resolved or rejected
      this.cancelQuery(query);

      // Create a new promise with attached resolve and reject methods
      var resolvers = {};
      query.promise = new Promise(function (resolve, reject) {
        resolvers.resolve = resolve;
        resolvers.reject = reject;
      });
      Object.assign(query.promise, resolvers);

      // Add this query to the pending queries
      this.pendingQueries.add(query);
      // Register the callbacks
      return query.promise.then(onComplete).catch(onError);
    }

    // Resolves a query with a result

  }, {
    key: 'resolveQuery',
    value: function resolveQuery(query, result) {
      this.pendingQueries.delete(query);
      query.promise.resolve(result);
    }

    // Rejects the promise

  }, {
    key: 'rejectQuery',
    value: function rejectQuery(query, errorMessage) {
      this.pendingQueries.delete(query);
      if (query.promise) {
        query.promise.reject(new Error(errorMessage));
      }
    }

    // Rejects promise with standard message for Query.delete()

  }, {
    key: 'deleteQuery',
    value: function deleteQuery(query) {
      return this.rejectQuery(query, ERR_DELETED);
    }

    // Rejects promise with standard message for Query.cancel()

  }, {
    key: 'cancelQuery',
    value: function cancelQuery(query) {
      return this.rejectQuery(query, ERR_CANCEL);
    }

    // Rejects promise with registered message for invalidation

  }, {
    key: 'invalidateQuery',
    value: function invalidateQuery(query) {
      if (query instanceof this.invalidQueryType) {
        this.rejectQuery(query, this.invalidErrorMessage);
      }
    }

    // Checks all queries to see if need to be invalidated

  }, {
    key: 'cancelInvalidQueries',
    value: function cancelInvalidQueries(gl) {
      // We assume that we can cancel queries for all context.
      // Should be OK since this is used to check for "disjoint" GPU state
      if (this.checkInvalid(gl)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.pendingQueries.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var query = _step2.value;

            this.invalidateQuery(query);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }]);

  return QueryManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (new QueryManager());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy93ZWJnbC9oZWxwZXJzL3F1ZXJ5LW1hbmFnZXIuanMiXSwibmFtZXMiOlsiRVJSX0RFTEVURUQiLCJFUlJfQ0FOQ0VMIiwibm9vcCIsIngiLCJRdWVyeU1hbmFnZXIiLCJwZW5kaW5nUXVlcmllcyIsIlNldCIsImludmFsaWRRdWVyeVR5cGUiLCJpbnZhbGlkRXJyb3JNZXNzYWdlIiwiY2hlY2tJbnZhbGlkIiwiZ2wiLCJjYW5jZWxJbnZhbGlkUXVlcmllcyIsInZhbHVlcyIsInF1ZXJ5IiwicmVzdWx0QXZhaWxhYmxlIiwiaXNSZXN1bHRBdmFpbGFibGUiLCJyZXN1bHQiLCJnZXRSZXN1bHQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeVR5cGUiLCJlcnJvck1lc3NhZ2UiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsImNhbmNlbFF1ZXJ5IiwicmVzb2x2ZXJzIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkIiwidGhlbiIsImNhdGNoIiwiZGVsZXRlIiwiRXJyb3IiLCJyZWplY3RRdWVyeSIsImludmFsaWRhdGVRdWVyeSJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLElBQU1BLGNBQWMsK0NBQXBCO0FBQ0EsSUFBTUMsYUFBYSxnREFBbkI7O0FBRUEsSUFBTUMsT0FBTyxTQUFQQSxJQUFPO0FBQUEsU0FBS0MsQ0FBTDtBQUFBLENBQWI7O0lBRU1DLFk7O0FBRUo7Ozs7Ozs7Ozs7Ozs7QUFhQSwwQkFBYztBQUFBOztBQUNaLFNBQUtDLGNBQUwsR0FBc0IsSUFBSUMsR0FBSixFQUF0QjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkIsRUFBM0I7QUFDQSxTQUFLQyxZQUFMLEdBQW9CO0FBQUEsYUFBTSxLQUFOO0FBQUEsS0FBcEI7QUFDRDs7QUFFRDs7QUFFQTtBQUNBOzs7Ozt5QkFDS0MsRSxFQUFJO0FBQ1AsV0FBS0Msb0JBQUwsQ0FB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bUlBQWtEO0FBQUEsZ0JBQXZDQyxLQUF1Qzs7QUFDaEQsaUJBQUt3QixlQUFMLENBQXFCeEIsS0FBckI7QUFDRDtBQUh3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSTFCO0FBQ0Y7Ozs7OztBQUdILGVBQWUsSUFBSVQsWUFBSixFQUFmIiwiZmlsZSI6InF1ZXJ5LW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IEVSUl9ERUxFVEVEID0gJ1F1ZXJ5IHdhcyBkZWxldGVkIGJlZm9yZSByZXN1bHQgd2FzIGF2YWlsYWJsZSc7XG5jb25zdCBFUlJfQ0FOQ0VMID0gJ1F1ZXJ5IHdhcyBjYW5jZWxlZCBiZWZvcmUgcmVzdWx0IHdhcyBhdmFpbGFibGUnO1xuXG5jb25zdCBub29wID0geCA9PiB4O1xuXG5jbGFzcyBRdWVyeU1hbmFnZXIge1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBjbGFzcyB0aGF0IGhlbHBzIFwiYXN5bmNocm9ub3VzIFdlYkdMIHF1ZXJ5IG9iamVjdHNcIiBtYW5hZ2VcbiAgICogcGVuZGluZyByZXF1ZXN0cyAoZS5nLiBmb3IgRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5IGFuZCBXZWJHTDIgcXVlcmllcylcbiAgICpcbiAgICogQ3JlYXRlcyBhbmQgbWFuYWdlcyBwcm9taXNlcyBmb3IgdGhlIHF1ZXJpZXMuXG4gICAqIFRyYWNrcyBwZW5kaW5nIHF1ZXJpZXMgZW5hYmxpbmcgcG9sbGluZy5cbiAgICogVHJhY2tzIHBlbmRpbmcgcXVlcmllcyBlbmFibGluZyBpbnZhbGlkYXRpb24uXG4gICAqIEVuY2Fwc3VsYXRlcyBzb21lIHN0YW5kYXJkIGVycm9yIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBSZW1hcmtzOlxuICAgKiAtIE1haW50YWlucyBhIG1pbmltYWwgbGlzdCBvZiBwZW5kaW5nIHF1ZXJpZXMgb25seSB0byBtaW5pbWl6ZSBHQyBpbXBhY3RcbiAgICogLSBFeHBvcnRlZCBhcyBhIHNpbmdsZXRvbiBjbGFzcyBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5pbnZhbGlkUXVlcnlUeXBlID0gbnVsbDtcbiAgICB0aGlzLmludmFsaWRFcnJvck1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLmNoZWNrSW52YWxpZCA9ICgpID0+IGZhbHNlO1xuICB9XG5cbiAgLy8gQVBJIFRIQVQgU0hPVUxEIEJFIEVYUE9TRUQgVE8gQVBQTElDQVRJT05cblxuICAvLyBDaGVja3MgaW52YWxpZGF0aW9uIGNhbGxiYWNrIGFuZCB0aGVuIGFsbCBwZW5kaW5nIHF1ZXJpZXMgZm9yIGNvbXBsZXRpb25cbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIHRpY2tcbiAgcG9sbChnbCkge1xuICAgIHRoaXMuY2FuY2VsSW52YWxpZFF1ZXJpZXMoZ2wpO1xuXG4gICAgLy8gTm93IGNoZWNrIGF2YWlsYWJpbGl0eSBvZiByZXN1bHRzIGFuZCByZXNvbHZlIHByb21pc2VzIGFzIGFwcHJvcHJpYXRlXG4gICAgZm9yIChjb25zdCBxdWVyeSBvZiB0aGlzLnBlbmRpbmdRdWVyaWVzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCByZXN1bHRBdmFpbGFibGUgPSBxdWVyeS5pc1Jlc3VsdEF2YWlsYWJsZSgpO1xuICAgICAgaWYgKHJlc3VsdEF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBxdWVyeS5nZXRSZXN1bHQoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlUXVlcnkocXVlcnksIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVBJIEZPUiBNQU5BR0VEIFFVRVJZIENMQVNTRVNcblxuICAvLyBSZWdpc3RlcnMgcXVlcnkgaW52YWxpZGF0aW9uIG1ldGhvZCAtIHVzZWQgdG8gZGV0ZWN0IGRpc2pvaW50IHRpbWVyIHF1ZXJpZXNcbiAgc2V0SW52YWxpZGF0b3Ioe3F1ZXJ5VHlwZSwgZXJyb3JNZXNzYWdlLCBjaGVja0ludmFsaWR9KSB7XG4gICAgdGhpcy5pbnZhbGlkUXVlcnlUeXBlID0gcXVlcnlUeXBlO1xuICAgIHRoaXMuaW52YWxpZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICB0aGlzLmNoZWNrSW52YWxpZCA9IGNoZWNrSW52YWxpZDtcbiAgfVxuXG4gIC8vIFN0YXJ0cyBhIHF1ZXJ5LCBzZXRzIHVwIGEgbmV3IHByb21pc2VcbiAgYmVnaW5RdWVyeShxdWVyeSwgb25Db21wbGV0ZSA9IG5vb3AsIG9uRXJyb3IgPSBub29wKSB7XG4gICAgLy8gTWFrZSBzdXJlIGRpc2pvaW50IHN0YXRlIGlzIGNsZWFyZWQsIHNvIHRoYXQgdGhpcyBxdWVyeSBzdGFydHMgZnJlc2hcbiAgICAvLyBDYW5jZWwgb3RoZXIgcXVlcmllcyBpZiBuZWVkZWRcbiAgICB0aGlzLmNhbmNlbEludmFsaWRRdWVyaWVzKHF1ZXJ5LmdsKTtcblxuICAgIC8vIENhbmNlbCBjdXJyZW50IHByb21pc2UgLSBub29wIGlmIGFscmVhZHkgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiAgICB0aGlzLmNhbmNlbFF1ZXJ5KHF1ZXJ5KTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBwcm9taXNlIHdpdGggYXR0YWNoZWQgcmVzb2x2ZSBhbmQgcmVqZWN0IG1ldGhvZHNcbiAgICBjb25zdCByZXNvbHZlcnMgPSB7fTtcbiAgICBxdWVyeS5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZXJzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmVzb2x2ZXJzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LnByb21pc2UsIHJlc29sdmVycyk7XG5cbiAgICAvLyBBZGQgdGhpcyBxdWVyeSB0byB0aGUgcGVuZGluZyBxdWVyaWVzXG4gICAgdGhpcy5wZW5kaW5nUXVlcmllcy5hZGQocXVlcnkpO1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBjYWxsYmFja3NcbiAgICByZXR1cm4gcXVlcnkucHJvbWlzZS50aGVuKG9uQ29tcGxldGUpLmNhdGNoKG9uRXJyb3IpO1xuICB9XG5cbiAgLy8gUmVzb2x2ZXMgYSBxdWVyeSB3aXRoIGEgcmVzdWx0XG4gIHJlc29sdmVRdWVyeShxdWVyeSwgcmVzdWx0KSB7XG4gICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgIHF1ZXJ5LnByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICB9XG5cbiAgLy8gUmVqZWN0cyB0aGUgcHJvbWlzZVxuICByZWplY3RRdWVyeShxdWVyeSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgIGlmIChxdWVyeS5wcm9taXNlKSB7XG4gICAgICBxdWVyeS5wcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVqZWN0cyBwcm9taXNlIHdpdGggc3RhbmRhcmQgbWVzc2FnZSBmb3IgUXVlcnkuZGVsZXRlKClcbiAgZGVsZXRlUXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3RRdWVyeShxdWVyeSwgRVJSX0RFTEVURUQpO1xuICB9XG5cbiAgLy8gUmVqZWN0cyBwcm9taXNlIHdpdGggc3RhbmRhcmQgbWVzc2FnZSBmb3IgUXVlcnkuY2FuY2VsKClcbiAgY2FuY2VsUXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3RRdWVyeShxdWVyeSwgRVJSX0NBTkNFTCk7XG4gIH1cblxuICAvLyBSZWplY3RzIHByb21pc2Ugd2l0aCByZWdpc3RlcmVkIG1lc3NhZ2UgZm9yIGludmFsaWRhdGlvblxuICBpbnZhbGlkYXRlUXVlcnkocXVlcnkpIHtcbiAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiB0aGlzLmludmFsaWRRdWVyeVR5cGUpIHtcbiAgICAgIHRoaXMucmVqZWN0UXVlcnkocXVlcnksIHRoaXMuaW52YWxpZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIGFsbCBxdWVyaWVzIHRvIHNlZSBpZiBuZWVkIHRvIGJlIGludmFsaWRhdGVkXG4gIGNhbmNlbEludmFsaWRRdWVyaWVzKGdsKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgd2UgY2FuIGNhbmNlbCBxdWVyaWVzIGZvciBhbGwgY29udGV4dC5cbiAgICAvLyBTaG91bGQgYmUgT0sgc2luY2UgdGhpcyBpcyB1c2VkIHRvIGNoZWNrIGZvciBcImRpc2pvaW50XCIgR1BVIHN0YXRlXG4gICAgaWYgKHRoaXMuY2hlY2tJbnZhbGlkKGdsKSkge1xuICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiB0aGlzLnBlbmRpbmdRdWVyaWVzLnZhbHVlcygpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFF1ZXJ5TWFuYWdlcigpO1xuIl19

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getUniformDescriptors */
/* unused harmony export getVaryingMap */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__texture__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__uniforms__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shader__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-inline-comments */










var Program = function (_Resource) {
  _inherits(Program, _Resource);

  /*
   * @classdesc
   * Handles creation of programs, mapping of attributes and uniforms
   *
   * @class
   * @param {WebGLRenderingContext} gl - gl context
   * @param {Object} opts - options
   * @param {String} opts.vs - Vertex shader source
   * @param {String} opts.fs - Fragment shader source
   * @param {String} opts.id= - Id
   */
  function Program(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Program);

    var _this = _possibleConstructorReturn(this, (Program.__proto__ || Object.getPrototypeOf(Program)).call(this, gl, opts));

    _this.initialize(opts);
    Object.seal(_this);

    // If program is not named, name it after shader names
    if (!opts.id) {
      var programName = _this.vs.getName() || _this.fs.getName();
      programName = programName.replace(/shader/i, '');
      programName = programName ? programName + '-program' : 'program';
      // TODO - this.id will already have been initialized
      _this.id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils__["uid"])(programName);
    }
    return _this;
  }

  _createClass(Program, [{
    key: 'initialize',
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vs = _ref.vs,
          fs = _ref.fs,
          defaultUniforms = _ref.defaultUniforms,
          varyings = _ref.varyings,
          _ref$bufferMode = _ref.bufferMode,
          bufferMode = _ref$bufferMode === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SEPARATE_ATTRIBS : _ref$bufferMode;

      // Create shaders if needed
      this.vs = typeof vs === 'string' ? new __WEBPACK_IMPORTED_MODULE_6__shader__["b" /* VertexShader */](this.gl, vs) : vs;
      this.fs = typeof fs === 'string' ? new __WEBPACK_IMPORTED_MODULE_6__shader__["c" /* FragmentShader */](this.gl, fs) : fs;

      __WEBPACK_IMPORTED_MODULE_8_assert___default()(this.vs instanceof __WEBPACK_IMPORTED_MODULE_6__shader__["b" /* VertexShader */], 'Program: bad vertex shader');
      __WEBPACK_IMPORTED_MODULE_8_assert___default()(this.fs instanceof __WEBPACK_IMPORTED_MODULE_6__shader__["c" /* FragmentShader */], 'Program: bad fragment shader');

      this.defaultUniforms = defaultUniforms;

      // Setup varyings if supplied
      if (varyings) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        this.varyings = getVaryingMap(varyings, bufferMode);
      }

      this._compileAndLink();

      // determine attribute locations (i.e. indices)
      this._attributeLocations = this._getAttributeLocations();
      this._attributeCount = this.getAttributeCount();
      this._warn = [];
      this._filledLocations = {};

      // prepare uniform setters
      this._uniformSetters = this._getUniformSetters();
      this._uniformCount = this.getUniformCount();
      this._textureIndexCounter = 0;

      Object.seal(this);

      return this;
    }
  }, {
    key: 'use',
    value: function use() {
      this.gl.useProgram(this.handle);
      return this;
    }

    // A good thing about webGL is that there are so many ways to draw things,
    // e.g. depending on whether data is indexed and/or isInstanced.
    // This function unifies those into a single call with simple parameters
    // that have sane defaults.

  }, {
    key: 'draw',
    value: function draw(gl, _ref2) {
      var _ref2$drawMode = _ref2.drawMode,
          drawMode = _ref2$drawMode === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRIANGLES : _ref2$drawMode,
          vertexCount = _ref2.vertexCount,
          _ref2$offset = _ref2.offset,
          offset = _ref2$offset === undefined ? 0 : _ref2$offset,
          _ref2$isIndexed = _ref2.isIndexed,
          isIndexed = _ref2$isIndexed === undefined ? false : _ref2$isIndexed,
          _ref2$indexType = _ref2.indexType,
          indexType = _ref2$indexType === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT : _ref2$indexType,
          _ref2$isInstanced = _ref2.isInstanced,
          isInstanced = _ref2$isInstanced === undefined ? false : _ref2$isInstanced,
          _ref2$instanceCount = _ref2.instanceCount,
          instanceCount = _ref2$instanceCount === undefined ? 0 : _ref2$instanceCount,
          transformFeedback = _ref2.transformFeedback;

      this.gl.useProgram(this.handle);

      if (transformFeedback) {
        transformFeedback.begin();
      }

      var extension = gl.getExtension('ANGLE_instanced_arrays');

      // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension
      if (isInstanced && isIndexed) {
        extension.drawElementsInstancedANGLE(drawMode, vertexCount, indexType, offset, instanceCount);
      } else if (isInstanced) {
        extension.drawArraysInstancedANGLE(drawMode, offset, vertexCount, instanceCount);
      } else if (isIndexed) {
        gl.drawElements(drawMode, vertexCount, indexType, offset);
      } else {
        gl.drawArrays(drawMode, offset, vertexCount);
      }

      if (transformFeedback) {
        transformFeedback.end();
      }

      return this;
    }

    /**
     * Attach a map of Buffers values to a program
     * Only attributes with names actually present in the linked program
     * will be updated. Other supplied buffers will be ignored.
     *
     * @param {Object} buffers - An object map with attribute names being keys
     *  and values are expected to be instances of Buffer.
     * @returns {Program} Returns itself for chaining.
     */
    /* eslint-disable max-statements */

  }, {
    key: 'setBuffers',
    value: function setBuffers(buffers) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$clear = _ref3.clear,
          clear = _ref3$clear === undefined ? true : _ref3$clear,
          _ref3$check = _ref3.check,
          check = _ref3$check === undefined ? true : _ref3$check,
          _ref3$drawParams = _ref3.drawParams,
          drawParams = _ref3$drawParams === undefined ? {} : _ref3$drawParams;

      if (clear) {
        this._filledLocations = {};
      }

      // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER
      // index type is saved for drawElement calls
      drawParams.isInstanced = false;
      drawParams.isIndexed = false;
      drawParams.indexType = null;

      var _sortBuffersByLocatio = this._sortBuffersByLocation(buffers),
          locations = _sortBuffersByLocatio.locations,
          elements = _sortBuffersByLocatio.elements;

      var gl = this.gl;

      // Process locations in order

      for (var location = 0; location < locations.length; ++location) {
        var bufferName = locations[location];
        var buffer = buffers[bufferName];
        // DISABLE MISSING ATTRIBUTE
        if (!buffer) {
          __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["disable"](gl, location);
        } else {
          var divisor = buffer.layout.instanced ? 1 : 0;
          __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["enable"](gl, location);
          __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["setBuffer"]({ gl: gl, location: location, buffer: buffer });
          __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["setDivisor"](gl, location, divisor);
          drawParams.isInstanced = buffer.layout.instanced > 0;
          this._filledLocations[bufferName] = true;
        }
      }

      // SET ELEMENTS ARRAY BUFFER
      if (elements) {
        var _buffer = buffers[elements];
        _buffer.bind();
        drawParams.isIndexed = true;
        drawParams.indexType = _buffer.layout.type;
      }

      if (check) {
        this._checkBuffers();
      }

      return this;
    }
    /* eslint-enable max-statements */

    /*
     * @returns {Program} Returns itself for chaining.
     */

  }, {
    key: 'unsetBuffers',
    value: function unsetBuffers() {
      var length = this._attributeCount;
      for (var i = 1; i < length; ++i) {
        // VertexAttributes.setDivisor(gl, i, 0);
        __WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["disable"](this.gl, i);
      }

      // Clear elements buffer
      this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ELEMENT_ARRAY_BUFFER, null);
      return this;
    }

    /**
     * Apply a set of uniform values to a program
     * Only uniforms with names actually present in the linked program
     * will be updated.
     * other uniforms will be ignored
     *
     * @param {Object} uniformMap - An object with names being keys
     * @returns {Program} - returns itself for chaining.
     */
    /* eslint-disable max-depth */

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniforms) {
      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      for (var uniformName in uniforms) {
        var uniform = uniforms[uniformName];
        var uniformSetter = this._uniformSetters[uniformName];
        var sampler = samplers[uniformName];

        if (uniformSetter) {
          if (uniform instanceof __WEBPACK_IMPORTED_MODULE_4__texture__["a" /* default */]) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }

            // Bind texture to index
            var texture = uniform;
            var textureIndex = uniformSetter.textureIndex;


            texture.bind(textureIndex);

            // Bind a sampler (if supplied) to index
            if (sampler) {
              sampler.bind(textureIndex);
            }

            // Set the uniform sampler to the texture index
            uniformSetter(textureIndex);
          } else {
            // Just set the value
            uniformSetter(uniform);
          }
        }
      }

      return this;
    }
    /* eslint-enable max-depth */

    // setTransformFeedbackBuffers(buffers) {
    //   for (const buffer of buffers) {
    //     buffer.bindBase()
    //   }
    // }

    /**
     * ATTRIBUTES API
     * (Locations are numeric indices)
     * @return {Number} count
     */

  }, {
    key: 'getAttributeCount',
    value: function getAttributeCount() {
      return this._getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ACTIVE_ATTRIBUTES);
    }

    /**
     * Returns location (index) of a name
     * @param {String} attributeName - name of an attribute
     *   (matches name in a linked shader)
     * @returns {Number} - // array of actual attribute names from shader linking
     */

  }, {
    key: 'getAttributeLocation',
    value: function getAttributeLocation(attributeName) {
      return this.gl.getAttribLocation(this.handle, attributeName);
    }

    /**
     * Returns an object with info about attribute at index "location"/
     * @param {int} location - index of an attribute
     * @returns {WebGLActiveInfo} - info about an active attribute
     *   fields: {name, size, type}
     */

  }, {
    key: 'getAttributeInfo',
    value: function getAttributeInfo(location) {
      return this.gl.getActiveAttrib(this.handle, location);
    }

    /**
     * UNIFORMS API
     * (Locations are numeric indices)
     * @return {Number} count
     */

  }, {
    key: 'getUniformCount',
    value: function getUniformCount() {
      return this._getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ACTIVE_UNIFORMS);
    }

    /*
     * @returns {WebGLActiveInfo} - object with {name, size, type}
     */

  }, {
    key: 'getUniformInfo',
    value: function getUniformInfo(index) {
      return this.gl.getActiveUniform(this.handle, index);
    }

    /*
     * @returns {WebGLUniformLocation} - opaque object representing location
     * of uniform, used by setter methods
     */

  }, {
    key: 'getUniformLocation',
    value: function getUniformLocation(name) {
      return this.gl.getUniformLocation(this.handle, name);
    }
  }, {
    key: 'getUniformValue',
    value: function getUniformValue(location) {
      return this.gl.getUniform(this.handle, location);
    }

    // WebGL2
    /**
     * @param {GLuint} index
     * @return {WebGLActiveInfo} - object with {name, size, type}
     */

  }, {
    key: 'getVarying',
    value: function getVarying(program, index) {
      var result = this.gl.getTransformFeedbackVarying(program, index);
      return result;
    }

    // Retrieves the assigned color number binding for the user-defined varying
    // out variable name for program. program must have previously been linked.

  }, {
    key: 'getFragDataLocation',
    value: function getFragDataLocation(varyingName) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(this.gl);
      return this.gl.getFragDataLocation(this.handle, varyingName);
    }

    // @returns {WebGLShader[]} - array of attached WebGLShader objects

  }, {
    key: 'getAttachedShaders',
    value: function getAttachedShaders() {
      return this.gl.getAttachedShaders(this.handle);
    }

    // PRIVATE METHODS

  }, {
    key: '_compileAndLink',
    value: function _compileAndLink() {
      var gl = this.gl;

      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      gl.linkProgram(this.handle);

      // Avoid checking program linking error in production
      if (gl.debug || __WEBPACK_IMPORTED_MODULE_7__utils__["log"].priority > 0) {
        gl.validateProgram(this.handle);
        var linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
        if (!linked) {
          throw new Error('Error linking ' + gl.getProgramInfoLog(this.handle));
        }
      }
    }
  }, {
    key: '_checkBuffers',
    value: function _checkBuffers() {
      for (var attributeName in this._attributeLocations) {
        if (!this._filledLocations[attributeName] && !this._warn[attributeName]) {
          var location = this._attributeLocations[attributeName];
          // throw new Error(`Program ${this.id}: ` +
          //   `Attribute ${location}:${attributeName} not supplied`);
          __WEBPACK_IMPORTED_MODULE_7__utils__["log"].warn(0, 'Program ' + this.id + ': Attribute ' + location + ':' + attributeName + ' not supplied');
          this._warn[attributeName] = true;
        }
      }
      return this;
    }
  }, {
    key: '_sortBuffersByLocation',
    value: function _sortBuffersByLocation(buffers) {
      var elements = null;
      var locations = new Array(this._attributeCount);

      for (var bufferName in buffers) {
        var buffer = buffers[bufferName];
        var location = this._attributeLocations[bufferName];
        if (location === undefined) {
          if (buffer.target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ELEMENT_ARRAY_BUFFER && elements) {
            throw new Error(this._print(bufferName) + ' duplicate GL.ELEMENT_ARRAY_BUFFER');
          } else if (buffer.target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ELEMENT_ARRAY_BUFFER) {
            elements = bufferName;
          } else if (!this._warn[bufferName]) {
            __WEBPACK_IMPORTED_MODULE_7__utils__["log"].warn(2, this._print(bufferName) + ' not used');
            this._warn[bufferName] = true;
          }
        } else {
          if (buffer.target === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ELEMENT_ARRAY_BUFFER) {
            throw new Error(this._print(bufferName) + ':' + location + ' ' + 'has both location and type gl.ELEMENT_ARRAY_BUFFER');
          }
          locations[location] = bufferName;
        }
      }
      return { locations: locations, elements: elements };
    }

    // Check that all active attributes are enabled

  }, {
    key: '_areAllAttributesEnabled',
    value: function _areAllAttributesEnabled() {
      var gl = this.gl;

      var length = this._attributeCount;
      for (var i = 0; i < length; ++i) {
        if (!__WEBPACK_IMPORTED_MODULE_2__vertex_attributes__["isEnabled"](gl, i)) {
          return false;
        }
      }
      return true;
    }

    // determine attribute locations (maps attribute name to index)

  }, {
    key: '_getAttributeLocations',
    value: function _getAttributeLocations() {
      var attributeLocations = {};
      var length = this.getAttributeCount();
      for (var location = 0; location < length; location++) {
        var name = this.getAttributeInfo(location).name;
        attributeLocations[name] = this.getAttributeLocation(name);
      }
      return attributeLocations;
    }

    // create uniform setters
    // Map of uniform names to setter functions

  }, {
    key: '_getUniformSetters',
    value: function _getUniformSetters() {
      var gl = this.gl;

      var uniformSetters = {};
      var length = this.getUniformCount();
      for (var i = 0; i < length; i++) {
        var info = this.getUniformInfo(i);
        var parsedName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__uniforms__["a" /* parseUniformName */])(info.name);
        var location = this.getUniformLocation(parsedName.name);
        uniformSetters[parsedName.name] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__uniforms__["b" /* getUniformSetter */])(gl, location, info, parsedName.isArray);
      }
      return uniformSetters;
    }
  }, {
    key: '_print',
    value: function _print(bufferName) {
      return 'Program ' + this.id + ': Attribute ' + bufferName;
    }
  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createProgram();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
  }, {
    key: '_getOptionsFromHandle',
    value: function _getOptionsFromHandle(handle) {
      var shaderHandles = this.gl.getAttachedShaders(handle);
      var opts = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shaderHandle = _step.value;

          var type = this.gl.getShaderParameter(this.handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SHADER_TYPE);
          switch (type) {
            case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERTEX_SHADER:
              opts.vs = new __WEBPACK_IMPORTED_MODULE_6__shader__["b" /* VertexShader */]({ handle: shaderHandle });
              break;
            case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAGMENT_SHADER:
              opts.fs = new __WEBPACK_IMPORTED_MODULE_6__shader__["c" /* FragmentShader */]({ handle: shaderHandle });
              break;
            default:
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return opts;
    }

    // Return the value for the passed pname given the passed program.
    // The type returned is the natural type for the requested pname,
    // as given in the following table:

  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      // Return default values for WebGL2 parameters under WebGL1
      if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(this.gl)) {
        switch (pname) {
          case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRANSFORM_FEEDBACK_BUFFER_MODE:
            return __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SEPARATE_ATTRIBS;
          case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRANSFORM_FEEDBACK_VARYINGS:
            return 0;
          case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ACTIVE_UNIFORM_BLOCKS:
            return 0;
          default:
        }
      }
      return this.gl.getProgramParameter(this.handle, pname);
    }
  }]);

  return Program;
}(__WEBPACK_IMPORTED_MODULE_3__resource__["a" /* default */]);

// create uniform setters
// Map of uniform names to setter functions


/* harmony default export */ __webpack_exports__["a"] = (Program);
function getUniformDescriptors(gl, program) {
  var uniformDescriptors = {};
  var length = program.getUniformCount();
  for (var i = 0; i < length; i++) {
    var info = program.getUniformInfo(i);
    var location = program.getUniformLocation(info.name);
    var descriptor = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__uniforms__["b" /* getUniformSetter */])(gl, location, info);
    uniformDescriptors[descriptor.name] = descriptor;
  }
  return uniformDescriptors;
}

// Get a map of buffer indices
function getVaryingMap(varyings, bufferMode) {
  var varyingMap = {};
  var index = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = varyings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var varying = _step2.value;

      if (bufferMode === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SEPARATE_ATTRIBS) {
        varyingMap[varyings] = { index: index };
        index++;
      } else if (varying === 'gl_NextBuffer') {
        index++;
      } else {
        // Add a "safe" offset as fallback unless app specifies it
        // Could query
        varyingMap[varyings] = { index: index, offset: 16 };
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return varyingMap;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9wcm9ncmFtLmpzIl0sIm5hbWVzIjpbIkdMIiwiYXNzZXJ0V2ViR0wyQ29udGV4dCIsImlzV2ViR0wyQ29udGV4dCIsIlZlcnRleEF0dHJpYnV0ZXMiLCJSZXNvdXJjZSIsIlRleHR1cmUiLCJwYXJzZVVuaWZvcm1OYW1lIiwiZ2V0VW5pZm9ybVNldHRlciIsIlZlcnRleFNoYWRlciIsIkZyYWdtZW50U2hhZGVyIiwibG9nIiwidWlkIiwiYXNzZXJ0IiwiUHJvZ3JhbSIsImdsIiwib3B0cyIsImluaXRpYWxpemUiLCJPYmplY3QiLCJzZWFsIiwiaWQiLCJwcm9ncmFtTmFtZSIsInZzIiwiZ2V0TmFtZSIsImZzIiwicmVwbGFjZSIsImRlZmF1bHRVbmlmb3JtcyIsInZhcnlpbmdzIiwiYnVmZmVyTW9kZSIsIlNFUEFSQVRFX0FUVFJJQlMiLCJ0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIiwiaGFuZGxlIiwiZ2V0VmFyeWluZ01hcCIsIl9jb21waWxlQW5kTGluayIsIl9hdHRyaWJ1dGVMb2NhdGlvbnMiLCJfZ2V0QXR0cmlidXRlTG9jYXRpb25zIiwiX2F0dHJpYnV0ZUNvdW50IiwiZ2V0QXR0cmlidXRlQ291bnQiLCJfd2FybiIsIl9maWxsZWRMb2NhdGlvbnMiLCJfdW5pZm9ybVNldHRlcnMiLCJfZ2V0VW5pZm9ybVNldHRlcnMiLCJfdW5pZm9ybUNvdW50IiwiZ2V0VW5pZm9ybUNvdW50IiwiX3RleHR1cmVJbmRleENvdW50ZXIiLCJ1c2VQcm9ncmFtIiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhDb3VudCIsIm9mZnNldCIsImlzSW5kZXhlZCIsImluZGV4VHlwZSIsIlVOU0lHTkVEX1NIT1JUIiwiaXNJbnN0YW5jZWQiLCJpbnN0YW5jZUNvdW50IiwidHJhbnNmb3JtRmVlZGJhY2siLCJiZWdpbiIsImV4dGVuc2lvbiIsImdldEV4dGVuc2lvbiIsImRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFIiwiZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFIiwiZHJhd0VsZW1lbnRzIiwiZHJhd0FycmF5cyIsImVuZCIsImJ1ZmZlcnMiLCJjbGVhciIsImNoZWNrIiwiZHJhd1BhcmFtcyIsIl9zb3J0QnVmZmVyc0J5TG9jYXRpb24iLCJsb2NhdGlvbnMiLCJlbGVtZW50cyIsImxvY2F0aW9uIiwibGVuZ3RoIiwiYnVmZmVyTmFtZSIsImJ1ZmZlciIsImRpc2FibGUiLCJkaXZpc29yIiwibGF5b3V0IiwiaW5zdGFuY2VkIiwiZW5hYmxlIiwic2V0QnVmZmVyIiwic2V0RGl2aXNvciIsImJpbmQiLCJ0eXBlIiwiX2NoZWNrQnVmZmVycyIsImkiLCJiaW5kQnVmZmVyIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJ1bmlmb3JtcyIsInNhbXBsZXJzIiwidW5pZm9ybU5hbWUiLCJ1bmlmb3JtIiwidW5pZm9ybVNldHRlciIsInNhbXBsZXIiLCJ0ZXh0dXJlSW5kZXgiLCJ1bmRlZmluZWQiLCJ0ZXh0dXJlIiwiX2dldFBhcmFtZXRlciIsIkFDVElWRV9BVFRSSUJVVEVTIiwiYXR0cmlidXRlTmFtZSIsImdldEF0dHJpYkxvY2F0aW9uIiwiZ2V0QWN0aXZlQXR0cmliIiwiQUNUSVZFX1VOSUZPUk1TIiwiaW5kZXgiLCJnZXRBY3RpdmVVbmlmb3JtIiwibmFtZSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsImdldFVuaWZvcm0iLCJwcm9ncmFtIiwicmVzdWx0IiwiZ2V0VHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nIiwidmFyeWluZ05hbWUiLCJnZXRGcmFnRGF0YUxvY2F0aW9uIiwiZ2V0QXR0YWNoZWRTaGFkZXJzIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJkZWJ1ZyIsInByaW9yaXR5IiwidmFsaWRhdGVQcm9ncmFtIiwibGlua2VkIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiRXJyb3IiLCJnZXRQcm9ncmFtSW5mb0xvZyIsIndhcm4iLCJBcnJheSIsInRhcmdldCIsIl9wcmludCIsImlzRW5hYmxlZCIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImdldEF0dHJpYnV0ZUluZm8iLCJnZXRBdHRyaWJ1dGVMb2NhdGlvbiIsInVuaWZvcm1TZXR0ZXJzIiwiaW5mbyIsImdldFVuaWZvcm1JbmZvIiwicGFyc2VkTmFtZSIsImlzQXJyYXkiLCJjcmVhdGVQcm9ncmFtIiwiZGVsZXRlUHJvZ3JhbSIsInNoYWRlckhhbmRsZXMiLCJzaGFkZXJIYW5kbGUiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJTSEFERVJfVFlQRSIsIlZFUlRFWF9TSEFERVIiLCJGUkFHTUVOVF9TSEFERVIiLCJwbmFtZSIsIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfTU9ERSIsIlRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyIsIkFDVElWRV9VTklGT1JNX0JMT0NLUyIsImdldFVuaWZvcm1EZXNjcmlwdG9ycyIsInVuaWZvcm1EZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJ2YXJ5aW5nTWFwIiwidmFyeWluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLE9BQU9BLEVBQVAsTUFBZSxPQUFmO0FBQ0EsU0FBUUMsbUJBQVIsRUFBNkJDLGVBQTdCLFFBQW1ELFdBQW5EO0FBQ0EsT0FBTyxLQUFLQyxnQkFBWixNQUFrQyxxQkFBbEM7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixXQUFwQjtBQUNBLFNBQVFDLGdCQUFSLEVBQTBCQyxnQkFBMUIsUUFBaUQsWUFBakQ7QUFDQSxTQUFRQyxZQUFSLEVBQXNCQyxjQUF0QixRQUEyQyxVQUEzQztBQUNBLFNBQVFDLEdBQVIsRUFBYUMsR0FBYixRQUF1QixVQUF2QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0lBRXFCQyxPOzs7QUFDbkI7Ozs7Ozs7Ozs7O0FBV0EsbUJBQVlDLEVBQVosRUFBMkI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsa0hBQ25CRCxFQURtQixFQUNmQyxJQURlOztBQUV6QixVQUFLQyxVQUFMLENBQWdCRCxJQUFoQjtBQUNBRSxXQUFPQyxJQUFQOztBQUVBO0FBQ0EsUUFBSSxDQUFDSCxLQUFLSSxFQUFWLEVBQWM7QUFDWixVQUFJQyxjQUFjLE1BQUtDLEVBQUwsQ0FBUUMsT0FBUixNQUFxQixNQUFLQyxFQUFMLENBQVFELE9BQVIsRUFBdkM7QUFDQUYsb0JBQWNBLFlBQVlJLE9BQVosQ0FBb0IsU0FBcEIsRUFBK0IsRUFBL0IsQ0FBZDtBQUNBSixvQkFBY0EsY0FBaUJBLFdBQWpCLGdCQUF5QyxTQUF2RDtBQUNBO0FBQ0EsWUFBS0QsRUFBTCxHQUFVUixJQUFJUyxXQUFKLENBQVY7QUFDRDtBQVp3QjtBQWExQjs7OztpQ0FFc0Y7QUFBQSxxRkFBSixFQUFJO0FBQUEsVUFBM0VDLEVBQTJFLFFBQTNFQSxFQUEyRTtBQUFBLFVBQXZFRSxFQUF1RSxRQUF2RUEsRUFBdUU7QUFBQSxVQUFuRUUsZUFBbUUsUUFBbkVBLGVBQW1FO0FBQUEsVUFBbERDLFFBQWtELFFBQWxEQSxRQUFrRDtBQUFBLGlDQUF4Q0MsVUFBd0M7QUFBQSxVQUF4Q0EsVUFBd0MsbUNBQTNCM0IsR0FBRzRCLGdCQUF3Qjs7QUFDckY7QUFDQSxXQUFLUCxFQUFMLEdBQVUsT0FBT0EsRUFBUCxLQUFjLFFBQWQsR0FBeUIsSUFBSWIsWUFBSixDQUFpQixLQUFLTSxFQUF0QixFQUEwQk8sRUFBMUIsQ0FBekIsR0FBeURBLEVBQW5FO0FBQ0EsV0FBS0UsRUFBTCxHQUFVLE9BQU9BLEVBQVAsS0FBYyxRQUFkLEdBQXlCLElBQUlkLGNBQUosQ0FBbUIsS0FBS0ssRUFBeEIsRUFBNEJTLEVBQTVCLENBQXpCLEdBQTJEQSxFQUFyRTs7QUFFQVgsYUFBTyxLQUFLUyxFQUFMLFlBQW1CYixZQUExQixFQUF3Qyw0QkFBeEM7QUFDQUksYUFBTyxLQUFLVyxFQUFMLFlBQW1CZCxjQUExQixFQUEwQyw4QkFBMUM7O0FBRUEsV0FBS2dCLGVBQUwsR0FBdUJBLGVBQXZCOztBQUVBO0FBQ0EsVUFBSUMsUUFBSixFQUFjO0FBQ1p6Qiw0QkFBb0IsS0FBS2EsRUFBekI7QUFDQSxhQUFLQSxFQUFMLENBQVFlLHlCQUFSLENBQWtDLEtBQUtDLE1BQXZDLEVBQStDSixRQUEvQyxFQUF5REMsVUFBekQ7QUFDQSxhQUFLRCxRQUFMLEdBQWdCSyxjQUFjTCxRQUFkLEVBQXdCQyxVQUF4QixDQUFoQjtBQUNEOztBQUVELFdBQUtLLGVBQUw7O0FBRUE7QUFDQSxXQUFLQyxtQkFBTCxHQUEyQixLQUFLQyxzQkFBTCxFQUEzQjtBQUNBLFdBQUtDLGVBQUwsR0FBdUIsS0FBS0MsaUJBQUwsRUFBdkI7QUFDQSxXQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNBLFdBQUtDLGdCQUFMLEdBQXdCLEVBQXhCOztBQUVBO0FBQ0EsV0FBS0MsZUFBTCxHQUF1QixLQUFLQyxrQkFBTCxFQUF2QjtBQUNBLFdBQUtDLGFBQUwsR0FBcUIsS0FBS0MsZUFBTCxFQUFyQjtBQUNBLFdBQUtDLG9CQUFMLEdBQTRCLENBQTVCOztBQUVBMUIsYUFBT0MsSUFBUCxDQUFZLElBQVo7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7OzswQkFFSztBQUNKLFdBQUtKLEVBQUwsQ0FBUThCLFVBQVIsQ0FBbUIsS0FBS2QsTUFBeEI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7Ozt5QkFDS2hCLEUsU0FTRjtBQUFBLGlDQVJEK0IsUUFRQztBQUFBLFVBUkRBLFFBUUMsa0NBUlU3QyxHQUFHOEMsU0FRYjtBQUFBLFVBUERDLFdBT0MsU0FQREEsV0FPQztBQUFBLCtCQU5EQyxNQU1DO0FBQUEsVUFOREEsTUFNQyxnQ0FOUSxDQU1SO0FBQUEsa0NBTERDLFNBS0M7QUFBQSxVQUxEQSxTQUtDLG1DQUxXLEtBS1g7QUFBQSxrQ0FKREMsU0FJQztBQUFBLFVBSkRBLFNBSUMsbUNBSldsRCxHQUFHbUQsY0FJZDtBQUFBLG9DQUhEQyxXQUdDO0FBQUEsVUFIREEsV0FHQyxxQ0FIYSxLQUdiO0FBQUEsc0NBRkRDLGFBRUM7QUFBQSxVQUZEQSxhQUVDLHVDQUZlLENBRWY7QUFBQSxVQUREQyxpQkFDQyxTQUREQSxpQkFDQzs7QUFDRCxXQUFLeEMsRUFBTCxDQUFROEIsVUFBUixDQUFtQixLQUFLZCxNQUF4Qjs7QUFFQSxVQUFJd0IsaUJBQUosRUFBdUI7QUFDckJBLDBCQUFrQkMsS0FBbEI7QUFDRDs7QUFFRCxVQUFNQyxZQUFZMUMsR0FBRzJDLFlBQUgsQ0FBZ0Isd0JBQWhCLENBQWxCOztBQUVBO0FBQ0EsVUFBSUwsZUFBZUgsU0FBbkIsRUFBOEI7QUFDNUJPLGtCQUFVRSwwQkFBVixDQUNFYixRQURGLEVBQ1lFLFdBRFosRUFDeUJHLFNBRHpCLEVBQ29DRixNQURwQyxFQUM0Q0ssYUFENUM7QUFHRCxPQUpELE1BSU8sSUFBSUQsV0FBSixFQUFpQjtBQUN0Qkksa0JBQVVHLHdCQUFWLENBQ0VkLFFBREYsRUFDWUcsTUFEWixFQUNvQkQsV0FEcEIsRUFDaUNNLGFBRGpDO0FBR0QsT0FKTSxNQUlBLElBQUlKLFNBQUosRUFBZTtBQUNwQm5DLFdBQUc4QyxZQUFILENBQWdCZixRQUFoQixFQUEwQkUsV0FBMUIsRUFBdUNHLFNBQXZDLEVBQWtERixNQUFsRDtBQUNELE9BRk0sTUFFQTtBQUNMbEMsV0FBRytDLFVBQUgsQ0FBY2hCLFFBQWQsRUFBd0JHLE1BQXhCLEVBQWdDRCxXQUFoQztBQUNEOztBQUVELFVBQUlPLGlCQUFKLEVBQXVCO0FBQ3JCQSwwQkFBa0JRLEdBQWxCO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7OytCQUNXQyxPLEVBQTZEO0FBQUEsc0ZBQUosRUFBSTtBQUFBLDhCQUFuREMsS0FBbUQ7QUFBQSxVQUFuREEsS0FBbUQsK0JBQTNDLElBQTJDO0FBQUEsOEJBQXJDQyxLQUFxQztBQUFBLFVBQXJDQSxLQUFxQywrQkFBN0IsSUFBNkI7QUFBQSxtQ0FBdkJDLFVBQXVCO0FBQUEsVUFBdkJBLFVBQXVCLG9DQUFWLEVBQVU7O0FBQ3RFLFVBQUlGLEtBQUosRUFBVztBQUNULGFBQUsxQixnQkFBTCxHQUF3QixFQUF4QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTRCLGlCQUFXZCxXQUFYLEdBQXlCLEtBQXpCO0FBQ0FjLGlCQUFXakIsU0FBWCxHQUF1QixLQUF2QjtBQUNBaUIsaUJBQVdoQixTQUFYLEdBQXVCLElBQXZCOztBQVRzRSxrQ0FXeEMsS0FBS2lCLHNCQUFMLENBQTRCSixPQUE1QixDQVh3QztBQUFBLFVBVy9ESyxTQVgrRCx5QkFXL0RBLFNBWCtEO0FBQUEsVUFXcERDLFFBWG9ELHlCQVdwREEsUUFYb0Q7O0FBQUEsVUFhL0R2RCxFQWIrRCxHQWF6RCxJQWJ5RCxDQWEvREEsRUFiK0Q7O0FBZXRFOztBQUNBLFdBQUssSUFBSXdELFdBQVcsQ0FBcEIsRUFBdUJBLFdBQVdGLFVBQVVHLE1BQTVDLEVBQW9ELEVBQUVELFFBQXRELEVBQWdFO0FBQzlELFlBQU1FLGFBQWFKLFVBQVVFLFFBQVYsQ0FBbkI7QUFDQSxZQUFNRyxTQUFTVixRQUFRUyxVQUFSLENBQWY7QUFDQTtBQUNBLFlBQUksQ0FBQ0MsTUFBTCxFQUFhO0FBQ1h0RSwyQkFBaUJ1RSxPQUFqQixDQUF5QjVELEVBQXpCLEVBQTZCd0QsUUFBN0I7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFNSyxVQUFVRixPQUFPRyxNQUFQLENBQWNDLFNBQWQsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBOUM7QUFDQTFFLDJCQUFpQjJFLE1BQWpCLENBQXdCaEUsRUFBeEIsRUFBNEJ3RCxRQUE1QjtBQUNBbkUsMkJBQWlCNEUsU0FBakIsQ0FBMkIsRUFBQ2pFLE1BQUQsRUFBS3dELGtCQUFMLEVBQWVHLGNBQWYsRUFBM0I7QUFDQXRFLDJCQUFpQjZFLFVBQWpCLENBQTRCbEUsRUFBNUIsRUFBZ0N3RCxRQUFoQyxFQUEwQ0ssT0FBMUM7QUFDQVQscUJBQVdkLFdBQVgsR0FBeUJxQixPQUFPRyxNQUFQLENBQWNDLFNBQWQsR0FBMEIsQ0FBbkQ7QUFDQSxlQUFLdkMsZ0JBQUwsQ0FBc0JrQyxVQUF0QixJQUFvQyxJQUFwQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFJSCxRQUFKLEVBQWM7QUFDWixZQUFNSSxVQUFTVixRQUFRTSxRQUFSLENBQWY7QUFDQUksZ0JBQU9RLElBQVA7QUFDQWYsbUJBQVdqQixTQUFYLEdBQXVCLElBQXZCO0FBQ0FpQixtQkFBV2hCLFNBQVgsR0FBdUJ1QixRQUFPRyxNQUFQLENBQWNNLElBQXJDO0FBQ0Q7O0FBRUQsVUFBSWpCLEtBQUosRUFBVztBQUNULGFBQUtrQixhQUFMO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7QUFDRDs7QUFFQTs7Ozs7O21DQUdlO0FBQ2IsVUFBTVosU0FBUyxLQUFLcEMsZUFBcEI7QUFDQSxXQUFLLElBQUlpRCxJQUFJLENBQWIsRUFBZ0JBLElBQUliLE1BQXBCLEVBQTRCLEVBQUVhLENBQTlCLEVBQWlDO0FBQy9CO0FBQ0FqRix5QkFBaUJ1RSxPQUFqQixDQUF5QixLQUFLNUQsRUFBOUIsRUFBa0NzRSxDQUFsQztBQUNEOztBQUVEO0FBQ0EsV0FBS3RFLEVBQUwsQ0FBUXVFLFVBQVIsQ0FBbUJyRixHQUFHc0Ysb0JBQXRCLEVBQTRDLElBQTVDO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7O2dDQUNZQyxRLEVBQXlCO0FBQUEsVUFBZkMsUUFBZSx1RUFBSixFQUFJOztBQUNuQyxXQUFLLElBQU1DLFdBQVgsSUFBMEJGLFFBQTFCLEVBQW9DO0FBQ2xDLFlBQU1HLFVBQVVILFNBQVNFLFdBQVQsQ0FBaEI7QUFDQSxZQUFNRSxnQkFBZ0IsS0FBS3BELGVBQUwsQ0FBcUJrRCxXQUFyQixDQUF0QjtBQUNBLFlBQU1HLFVBQVVKLFNBQVNDLFdBQVQsQ0FBaEI7O0FBRUEsWUFBSUUsYUFBSixFQUFtQjtBQUNqQixjQUFJRCxtQkFBbUJyRixPQUF2QixFQUFnQztBQUM5QixnQkFBSXNGLGNBQWNFLFlBQWQsS0FBK0JDLFNBQW5DLEVBQThDO0FBQzVDSCw0QkFBY0UsWUFBZCxHQUE2QixLQUFLbEQsb0JBQUwsRUFBN0I7QUFDRDs7QUFFRDtBQUNBLGdCQUFNb0QsVUFBVUwsT0FBaEI7QUFOOEIsZ0JBT3ZCRyxZQVB1QixHQU9QRixhQVBPLENBT3ZCRSxZQVB1Qjs7O0FBUzlCRSxvQkFBUWQsSUFBUixDQUFhWSxZQUFiOztBQUVBO0FBQ0EsZ0JBQUlELE9BQUosRUFBYTtBQUNYQSxzQkFBUVgsSUFBUixDQUFhWSxZQUFiO0FBQ0Q7O0FBRUQ7QUFDQUYsMEJBQWNFLFlBQWQ7QUFDRCxXQWxCRCxNQWtCTztBQUNMO0FBQ0FGLDBCQUFjRCxPQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGFBQU8sSUFBUDtBQUNEO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7d0NBS29CO0FBQ2xCLGFBQU8sS0FBS00sYUFBTCxDQUFtQmhHLEdBQUdpRyxpQkFBdEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7eUNBTXFCQyxhLEVBQWU7QUFDbEMsYUFBTyxLQUFLcEYsRUFBTCxDQUFRcUYsaUJBQVIsQ0FBMEIsS0FBS3JFLE1BQS9CLEVBQXVDb0UsYUFBdkMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7cUNBTWlCNUIsUSxFQUFVO0FBQ3pCLGFBQU8sS0FBS3hELEVBQUwsQ0FBUXNGLGVBQVIsQ0FBd0IsS0FBS3RFLE1BQTdCLEVBQXFDd0MsUUFBckMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztzQ0FLa0I7QUFDaEIsYUFBTyxLQUFLMEIsYUFBTCxDQUFtQmhHLEdBQUdxRyxlQUF0QixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OzttQ0FHZUMsSyxFQUFPO0FBQ3BCLGFBQU8sS0FBS3hGLEVBQUwsQ0FBUXlGLGdCQUFSLENBQXlCLEtBQUt6RSxNQUE5QixFQUFzQ3dFLEtBQXRDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozt1Q0FJbUJFLEksRUFBTTtBQUN2QixhQUFPLEtBQUsxRixFQUFMLENBQVEyRixrQkFBUixDQUEyQixLQUFLM0UsTUFBaEMsRUFBd0MwRSxJQUF4QyxDQUFQO0FBQ0Q7OztvQ0FFZWxDLFEsRUFBVTtBQUN4QixhQUFPLEtBQUt4RCxFQUFMLENBQVE0RixVQUFSLENBQW1CLEtBQUs1RSxNQUF4QixFQUFnQ3dDLFFBQWhDLENBQVA7QUFDRDs7QUFFRDtBQUNBOzs7Ozs7OytCQUlXcUMsTyxFQUFTTCxLLEVBQU87QUFDekIsVUFBTU0sU0FBUyxLQUFLOUYsRUFBTCxDQUFRK0YsMkJBQVIsQ0FBb0NGLE9BQXBDLEVBQTZDTCxLQUE3QyxDQUFmO0FBQ0EsYUFBT00sTUFBUDtBQUNEOztBQUVEO0FBQ0E7Ozs7d0NBQ29CRSxXLEVBQWE7QUFDL0I3RywwQkFBb0IsS0FBS2EsRUFBekI7QUFDQSxhQUFPLEtBQUtBLEVBQUwsQ0FBUWlHLG1CQUFSLENBQTRCLEtBQUtqRixNQUFqQyxFQUF5Q2dGLFdBQXpDLENBQVA7QUFDRDs7QUFFRDs7Ozt5Q0FDcUI7QUFDbkIsYUFBTyxLQUFLaEcsRUFBTCxDQUFRa0csa0JBQVIsQ0FBMkIsS0FBS2xGLE1BQWhDLENBQVA7QUFDRDs7QUFFRDs7OztzQ0FFa0I7QUFBQSxVQUNUaEIsRUFEUyxHQUNILElBREcsQ0FDVEEsRUFEUzs7QUFFaEJBLFNBQUdtRyxZQUFILENBQWdCLEtBQUtuRixNQUFyQixFQUE2QixLQUFLVCxFQUFMLENBQVFTLE1BQXJDO0FBQ0FoQixTQUFHbUcsWUFBSCxDQUFnQixLQUFLbkYsTUFBckIsRUFBNkIsS0FBS1AsRUFBTCxDQUFRTyxNQUFyQztBQUNBaEIsU0FBR29HLFdBQUgsQ0FBZSxLQUFLcEYsTUFBcEI7O0FBRUE7QUFDQSxVQUFJaEIsR0FBR3FHLEtBQUgsSUFBWXpHLElBQUkwRyxRQUFKLEdBQWUsQ0FBL0IsRUFBa0M7QUFDaEN0RyxXQUFHdUcsZUFBSCxDQUFtQixLQUFLdkYsTUFBeEI7QUFDQSxZQUFNd0YsU0FBU3hHLEdBQUd5RyxtQkFBSCxDQUF1QixLQUFLekYsTUFBNUIsRUFBb0NoQixHQUFHMEcsV0FBdkMsQ0FBZjtBQUNBLFlBQUksQ0FBQ0YsTUFBTCxFQUFhO0FBQ1gsZ0JBQU0sSUFBSUcsS0FBSixvQkFBMkIzRyxHQUFHNEcsaUJBQUgsQ0FBcUIsS0FBSzVGLE1BQTFCLENBQTNCLENBQU47QUFDRDtBQUNGO0FBQ0Y7OztvQ0FFZTtBQUNkLFdBQUssSUFBTW9FLGFBQVgsSUFBNEIsS0FBS2pFLG1CQUFqQyxFQUFzRDtBQUNwRCxZQUFJLENBQUMsS0FBS0ssZ0JBQUwsQ0FBc0I0RCxhQUF0QixDQUFELElBQXlDLENBQUMsS0FBSzdELEtBQUwsQ0FBVzZELGFBQVgsQ0FBOUMsRUFBeUU7QUFDdkUsY0FBTTVCLFdBQVcsS0FBS3JDLG1CQUFMLENBQXlCaUUsYUFBekIsQ0FBakI7QUFDQTtBQUNBO0FBQ0F4RixjQUFJaUgsSUFBSixDQUFTLENBQVQsZUFBdUIsS0FBS3hHLEVBQTVCLG9CQUE2Q21ELFFBQTdDLFNBQXlENEIsYUFBekQ7QUFDQSxlQUFLN0QsS0FBTCxDQUFXNkQsYUFBWCxJQUE0QixJQUE1QjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7OzJDQUVzQm5DLE8sRUFBUztBQUM5QixVQUFJTSxXQUFXLElBQWY7QUFDQSxVQUFNRCxZQUFZLElBQUl3RCxLQUFKLENBQVUsS0FBS3pGLGVBQWYsQ0FBbEI7O0FBRUEsV0FBSyxJQUFNcUMsVUFBWCxJQUF5QlQsT0FBekIsRUFBa0M7QUFDaEMsWUFBTVUsU0FBU1YsUUFBUVMsVUFBUixDQUFmO0FBQ0EsWUFBTUYsV0FBVyxLQUFLckMsbUJBQUwsQ0FBeUJ1QyxVQUF6QixDQUFqQjtBQUNBLFlBQUlGLGFBQWF3QixTQUFqQixFQUE0QjtBQUMxQixjQUFJckIsT0FBT29ELE1BQVAsS0FBa0I3SCxHQUFHc0Ysb0JBQXJCLElBQTZDakIsUUFBakQsRUFBMkQ7QUFDekQsa0JBQU0sSUFBSW9ELEtBQUosQ0FBYSxLQUFLSyxNQUFMLENBQVl0RCxVQUFaLENBQWIsd0NBQU47QUFDRCxXQUZELE1BRU8sSUFBSUMsT0FBT29ELE1BQVAsS0FBa0I3SCxHQUFHc0Ysb0JBQXpCLEVBQStDO0FBQ3BEakIsdUJBQVdHLFVBQVg7QUFDRCxXQUZNLE1BRUEsSUFBSSxDQUFDLEtBQUtuQyxLQUFMLENBQVdtQyxVQUFYLENBQUwsRUFBNkI7QUFDbEM5RCxnQkFBSWlILElBQUosQ0FBUyxDQUFULEVBQWUsS0FBS0csTUFBTCxDQUFZdEQsVUFBWixDQUFmO0FBQ0EsaUJBQUtuQyxLQUFMLENBQVdtQyxVQUFYLElBQXlCLElBQXpCO0FBQ0Q7QUFDRixTQVRELE1BU087QUFDTCxjQUFJQyxPQUFPb0QsTUFBUCxLQUFrQjdILEdBQUdzRixvQkFBekIsRUFBK0M7QUFDN0Msa0JBQU0sSUFBSW1DLEtBQUosQ0FBYSxLQUFLSyxNQUFMLENBQVl0RCxVQUFaLENBQUgsU0FBOEJGLFFBQTlCLFNBQ2Qsb0RBREksQ0FBTjtBQUVEO0FBQ0RGLG9CQUFVRSxRQUFWLElBQXNCRSxVQUF0QjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLEVBQUNKLG9CQUFELEVBQVlDLGtCQUFaLEVBQVA7QUFDRDs7QUFFRDs7OzsrQ0FDMkI7QUFBQSxVQUNsQnZELEVBRGtCLEdBQ1osSUFEWSxDQUNsQkEsRUFEa0I7O0FBRXpCLFVBQU15RCxTQUFTLEtBQUtwQyxlQUFwQjtBQUNBLFdBQUssSUFBSWlELElBQUksQ0FBYixFQUFnQkEsSUFBSWIsTUFBcEIsRUFBNEIsRUFBRWEsQ0FBOUIsRUFBaUM7QUFDL0IsWUFBSSxDQUFDakYsaUJBQWlCNEgsU0FBakIsQ0FBMkJqSCxFQUEzQixFQUErQnNFLENBQS9CLENBQUwsRUFBd0M7QUFDdEMsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs2Q0FDeUI7QUFDdkIsVUFBTTRDLHFCQUFxQixFQUEzQjtBQUNBLFVBQU16RCxTQUFTLEtBQUtuQyxpQkFBTCxFQUFmO0FBQ0EsV0FBSyxJQUFJa0MsV0FBVyxDQUFwQixFQUF1QkEsV0FBV0MsTUFBbEMsRUFBMENELFVBQTFDLEVBQXNEO0FBQ3BELFlBQU1rQyxPQUFPLEtBQUt5QixnQkFBTCxDQUFzQjNELFFBQXRCLEVBQWdDa0MsSUFBN0M7QUFDQXdCLDJCQUFtQnhCLElBQW5CLElBQTJCLEtBQUswQixvQkFBTCxDQUEwQjFCLElBQTFCLENBQTNCO0FBQ0Q7QUFDRCxhQUFPd0Isa0JBQVA7QUFDRDs7QUFFRDtBQUNBOzs7O3lDQUNxQjtBQUFBLFVBQ1psSCxFQURZLEdBQ04sSUFETSxDQUNaQSxFQURZOztBQUVuQixVQUFNcUgsaUJBQWlCLEVBQXZCO0FBQ0EsVUFBTTVELFNBQVMsS0FBSzdCLGVBQUwsRUFBZjtBQUNBLFdBQUssSUFBSTBDLElBQUksQ0FBYixFQUFnQkEsSUFBSWIsTUFBcEIsRUFBNEJhLEdBQTVCLEVBQWlDO0FBQy9CLFlBQU1nRCxPQUFPLEtBQUtDLGNBQUwsQ0FBb0JqRCxDQUFwQixDQUFiO0FBQ0EsWUFBTWtELGFBQWFoSSxpQkFBaUI4SCxLQUFLNUIsSUFBdEIsQ0FBbkI7QUFDQSxZQUFNbEMsV0FBVyxLQUFLbUMsa0JBQUwsQ0FBd0I2QixXQUFXOUIsSUFBbkMsQ0FBakI7QUFDQTJCLHVCQUFlRyxXQUFXOUIsSUFBMUIsSUFDRWpHLGlCQUFpQk8sRUFBakIsRUFBcUJ3RCxRQUFyQixFQUErQjhELElBQS9CLEVBQXFDRSxXQUFXQyxPQUFoRCxDQURGO0FBRUQ7QUFDRCxhQUFPSixjQUFQO0FBQ0Q7OzsyQkFFTTNELFUsRUFBWTtBQUNqQiwwQkFBa0IsS0FBS3JELEVBQXZCLG9CQUF3Q3FELFVBQXhDO0FBQ0Q7OztvQ0FFZTtBQUNkLGFBQU8sS0FBSzFELEVBQUwsQ0FBUTBILGFBQVIsRUFBUDtBQUNEOzs7b0NBRWU7QUFDZCxXQUFLMUgsRUFBTCxDQUFRMkgsYUFBUixDQUFzQixLQUFLM0csTUFBM0I7QUFDRDs7OzBDQUVxQkEsTSxFQUFRO0FBQzVCLFVBQU00RyxnQkFBZ0IsS0FBSzVILEVBQUwsQ0FBUWtHLGtCQUFSLENBQTJCbEYsTUFBM0IsQ0FBdEI7QUFDQSxVQUFNZixPQUFPLEVBQWI7QUFGNEI7QUFBQTtBQUFBOztBQUFBO0FBRzVCLDZCQUEyQjJILGFBQTNCLDhIQUEwQztBQUFBLGNBQS9CQyxZQUErQjs7QUFDeEMsY0FBTXpELE9BQU8sS0FBS3BFLEVBQUwsQ0FBUThILGtCQUFSLENBQTJCLEtBQUs5RyxNQUFoQyxFQUF3QzlCLEdBQUc2SSxXQUEzQyxDQUFiO0FBQ0Esa0JBQVEzRCxJQUFSO0FBQ0EsaUJBQUtsRixHQUFHOEksYUFBUjtBQUNFL0gsbUJBQUtNLEVBQUwsR0FBVSxJQUFJYixZQUFKLENBQWlCLEVBQUNzQixRQUFRNkcsWUFBVCxFQUFqQixDQUFWO0FBQ0E7QUFDRixpQkFBSzNJLEdBQUcrSSxlQUFSO0FBQ0VoSSxtQkFBS1EsRUFBTCxHQUFVLElBQUlkLGNBQUosQ0FBbUIsRUFBQ3FCLFFBQVE2RyxZQUFULEVBQW5CLENBQVY7QUFDQTtBQUNGO0FBUEE7QUFTRDtBQWQyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWU1QixhQUFPNUgsSUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7OztrQ0FDY2lJLEssRUFBTztBQUNuQjtBQUNBLFVBQUksQ0FBQzlJLGdCQUFnQixLQUFLWSxFQUFyQixDQUFMLEVBQStCO0FBQzdCLGdCQUFRa0ksS0FBUjtBQUNBLGVBQUtoSixHQUFHaUosOEJBQVI7QUFBd0MsbUJBQU9qSixHQUFHNEIsZ0JBQVY7QUFDeEMsZUFBSzVCLEdBQUdrSiwyQkFBUjtBQUFxQyxtQkFBTyxDQUFQO0FBQ3JDLGVBQUtsSixHQUFHbUoscUJBQVI7QUFBK0IsbUJBQU8sQ0FBUDtBQUMvQjtBQUpBO0FBTUQ7QUFDRCxhQUFPLEtBQUtySSxFQUFMLENBQVF5RyxtQkFBUixDQUE0QixLQUFLekYsTUFBakMsRUFBeUNrSCxLQUF6QyxDQUFQO0FBQ0Q7Ozs7RUF4Y2tDNUksUTs7QUEyY3JDO0FBQ0E7OztlQTVjcUJTLE87QUE2Y3JCLE9BQU8sU0FBU3VJLHFCQUFULENBQStCdEksRUFBL0IsRUFBbUM2RixPQUFuQyxFQUE0QztBQUNqRCxNQUFNMEMscUJBQXFCLEVBQTNCO0FBQ0EsTUFBTTlFLFNBQVNvQyxRQUFRakUsZUFBUixFQUFmO0FBQ0EsT0FBSyxJQUFJMEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJYixNQUFwQixFQUE0QmEsR0FBNUIsRUFBaUM7QUFDL0IsUUFBTWdELE9BQU96QixRQUFRMEIsY0FBUixDQUF1QmpELENBQXZCLENBQWI7QUFDQSxRQUFNZCxXQUFXcUMsUUFBUUYsa0JBQVIsQ0FBMkIyQixLQUFLNUIsSUFBaEMsQ0FBakI7QUFDQSxRQUFNOEMsYUFBYS9JLGlCQUFpQk8sRUFBakIsRUFBcUJ3RCxRQUFyQixFQUErQjhELElBQS9CLENBQW5CO0FBQ0FpQix1QkFBbUJDLFdBQVc5QyxJQUE5QixJQUFzQzhDLFVBQXRDO0FBQ0Q7QUFDRCxTQUFPRCxrQkFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBTyxTQUFTdEgsYUFBVCxDQUF1QkwsUUFBdkIsRUFBaUNDLFVBQWpDLEVBQTZDO0FBQ2xELE1BQU00SCxhQUFhLEVBQW5CO0FBQ0EsTUFBSWpELFFBQVEsQ0FBWjtBQUZrRDtBQUFBO0FBQUE7O0FBQUE7QUFHbEQsMEJBQXNCNUUsUUFBdEIsbUlBQWdDO0FBQUEsVUFBckI4SCxPQUFxQjs7QUFDOUIsVUFBSTdILGVBQWUzQixHQUFHNEIsZ0JBQXRCLEVBQXdDO0FBQ3RDMkgsbUJBQVc3SCxRQUFYLElBQXVCLEVBQUM0RSxZQUFELEVBQXZCO0FBQ0FBO0FBQ0QsT0FIRCxNQUdPLElBQUlrRCxZQUFZLGVBQWhCLEVBQWlDO0FBQ3RDbEQ7QUFDRCxPQUZNLE1BRUE7QUFDTDtBQUNBO0FBQ0FpRCxtQkFBVzdILFFBQVgsSUFBdUIsRUFBQzRFLFlBQUQsRUFBUXRELFFBQVEsRUFBaEIsRUFBdkI7QUFDRDtBQUNGO0FBZGlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZWxELFNBQU91RyxVQUFQO0FBQ0QiLCJmaWxlIjoicHJvZ3JhbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWlubGluZS1jb21tZW50cyAqL1xuaW1wb3J0IEdMIGZyb20gJy4vYXBpJztcbmltcG9ydCB7YXNzZXJ0V2ViR0wyQ29udGV4dCwgaXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0ICogYXMgVmVydGV4QXR0cmlidXRlcyBmcm9tICcuL3ZlcnRleC1hdHRyaWJ1dGVzJztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5pbXBvcnQge3BhcnNlVW5pZm9ybU5hbWUsIGdldFVuaWZvcm1TZXR0ZXJ9IGZyb20gJy4vdW5pZm9ybXMnO1xuaW1wb3J0IHtWZXJ0ZXhTaGFkZXIsIEZyYWdtZW50U2hhZGVyfSBmcm9tICcuL3NoYWRlcic7XG5pbXBvcnQge2xvZywgdWlkfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyYW0gZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogSGFuZGxlcyBjcmVhdGlvbiBvZiBwcm9ncmFtcywgbWFwcGluZyBvZiBhdHRyaWJ1dGVzIGFuZCB1bmlmb3Jtc1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gZ2wgY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMudnMgLSBWZXJ0ZXggc2hhZGVyIHNvdXJjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5mcyAtIEZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuaWQ9IC0gSWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzID0ge30pIHtcbiAgICBzdXBlcihnbCwgb3B0cyk7XG4gICAgdGhpcy5pbml0aWFsaXplKG9wdHMpO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuXG4gICAgLy8gSWYgcHJvZ3JhbSBpcyBub3QgbmFtZWQsIG5hbWUgaXQgYWZ0ZXIgc2hhZGVyIG5hbWVzXG4gICAgaWYgKCFvcHRzLmlkKSB7XG4gICAgICBsZXQgcHJvZ3JhbU5hbWUgPSB0aGlzLnZzLmdldE5hbWUoKSB8fCB0aGlzLmZzLmdldE5hbWUoKTtcbiAgICAgIHByb2dyYW1OYW1lID0gcHJvZ3JhbU5hbWUucmVwbGFjZSgvc2hhZGVyL2ksICcnKTtcbiAgICAgIHByb2dyYW1OYW1lID0gcHJvZ3JhbU5hbWUgPyBgJHtwcm9ncmFtTmFtZX0tcHJvZ3JhbWAgOiAncHJvZ3JhbSc7XG4gICAgICAvLyBUT0RPIC0gdGhpcy5pZCB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGluaXRpYWxpemVkXG4gICAgICB0aGlzLmlkID0gdWlkKHByb2dyYW1OYW1lKTtcbiAgICB9XG4gIH1cblxuICBpbml0aWFsaXplKHt2cywgZnMsIGRlZmF1bHRVbmlmb3JtcywgdmFyeWluZ3MsIGJ1ZmZlck1vZGUgPSBHTC5TRVBBUkFURV9BVFRSSUJTfSA9IHt9KSB7XG4gICAgLy8gQ3JlYXRlIHNoYWRlcnMgaWYgbmVlZGVkXG4gICAgdGhpcy52cyA9IHR5cGVvZiB2cyA9PT0gJ3N0cmluZycgPyBuZXcgVmVydGV4U2hhZGVyKHRoaXMuZ2wsIHZzKSA6IHZzO1xuICAgIHRoaXMuZnMgPSB0eXBlb2YgZnMgPT09ICdzdHJpbmcnID8gbmV3IEZyYWdtZW50U2hhZGVyKHRoaXMuZ2wsIGZzKSA6IGZzO1xuXG4gICAgYXNzZXJ0KHRoaXMudnMgaW5zdGFuY2VvZiBWZXJ0ZXhTaGFkZXIsICdQcm9ncmFtOiBiYWQgdmVydGV4IHNoYWRlcicpO1xuICAgIGFzc2VydCh0aGlzLmZzIGluc3RhbmNlb2YgRnJhZ21lbnRTaGFkZXIsICdQcm9ncmFtOiBiYWQgZnJhZ21lbnQgc2hhZGVyJyk7XG5cbiAgICB0aGlzLmRlZmF1bHRVbmlmb3JtcyA9IGRlZmF1bHRVbmlmb3JtcztcblxuICAgIC8vIFNldHVwIHZhcnlpbmdzIGlmIHN1cHBsaWVkXG4gICAgaWYgKHZhcnlpbmdzKSB7XG4gICAgICBhc3NlcnRXZWJHTDJDb250ZXh0KHRoaXMuZ2wpO1xuICAgICAgdGhpcy5nbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKHRoaXMuaGFuZGxlLCB2YXJ5aW5ncywgYnVmZmVyTW9kZSk7XG4gICAgICB0aGlzLnZhcnlpbmdzID0gZ2V0VmFyeWluZ01hcCh2YXJ5aW5ncywgYnVmZmVyTW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29tcGlsZUFuZExpbmsoKTtcblxuICAgIC8vIGRldGVybWluZSBhdHRyaWJ1dGUgbG9jYXRpb25zIChpLmUuIGluZGljZXMpXG4gICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zID0gdGhpcy5fZ2V0QXR0cmlidXRlTG9jYXRpb25zKCk7XG4gICAgdGhpcy5fYXR0cmlidXRlQ291bnQgPSB0aGlzLmdldEF0dHJpYnV0ZUNvdW50KCk7XG4gICAgdGhpcy5fd2FybiA9IFtdO1xuICAgIHRoaXMuX2ZpbGxlZExvY2F0aW9ucyA9IHt9O1xuXG4gICAgLy8gcHJlcGFyZSB1bmlmb3JtIHNldHRlcnNcbiAgICB0aGlzLl91bmlmb3JtU2V0dGVycyA9IHRoaXMuX2dldFVuaWZvcm1TZXR0ZXJzKCk7XG4gICAgdGhpcy5fdW5pZm9ybUNvdW50ID0gdGhpcy5nZXRVbmlmb3JtQ291bnQoKTtcbiAgICB0aGlzLl90ZXh0dXJlSW5kZXhDb3VudGVyID0gMDtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1c2UoKSB7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEEgZ29vZCB0aGluZyBhYm91dCB3ZWJHTCBpcyB0aGF0IHRoZXJlIGFyZSBzbyBtYW55IHdheXMgdG8gZHJhdyB0aGluZ3MsXG4gIC8vIGUuZy4gZGVwZW5kaW5nIG9uIHdoZXRoZXIgZGF0YSBpcyBpbmRleGVkIGFuZC9vciBpc0luc3RhbmNlZC5cbiAgLy8gVGhpcyBmdW5jdGlvbiB1bmlmaWVzIHRob3NlIGludG8gYSBzaW5nbGUgY2FsbCB3aXRoIHNpbXBsZSBwYXJhbWV0ZXJzXG4gIC8vIHRoYXQgaGF2ZSBzYW5lIGRlZmF1bHRzLlxuICBkcmF3KGdsLCB7XG4gICAgZHJhd01vZGUgPSBHTC5UUklBTkdMRVMsXG4gICAgdmVydGV4Q291bnQsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpc0luZGV4ZWQgPSBmYWxzZSxcbiAgICBpbmRleFR5cGUgPSBHTC5VTlNJR05FRF9TSE9SVCxcbiAgICBpc0luc3RhbmNlZCA9IGZhbHNlLFxuICAgIGluc3RhbmNlQ291bnQgPSAwLFxuICAgIHRyYW5zZm9ybUZlZWRiYWNrXG4gIH0pIHtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5oYW5kbGUpO1xuXG4gICAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrKSB7XG4gICAgICB0cmFuc2Zvcm1GZWVkYmFjay5iZWdpbigpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXG4gICAgLy8gVE9ETyAtIFVzZSBwb2x5ZmlsbGVkIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgaW5zdGVhZCBvZiBBTkdMRSBleHRlbnNpb25cbiAgICBpZiAoaXNJbnN0YW5jZWQgJiYgaXNJbmRleGVkKSB7XG4gICAgICBleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoXG4gICAgICAgIGRyYXdNb2RlLCB2ZXJ0ZXhDb3VudCwgaW5kZXhUeXBlLCBvZmZzZXQsIGluc3RhbmNlQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0luc3RhbmNlZCkge1xuICAgICAgZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShcbiAgICAgICAgZHJhd01vZGUsIG9mZnNldCwgdmVydGV4Q291bnQsIGluc3RhbmNlQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0luZGV4ZWQpIHtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyhkcmF3TW9kZSwgdmVydGV4Q291bnQsIGluZGV4VHlwZSwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZHJhd0FycmF5cyhkcmF3TW9kZSwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrKSB7XG4gICAgICB0cmFuc2Zvcm1GZWVkYmFjay5lbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBtYXAgb2YgQnVmZmVycyB2YWx1ZXMgdG8gYSBwcm9ncmFtXG4gICAqIE9ubHkgYXR0cmlidXRlcyB3aXRoIG5hbWVzIGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIGxpbmtlZCBwcm9ncmFtXG4gICAqIHdpbGwgYmUgdXBkYXRlZC4gT3RoZXIgc3VwcGxpZWQgYnVmZmVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBidWZmZXJzIC0gQW4gb2JqZWN0IG1hcCB3aXRoIGF0dHJpYnV0ZSBuYW1lcyBiZWluZyBrZXlzXG4gICAqICBhbmQgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZSBpbnN0YW5jZXMgb2YgQnVmZmVyLlxuICAgKiBAcmV0dXJucyB7UHJvZ3JhbX0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgc2V0QnVmZmVycyhidWZmZXJzLCB7Y2xlYXIgPSB0cnVlLCBjaGVjayA9IHRydWUsIGRyYXdQYXJhbXMgPSB7fX0gPSB7fSkge1xuICAgIGlmIChjbGVhcikge1xuICAgICAgdGhpcy5fZmlsbGVkTG9jYXRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gaW5kZXhpbmcgaXMgYXV0b2RldGVjdGVkIC0gYnVmZmVyIHdpdGggdGFyZ2V0IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSXG4gICAgLy8gaW5kZXggdHlwZSBpcyBzYXZlZCBmb3IgZHJhd0VsZW1lbnQgY2FsbHNcbiAgICBkcmF3UGFyYW1zLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgZHJhd1BhcmFtcy5pc0luZGV4ZWQgPSBmYWxzZTtcbiAgICBkcmF3UGFyYW1zLmluZGV4VHlwZSA9IG51bGw7XG5cbiAgICBjb25zdCB7bG9jYXRpb25zLCBlbGVtZW50c30gPSB0aGlzLl9zb3J0QnVmZmVyc0J5TG9jYXRpb24oYnVmZmVycyk7XG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcblxuICAgIC8vIFByb2Nlc3MgbG9jYXRpb25zIGluIG9yZGVyXG4gICAgZm9yIChsZXQgbG9jYXRpb24gPSAwOyBsb2NhdGlvbiA8IGxvY2F0aW9ucy5sZW5ndGg7ICsrbG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IGJ1ZmZlck5hbWUgPSBsb2NhdGlvbnNbbG9jYXRpb25dO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tidWZmZXJOYW1lXTtcbiAgICAgIC8vIERJU0FCTEUgTUlTU0lORyBBVFRSSUJVVEVcbiAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgIFZlcnRleEF0dHJpYnV0ZXMuZGlzYWJsZShnbCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IGJ1ZmZlci5sYXlvdXQuaW5zdGFuY2VkID8gMSA6IDA7XG4gICAgICAgIFZlcnRleEF0dHJpYnV0ZXMuZW5hYmxlKGdsLCBsb2NhdGlvbik7XG4gICAgICAgIFZlcnRleEF0dHJpYnV0ZXMuc2V0QnVmZmVyKHtnbCwgbG9jYXRpb24sIGJ1ZmZlcn0pO1xuICAgICAgICBWZXJ0ZXhBdHRyaWJ1dGVzLnNldERpdmlzb3IoZ2wsIGxvY2F0aW9uLCBkaXZpc29yKTtcbiAgICAgICAgZHJhd1BhcmFtcy5pc0luc3RhbmNlZCA9IGJ1ZmZlci5sYXlvdXQuaW5zdGFuY2VkID4gMDtcbiAgICAgICAgdGhpcy5fZmlsbGVkTG9jYXRpb25zW2J1ZmZlck5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTRVQgRUxFTUVOVFMgQVJSQVkgQlVGRkVSXG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2VsZW1lbnRzXTtcbiAgICAgIGJ1ZmZlci5iaW5kKCk7XG4gICAgICBkcmF3UGFyYW1zLmlzSW5kZXhlZCA9IHRydWU7XG4gICAgICBkcmF3UGFyYW1zLmluZGV4VHlwZSA9IGJ1ZmZlci5sYXlvdXQudHlwZTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2spIHtcbiAgICAgIHRoaXMuX2NoZWNrQnVmZmVycygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKlxuICAgKiBAcmV0dXJucyB7UHJvZ3JhbX0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgdW5zZXRCdWZmZXJzKCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX2F0dHJpYnV0ZUNvdW50O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIFZlcnRleEF0dHJpYnV0ZXMuc2V0RGl2aXNvcihnbCwgaSwgMCk7XG4gICAgICBWZXJ0ZXhBdHRyaWJ1dGVzLmRpc2FibGUodGhpcy5nbCwgaSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgZWxlbWVudHMgYnVmZmVyXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNldCBvZiB1bmlmb3JtIHZhbHVlcyB0byBhIHByb2dyYW1cbiAgICogT25seSB1bmlmb3JtcyB3aXRoIG5hbWVzIGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIGxpbmtlZCBwcm9ncmFtXG4gICAqIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogb3RoZXIgdW5pZm9ybXMgd2lsbCBiZSBpZ25vcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTWFwIC0gQW4gb2JqZWN0IHdpdGggbmFtZXMgYmVpbmcga2V5c1xuICAgKiBAcmV0dXJucyB7UHJvZ3JhbX0gLSByZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cbiAgc2V0VW5pZm9ybXModW5pZm9ybXMsIHNhbXBsZXJzID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuICAgICAgY29uc3QgdW5pZm9ybVNldHRlciA9IHRoaXMuX3VuaWZvcm1TZXR0ZXJzW3VuaWZvcm1OYW1lXTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t1bmlmb3JtTmFtZV07XG5cbiAgICAgIGlmICh1bmlmb3JtU2V0dGVyKSB7XG4gICAgICAgIGlmICh1bmlmb3JtIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgIGlmICh1bmlmb3JtU2V0dGVyLnRleHR1cmVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1bmlmb3JtU2V0dGVyLnRleHR1cmVJbmRleCA9IHRoaXMuX3RleHR1cmVJbmRleENvdW50ZXIrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBCaW5kIHRleHR1cmUgdG8gaW5kZXhcbiAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdW5pZm9ybTtcbiAgICAgICAgICBjb25zdCB7dGV4dHVyZUluZGV4fSA9IHVuaWZvcm1TZXR0ZXI7XG5cbiAgICAgICAgICB0ZXh0dXJlLmJpbmQodGV4dHVyZUluZGV4KTtcblxuICAgICAgICAgIC8vIEJpbmQgYSBzYW1wbGVyIChpZiBzdXBwbGllZCkgdG8gaW5kZXhcbiAgICAgICAgICBpZiAoc2FtcGxlcikge1xuICAgICAgICAgICAgc2FtcGxlci5iaW5kKHRleHR1cmVJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSB1bmlmb3JtIHNhbXBsZXIgdG8gdGhlIHRleHR1cmUgaW5kZXhcbiAgICAgICAgICB1bmlmb3JtU2V0dGVyKHRleHR1cmVJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSnVzdCBzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgdW5pZm9ybVNldHRlcih1bmlmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG5cbiAgLy8gc2V0VHJhbnNmb3JtRmVlZGJhY2tCdWZmZXJzKGJ1ZmZlcnMpIHtcbiAgLy8gICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gIC8vICAgICBidWZmZXIuYmluZEJhc2UoKVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBBVFRSSUJVVEVTIEFQSVxuICAgKiAoTG9jYXRpb25zIGFyZSBudW1lcmljIGluZGljZXMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gY291bnRcbiAgICovXG4gIGdldEF0dHJpYnV0ZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXIoR0wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYXRpb24gKGluZGV4KSBvZiBhIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgLSBuYW1lIG9mIGFuIGF0dHJpYnV0ZVxuICAgKiAgIChtYXRjaGVzIG5hbWUgaW4gYSBsaW5rZWQgc2hhZGVyKVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIC8vIGFycmF5IG9mIGFjdHVhbCBhdHRyaWJ1dGUgbmFtZXMgZnJvbSBzaGFkZXIgbGlua2luZ1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb24oYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuaGFuZGxlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgYXR0cmlidXRlIGF0IGluZGV4IFwibG9jYXRpb25cIi9cbiAgICogQHBhcmFtIHtpbnR9IGxvY2F0aW9uIC0gaW5kZXggb2YgYW4gYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHtXZWJHTEFjdGl2ZUluZm99IC0gaW5mbyBhYm91dCBhbiBhY3RpdmUgYXR0cmlidXRlXG4gICAqICAgZmllbGRzOiB7bmFtZSwgc2l6ZSwgdHlwZX1cbiAgICovXG4gIGdldEF0dHJpYnV0ZUluZm8obG9jYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5oYW5kbGUsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVTklGT1JNUyBBUElcbiAgICogKExvY2F0aW9ucyBhcmUgbnVtZXJpYyBpbmRpY2VzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvdW50XG4gICAqL1xuICBnZXRVbmlmb3JtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlcihHTC5BQ1RJVkVfVU5JRk9STVMpO1xuICB9XG5cbiAgLypcbiAgICogQHJldHVybnMge1dlYkdMQWN0aXZlSW5mb30gLSBvYmplY3Qgd2l0aCB7bmFtZSwgc2l6ZSwgdHlwZX1cbiAgICovXG4gIGdldFVuaWZvcm1JbmZvKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0QWN0aXZlVW5pZm9ybSh0aGlzLmhhbmRsZSwgaW5kZXgpO1xuICB9XG5cbiAgLypcbiAgICogQHJldHVybnMge1dlYkdMVW5pZm9ybUxvY2F0aW9ufSAtIG9wYXF1ZSBvYmplY3QgcmVwcmVzZW50aW5nIGxvY2F0aW9uXG4gICAqIG9mIHVuaWZvcm0sIHVzZWQgYnkgc2V0dGVyIG1ldGhvZHNcbiAgICovXG4gIGdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuaGFuZGxlLCBuYW1lKTtcbiAgfVxuXG4gIGdldFVuaWZvcm1WYWx1ZShsb2NhdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFVuaWZvcm0odGhpcy5oYW5kbGUsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIC8vIFdlYkdMMlxuICAvKipcbiAgICogQHBhcmFtIHtHTHVpbnR9IGluZGV4XG4gICAqIEByZXR1cm4ge1dlYkdMQWN0aXZlSW5mb30gLSBvYmplY3Qgd2l0aCB7bmFtZSwgc2l6ZSwgdHlwZX1cbiAgICovXG4gIGdldFZhcnlpbmcocHJvZ3JhbSwgaW5kZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdsLmdldFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZyhwcm9ncmFtLCBpbmRleCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldHJpZXZlcyB0aGUgYXNzaWduZWQgY29sb3IgbnVtYmVyIGJpbmRpbmcgZm9yIHRoZSB1c2VyLWRlZmluZWQgdmFyeWluZ1xuICAvLyBvdXQgdmFyaWFibGUgbmFtZSBmb3IgcHJvZ3JhbS4gcHJvZ3JhbSBtdXN0IGhhdmUgcHJldmlvdXNseSBiZWVuIGxpbmtlZC5cbiAgZ2V0RnJhZ0RhdGFMb2NhdGlvbih2YXJ5aW5nTmFtZSkge1xuICAgIGFzc2VydFdlYkdMMkNvbnRleHQodGhpcy5nbCk7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0RnJhZ0RhdGFMb2NhdGlvbih0aGlzLmhhbmRsZSwgdmFyeWluZ05hbWUpO1xuICB9XG5cbiAgLy8gQHJldHVybnMge1dlYkdMU2hhZGVyW119IC0gYXJyYXkgb2YgYXR0YWNoZWQgV2ViR0xTaGFkZXIgb2JqZWN0c1xuICBnZXRBdHRhY2hlZFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0QXR0YWNoZWRTaGFkZXJzKHRoaXMuaGFuZGxlKTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIF9jb21waWxlQW5kTGluaygpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIHRoaXMudnMuaGFuZGxlKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIHRoaXMuZnMuaGFuZGxlKTtcbiAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG5cbiAgICAvLyBBdm9pZCBjaGVja2luZyBwcm9ncmFtIGxpbmtpbmcgZXJyb3IgaW4gcHJvZHVjdGlvblxuICAgIGlmIChnbC5kZWJ1ZyB8fCBsb2cucHJpb3JpdHkgPiAwKSB7XG4gICAgICBnbC52YWxpZGF0ZVByb2dyYW0odGhpcy5oYW5kbGUpO1xuICAgICAgY29uc3QgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLmhhbmRsZSwgZ2wuTElOS19TVEFUVVMpO1xuICAgICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBsaW5raW5nICR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5oYW5kbGUpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0J1ZmZlcnMoKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9maWxsZWRMb2NhdGlvbnNbYXR0cmlidXRlTmFtZV0gJiYgIXRoaXMuX3dhcm5bYXR0cmlidXRlTmFtZV0pIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSAke3RoaXMuaWR9OiBgICtcbiAgICAgICAgLy8gICBgQXR0cmlidXRlICR7bG9jYXRpb259OiR7YXR0cmlidXRlTmFtZX0gbm90IHN1cHBsaWVkYCk7XG4gICAgICAgIGxvZy53YXJuKDAsIGBQcm9ncmFtICR7dGhpcy5pZH06IEF0dHJpYnV0ZSAke2xvY2F0aW9ufToke2F0dHJpYnV0ZU5hbWV9IG5vdCBzdXBwbGllZGApO1xuICAgICAgICB0aGlzLl93YXJuW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc29ydEJ1ZmZlcnNCeUxvY2F0aW9uKGJ1ZmZlcnMpIHtcbiAgICBsZXQgZWxlbWVudHMgPSBudWxsO1xuICAgIGNvbnN0IGxvY2F0aW9ucyA9IG5ldyBBcnJheSh0aGlzLl9hdHRyaWJ1dGVDb3VudCk7XG5cbiAgICBmb3IgKGNvbnN0IGJ1ZmZlck5hbWUgaW4gYnVmZmVycykge1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tidWZmZXJOYW1lXTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zW2J1ZmZlck5hbWVdO1xuICAgICAgaWYgKGxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci50YXJnZXQgPT09IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSICYmIGVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX3ByaW50KGJ1ZmZlck5hbWUpfSBkdXBsaWNhdGUgR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVJgKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIudGFyZ2V0ID09PSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUikge1xuICAgICAgICAgIGVsZW1lbnRzID0gYnVmZmVyTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fd2FybltidWZmZXJOYW1lXSkge1xuICAgICAgICAgIGxvZy53YXJuKDIsIGAke3RoaXMuX3ByaW50KGJ1ZmZlck5hbWUpfSBub3QgdXNlZGApO1xuICAgICAgICAgIHRoaXMuX3dhcm5bYnVmZmVyTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyLnRhcmdldCA9PT0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fcHJpbnQoYnVmZmVyTmFtZSl9OiR7bG9jYXRpb259IGAgK1xuICAgICAgICAgICAgJ2hhcyBib3RoIGxvY2F0aW9uIGFuZCB0eXBlIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYXRpb25zW2xvY2F0aW9uXSA9IGJ1ZmZlck5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bG9jYXRpb25zLCBlbGVtZW50c307XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IGFsbCBhY3RpdmUgYXR0cmlidXRlcyBhcmUgZW5hYmxlZFxuICBfYXJlQWxsQXR0cmlidXRlc0VuYWJsZWQoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5fYXR0cmlidXRlQ291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFWZXJ0ZXhBdHRyaWJ1dGVzLmlzRW5hYmxlZChnbCwgaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhdHRyaWJ1dGUgbG9jYXRpb25zIChtYXBzIGF0dHJpYnV0ZSBuYW1lIHRvIGluZGV4KVxuICBfZ2V0QXR0cmlidXRlTG9jYXRpb25zKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZ2V0QXR0cmlidXRlQ291bnQoKTtcbiAgICBmb3IgKGxldCBsb2NhdGlvbiA9IDA7IGxvY2F0aW9uIDwgbGVuZ3RoOyBsb2NhdGlvbisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVJbmZvKGxvY2F0aW9uKS5uYW1lO1xuICAgICAgYXR0cmlidXRlTG9jYXRpb25zW25hbWVdID0gdGhpcy5nZXRBdHRyaWJ1dGVMb2NhdGlvbihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZUxvY2F0aW9ucztcbiAgfVxuXG4gIC8vIGNyZWF0ZSB1bmlmb3JtIHNldHRlcnNcbiAgLy8gTWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gc2V0dGVyIGZ1bmN0aW9uc1xuICBfZ2V0VW5pZm9ybVNldHRlcnMoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG4gICAgY29uc3QgdW5pZm9ybVNldHRlcnMgPSB7fTtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmdldFVuaWZvcm1Db3VudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldFVuaWZvcm1JbmZvKGkpO1xuICAgICAgY29uc3QgcGFyc2VkTmFtZSA9IHBhcnNlVW5pZm9ybU5hbWUoaW5mby5uYW1lKTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocGFyc2VkTmFtZS5uYW1lKTtcbiAgICAgIHVuaWZvcm1TZXR0ZXJzW3BhcnNlZE5hbWUubmFtZV0gPVxuICAgICAgICBnZXRVbmlmb3JtU2V0dGVyKGdsLCBsb2NhdGlvbiwgaW5mbywgcGFyc2VkTmFtZS5pc0FycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1TZXR0ZXJzO1xuICB9XG5cbiAgX3ByaW50KGJ1ZmZlck5hbWUpIHtcbiAgICByZXR1cm4gYFByb2dyYW0gJHt0aGlzLmlkfTogQXR0cmlidXRlICR7YnVmZmVyTmFtZX1gO1xuICB9XG5cbiAgX2NyZWF0ZUhhbmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gIH1cblxuICBfZGVsZXRlSGFuZGxlKCkge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG4gIH1cblxuICBfZ2V0T3B0aW9uc0Zyb21IYW5kbGUoaGFuZGxlKSB7XG4gICAgY29uc3Qgc2hhZGVySGFuZGxlcyA9IHRoaXMuZ2wuZ2V0QXR0YWNoZWRTaGFkZXJzKGhhbmRsZSk7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIGZvciAoY29uc3Qgc2hhZGVySGFuZGxlIG9mIHNoYWRlckhhbmRsZXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcih0aGlzLmhhbmRsZSwgR0wuU0hBREVSX1RZUEUpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdMLlZFUlRFWF9TSEFERVI6XG4gICAgICAgIG9wdHMudnMgPSBuZXcgVmVydGV4U2hhZGVyKHtoYW5kbGU6IHNoYWRlckhhbmRsZX0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR0wuRlJBR01FTlRfU0hBREVSOlxuICAgICAgICBvcHRzLmZzID0gbmV3IEZyYWdtZW50U2hhZGVyKHtoYW5kbGU6IHNoYWRlckhhbmRsZX0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRzO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgdGhlIHBhc3NlZCBwbmFtZSBnaXZlbiB0aGUgcGFzc2VkIHByb2dyYW0uXG4gIC8vIFRoZSB0eXBlIHJldHVybmVkIGlzIHRoZSBuYXR1cmFsIHR5cGUgZm9yIHRoZSByZXF1ZXN0ZWQgcG5hbWUsXG4gIC8vIGFzIGdpdmVuIGluIHRoZSBmb2xsb3dpbmcgdGFibGU6XG4gIF9nZXRQYXJhbWV0ZXIocG5hbWUpIHtcbiAgICAvLyBSZXR1cm4gZGVmYXVsdCB2YWx1ZXMgZm9yIFdlYkdMMiBwYXJhbWV0ZXJzIHVuZGVyIFdlYkdMMVxuICAgIGlmICghaXNXZWJHTDJDb250ZXh0KHRoaXMuZ2wpKSB7XG4gICAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgICBjYXNlIEdMLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfTU9ERTogcmV0dXJuIEdMLlNFUEFSQVRFX0FUVFJJQlM7XG4gICAgICBjYXNlIEdMLlRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUzogcmV0dXJuIDA7XG4gICAgICBjYXNlIEdMLkFDVElWRV9VTklGT1JNX0JMT0NLUzogcmV0dXJuIDA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBwbmFtZSk7XG4gIH1cbn1cblxuLy8gY3JlYXRlIHVuaWZvcm0gc2V0dGVyc1xuLy8gTWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gc2V0dGVyIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaWZvcm1EZXNjcmlwdG9ycyhnbCwgcHJvZ3JhbSkge1xuICBjb25zdCB1bmlmb3JtRGVzY3JpcHRvcnMgPSB7fTtcbiAgY29uc3QgbGVuZ3RoID0gcHJvZ3JhbS5nZXRVbmlmb3JtQ291bnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGluZm8gPSBwcm9ncmFtLmdldFVuaWZvcm1JbmZvKGkpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvZ3JhbS5nZXRVbmlmb3JtTG9jYXRpb24oaW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0VW5pZm9ybVNldHRlcihnbCwgbG9jYXRpb24sIGluZm8pO1xuICAgIHVuaWZvcm1EZXNjcmlwdG9yc1tkZXNjcmlwdG9yLm5hbWVdID0gZGVzY3JpcHRvcjtcbiAgfVxuICByZXR1cm4gdW5pZm9ybURlc2NyaXB0b3JzO1xufVxuXG4vLyBHZXQgYSBtYXAgb2YgYnVmZmVyIGluZGljZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJ5aW5nTWFwKHZhcnlpbmdzLCBidWZmZXJNb2RlKSB7XG4gIGNvbnN0IHZhcnlpbmdNYXAgPSB7fTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIChjb25zdCB2YXJ5aW5nIG9mIHZhcnlpbmdzKSB7XG4gICAgaWYgKGJ1ZmZlck1vZGUgPT09IEdMLlNFUEFSQVRFX0FUVFJJQlMpIHtcbiAgICAgIHZhcnlpbmdNYXBbdmFyeWluZ3NdID0ge2luZGV4fTtcbiAgICAgIGluZGV4Kys7XG4gICAgfSBlbHNlIGlmICh2YXJ5aW5nID09PSAnZ2xfTmV4dEJ1ZmZlcicpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCBhIFwic2FmZVwiIG9mZnNldCBhcyBmYWxsYmFjayB1bmxlc3MgYXBwIHNwZWNpZmllcyBpdFxuICAgICAgLy8gQ291bGQgcXVlcnlcbiAgICAgIHZhcnlpbmdNYXBbdmFyeWluZ3NdID0ge2luZGV4LCBvZmZzZXQ6IDE2fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhcnlpbmdNYXA7XG59XG4iXX0=

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Shader */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return VertexShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return FragmentShader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';

// For now this is an internal class
var Shader = function (_Resource) {
  _inherits(Shader, _Resource);

  _createClass(Shader, null, [{
    key: 'getTypeName',
    value: function getTypeName(shaderType) {
      switch (shaderType) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERTEX_SHADER:
          return 'vertex-shader';
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAGMENT_SHADER:
          return 'fragment-shader';
        default:
          return 'unknown-shader';
      }
    }

    /* eslint-disable max-statements */

  }]);

  function Shader(gl, source, shaderType) {
    _classCallCheck(this, Shader);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);
    __WEBPACK_IMPORTED_MODULE_4_assert___default()(typeof source === 'string', ERR_SOURCE);

    var _this = _possibleConstructorReturn(this, (Shader.__proto__ || Object.getPrototypeOf(Shader)).call(this, gl, { id: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["f" /* getShaderName */])(source) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils__["uid"])(Shader.getTypeName(shaderType)) }));

    _this.shaderType = shaderType;
    _this.source = source;

    _this.opts.source = source;
    _this.initialize(_this.opts);
    return _this;
  }

  _createClass(Shader, [{
    key: 'initialize',
    value: function initialize(_ref) {
      var source = _ref.source;

      var shaderName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["f" /* getShaderName */])(source);
      if (shaderName) {
        this.id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils__["uid"])(shaderName);
      }
      this._compile(source);
      this.opts.source = source;
    }

    // Accessors

  }, {
    key: 'getParameter',
    value: function getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.getTypeName(this.shaderType) + ':' + this.id;
    }
  }, {
    key: 'getName',
    value: function getName() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["f" /* getShaderName */])(this.opts.source) || 'unnamed-shader';
    }
  }, {
    key: 'getSource',
    value: function getSource() {
      return this.gl.getShaderSource(this.handle);
    }

    // Debug method - Returns translated source if available

  }, {
    key: 'getTranslatedSource',
    value: function getTranslatedSource() {
      var extension = this.gl.getExtension('WEBGL_debug_shaders');
      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
    }

    // PRIVATE METHODS

  }, {
    key: '_compile',
    value: function _compile() {
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);

      // Avoid checking shader compilation errors on production
      if (this.gl.debug || __WEBPACK_IMPORTED_MODULE_3__utils__["log"].priority > 0) {
        // Throw if compilation failed
        var compileStatus = this.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COMPILE_STATUS);
        if (!compileStatus) {
          var infoLog = this.gl.getShaderInfoLog(this.handle);
          var error = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["g" /* formatGLSLCompilerError */])(infoLog, this.source, this.shaderType);
          throw new Error('Error while compiling the shader ' + error);
        }
      }

      // Log translated source, if compilation succeeded
      if (__WEBPACK_IMPORTED_MODULE_3__utils__["log"].priority >= 3) {
        __WEBPACK_IMPORTED_MODULE_3__utils__["log"].log(3, this.getTranslatedSource());
      }
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
  }, {
    key: '_getOptsFromHandle',
    value: function _getOptsFromHandle() {
      return {
        type: this.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SHADER_TYPE),
        source: this.getSource()
      };
    }
  }]);

  return Shader;
}(__WEBPACK_IMPORTED_MODULE_2__resource__["a" /* default */]);

var VertexShader = function (_Shader) {
  _inherits(VertexShader, _Shader);

  function VertexShader(gl, source) {
    _classCallCheck(this, VertexShader);

    return _possibleConstructorReturn(this, (VertexShader.__proto__ || Object.getPrototypeOf(VertexShader)).call(this, gl, source, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERTEX_SHADER));
  }

  // PRIVATE METHODS


  _createClass(VertexShader, [{
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createShader(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERTEX_SHADER);
    }
  }]);

  return VertexShader;
}(Shader);

var FragmentShader = function (_Shader2) {
  _inherits(FragmentShader, _Shader2);

  function FragmentShader(gl, source) {
    _classCallCheck(this, FragmentShader);

    return _possibleConstructorReturn(this, (FragmentShader.__proto__ || Object.getPrototypeOf(FragmentShader)).call(this, gl, source, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAGMENT_SHADER));
  }

  // PRIVATE METHODS


  _createClass(FragmentShader, [{
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createShader(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAGMENT_SHADER);
    }
  }]);

  return FragmentShader;
}(Shader);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9zaGFkZXIuanMiXSwibmFtZXMiOlsiR0wiLCJmb3JtYXRHTFNMQ29tcGlsZXJFcnJvciIsImdldFNoYWRlck5hbWUiLCJhc3NlcnRXZWJHTENvbnRleHQiLCJSZXNvdXJjZSIsImxvZyIsInVpZCIsImFzc2VydCIsIkVSUl9TT1VSQ0UiLCJTaGFkZXIiLCJzaGFkZXJUeXBlIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsImdsIiwic291cmNlIiwiaWQiLCJnZXRUeXBlTmFtZSIsIm9wdHMiLCJpbml0aWFsaXplIiwic2hhZGVyTmFtZSIsIl9jb21waWxlIiwicG5hbWUiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJoYW5kbGUiLCJnZXRTaGFkZXJTb3VyY2UiLCJleHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJnZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImRlYnVnIiwicHJpb3JpdHkiLCJjb21waWxlU3RhdHVzIiwiZ2V0UGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJpbmZvTG9nIiwiZ2V0U2hhZGVySW5mb0xvZyIsImVycm9yIiwiRXJyb3IiLCJnZXRUcmFuc2xhdGVkU291cmNlIiwiZGVsZXRlU2hhZGVyIiwidHlwZSIsIlNIQURFUl9UWVBFIiwiZ2V0U291cmNlIiwiVmVydGV4U2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwiRnJhZ21lbnRTaGFkZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsT0FBT0EsRUFBUCxJQUFZQyx1QkFBWixFQUFxQ0MsYUFBckMsUUFBeUQsT0FBekQ7QUFDQSxTQUFRQyxrQkFBUixRQUFpQyxXQUFqQztBQUNBLE9BQU9DLFFBQVAsTUFBcUIsWUFBckI7QUFDQSxTQUFRQyxHQUFSLEVBQWFDLEdBQWIsUUFBdUIsVUFBdkI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGFBQWEsc0RBQW5C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b3J0IEdMLCB7Zm9ybWF0R0xTTENvbXBpbGVyRXJyb3IsIGdldFNoYWRlck5hbWV9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7YXNzZXJ0V2ViR0xDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcmVzb3VyY2UnO1xuaW1wb3J0IHtsb2csIHVpZH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBFUlJfU09VUkNFID0gJ1NoYWRlcjogR0xTTCBzb3VyY2UgY29kZSBtdXN0IGJlIGEgSmF2YVNjcmlwdCBzdHJpbmcnO1xuXG4vLyBGb3Igbm93IHRoaXMgaXMgYW4gaW50ZXJuYWwgY2xhc3NcbmV4cG9ydCBjbGFzcyBTaGFkZXIgZXh0ZW5kcyBSZXNvdXJjZSB7XG5cbiAgc3RhdGljIGdldFR5cGVOYW1lKHNoYWRlclR5cGUpIHtcbiAgICBzd2l0Y2ggKHNoYWRlclR5cGUpIHtcbiAgICBjYXNlIEdMLlZFUlRFWF9TSEFERVI6IHJldHVybiAndmVydGV4LXNoYWRlcic7XG4gICAgY2FzZSBHTC5GUkFHTUVOVF9TSEFERVI6IHJldHVybiAnZnJhZ21lbnQtc2hhZGVyJztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ3Vua25vd24tc2hhZGVyJztcbiAgICB9XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBjb25zdHJ1Y3RvcihnbCwgc291cmNlLCBzaGFkZXJUeXBlKSB7XG4gICAgYXNzZXJ0V2ViR0xDb250ZXh0KGdsKTtcbiAgICBhc3NlcnQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycsIEVSUl9TT1VSQ0UpO1xuXG4gICAgc3VwZXIoZ2wsIHtpZDogZ2V0U2hhZGVyTmFtZShzb3VyY2UpIHx8IHVpZChTaGFkZXIuZ2V0VHlwZU5hbWUoc2hhZGVyVHlwZSkpfSk7XG5cbiAgICB0aGlzLnNoYWRlclR5cGUgPSBzaGFkZXJUeXBlO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgdGhpcy5vcHRzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmluaXRpYWxpemUodGhpcy5vcHRzKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoe3NvdXJjZX0pIHtcbiAgICBjb25zdCBzaGFkZXJOYW1lID0gZ2V0U2hhZGVyTmFtZShzb3VyY2UpO1xuICAgIGlmIChzaGFkZXJOYW1lKSB7XG4gICAgICB0aGlzLmlkID0gdWlkKHNoYWRlck5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9jb21waWxlKHNvdXJjZSk7XG4gICAgdGhpcy5vcHRzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIC8vIEFjY2Vzc29yc1xuXG4gIGdldFBhcmFtZXRlcihwbmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcih0aGlzLmhhbmRsZSwgcG5hbWUpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0VHlwZU5hbWUodGhpcy5zaGFkZXJUeXBlKX06JHt0aGlzLmlkfWA7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiBnZXRTaGFkZXJOYW1lKHRoaXMub3B0cy5zb3VyY2UpIHx8ICd1bm5hbWVkLXNoYWRlcic7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0U2hhZGVyU291cmNlKHRoaXMuaGFuZGxlKTtcbiAgfVxuXG4gIC8vIERlYnVnIG1ldGhvZCAtIFJldHVybnMgdHJhbnNsYXRlZCBzb3VyY2UgaWYgYXZhaWxhYmxlXG4gIGdldFRyYW5zbGF0ZWRTb3VyY2UoKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3NoYWRlcnMnKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uID9cbiAgICAgIGV4dGVuc2lvbi5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKHRoaXMuaGFuZGxlKSA6XG4gICAgICAnTm8gdHJhbnNsYXRlZCBzb3VyY2UgYXZhaWxhYmxlLiBXRUJHTF9kZWJ1Z19zaGFkZXJzIG5vdCBpbXBsZW1lbnRlZCc7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UodGhpcy5oYW5kbGUsIHRoaXMuc291cmNlKTtcbiAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIodGhpcy5oYW5kbGUpO1xuXG4gICAgLy8gQXZvaWQgY2hlY2tpbmcgc2hhZGVyIGNvbXBpbGF0aW9uIGVycm9ycyBvbiBwcm9kdWN0aW9uXG4gICAgaWYgKHRoaXMuZ2wuZGVidWcgfHwgbG9nLnByaW9yaXR5ID4gMCkge1xuICAgICAgLy8gVGhyb3cgaWYgY29tcGlsYXRpb24gZmFpbGVkXG4gICAgICBjb25zdCBjb21waWxlU3RhdHVzID0gdGhpcy5nZXRQYXJhbWV0ZXIoR0wuQ09NUElMRV9TVEFUVVMpO1xuICAgICAgaWYgKCFjb21waWxlU3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IGluZm9Mb2cgPSB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codGhpcy5oYW5kbGUpO1xuICAgICAgICBjb25zdCBlcnJvciA9IGZvcm1hdEdMU0xDb21waWxlckVycm9yKGluZm9Mb2csIHRoaXMuc291cmNlLCB0aGlzLnNoYWRlclR5cGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGNvbXBpbGluZyB0aGUgc2hhZGVyICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9nIHRyYW5zbGF0ZWQgc291cmNlLCBpZiBjb21waWxhdGlvbiBzdWNjZWVkZWRcbiAgICBpZiAobG9nLnByaW9yaXR5ID49IDMpIHtcbiAgICAgIGxvZy5sb2coMywgdGhpcy5nZXRUcmFuc2xhdGVkU291cmNlKCkpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWxldGVIYW5kbGUoKSB7XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodGhpcy5oYW5kbGUpO1xuICB9XG5cbiAgX2dldE9wdHNGcm9tSGFuZGxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmdldFBhcmFtZXRlcihHTC5TSEFERVJfVFlQRSksXG4gICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWZXJ0ZXhTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuICBjb25zdHJ1Y3RvcihnbCwgc291cmNlKSB7XG4gICAgc3VwZXIoZ2wsIHNvdXJjZSwgR0wuVkVSVEVYX1NIQURFUik7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgX2NyZWF0ZUhhbmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5jcmVhdGVTaGFkZXIoR0wuVkVSVEVYX1NIQURFUik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZyYWdtZW50U2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IoZ2wsIHNvdXJjZSkge1xuICAgIHN1cGVyKGdsLCBzb3VyY2UsIEdMLkZSQUdNRU5UX1NIQURFUik7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgX2NyZWF0ZUhhbmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5jcmVhdGVTaGFkZXIoR0wuRlJBR01FTlRfU0hBREVSKTtcbiAgfVxufVxuIl19

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__texture__ = __webpack_require__(21);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Texture2D = function (_Texture) {
  _inherits(Texture2D, _Texture);

  _createClass(Texture2D, null, [{
    key: 'makeFromSolidColor',
    value: function makeFromSolidColor(gl, _ref) {
      var _ref2 = _slicedToArray(_ref, 4),
          _ref2$ = _ref2[0],
          r = _ref2$ === undefined ? 0 : _ref2$,
          _ref2$2 = _ref2[1],
          g = _ref2$2 === undefined ? 0 : _ref2$2,
          _ref2$3 = _ref2[2],
          b = _ref2$3 === undefined ? 0 : _ref2$3,
          _ref2$4 = _ref2[3],
          a = _ref2$4 === undefined ? 1 : _ref2$4;

      return new Texture2D(gl, {
        pixels: new Uint8Array([r, g, b, a]),
        width: 1,
        format: gl.RGBA,
        magFilter: gl.NEAREST,
        minFilter: gl.NEAREST
      });
    }
  }, {
    key: 'makeFromPixelArray',
    value: function makeFromPixelArray(gl, opts) {
      var dataArray = opts.dataArray,
          _opts$format = opts.format,
          format = _opts$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].RGBA : _opts$format,
          _opts$width = opts.width,
          width = _opts$width === undefined ? 1 : _opts$width,
          height = opts.height;
      // Don't need to do this if the data is already in a typed array

      var dataTypedArray = new Uint8Array(dataArray);
      return new Texture2D(gl, Object.assign({
        pixels: dataTypedArray,
        width: width,
        height: height,
        format: format
      }, opts));
    }

    /**
     * @classdesc
     * 2D WebGL Texture
     * Note: Constructor will initialize your texture.
     *
     * @class
     * @param {WebGLRenderingContext} gl - gl context
     * @param {Image|ArrayBuffer|null} opts= - named options
     * @param {Image|ArrayBuffer|null} opts.data= - buffer
     * @param {GLint} width - width of texture
     * @param {GLint} height - height of texture
     */

  }]);

  function Texture2D(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Texture2D);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);

    var _this = _possibleConstructorReturn(this, (Texture2D.__proto__ || Object.getPrototypeOf(Texture2D)).call(this, gl, Object.assign({}, opts, { target: gl.TEXTURE_2D })));

    _this.initialize(opts);

    Object.seal(_this);
    return _this;
  }

  // target cannot be modified by bind:
  // textures are special because when you first bind them to a target,
  // they get special information. When you first bind a texture as a
  // GL_TEXTURE_2D, you are actually setting special state in the texture.
  // You are saying that this texture is a 2D texture.
  // And it will always be a 2D texture; this state cannot be changed ever.
  // If you have a texture that was first bound as a GL_TEXTURE_2D,
  // you must always bind it as a GL_TEXTURE_2D;
  // attempting to bind it as GL_TEXTURE_1D will give rise to an error
  // (while run-time).

  _createClass(Texture2D, [{
    key: 'bind',
    value: function bind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
      var gl = this.gl;

      if (textureUnit === undefined) {
        throw new Error('Texture.bind: must specify texture unit');
      }
      this.textureUnit = textureUnit;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      var gl = this.gl;

      if (this.textureUnit === undefined) {
        throw new Error('Texture.unbind: texture unit not specified');
      }
      gl.activeTexture(gl.TEXTURE0 + this.textureUnit);
      gl.bindTexture(this.target, null);
      return this.textureUnit;
    }
  }, {
    key: 'getActiveUnit',
    value: function getActiveUnit() {
      return this.gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].ACTIVE_TEXTURE) - __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].TEXTURE0;
    }

    // WebGL2

  }, {
    key: 'setPixels',
    value: function setPixels() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var buffer = opts.buffer,
          _opts$width2 = opts.width,
          width = _opts$width2 === undefined ? null : _opts$width2,
          _opts$height = opts.height,
          height = _opts$height === undefined ? null : _opts$height,
          _opts$mipmapLevel = opts.mipmapLevel,
          mipmapLevel = _opts$mipmapLevel === undefined ? 0 : _opts$mipmapLevel,
          _opts$format2 = opts.format,
          format = _opts$format2 === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].RGBA : _opts$format2,
          _opts$type = opts.type,
          type = _opts$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].UNSIGNED_BYTE : _opts$type,
          _opts$border = opts.border,
          border = _opts$border === undefined ? 0 : _opts$border;
      var gl = this.gl;

      // This signature of texImage2D uses currently bound GL_PIXEL_UNPACK_BUFFER

      gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].PIXEL_UNPACK_BUFFER, buffer.target);
      // And as always, we must also bind the texture itself
      this.bind();

      gl.texImage2D(gl.TEXTURE_2D, mipmapLevel, format, width, height, border, format, type, buffer.target);

      this.unbind();
      gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].GL_PIXEL_UNPACK_BUFFER, null);
      return this;
    }
  }, {
    key: 'setImageDataFromCompressedBuffer',
    value: function setImageDataFromCompressedBuffer(opts) {
      var buffer = opts.buffer,
          _opts$width3 = opts.width,
          width = _opts$width3 === undefined ? null : _opts$width3,
          _opts$height2 = opts.height,
          height = _opts$height2 === undefined ? null : _opts$height2,
          _opts$mipmapLevel2 = opts.mipmapLevel,
          mipmapLevel = _opts$mipmapLevel2 === undefined ? 0 : _opts$mipmapLevel2,
          _opts$internalFormat = opts.internalFormat,
          internalFormat = _opts$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].RGBA : _opts$internalFormat,
          _opts$border2 = opts.border,
          border = _opts$border2 === undefined ? 0 : _opts$border2;
      var gl = this.gl;

      gl.compressedTexImage2D(this.target, mipmapLevel, internalFormat, width, height, border, buffer);
      // gl.compressedTexSubImage2D(target,
      //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);
      return this;
    }

    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     */

  }, {
    key: 'copyImageFromFramebuffer',
    value: function copyImageFromFramebuffer(opts) {
      var framebuffer = opts.framebuffer,
          x = opts.x,
          y = opts.y,
          width = opts.width,
          height = opts.height,
          _opts$mipmapLevel3 = opts.mipmapLevel,
          mipmapLevel = _opts$mipmapLevel3 === undefined ? 0 : _opts$mipmapLevel3,
          _opts$internalFormat2 = opts.internalFormat,
          internalFormat = _opts$internalFormat2 === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["e" /* GL */].RGBA : _opts$internalFormat2,
          _opts$border3 = opts.border,
          border = _opts$border3 === undefined ? 0 : _opts$border3;
      var gl = this.gl;

      framebuffer.bind();

      // target
      this.bind();
      gl.copyTexImage2D(this.target, mipmapLevel, internalFormat, x, y, width, height, border);
      this.unbind();

      framebuffer.unbind();
    }
  }, {
    key: 'copySubImage',
    value: function copySubImage(opts) {
      _objectDestructuringEmpty(opts);

      // if (pixels instanceof ArrayBufferView) {
      //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);
      // }
      // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);
      // // Additional signature in a WebGL 2 context:
      // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);

    }
  }]);

  return Texture2D;
}(__WEBPACK_IMPORTED_MODULE_2__texture__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Texture2D);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90ZXh0dXJlLTJkLmpzIl0sIm5hbWVzIjpbIkdMIiwiYXNzZXJ0V2ViR0xDb250ZXh0IiwiVGV4dHVyZSIsIlRleHR1cmUyRCIsImdsIiwiciIsImciLCJiIiwiYSIsInBpeGVscyIsIlVpbnQ4QXJyYXkiLCJ3aWR0aCIsImZvcm1hdCIsIlJHQkEiLCJtYWdGaWx0ZXIiLCJORUFSRVNUIiwibWluRmlsdGVyIiwib3B0cyIsImRhdGFBcnJheSIsImhlaWdodCIsImRhdGFUeXBlZEFycmF5IiwiT2JqZWN0IiwiYXNzaWduIiwidGFyZ2V0IiwiVEVYVFVSRV8yRCIsImluaXRpYWxpemUiLCJzZWFsIiwidGV4dHVyZVVuaXQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsImJpbmRUZXh0dXJlIiwiaGFuZGxlIiwiZ2V0UGFyYW1ldGVyIiwiQUNUSVZFX1RFWFRVUkUiLCJidWZmZXIiLCJtaXBtYXBMZXZlbCIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiYm9yZGVyIiwiYmluZEJ1ZmZlciIsIlBJWEVMX1VOUEFDS19CVUZGRVIiLCJiaW5kIiwidGV4SW1hZ2UyRCIsInVuYmluZCIsIkdMX1BJWEVMX1VOUEFDS19CVUZGRVIiLCJpbnRlcm5hbEZvcm1hdCIsImNvbXByZXNzZWRUZXhJbWFnZTJEIiwiZnJhbWVidWZmZXIiLCJ4IiwieSIsImNvcHlUZXhJbWFnZTJEIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxTQUFRQSxFQUFSLFFBQWlCLE9BQWpCO0FBQ0EsU0FBUUMsa0JBQVIsUUFBaUMsV0FBakM7QUFDQSxPQUFPQyxPQUFQLE1BQW9CLFdBQXBCOztJQUVxQkMsUzs7Ozs7dUNBRU9DLEUsUUFBa0M7QUFBQTtBQUFBO0FBQUEsVUFBN0JDLENBQTZCLDBCQUF6QixDQUF5QjtBQUFBO0FBQUEsVUFBdEJDLENBQXNCLDJCQUFsQixDQUFrQjtBQUFBO0FBQUEsVUFBZkMsQ0FBZSwyQkFBWCxDQUFXO0FBQUE7QUFBQSxVQUFSQyxDQUFRLDJCQUFKLENBQUk7O0FBQzFELGFBQU8sSUFBSUwsU0FBSixDQUFjQyxFQUFkLEVBQWtCO0FBQ3ZCSyxnQkFBUSxJQUFJQyxVQUFKLENBQWUsQ0FBQ0wsQ0FBRCxFQUFJQyxDQUFKLEVBQU9DLENBQVAsRUFBVUMsQ0FBVixDQUFmLENBRGU7QUFFdkJHLGVBQU8sQ0FGZ0I7QUFHdkJDLGdCQUFRUixHQUFHUyxJQUhZO0FBSXZCQyxtQkFBV1YsR0FBR1csT0FKUztBQUt2QkMsbUJBQVdaLEdBQUdXO0FBTFMsT0FBbEIsQ0FBUDtBQU9EOzs7dUNBRXlCWCxFLEVBQUlhLEksRUFBTTtBQUFBLFVBQzNCQyxTQUQyQixHQUN1QkQsSUFEdkIsQ0FDM0JDLFNBRDJCO0FBQUEseUJBQ3VCRCxJQUR2QixDQUNoQkwsTUFEZ0I7QUFBQSxVQUNoQkEsTUFEZ0IsZ0NBQ1BaLEdBQUdhLElBREk7QUFBQSx3QkFDdUJJLElBRHZCLENBQ0VOLEtBREY7QUFBQSxVQUNFQSxLQURGLCtCQUNVLENBRFY7QUFBQSxVQUNhUSxNQURiLEdBQ3VCRixJQUR2QixDQUNhRSxNQURiO0FBRWxDOztBQUNBLFVBQU1DLGlCQUFpQixJQUFJVixVQUFKLENBQWVRLFNBQWYsQ0FBdkI7QUFDQSxhQUFPLElBQUlmLFNBQUosQ0FBY0MsRUFBZCxFQUFrQmlCLE9BQU9DLE1BQVAsQ0FBYztBQUNyQ2IsZ0JBQVFXLGNBRDZCO0FBRXJDVCxvQkFGcUM7QUFHckNRLHNCQUhxQztBQUlyQ1A7QUFKcUMsT0FBZCxFQUt0QkssSUFMc0IsQ0FBbEIsQ0FBUDtBQU1EOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFZQSxxQkFBWWIsRUFBWixFQUEyQjtBQUFBLFFBQVhhLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFDekJoQix1QkFBbUJHLEVBQW5COztBQUR5QixzSEFHbkJBLEVBSG1CLEVBR2ZpQixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkwsSUFBbEIsRUFBd0IsRUFBQ00sUUFBUW5CLEdBQUdvQixVQUFaLEVBQXhCLENBSGU7O0FBS3pCLFVBQUtDLFVBQUwsQ0FBZ0JSLElBQWhCOztBQUVBSSxXQUFPSyxJQUFQO0FBUHlCO0FBUTFCOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzJCQUVxQztBQUFBLFVBQWhDQyxXQUFnQyx1RUFBbEIsS0FBS0EsV0FBYTtBQUFBLFVBQzVCdkIsRUFENEIsR0FDdEIsSUFEc0IsQ0FDNUJBLEVBRDRCOztBQUVuQyxVQUFJdUIsZ0JBQWdCQyxTQUFwQixFQUErQjtBQUM3QixjQUFNLElBQUlDLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBQ0Q7QUFDRCxXQUFLRixXQUFMLEdBQW1CQSxXQUFuQjtBQUNBdkIsU0FBRzBCLGFBQUgsQ0FBaUIxQixHQUFHMkIsUUFBSCxHQUFjSixXQUEvQjtBQUNBdkIsU0FBRzRCLFdBQUgsQ0FBZSxLQUFLVCxNQUFwQixFQUE0QixLQUFLVSxNQUFqQztBQUNBLGFBQU9OLFdBQVA7QUFDRDs7OzZCQUVRO0FBQUEsVUFDQXZCLEVBREEsR0FDTSxJQUROLENBQ0FBLEVBREE7O0FBRVAsVUFBSSxLQUFLdUIsV0FBTCxLQUFxQkMsU0FBekIsRUFBb0M7QUFDbEMsY0FBTSxJQUFJQyxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNEO0FBQ0R6QixTQUFHMEIsYUFBSCxDQUFpQjFCLEdBQUcyQixRQUFILEdBQWMsS0FBS0osV0FBcEM7QUFDQXZCLFNBQUc0QixXQUFILENBQWUsS0FBS1QsTUFBcEIsRUFBNEIsSUFBNUI7QUFDQSxhQUFPLEtBQUtJLFdBQVo7QUFDRDs7O29DQUVlO0FBQ2QsYUFBTyxLQUFLdkIsRUFBTCxDQUFROEIsWUFBUixDQUFxQmxDLEdBQUdtQyxjQUF4QixJQUEwQ25DLEdBQUcrQixRQUFwRDtBQUNEOztBQUVEOzs7O2dDQUNxQjtBQUFBLFVBQVhkLElBQVcsdUVBQUosRUFBSTtBQUFBLFVBRWpCbUIsTUFGaUIsR0FTZm5CLElBVGUsQ0FFakJtQixNQUZpQjtBQUFBLHlCQVNmbkIsSUFUZSxDQUdqQk4sS0FIaUI7QUFBQSxVQUdqQkEsS0FIaUIsZ0NBR1QsSUFIUztBQUFBLHlCQVNmTSxJQVRlLENBSWpCRSxNQUppQjtBQUFBLFVBSWpCQSxNQUppQixnQ0FJUixJQUpRO0FBQUEsOEJBU2ZGLElBVGUsQ0FLakJvQixXQUxpQjtBQUFBLFVBS2pCQSxXQUxpQixxQ0FLSCxDQUxHO0FBQUEsMEJBU2ZwQixJQVRlLENBTWpCTCxNQU5pQjtBQUFBLFVBTWpCQSxNQU5pQixpQ0FNUlosR0FBR2EsSUFOSztBQUFBLHVCQVNmSSxJQVRlLENBT2pCcUIsSUFQaUI7QUFBQSxVQU9qQkEsSUFQaUIsOEJBT1Z0QyxHQUFHdUMsYUFQTztBQUFBLHlCQVNmdEIsSUFUZSxDQVFqQnVCLE1BUmlCO0FBQUEsVUFRakJBLE1BUmlCLGdDQVFSLENBUlE7QUFBQSxVQVdacEMsRUFYWSxHQVdOLElBWE0sQ0FXWkEsRUFYWTs7QUFhbkI7O0FBQ0FBLFNBQUdxQyxVQUFILENBQWN6QyxHQUFHMEMsbUJBQWpCLEVBQXNDTixPQUFPYixNQUE3QztBQUNBO0FBQ0EsV0FBS29CLElBQUw7O0FBRUF2QyxTQUFHd0MsVUFBSCxDQUFjeEMsR0FBR29CLFVBQWpCLEVBQ0VhLFdBREYsRUFDZXpCLE1BRGYsRUFDdUJELEtBRHZCLEVBQzhCUSxNQUQ5QixFQUNzQ3FCLE1BRHRDLEVBQzhDNUIsTUFEOUMsRUFDc0QwQixJQUR0RCxFQUM0REYsT0FBT2IsTUFEbkU7O0FBR0EsV0FBS3NCLE1BQUw7QUFDQXpDLFNBQUdxQyxVQUFILENBQWN6QyxHQUFHOEMsc0JBQWpCLEVBQXlDLElBQXpDO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7OztxREFFZ0M3QixJLEVBQU07QUFBQSxVQUVuQ21CLE1BRm1DLEdBV2pDbkIsSUFYaUMsQ0FFbkNtQixNQUZtQztBQUFBLHlCQVdqQ25CLElBWGlDLENBSW5DTixLQUptQztBQUFBLFVBSW5DQSxLQUptQyxnQ0FJM0IsSUFKMkI7QUFBQSwwQkFXakNNLElBWGlDLENBS25DRSxNQUxtQztBQUFBLFVBS25DQSxNQUxtQyxpQ0FLMUIsSUFMMEI7QUFBQSwrQkFXakNGLElBWGlDLENBTW5Db0IsV0FObUM7QUFBQSxVQU1uQ0EsV0FObUMsc0NBTXJCLENBTnFCO0FBQUEsaUNBV2pDcEIsSUFYaUMsQ0FPbkM4QixjQVBtQztBQUFBLFVBT25DQSxjQVBtQyx3Q0FPbEIvQyxHQUFHYSxJQVBlO0FBQUEsMEJBV2pDSSxJQVhpQyxDQVVuQ3VCLE1BVm1DO0FBQUEsVUFVbkNBLE1BVm1DLGlDQVUxQixDQVYwQjtBQUFBLFVBYTlCcEMsRUFiOEIsR0FheEIsSUFid0IsQ0FhOUJBLEVBYjhCOztBQWNyQ0EsU0FBRzRDLG9CQUFILENBQXdCLEtBQUt6QixNQUE3QixFQUNFYyxXQURGLEVBQ2VVLGNBRGYsRUFDK0JwQyxLQUQvQixFQUNzQ1EsTUFEdEMsRUFDOENxQixNQUQ5QyxFQUNzREosTUFEdEQ7QUFFQTtBQUNBO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZDQUt5Qm5CLEksRUFBTTtBQUFBLFVBRTNCZ0MsV0FGMkIsR0FZekJoQyxJQVp5QixDQUUzQmdDLFdBRjJCO0FBQUEsVUFJM0JDLENBSjJCLEdBWXpCakMsSUFaeUIsQ0FJM0JpQyxDQUoyQjtBQUFBLFVBSzNCQyxDQUwyQixHQVl6QmxDLElBWnlCLENBSzNCa0MsQ0FMMkI7QUFBQSxVQU0zQnhDLEtBTjJCLEdBWXpCTSxJQVp5QixDQU0zQk4sS0FOMkI7QUFBQSxVQU8zQlEsTUFQMkIsR0FZekJGLElBWnlCLENBTzNCRSxNQVAyQjtBQUFBLCtCQVl6QkYsSUFaeUIsQ0FRM0JvQixXQVIyQjtBQUFBLFVBUTNCQSxXQVIyQixzQ0FRYixDQVJhO0FBQUEsa0NBWXpCcEIsSUFaeUIsQ0FTM0I4QixjQVQyQjtBQUFBLFVBUzNCQSxjQVQyQix5Q0FTVi9DLEdBQUdhLElBVE87QUFBQSwwQkFZekJJLElBWnlCLENBVzNCdUIsTUFYMkI7QUFBQSxVQVczQkEsTUFYMkIsaUNBV2xCLENBWGtCO0FBQUEsVUFjdEJwQyxFQWRzQixHQWNoQixJQWRnQixDQWN0QkEsRUFkc0I7O0FBZTdCNkMsa0JBQVlOLElBQVo7O0FBRUE7QUFDQSxXQUFLQSxJQUFMO0FBQ0F2QyxTQUFHZ0QsY0FBSCxDQUNFLEtBQUs3QixNQURQLEVBQ2VjLFdBRGYsRUFDNEJVLGNBRDVCLEVBQzRDRyxDQUQ1QyxFQUMrQ0MsQ0FEL0MsRUFDa0R4QyxLQURsRCxFQUN5RFEsTUFEekQsRUFDaUVxQixNQURqRTtBQUVBLFdBQUtLLE1BQUw7O0FBRUFJLGtCQUFZSixNQUFaO0FBQ0Q7OztpQ0FFWTVCLEksRUFBTTtBQUFBLGdDQVliQSxJQVphOztBQWNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Q7Ozs7RUF4TG9DZixPOztlQUFsQkMsUyIsImZpbGUiOiJ0ZXh0dXJlLTJkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtHTH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthc3NlcnRXZWJHTENvbnRleHR9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL3RleHR1cmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlMkQgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICBzdGF0aWMgbWFrZUZyb21Tb2xpZENvbG9yKGdsLCBbciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDFdKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHtcbiAgICAgIHBpeGVsczogbmV3IFVpbnQ4QXJyYXkoW3IsIGcsIGIsIGFdKSxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgZm9ybWF0OiBnbC5SR0JBLFxuICAgICAgbWFnRmlsdGVyOiBnbC5ORUFSRVNULFxuICAgICAgbWluRmlsdGVyOiBnbC5ORUFSRVNUXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgbWFrZUZyb21QaXhlbEFycmF5KGdsLCBvcHRzKSB7XG4gICAgY29uc3Qge2RhdGFBcnJheSwgZm9ybWF0ID0gR0wuUkdCQSwgd2lkdGggPSAxLCBoZWlnaHR9ID0gb3B0cztcbiAgICAvLyBEb24ndCBuZWVkIHRvIGRvIHRoaXMgaWYgdGhlIGRhdGEgaXMgYWxyZWFkeSBpbiBhIHR5cGVkIGFycmF5XG4gICAgY29uc3QgZGF0YVR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhQXJyYXkpO1xuICAgIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIHBpeGVsczogZGF0YVR5cGVkQXJyYXksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGZvcm1hdFxuICAgIH0sIG9wdHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIDJEIFdlYkdMIFRleHR1cmVcbiAgICogTm90ZTogQ29uc3RydWN0b3Igd2lsbCBpbml0aWFsaXplIHlvdXIgdGV4dHVyZS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIGdsIGNvbnRleHRcbiAgICogQHBhcmFtIHtJbWFnZXxBcnJheUJ1ZmZlcnxudWxsfSBvcHRzPSAtIG5hbWVkIG9wdGlvbnNcbiAgICogQHBhcmFtIHtJbWFnZXxBcnJheUJ1ZmZlcnxudWxsfSBvcHRzLmRhdGE9IC0gYnVmZmVyXG4gICAqIEBwYXJhbSB7R0xpbnR9IHdpZHRoIC0gd2lkdGggb2YgdGV4dHVyZVxuICAgKiBAcGFyYW0ge0dMaW50fSBoZWlnaHQgLSBoZWlnaHQgb2YgdGV4dHVyZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2wsIG9wdHMgPSB7fSkge1xuICAgIGFzc2VydFdlYkdMQ29udGV4dChnbCk7XG5cbiAgICBzdXBlcihnbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge3RhcmdldDogZ2wuVEVYVFVSRV8yRH0pKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHRzKTtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLy8gdGFyZ2V0IGNhbm5vdCBiZSBtb2RpZmllZCBieSBiaW5kOlxuICAvLyB0ZXh0dXJlcyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdoZW4geW91IGZpcnN0IGJpbmQgdGhlbSB0byBhIHRhcmdldCxcbiAgLy8gdGhleSBnZXQgc3BlY2lhbCBpbmZvcm1hdGlvbi4gV2hlbiB5b3UgZmlyc3QgYmluZCBhIHRleHR1cmUgYXMgYVxuICAvLyBHTF9URVhUVVJFXzJELCB5b3UgYXJlIGFjdHVhbGx5IHNldHRpbmcgc3BlY2lhbCBzdGF0ZSBpbiB0aGUgdGV4dHVyZS5cbiAgLy8gWW91IGFyZSBzYXlpbmcgdGhhdCB0aGlzIHRleHR1cmUgaXMgYSAyRCB0ZXh0dXJlLlxuICAvLyBBbmQgaXQgd2lsbCBhbHdheXMgYmUgYSAyRCB0ZXh0dXJlOyB0aGlzIHN0YXRlIGNhbm5vdCBiZSBjaGFuZ2VkIGV2ZXIuXG4gIC8vIElmIHlvdSBoYXZlIGEgdGV4dHVyZSB0aGF0IHdhcyBmaXJzdCBib3VuZCBhcyBhIEdMX1RFWFRVUkVfMkQsXG4gIC8vIHlvdSBtdXN0IGFsd2F5cyBiaW5kIGl0IGFzIGEgR0xfVEVYVFVSRV8yRDtcbiAgLy8gYXR0ZW1wdGluZyB0byBiaW5kIGl0IGFzIEdMX1RFWFRVUkVfMUQgd2lsbCBnaXZlIHJpc2UgdG8gYW4gZXJyb3JcbiAgLy8gKHdoaWxlIHJ1bi10aW1lKS5cblxuICBiaW5kKHRleHR1cmVVbml0ID0gdGhpcy50ZXh0dXJlVW5pdCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzO1xuICAgIGlmICh0ZXh0dXJlVW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUuYmluZDogbXVzdCBzcGVjaWZ5IHRleHR1cmUgdW5pdCcpO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXQ7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgIHJldHVybiB0ZXh0dXJlVW5pdDtcbiAgfVxuXG4gIHVuYmluZCgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBpZiAodGhpcy50ZXh0dXJlVW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUudW5iaW5kOiB0ZXh0dXJlIHVuaXQgbm90IHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy50ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUodGhpcy50YXJnZXQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVVbml0O1xuICB9XG5cbiAgZ2V0QWN0aXZlVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoR0wuQUNUSVZFX1RFWFRVUkUpIC0gR0wuVEVYVFVSRTA7XG4gIH1cblxuICAvLyBXZWJHTDJcbiAgc2V0UGl4ZWxzKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHdpZHRoID0gbnVsbCxcbiAgICAgIGhlaWdodCA9IG51bGwsXG4gICAgICBtaXBtYXBMZXZlbCA9IDAsXG4gICAgICBmb3JtYXQgPSBHTC5SR0JBLFxuICAgICAgdHlwZSA9IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICBib3JkZXIgPSAwXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcblxuICAgIC8vIFRoaXMgc2lnbmF0dXJlIG9mIHRleEltYWdlMkQgdXNlcyBjdXJyZW50bHkgYm91bmQgR0xfUElYRUxfVU5QQUNLX0JVRkZFUlxuICAgIGdsLmJpbmRCdWZmZXIoR0wuUElYRUxfVU5QQUNLX0JVRkZFUiwgYnVmZmVyLnRhcmdldCk7XG4gICAgLy8gQW5kIGFzIGFsd2F5cywgd2UgbXVzdCBhbHNvIGJpbmQgdGhlIHRleHR1cmUgaXRzZWxmXG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsXG4gICAgICBtaXBtYXBMZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgYnVmZmVyLnRhcmdldCk7XG5cbiAgICB0aGlzLnVuYmluZCgpO1xuICAgIGdsLmJpbmRCdWZmZXIoR0wuR0xfUElYRUxfVU5QQUNLX0JVRkZFUiwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbWFnZURhdGFGcm9tQ29tcHJlc3NlZEJ1ZmZlcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyLFxuICAgICAgLy8gb2Zmc2V0ID0gMCxcbiAgICAgIHdpZHRoID0gbnVsbCxcbiAgICAgIGhlaWdodCA9IG51bGwsXG4gICAgICBtaXBtYXBMZXZlbCA9IDAsXG4gICAgICBpbnRlcm5hbEZvcm1hdCA9IEdMLlJHQkEsXG4gICAgICAvLyBmb3JtYXQgPSBHTC5SR0JBLFxuICAgICAgLy8gdHlwZSA9IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICBib3JkZXIgPSAwXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCh0aGlzLnRhcmdldCxcbiAgICAgIG1pcG1hcExldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBidWZmZXIpO1xuICAgIC8vIGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKHRhcmdldCxcbiAgICAvLyAgIGxldmVsLCB4b2Zmc2V0LCB5b2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIEFycmF5QnVmZmVyVmlldz8gcGl4ZWxzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgdHdvLWRpbWVuc2lvbmFsIHRleHR1cmUgaW1hZ2Ugb3IgY3ViZS1tYXAgdGV4dHVyZSBpbWFnZSB3aXRoXG4gICAqIHBpeGVscyBmcm9tIHRoZSBjdXJyZW50IGZyYW1lYnVmZmVyIChyYXRoZXIgdGhhbiBmcm9tIGNsaWVudCBtZW1vcnkpLlxuICAgKiAoZ2wuY29weVRleEltYWdlMkQgd3JhcHBlcilcbiAgICovXG4gIGNvcHlJbWFnZUZyb21GcmFtZWJ1ZmZlcihvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVidWZmZXIsXG4gICAgICAvLyBvZmZzZXQgPSAwLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pcG1hcExldmVsID0gMCxcbiAgICAgIGludGVybmFsRm9ybWF0ID0gR0wuUkdCQSxcbiAgICAgIC8vIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgYm9yZGVyID0gMFxuICAgIH0gPSBvcHRzO1xuXG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG4gICAgZnJhbWVidWZmZXIuYmluZCgpO1xuXG4gICAgLy8gdGFyZ2V0XG4gICAgdGhpcy5iaW5kKCk7XG4gICAgZ2wuY29weVRleEltYWdlMkQoXG4gICAgICB0aGlzLnRhcmdldCwgbWlwbWFwTGV2ZWwsIGludGVybmFsRm9ybWF0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIpO1xuICAgIHRoaXMudW5iaW5kKCk7XG5cbiAgICBmcmFtZWJ1ZmZlci51bmJpbmQoKTtcbiAgfVxuXG4gIGNvcHlTdWJJbWFnZShvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgLy8gcGl4ZWxzLFxuICAgICAgLy8gb2Zmc2V0ID0gMCxcbiAgICAgIC8vIHgsXG4gICAgICAvLyB5LFxuICAgICAgLy8gd2lkdGgsXG4gICAgICAvLyBoZWlnaHQsXG4gICAgICAvLyBtaXBtYXBMZXZlbCA9IDAsXG4gICAgICAvLyBpbnRlcm5hbEZvcm1hdCA9IEdMLlJHQkEsXG4gICAgICAvLyB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICAgIC8vIGJvcmRlciA9IDBcbiAgICB9ID0gb3B0cztcblxuICAgIC8vIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAvLyAgIGdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwaXhlbHMpO1xuICAgIC8vIH1cbiAgICAvLyBnbC50ZXhTdWJJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgPyBwaXhlbHMpO1xuICAgIC8vIGdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeCwgeSwgZm9ybWF0LCB0eXBlLCBIVE1MSW1hZ2VFbGVtZW50IHBpeGVscyk7XG4gICAgLy8gZ2wudGV4U3ViSW1hZ2UyRCh0YXJnZXQsIGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIEhUTUxDYW52YXNFbGVtZW50IHBpeGVscyk7XG4gICAgLy8gZ2wudGV4U3ViSW1hZ2UyRCh0YXJnZXQsIGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIEhUTUxWaWRlb0VsZW1lbnQgcGl4ZWxzKTtcbiAgICAvLyAvLyBBZGRpdGlvbmFsIHNpZ25hdHVyZSBpbiBhIFdlYkdMIDIgY29udGV4dDpcbiAgICAvLyBnbC50ZXhTdWJJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgR0xpbnRwdHIgb2Zmc2V0KTtcbiAgfVxufVxuIl19

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseUniformName;
/* harmony export (immutable) */ __webpack_exports__["b"] = getUniformSetter;
/* harmony export (immutable) */ __webpack_exports__["c"] = checkUniformValues;
/* harmony export (immutable) */ __webpack_exports__["d"] = getUniformsTable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__texture__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assert__);
var _UNIFORM_BASE_DESCRIP;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






// TODO - use tables to reduce complexity of method below
/* eslint-disable max-len */
var UNIFORM_BASE_DESCRIPTORS = (_UNIFORM_BASE_DESCRIP = {}, _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT, { function: 'uniform1f', type: Float32Array }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].INT, { function: 'uniform1i', type: Uint16Array }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].BOOL, { function: 'uniform1i', type: Uint16Array }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_VEC2, { function: 'uniform2fv', type: Float32Array, elements: 2 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_VEC3, { function: 'uniform3fv', type: Float32Array, elements: 3 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_VEC4, { function: 'uniform4fv', type: Float32Array, elements: 4 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].INT_VEC2, { function: 'uniform2iv', type: Uint16Array, elements: 2 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].INT_VEC3, { function: 'uniform3iv', type: Uint16Array, elements: 3 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].INT_VEC4, { function: 'uniform4iv', type: Uint16Array, elements: 4 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].BOOL_VEC2, { function: 'uniform2iv', type: Uint16Array, elements: 2 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].BOOL_VEC3, { function: 'uniform3fv', type: Uint16Array, elements: 3 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].BOOL_VEC4, { function: 'uniform4iv', type: Uint16Array, elements: 4 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_MAT2, { function: 'uniformMatrix2fv', type: Float32Array, matrix: true, elements: 4 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_MAT3, { mfunction: 'uniformMatrix3fv', type: Float32Array, matrix: true, elements: 9 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FLOAT_MAT4, { function: 'uniformMatrix4fv', type: Float32Array, matrix: true, elements: 16 }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SAMPLER_2D, { function: 'uniform1i', type: Uint16Array, texture: true }), _defineProperty(_UNIFORM_BASE_DESCRIP, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SAMPLER_CUBE, { function: 'uniform1i', type: Uint16Array, texture: true }), _UNIFORM_BASE_DESCRIP);
/* eslint-enable max-len */

function parseUniformName(name) {
  // name = name[name.length - 1] === ']' ?
  // name.substr(0, name.length - 3) : name;

  // if array name then clean the array brackets
  var UNIFORM_NAME_REGEXP = /([^\[]*)(\[[0-9]+\])?/;
  var matches = name.match(UNIFORM_NAME_REGEXP);
  if (!matches || matches.length < 2) {
    throw new Error('Failed to parse GLSL uniform name ' + name);
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}

// Returns a Magic Uniform Setter
/* eslint-disable complexity */
function getUniformSetter(gl, location, info) {
  var descriptor = UNIFORM_BASE_DESCRIPTORS[info.type];
  if (!descriptor) {
    throw new Error('Unknown GLSL uniform type ' + info.type);
  }

  var glFunction = gl[descriptor.function].bind(gl);
  var TypedArray = descriptor.type;

  // How many data elements does app need to provide
  var flatArrayLength = info.size * (descriptor.elements || 1);

  // console.log('getSetter', location, info, flatArrayLength);

  // Set a uniform array
  var setter = void 0;
  if (flatArrayLength > 1) {
    setter = function setter(val) {
      if (!(val instanceof TypedArray)) {
        var typedArray = new TypedArray(flatArrayLength);
        typedArray.set(val);
        val = typedArray;
      }
      __WEBPACK_IMPORTED_MODULE_3_assert___default()(val.length === flatArrayLength);
      if (descriptor.matrix) {
        // Second param: whether to transpose the matrix. Must be false.
        glFunction(location, false, val);
      } else {
        glFunction(location, val);
      }
    };
  } else {
    setter = function setter(val) {
      return glFunction(location, val);
    };
  }

  // Set a primitive-valued uniform
  return setter;
}

// Basic checks of uniform values without knowledge of program
// To facilitate early detection of e.g. undefined values in JavaScript
function checkUniformValues(uniforms, source) {
  for (var uniformName in uniforms) {
    var value = uniforms[uniformName];
    if (!checkUniformValue(value)) {
      // Add space to source
      source = source ? source + ' ' : '';
      /* eslint-disable no-console */
      /* global console */
      // Value could be unprintable so write the object on console
      console.error(source + ' Bad uniform ' + uniformName, value);
      /* eslint-enable no-console */
      throw new Error(source + ' Bad uniform ' + uniformName);
    }
  }
  return true;
}

function checkUniformValue(value) {
  var ok = true;

  // Test for texture (for sampler uniforms)
  // WebGL2: if (value instanceof Texture || value instanceof Sampler) {
  if (value instanceof __WEBPACK_IMPORTED_MODULE_1__texture__["a" /* default */]) {
    ok = true;
    // Check that every element in array is a number, and at least 1 element
  } else if (Array.isArray(value)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var element = _step.value;

        if (!isFinite(element)) {
          ok = false;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    ok = ok && value.length > 0;
    // Typed arrays can only contain numbers, but check length
  } else if (ArrayBuffer.isView(value)) {
    ok = value.length > 0;
    // Check that single value is a number
  } else if (!isFinite(value)) {
    ok = false;
  }

  return ok;
}

// Prepares a table suitable for console.table
/* eslint-disable max-statements */
function getUniformsTable() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$header = _ref.header,
      header = _ref$header === undefined ? 'Uniforms' : _ref$header,
      program = _ref.program,
      uniforms = _ref.uniforms;

  __WEBPACK_IMPORTED_MODULE_3_assert___default()(program);

  var uniformLocations = program._uniformSetters;
  var table = _defineProperty({}, header, {});

  // Add program's provided uniforms
  for (var uniformName in uniformLocations) {
    var uniform = uniforms[uniformName];
    if (uniform !== undefined) {
      table[uniformName] = {
        Type: uniform,
        Value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["formatValue"])(uniform)
      };
    }
  }

  // Add program's unprovided uniforms
  for (var _uniformName in uniformLocations) {
    var _uniform = uniforms[_uniformName];
    if (_uniform === undefined) {
      table[_uniformName] = {
        Type: 'NOT PROVIDED',
        Value: 'N/A'
      };
    }
  }

  var unusedTable = {};
  var unusedCount = 0;

  // List any unused uniforms
  for (var _uniformName2 in uniforms) {
    var _uniform2 = uniforms[_uniformName2];
    if (!table[_uniformName2]) {
      unusedCount++;
      unusedTable[_uniformName2] = {
        Type: 'NOT USED: ' + _uniform2,
        Value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["formatValue"])(_uniform2)
      };
    }
  }

  return { table: table, unusedTable: unusedTable, unusedCount: unusedCount };
}

/*
  if (vector) {
    switch (type) {
    case GL.FLOAT:
      glFunction = gl.uniform1f;
      break;
    case GL.FLOAT_VEC2:
      glFunction = gl.uniform2fv;
      TypedArray = isArray ? Float32Array : new Float32Array(2);
      break;
    case GL.FLOAT_VEC3:
      glFunction = gl.uniform3fv;
      TypedArray = isArray ? Float32Array : new Float32Array(3);
      break;
    case GL.FLOAT_VEC4:
      glFunction = gl.uniform4fv;
      TypedArray = isArray ? Float32Array : new Float32Array(4);
      break;
    case GL.INT:
    case GL.BOOL:
    case GL.SAMPLER_2D:
    case GL.SAMPLER_CUBE:
      glFunction = gl.uniform1i;
      break;
    case GL.INT_VEC2:
    case GL.BOOL_VEC2:
      glFunction = gl.uniform2iv;
      TypedArray = isArray ? Uint16Array : new Uint16Array(2);
      break;
    case GL.INT_VEC3:
    case GL.BOOL_VEC3:
      glFunction = gl.uniform3iv;
      TypedArray = isArray ? Uint16Array : new Uint16Array(3);
      break;
    case GL.INT_VEC4:
    case GL.BOOL_VEC4:
      glFunction = gl.uniform4iv;
      TypedArray = isArray ? Uint16Array : new Uint16Array(4);
      break;
    case GL.FLOAT_MAT2:
      matrix = true;
      glFunction = gl.uniformMatrix2fv;
      break;
    case GL.FLOAT_MAT3:
      matrix = true;
      glFunction = gl.uniformMatrix3fv;
      break;
    case GL.FLOAT_MAT4:
      matrix = true;
      glFunction = gl.uniformMatrix4fv;
      break;
    default:
      break;
    }
  }
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC91bmlmb3Jtcy5qcyJdLCJuYW1lcyI6WyJHTCIsIlRleHR1cmUiLCJmb3JtYXRWYWx1ZSIsImFzc2VydCIsIlVOSUZPUk1fQkFTRV9ERVNDUklQVE9SUyIsIkZMT0FUIiwiZnVuY3Rpb24iLCJ0eXBlIiwiRmxvYXQzMkFycmF5IiwiSU5UIiwiVWludDE2QXJyYXkiLCJCT09MIiwiRkxPQVRfVkVDMiIsImVsZW1lbnRzIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJJTlRfVkVDMiIsIklOVF9WRUMzIiwiSU5UX1ZFQzQiLCJCT09MX1ZFQzIiLCJCT09MX1ZFQzMiLCJCT09MX1ZFQzQiLCJGTE9BVF9NQVQyIiwibWF0cml4IiwiRkxPQVRfTUFUMyIsIm1mdW5jdGlvbiIsIkZMT0FUX01BVDQiLCJTQU1QTEVSXzJEIiwidGV4dHVyZSIsIlNBTVBMRVJfQ1VCRSIsInBhcnNlVW5pZm9ybU5hbWUiLCJuYW1lIiwiVU5JRk9STV9OQU1FX1JFR0VYUCIsIm1hdGNoZXMiLCJtYXRjaCIsImxlbmd0aCIsIkVycm9yIiwiaXNBcnJheSIsIkJvb2xlYW4iLCJnZXRVbmlmb3JtU2V0dGVyIiwiZ2wiLCJsb2NhdGlvbiIsImluZm8iLCJkZXNjcmlwdG9yIiwiZ2xGdW5jdGlvbiIsImJpbmQiLCJUeXBlZEFycmF5IiwiZmxhdEFycmF5TGVuZ3RoIiwic2l6ZSIsInNldHRlciIsInZhbCIsInR5cGVkQXJyYXkiLCJzZXQiLCJjaGVja1VuaWZvcm1WYWx1ZXMiLCJ1bmlmb3JtcyIsInNvdXJjZSIsInVuaWZvcm1OYW1lIiwidmFsdWUiLCJjaGVja1VuaWZvcm1WYWx1ZSIsImNvbnNvbGUiLCJlcnJvciIsIm9rIiwiQXJyYXkiLCJlbGVtZW50IiwiaXNGaW5pdGUiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImdldFVuaWZvcm1zVGFibGUiLCJoZWFkZXIiLCJwcm9ncmFtIiwidW5pZm9ybUxvY2F0aW9ucyIsIl91bmlmb3JtU2V0dGVycyIsInRhYmxlIiwidW5pZm9ybSIsInVuZGVmaW5lZCIsIlR5cGUiLCJWYWx1ZSIsInVudXNlZFRhYmxlIiwidW51c2VkQ291bnQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPQSxFQUFQLE1BQWUsT0FBZjtBQUNBLE9BQU9DLE9BQVAsTUFBb0IsV0FBcEI7QUFDQSxTQUFRQyxXQUFSLFFBQTBCLFVBQTFCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTtBQUNBO0FBQ0EsSUFBTUMsK0ZBQ0hKLEdBQUdLLEtBREEsRUFDUSxFQUFDQyxVQUFVLFdBQVgsRUFBd0JDLE1BQU1DLFlBQTlCLEVBRFIsMENBRUhSLEdBQUdTLEdBRkEsRUFFTSxFQUFDSCxVQUFVLFdBQVgsRUFBd0JDLE1BQU1HLFdBQTlCLEVBRk4sMENBR0hWLEdBQUdXLElBSEEsRUFHTyxFQUFDTCxVQUFVLFdBQVgsRUFBd0JDLE1BQU1HLFdBQTlCLEVBSFAsMENBSUhWLEdBQUdZLFVBSkEsRUFJYSxFQUFDTixVQUFVLFlBQVgsRUFBeUJDLE1BQU1DLFlBQS9CLEVBQTZDSyxVQUFVLENBQXZELEVBSmIsMENBS0hiLEdBQUdjLFVBTEEsRUFLYSxFQUFDUixVQUFVLFlBQVgsRUFBeUJDLE1BQU1DLFlBQS9CLEVBQTZDSyxVQUFVLENBQXZELEVBTGIsMENBTUhiLEdBQUdlLFVBTkEsRUFNYSxFQUFDVCxVQUFVLFlBQVgsRUFBeUJDLE1BQU1DLFlBQS9CLEVBQTZDSyxVQUFVLENBQXZELEVBTmIsMENBT0hiLEdBQUdnQixRQVBBLEVBT1csRUFBQ1YsVUFBVSxZQUFYLEVBQXlCQyxNQUFNRyxXQUEvQixFQUE0Q0csVUFBVSxDQUF0RCxFQVBYLDBDQVFIYixHQUFHaUIsUUFSQSxFQVFXLEVBQUNYLFVBQVUsWUFBWCxFQUF5QkMsTUFBTUcsV0FBL0IsRUFBNENHLFVBQVUsQ0FBdEQsRUFSWCwwQ0FTSGIsR0FBR2tCLFFBVEEsRUFTVyxFQUFDWixVQUFVLFlBQVgsRUFBeUJDLE1BQU1HLFdBQS9CLEVBQTRDRyxVQUFVLENBQXRELEVBVFgsMENB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SUQ7QUFDRjs7QUFFRCxNQUFNQyxjQUFjLEVBQXBCO0FBQ0EsTUFBSUMsY0FBYyxDQUFsQjs7QUFFQTtBQUNBLE9BQUssSUFBTXRCLGFBQVgsSUFBMEJGLFFBQTFCLEVBQW9DO0FBQ2xDLFFBQU1tQixZQUFVbkIsU0FBU0UsYUFBVCxDQUFoQjtBQUNBLFFBQUksQ0FBQ2dCLE1BQU1oQixhQUFOLENBQUwsRUFBeUI7QUFDdkJzQjtBQUNBRCxrQkFBWXJCLGFBQVosSUFBMkI7QUFDekJtQiw2QkFBbUJGLFNBRE07QUFFekJHLGVBQU8xRSxZQUFZdUUsU0FBWjtBQUZrQixPQUEzQjtBQUlEO0FBQ0Y7O0FBRUQsU0FBTyxFQUFDRCxZQUFELEVBQVFLLHdCQUFSLEVBQXFCQyx3QkFBckIsRUFBUDtBQUNEOztBQUVEIiwiZmlsZSI6InVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdMIGZyb20gJy4vYXBpJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5pbXBvcnQge2Zvcm1hdFZhbHVlfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIFRPRE8gLSB1c2UgdGFibGVzIHRvIHJlZHVjZSBjb21wbGV4aXR5IG9mIG1ldGhvZCBiZWxvd1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuY29uc3QgVU5JRk9STV9CQVNFX0RFU0NSSVBUT1JTID0ge1xuICBbR0wuRkxPQVRdOiB7ZnVuY3Rpb246ICd1bmlmb3JtMWYnLCB0eXBlOiBGbG9hdDMyQXJyYXl9LFxuICBbR0wuSU5UXToge2Z1bmN0aW9uOiAndW5pZm9ybTFpJywgdHlwZTogVWludDE2QXJyYXl9LFxuICBbR0wuQk9PTF06IHtmdW5jdGlvbjogJ3VuaWZvcm0xaScsIHR5cGU6IFVpbnQxNkFycmF5fSxcbiAgW0dMLkZMT0FUX1ZFQzJdOiB7ZnVuY3Rpb246ICd1bmlmb3JtMmZ2JywgdHlwZTogRmxvYXQzMkFycmF5LCBlbGVtZW50czogMn0sXG4gIFtHTC5GTE9BVF9WRUMzXToge2Z1bmN0aW9uOiAndW5pZm9ybTNmdicsIHR5cGU6IEZsb2F0MzJBcnJheSwgZWxlbWVudHM6IDN9LFxuICBbR0wuRkxPQVRfVkVDNF06IHtmdW5jdGlvbjogJ3VuaWZvcm00ZnYnLCB0eXBlOiBGbG9hdDMyQXJyYXksIGVsZW1lbnRzOiA0fSxcbiAgW0dMLklOVF9WRUMyXToge2Z1bmN0aW9uOiAndW5pZm9ybTJpdicsIHR5cGU6IFVpbnQxNkFycmF5LCBlbGVtZW50czogMn0sXG4gIFtHTC5JTlRfVkVDM106IHtmdW5jdGlvbjogJ3VuaWZvcm0zaXYnLCB0eXBlOiBVaW50MTZBcnJheSwgZWxlbWVudHM6IDN9LFxuICBbR0wuSU5UX1ZFQzRdOiB7ZnVuY3Rpb246ICd1bmlmb3JtNGl2JywgdHlwZTogVWludDE2QXJyYXksIGVsZW1lbnRzOiA0fSxcbiAgW0dMLkJPT0xfVkVDMl06IHtmdW5jdGlvbjogJ3VuaWZvcm0yaXYnLCB0eXBlOiBVaW50MTZBcnJheSwgZWxlbWVudHM6IDJ9LFxuICBbR0wuQk9PTF9WRUMzXToge2Z1bmN0aW9uOiAndW5pZm9ybTNmdicsIHR5cGU6IFVpbnQxNkFycmF5LCBlbGVtZW50czogM30sXG4gIFtHTC5CT09MX1ZFQzRdOiB7ZnVuY3Rpb246ICd1bmlmb3JtNGl2JywgdHlwZTogVWludDE2QXJyYXksIGVsZW1lbnRzOiA0fSxcbiAgW0dMLkZMT0FUX01BVDJdOiB7ZnVuY3Rpb246ICd1bmlmb3JtTWF0cml4MmZ2JywgdHlwZTogRmxvYXQzMkFycmF5LCBtYXRyaXg6IHRydWUsIGVsZW1lbnRzOiA0fSxcbiAgW0dMLkZMT0FUX01BVDNdOiB7bWZ1bmN0aW9uOiAndW5pZm9ybU1hdHJpeDNmdicsIHR5cGU6IEZsb2F0MzJBcnJheSwgbWF0cml4OiB0cnVlLCBlbGVtZW50czogOX0sXG4gIFtHTC5GTE9BVF9NQVQ0XToge2Z1bmN0aW9uOiAndW5pZm9ybU1hdHJpeDRmdicsIHR5cGU6IEZsb2F0MzJBcnJheSwgbWF0cml4OiB0cnVlLCBlbGVtZW50czogMTZ9LFxuICBbR0wuU0FNUExFUl8yRF06IHtmdW5jdGlvbjogJ3VuaWZvcm0xaScsIHR5cGU6IFVpbnQxNkFycmF5LCB0ZXh0dXJlOiB0cnVlfSxcbiAgW0dMLlNBTVBMRVJfQ1VCRV06IHtmdW5jdGlvbjogJ3VuaWZvcm0xaScsIHR5cGU6IFVpbnQxNkFycmF5LCB0ZXh0dXJlOiB0cnVlfVxufTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbmlmb3JtTmFtZShuYW1lKSB7XG4gIC8vIG5hbWUgPSBuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICddJyA/XG4gIC8vIG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gMykgOiBuYW1lO1xuXG4gIC8vIGlmIGFycmF5IG5hbWUgdGhlbiBjbGVhbiB0aGUgYXJyYXkgYnJhY2tldHNcbiAgY29uc3QgVU5JRk9STV9OQU1FX1JFR0VYUCA9IC8oW15cXFtdKikoXFxbWzAtOV0rXFxdKT8vO1xuICBjb25zdCBtYXRjaGVzID0gbmFtZS5tYXRjaChVTklGT1JNX05BTUVfUkVHRVhQKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIEdMU0wgdW5pZm9ybSBuYW1lICR7bmFtZX1gKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbWF0Y2hlc1sxXSxcbiAgICBsZW5ndGg6IG1hdGNoZXNbMl0gfHwgMSxcbiAgICBpc0FycmF5OiBCb29sZWFuKG1hdGNoZXNbMl0pXG4gIH07XG59XG5cbi8vIFJldHVybnMgYSBNYWdpYyBVbmlmb3JtIFNldHRlclxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaWZvcm1TZXR0ZXIoZ2wsIGxvY2F0aW9uLCBpbmZvKSB7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBVTklGT1JNX0JBU0VfREVTQ1JJUFRPUlNbaW5mby50eXBlXTtcbiAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEdMU0wgdW5pZm9ybSB0eXBlICR7aW5mby50eXBlfWApO1xuICB9XG5cbiAgY29uc3QgZ2xGdW5jdGlvbiA9IGdsW2Rlc2NyaXB0b3IuZnVuY3Rpb25dLmJpbmQoZ2wpO1xuICBjb25zdCBUeXBlZEFycmF5ID0gZGVzY3JpcHRvci50eXBlO1xuXG4gIC8vIEhvdyBtYW55IGRhdGEgZWxlbWVudHMgZG9lcyBhcHAgbmVlZCB0byBwcm92aWRlXG4gIGNvbnN0IGZsYXRBcnJheUxlbmd0aCA9IGluZm8uc2l6ZSAqIChkZXNjcmlwdG9yLmVsZW1lbnRzIHx8IDEpO1xuXG4gIC8vIGNvbnNvbGUubG9nKCdnZXRTZXR0ZXInLCBsb2NhdGlvbiwgaW5mbywgZmxhdEFycmF5TGVuZ3RoKTtcblxuICAvLyBTZXQgYSB1bmlmb3JtIGFycmF5XG4gIGxldCBzZXR0ZXI7XG4gIGlmIChmbGF0QXJyYXlMZW5ndGggPiAxKSB7XG4gICAgc2V0dGVyID0gdmFsID0+IHtcbiAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIFR5cGVkQXJyYXkpKSB7XG4gICAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSBuZXcgVHlwZWRBcnJheShmbGF0QXJyYXlMZW5ndGgpO1xuICAgICAgICB0eXBlZEFycmF5LnNldCh2YWwpO1xuICAgICAgICB2YWwgPSB0eXBlZEFycmF5O1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHZhbC5sZW5ndGggPT09IGZsYXRBcnJheUxlbmd0aCk7XG4gICAgICBpZiAoZGVzY3JpcHRvci5tYXRyaXgpIHtcbiAgICAgICAgLy8gU2Vjb25kIHBhcmFtOiB3aGV0aGVyIHRvIHRyYW5zcG9zZSB0aGUgbWF0cml4LiBNdXN0IGJlIGZhbHNlLlxuICAgICAgICBnbEZ1bmN0aW9uKGxvY2F0aW9uLCBmYWxzZSwgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsRnVuY3Rpb24obG9jYXRpb24sIHZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzZXR0ZXIgPSB2YWwgPT4gZ2xGdW5jdGlvbihsb2NhdGlvbiwgdmFsKTtcbiAgfVxuXG4gIC8vIFNldCBhIHByaW1pdGl2ZS12YWx1ZWQgdW5pZm9ybVxuICByZXR1cm4gc2V0dGVyO1xufVxuXG4vLyBCYXNpYyBjaGVja3Mgb2YgdW5pZm9ybSB2YWx1ZXMgd2l0aG91dCBrbm93bGVkZ2Ugb2YgcHJvZ3JhbVxuLy8gVG8gZmFjaWxpdGF0ZSBlYXJseSBkZXRlY3Rpb24gb2YgZS5nLiB1bmRlZmluZWQgdmFsdWVzIGluIEphdmFTY3JpcHRcbmV4cG9ydCBmdW5jdGlvbiBjaGVja1VuaWZvcm1WYWx1ZXModW5pZm9ybXMsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgY29uc3QgdmFsdWUgPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG4gICAgaWYgKCFjaGVja1VuaWZvcm1WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIEFkZCBzcGFjZSB0byBzb3VyY2VcbiAgICAgIHNvdXJjZSA9IHNvdXJjZSA/IGAke3NvdXJjZX0gYCA6ICcnO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgICAgIC8vIFZhbHVlIGNvdWxkIGJlIHVucHJpbnRhYmxlIHNvIHdyaXRlIHRoZSBvYmplY3Qgb24gY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgJHtzb3VyY2V9IEJhZCB1bmlmb3JtICR7dW5pZm9ybU5hbWV9YCwgdmFsdWUpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c291cmNlfSBCYWQgdW5pZm9ybSAke3VuaWZvcm1OYW1lfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tVbmlmb3JtVmFsdWUodmFsdWUpIHtcbiAgbGV0IG9rID0gdHJ1ZTtcblxuICAvLyBUZXN0IGZvciB0ZXh0dXJlIChmb3Igc2FtcGxlciB1bmlmb3JtcylcbiAgLy8gV2ViR0wyOiBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlIHx8IHZhbHVlIGluc3RhbmNlb2YgU2FtcGxlcikge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgb2sgPSB0cnVlO1xuICAvLyBDaGVjayB0aGF0IGV2ZXJ5IGVsZW1lbnQgaW4gYXJyYXkgaXMgYSBudW1iZXIsIGFuZCBhdCBsZWFzdCAxIGVsZW1lbnRcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZSkge1xuICAgICAgaWYgKCFpc0Zpbml0ZShlbGVtZW50KSkge1xuICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBvayA9IG9rICYmICh2YWx1ZS5sZW5ndGggPiAwKTtcbiAgLy8gVHlwZWQgYXJyYXlzIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgYnV0IGNoZWNrIGxlbmd0aFxuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICBvayA9IHZhbHVlLmxlbmd0aCA+IDA7XG4gIC8vIENoZWNrIHRoYXQgc2luZ2xlIHZhbHVlIGlzIGEgbnVtYmVyXG4gIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIG9rID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gb2s7XG59XG5cbi8vIFByZXBhcmVzIGEgdGFibGUgc3VpdGFibGUgZm9yIGNvbnNvbGUudGFibGVcbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pZm9ybXNUYWJsZSh7XG4gIGhlYWRlciA9ICdVbmlmb3JtcycsXG4gIHByb2dyYW0sXG4gIHVuaWZvcm1zXG59ID0ge30pIHtcbiAgYXNzZXJ0KHByb2dyYW0pO1xuXG4gIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSBwcm9ncmFtLl91bmlmb3JtU2V0dGVycztcbiAgY29uc3QgdGFibGUgPSB7W2hlYWRlcl06IHt9fTtcblxuICAvLyBBZGQgcHJvZ3JhbSdzIHByb3ZpZGVkIHVuaWZvcm1zXG4gIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybUxvY2F0aW9ucykge1xuICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG4gICAgaWYgKHVuaWZvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFibGVbdW5pZm9ybU5hbWVdID0ge1xuICAgICAgICBUeXBlOiB1bmlmb3JtLFxuICAgICAgICBWYWx1ZTogZm9ybWF0VmFsdWUodW5pZm9ybSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHByb2dyYW0ncyB1bnByb3ZpZGVkIHVuaWZvcm1zXG4gIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybUxvY2F0aW9ucykge1xuICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG4gICAgaWYgKHVuaWZvcm0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFibGVbdW5pZm9ybU5hbWVdID0ge1xuICAgICAgICBUeXBlOiAnTk9UIFBST1ZJREVEJyxcbiAgICAgICAgVmFsdWU6ICdOL0EnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVudXNlZFRhYmxlID0ge307XG4gIGxldCB1bnVzZWRDb3VudCA9IDA7XG5cbiAgLy8gTGlzdCBhbnkgdW51c2VkIHVuaWZvcm1zXG4gIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpIHtcbiAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuICAgIGlmICghdGFibGVbdW5pZm9ybU5hbWVdKSB7XG4gICAgICB1bnVzZWRDb3VudCsrO1xuICAgICAgdW51c2VkVGFibGVbdW5pZm9ybU5hbWVdID0ge1xuICAgICAgICBUeXBlOiBgTk9UIFVTRUQ6ICR7dW5pZm9ybX1gLFxuICAgICAgICBWYWx1ZTogZm9ybWF0VmFsdWUodW5pZm9ybSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHt0YWJsZSwgdW51c2VkVGFibGUsIHVudXNlZENvdW50fTtcbn1cblxuLypcbiAgaWYgKHZlY3Rvcikge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR0wuRkxPQVQ6XG4gICAgICBnbEZ1bmN0aW9uID0gZ2wudW5pZm9ybTFmO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHTC5GTE9BVF9WRUMyOlxuICAgICAgZ2xGdW5jdGlvbiA9IGdsLnVuaWZvcm0yZnY7XG4gICAgICBUeXBlZEFycmF5ID0gaXNBcnJheSA/IEZsb2F0MzJBcnJheSA6IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdMLkZMT0FUX1ZFQzM6XG4gICAgICBnbEZ1bmN0aW9uID0gZ2wudW5pZm9ybTNmdjtcbiAgICAgIFR5cGVkQXJyYXkgPSBpc0FycmF5ID8gRmxvYXQzMkFycmF5IDogbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgR0wuRkxPQVRfVkVDNDpcbiAgICAgIGdsRnVuY3Rpb24gPSBnbC51bmlmb3JtNGZ2O1xuICAgICAgVHlwZWRBcnJheSA9IGlzQXJyYXkgPyBGbG9hdDMyQXJyYXkgOiBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHTC5JTlQ6XG4gICAgY2FzZSBHTC5CT09MOlxuICAgIGNhc2UgR0wuU0FNUExFUl8yRDpcbiAgICBjYXNlIEdMLlNBTVBMRVJfQ1VCRTpcbiAgICAgIGdsRnVuY3Rpb24gPSBnbC51bmlmb3JtMWk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdMLklOVF9WRUMyOlxuICAgIGNhc2UgR0wuQk9PTF9WRUMyOlxuICAgICAgZ2xGdW5jdGlvbiA9IGdsLnVuaWZvcm0yaXY7XG4gICAgICBUeXBlZEFycmF5ID0gaXNBcnJheSA/IFVpbnQxNkFycmF5IDogbmV3IFVpbnQxNkFycmF5KDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHTC5JTlRfVkVDMzpcbiAgICBjYXNlIEdMLkJPT0xfVkVDMzpcbiAgICAgIGdsRnVuY3Rpb24gPSBnbC51bmlmb3JtM2l2O1xuICAgICAgVHlwZWRBcnJheSA9IGlzQXJyYXkgPyBVaW50MTZBcnJheSA6IG5ldyBVaW50MTZBcnJheSgzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgR0wuSU5UX1ZFQzQ6XG4gICAgY2FzZSBHTC5CT09MX1ZFQzQ6XG4gICAgICBnbEZ1bmN0aW9uID0gZ2wudW5pZm9ybTRpdjtcbiAgICAgIFR5cGVkQXJyYXkgPSBpc0FycmF5ID8gVWludDE2QXJyYXkgOiBuZXcgVWludDE2QXJyYXkoNCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdMLkZMT0FUX01BVDI6XG4gICAgICBtYXRyaXggPSB0cnVlO1xuICAgICAgZ2xGdW5jdGlvbiA9IGdsLnVuaWZvcm1NYXRyaXgyZnY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdMLkZMT0FUX01BVDM6XG4gICAgICBtYXRyaXggPSB0cnVlO1xuICAgICAgZ2xGdW5jdGlvbiA9IGdsLnVuaWZvcm1NYXRyaXgzZnY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdMLkZMT0FUX01BVDQ6XG4gICAgICBtYXRyaXggPSB0cnVlO1xuICAgICAgZ2xGdW5jdGlvbiA9IGdsLnVuaWZvcm1NYXRyaXg0ZnY7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4qL1xuIl19

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(23);

var ReactNoopUpdateQueue = __webpack_require__(66);

var canDefineProperty = __webpack_require__(39);
var emptyObject = __webpack_require__(48);
var invariant = __webpack_require__(14);
var warning = __webpack_require__(11);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(23);

var ReactCurrentOwner = __webpack_require__(38);

var invariant = __webpack_require__(14);
var warning = __webpack_require__(11);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(11);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var isBrowser = window && window.addEventListener;

/**
 * Low-level api leveraging window.postMessage
 *
 * @param type {String} The action type
 * @param payload {Any} The action payload
 */
var send = function send(type) {
  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isBrowser || !window.__SEER_INITIALIZED__) {
    return;
  }
  try {
    window.postMessage({ type: type, payload: payload, source: 'seer-agent' }, '*');
  } catch (e) {// eslint-disable-line
  }
};

var listeners = new Map();

var listener = function listener(message) {
  if (!message || !message.data || message.data.source !== 'seer-core') {
    return;
  }
  var _message$data = message.data,
      type = _message$data.type,
      payload = _message$data.payload;


  var typeListeners = listeners.get(type);
  if (typeListeners) {
    typeListeners.forEach(function (cb) {
      return cb(payload);
    });
  }
};

/**
 * Initilize window listener. There will be only one for the whole process
 * to prevent too many registrations.
 *
 * This method will be called automatically if you use the `listenFor` method.
 */
var init = function init() {
  if (!isBrowser || window.__SEER_LISTENER__) {
    return;
  }
  window.addEventListener('message', listener);
  window.__SEER_LISTENER__ = true;
};

/**
 * Clean listener. Can be useful in case you want to unregister upcoming events
 * or liberate memory.
 */
var clean = function clean() {
  if (!isBrowser || !window.__SEER_LISTENER__) {
    return;
  }
  window.removeEventListener('message', listener);
  delete window.__SEER_LISTENER__;
};

/**
 * Create a listener that will be called upon events of the given key
 *
 * @param key {String} The unique tab key
 * @param cb {Function} A callback that will receive the message payload
 */
var listenFor = function listenFor(type, cb) {
  if (!type || !cb) {
    throw new Error('Please provide a type and callback');
  }
  if (!listeners.has(type)) {
    listeners.set(type, []);
  }
  if (!window.__SEER_LISTENER__) {
    init();
  }
  listeners.get(type).push(cb);
};

/**
 * Basic tab creation
 *
 * @param key {String} The unique key of the tab
 */
var createTab = function createTab(key) {
  return send('CREATE_TAB', { key: key });
};

/**
 * Basic tab deletion
 *
 * @param key {Stirng} The unique key of the tab
 */
var removeTab = function removeTab(key) {
  return send('REMOVE_TAB', { key: key });
};

/**
 * Creates a new simple list
 * TODO push, remove
 *
 * @param key {String} The key of the tab
 * @param data {Array} The array representing the list
 */
var list = function list(key, data) {
  return send('LIST', { key: key, data: data });
};

/**
 * Creates a new indexed list, usefull for O(1) accessing and performance
 *
 * @param key {String} The key of the tab
 * @param data {Object} The indexed object
 */
var indexedList = function indexedList(key, data) {
  return send('INDEXED_LIST', { key: key, data: data });
};

/**
 * Creates/Update an element in the indexed list, based on the itemKey
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param data {Any} The value of the item
 */
var indexedListItem = function indexedListItem(key, itemKey, data) {
  return send('INDEXED_LIST_ITEM', { key: key, itemKey: itemKey, data: data });
};

exports.default = {
  send: send,
  createTab: createTab,
  removeTab: removeTab,

  list: list,

  indexedList: indexedList,
  indexedListItem: indexedListItem,

  listeners: listeners,
  listenFor: listenFor,
  init: init,
  clean: clean
};


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setOverride; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getOverrides; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return layerEditListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return logLayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_seer__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_seer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_seer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__);
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }




/**
 * Recursively set a nested property of an object given a properties array and a value
 */
var recursiveSet = function recursiveSet(obj, path, value) {
  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

/**
 * Create an override on the specify layer, indexed by a valuePath array.
 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
 */
var setOverride = function setOverride(id, valuePath, value) {
  if (!__WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__["window"].__SEER_INITIALIZED__) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var props = overrides.get(id);
  props.set(valuePath, value);
};

/**
 * Get the props overrides of a specific layer if Seer as been initialized
 * Invalidates the data to be sure new ones are always picked up.
 */
var getOverrides = function getOverrides(props) {
  if (!__WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__["window"].__SEER_INITIALIZED__ || !props.id) {
    return;
  }

  var overs = overrides.get(props.id);
  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(props, valuePath, value);
    // Invalidate data array if we have a data override
    if (valuePath[0] === 'data') {
      props.data = [].concat(_toConsumableArray(props.data));
    }
  });
};

/**
 * Listen for deck.gl edit events
 */
var layerEditListener = function layerEditListener(cb) {
  if (!__WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__["window"].__SEER_INITIALIZED__) {
    return;
  }

  __WEBPACK_IMPORTED_MODULE_0_seer___default.a.listenFor('deck.gl', function (payload) {
    if (payload.type !== 'edit') {
      return;
    }

    cb(payload);
  });
};

// Blacklist some properties that can't be stringified (eg: circular dependencies)
var dataBlackList = ['zoomLevels'];

/**
 * Transform the data passed to Seer for performance purposes.
 * Slice the data array to the first 20 items
 */
var transformData = function transformData(data) {
  if (!data) {
    return [];
  }

  var out = data.type === 'FeatureCollection' ? data.features : data;
  return out.slice(0, 20).map(function (item) {
    return Object.keys(item).reduce(function (acc, key) {
      if (dataBlackList.includes(key)) {
        return acc;
      }
      acc[key] = item[key];
      return acc;
    }, {});
  });
};

/**
 * Log layer's properties to Seer
 */
var logLayer = function logLayer(layer) {
  if (!__WEBPACK_IMPORTED_MODULE_1__lib_utils_globals__["window"].__SEER_INITIALIZED__) {
    return;
  }

  var simpleProps = Object.keys(layer.props).reduce(function (acc, key) {
    if (typeof layer.props[key] === 'function') {
      return acc;
    }

    acc[key] = key === 'data' ? transformData(layer.props.data) : layer.props[key];
    return acc;
  }, {});

  __WEBPACK_IMPORTED_MODULE_0_seer___default.a.indexedListItem('deck.gl', layer.id, simpleProps);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWJ1Zy9zZWVyLWludGVncmF0aW9uLmpzIl0sIm5hbWVzIjpbInNlZXIiLCJ3aW5kb3ciLCJyZWN1cnNpdmVTZXQiLCJvYmoiLCJwYXRoIiwidmFsdWUiLCJsZW5ndGgiLCJzbGljZSIsIm92ZXJyaWRlcyIsIk1hcCIsInNldE92ZXJyaWRlIiwiaWQiLCJ2YWx1ZVBhdGgiLCJfX1NFRVJfSU5JVElBTElaRURfXyIsImhhcyIsInNldCIsInByb3BzIiwiZ2V0IiwiZ2V0T3ZlcnJpZGVzIiwib3ZlcnMiLCJmb3JFYWNoIiwiZGF0YSIsImxheWVyRWRpdExpc3RlbmVyIiwibGlzdGVuRm9yIiwicGF5bG9hZCIsInR5cGUiLCJjYiIsImRhdGFCbGFja0xpc3QiLCJ0cmFuc2Zvcm1EYXRhIiwib3V0IiwiZmVhdHVyZXMiLCJtYXAiLCJPYmplY3QiLCJrZXlzIiwiaXRlbSIsInJlZHVjZSIsImFjYyIsImtleSIsImluY2x1ZGVzIiwibG9nTGF5ZXIiLCJzaW1wbGVQcm9wcyIsImxheWVyIiwiaW5kZXhlZExpc3RJdGVtIl0sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU9BLElBQVAsTUFBaUIsTUFBakI7QUFDQSxTQUFRQyxNQUFSLFFBQXFCLHNCQUFyQjs7QUFFQTs7O0FBR0EsSUFBTUMsZUFBZSxTQUFmQSxZQUFlLENBQUNDLEdBQUQsRUFBTUMsSUFBTixFQUFZQyxLQUFaLEVBQXNCO0FBQ3pDLE1BQUlELEtBQUtFLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQkosaUJBQWFDLElBQUlDLEtBQUssQ0FBTCxDQUFKLENBQWIsRUFBMkJBLEtBQUtHLEtBQUwsQ0FBVyxDQUFYLENBQTNCLEVBQTBDRixLQUExQztBQUNELEdBRkQsTUFFTztBQUNMRixRQUFJQyxLQUFLLENBQUwsQ0FBSixJQUFlQyxLQUFmO0FBQ0Q7QUFDRixDQU5EOztBQVFBLElBQU1HLFlBQVksSUFBSUMsR0FBSixFQUFsQjs7QUFFQTs7OztBQUlBLE9BQU8sSUFBTUMsY0FBYyxT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LElBQTFCLENBQWpCLEdBQW1Eb0IsTUFBTXpCLEtBQU4sQ0FBWXFCLEdBQVosQ0FBOUQ7QUFDQSxXQUFPRCxHQUFQO0FBQ0QsR0FQbUIsRUFPakIsRUFQaUIsQ0FBcEI7O0FBU0FwQyxPQUFLMEMsZUFBTCxDQUFxQixTQUFyQixFQUFnQ0QsTUFBTTlCLEVBQXRDLEVBQTBDNkIsV0FBMUM7QUFFRCxDQWhCTSIsImZpbGUiOiJzZWVyLWludGVncmF0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNlZXIgZnJvbSAnc2Vlcic7XG5pbXBvcnQge3dpbmRvd30gZnJvbSAnLi4vbGliL3V0aWxzL2dsb2JhbHMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgZ2l2ZW4gYSBwcm9wZXJ0aWVzIGFycmF5IGFuZCBhIHZhbHVlXG4gKi9cbmNvbnN0IHJlY3Vyc2l2ZVNldCA9IChvYmosIHBhdGgsIHZhbHVlKSA9PiB7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICByZWN1cnNpdmVTZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW3BhdGhbMF1dID0gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IG92ZXJyaWRlcyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gb3ZlcnJpZGUgb24gdGhlIHNwZWNpZnkgbGF5ZXIsIGluZGV4ZWQgYnkgYSB2YWx1ZVBhdGggYXJyYXkuXG4gKiBEbyBub3RoaW5nIGluIGNhc2UgU2VlciBhcyBub3QgYmVlbiBpbml0aWFsaXplZCB0byBwcmV2ZW50IGFueSBwcmVmb3JtYW5jZSBkcmF3YmFjay5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldE92ZXJyaWRlID0gKGlkLCB2YWx1ZVBhdGgsIHZhbHVlKSA9PiB7XG4gIGlmICghd2luZG93Ll9fU0VFUl9JTklUSUFMSVpFRF9fKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFvdmVycmlkZXMuaGFzKGlkKSkge1xuICAgIG92ZXJyaWRlcy5zZXQoaWQsIG5ldyBNYXAoKSk7XG4gIH1cblxuICBjb25zdCBwcm9wcyA9IG92ZXJyaWRlcy5nZXQoaWQpO1xuICBwcm9wcy5zZXQodmFsdWVQYXRoLCB2YWx1ZSk7XG5cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wcyBvdmVycmlkZXMgb2YgYSBzcGVjaWZpYyBsYXllciBpZiBTZWVyIGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAqIEludmFsaWRhdGVzIHRoZSBkYXRhIHRvIGJlIHN1cmUgbmV3IG9uZXMgYXJlIGFsd2F5cyBwaWNrZWQgdXAuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPdmVycmlkZXMgPSBwcm9wcyA9PiB7XG4gIGlmICghd2luZG93Ll9fU0VFUl9JTklUSUFMSVpFRF9fIHx8ICFwcm9wcy5pZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG92ZXJzID0gb3ZlcnJpZGVzLmdldChwcm9wcy5pZCk7XG4gIGlmICghb3ZlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdmVycy5mb3JFYWNoKCh2YWx1ZSwgdmFsdWVQYXRoKSA9PiB7XG4gICAgcmVjdXJzaXZlU2V0KHByb3BzLCB2YWx1ZVBhdGgsIHZhbHVlKTtcbiAgICAvLyBJbnZhbGlkYXRlIGRhdGEgYXJyYXkgaWYgd2UgaGF2ZSBhIGRhdGEgb3ZlcnJpZGVcbiAgICBpZiAodmFsdWVQYXRoWzBdID09PSAnZGF0YScpIHtcbiAgICAgIHByb3BzLmRhdGEgPSBbLi4ucHJvcHMuZGF0YV07XG4gICAgfVxuICB9KTtcblxufTtcblxuLyoqXG4gKiBMaXN0ZW4gZm9yIGRlY2suZ2wgZWRpdCBldmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVyRWRpdExpc3RlbmVyID0gY2IgPT4ge1xuICBpZiAoIXdpbmRvdy5fX1NFRVJfSU5JVElBTElaRURfXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlZXIubGlzdGVuRm9yKCdkZWNrLmdsJywgcGF5bG9hZCA9PiB7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gJ2VkaXQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2IocGF5bG9hZCk7XG4gIH0pO1xufTtcblxuLy8gQmxhY2tsaXN0IHNvbWUgcHJvcGVydGllcyB0aGF0IGNhbid0IGJlIHN0cmluZ2lmaWVkIChlZzogY2lyY3VsYXIgZGVwZW5kZW5jaWVzKVxuY29uc3QgZGF0YUJsYWNrTGlzdCA9IFsnem9vbUxldmVscyddO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBwYXNzZWQgdG8gU2VlciBmb3IgcGVyZm9ybWFuY2UgcHVycG9zZXMuXG4gKiBTbGljZSB0aGUgZGF0YSBhcnJheSB0byB0aGUgZmlyc3QgMjAgaXRlbXNcbiAqL1xuY29uc3QgdHJhbnNmb3JtRGF0YSA9IGRhdGEgPT4ge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBvdXQgPSBkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicgPyBkYXRhLmZlYXR1cmVzIDogZGF0YTtcbiAgcmV0dXJuIG91dC5zbGljZSgwLCAyMCkubWFwKGl0ZW0gPT4gT2JqZWN0LmtleXMoaXRlbSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChkYXRhQmxhY2tMaXN0LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGFjY1trZXldID0gaXRlbVtrZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KSk7XG59O1xuXG4vKipcbiAqIExvZyBsYXllcidzIHByb3BlcnRpZXMgdG8gU2VlclxuICovXG5leHBvcnQgY29uc3QgbG9nTGF5ZXIgPSBsYXllciA9PiB7XG4gIGlmICghd2luZG93Ll9fU0VFUl9JTklUSUFMSVpFRF9fKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2ltcGxlUHJvcHMgPSBPYmplY3Qua2V5cyhsYXllci5wcm9wcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgbGF5ZXIucHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBhY2Nba2V5XSA9IGtleSA9PT0gJ2RhdGEnID8gdHJhbnNmb3JtRGF0YShsYXllci5wcm9wcy5kYXRhKSA6IGxheWVyLnByb3BzW2tleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHNlZXIuaW5kZXhlZExpc3RJdGVtKCdkZWNrLmdsJywgbGF5ZXIuaWQsIHNpbXBsZVByb3BzKTtcblxufTtcbiJdfQ==

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reflection_effect__ = __webpack_require__(132);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__reflection_effect__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxPQUFSLFFBQWlDLHFCQUFqQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQge2RlZmF1bHQgYXMgZGVmYXVsdH0gZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdCc7XG4iXX0=

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grid_cell_layer_vertex_glsl__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grid_cell_layer_vertex_64_glsl__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__ = __webpack_require__(142);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [255, 0, 255, 255];

var defaultProps = {
  cellSize: 1000,
  coverage: 1,
  elevationScale: 1,
  extruded: true,
  fp64: false,

  getPosition: function getPosition(x) {
    return x.position;
  },
  getElevation: function getElevation(x) {
    return x.elevation;
  },
  getColor: function getColor(x) {
    return x.color;
  },

  lightSettings: {
    lightsPosition: [-122.45, 37.65, 8000, -122.45, 37.20, 1000],
    ambientRatio: 0.4,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [1.0, 0.0, 0.8, 0.0],
    numberOfLights: 2
  }
};

var GridCellLayer = function (_Layer) {
  _inherits(GridCellLayer, _Layer);

  function GridCellLayer() {
    _classCallCheck(this, GridCellLayer);

    return _possibleConstructorReturn(this, (GridCellLayer.__proto__ || Object.getPrototypeOf(GridCellLayer)).apply(this, arguments));
  }

  _createClass(GridCellLayer, [{
    key: 'getShaders',

    /**
     * A generic GridLayer that takes latitude longitude delta of cells as a uniform
     * and the min lat lng of cells. grid can be 3d when pass in a height
     * and set enable3d to true
     *
     * @param {array} props.data -
     * @param {boolean} props.extruded - enable grid elevation
     * @param {number} props.cellSize - grid cell size in meters
     * @param {function} props.getPosition - position accessor, returned as [minLng, minLat]
     * @param {function} props.getElevation - elevation accessor
     * @param {function} props.getColor - color accessor, returned as [r, g, b, a]
     */

    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__grid_cell_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64', 'lighting'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__grid_cell_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__["a" /* default */],
        modules: ['lighting'],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      var attributeManager = this.state.attributeManager;
      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 4, accessor: ['getPosition', 'getElevation'], update: this.calculateInstancePositions },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64xyLow: {
              size: 2,
              accessor: 'getPosition',
              update: this.calculateInstancePositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instancePositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(GridCellLayer.prototype.__proto__ || Object.getPrototypeOf(GridCellLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      // Re-generate model if geometry changed
      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
      this.updateUniforms();
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var geometry = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["j" /* CubeGeometry */]({});
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: geometry,
        isInstanced: true
      });
    }
  }, {
    key: 'updateUniforms',
    value: function updateUniforms() {
      var _props = this.props,
          opacity = _props.opacity,
          extruded = _props.extruded,
          elevationScale = _props.elevationScale,
          cellSize = _props.cellSize,
          coverage = _props.coverage,
          lightSettings = _props.lightSettings;
      var viewport = this.context.viewport;

      var _viewport$getDistance = viewport.getDistanceScales(),
          pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;

      this.setUniforms(Object.assign({}, {
        extruded: extruded,
        elevationScale: elevationScale,
        opacity: opacity,
        cellSize: cellSize * pixelsPerMeter[0],
        coverage: coverage
      }, lightSettings));
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;

      _get(GridCellLayer.prototype.__proto__ || Object.getPrototypeOf(GridCellLayer.prototype), 'draw', this).call(this, { uniforms: Object.assign({}, uniforms) });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getPosition = _props2.getPosition,
          getElevation = _props2.getElevation;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var position = getPosition(object);
          var elevation = getElevation(object) || 0;
          value[i + 0] = position[0];
          value[i + 1] = position[1];
          value[i + 2] = 0;
          value[i + 3] = elevation;
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64xyLow',
    value: function calculateInstancePositions64xyLow(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getPosition = _props3.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;

          var position = getPosition(point);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[1])[1];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getColor = _props4.getColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          var color = getColor(object) || DEFAULT_COLOR;
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return GridCellLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (GridCellLayer);


GridCellLayer.layerName = 'GridCellLayer';
GridCellLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiYXNzZW1ibGVTaGFkZXJzIiwiR0wiLCJNb2RlbCIsIkN1YmVHZW9tZXRyeSIsImZwNjRpZnkiLCJlbmFibGU2NGJpdFN1cHBvcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsImdyaWRDZWxsVmVydGV4IiwiZ3JpZENlbGxWZXJ0ZXg2NCIsImdyaWRDZWxsRnJhZ21lbnQiLCJERUZBVUxUX0NPTE9SIiwiZGVmYXVsdFByb3BzIiwiY2VsbFNpemUiLCJjb3ZlcmFnZSIsImVsZXZhdGlvblNjYWxlIiwiZXh0cnVkZWQiLCJmcDY0IiwiZ2V0UG9zaXRpb24iLCJ4IiwicG9zaXRpb24iLCJnZXRFbGV2YXRpb24iLCJlbGV2YXRpb24iLCJnZXRDb2xvciIsImNvbG9yIiwibGlnaHRTZXR0aW5ncyIsImxpZ2h0c1Bvc2l0aW9uIiwiYW1iaWVudFJhdGlvIiwiZGlmZnVzZVJhdGlvIiwic3BlY3VsYXJSYXRpbyIsImxpZ2h0c1N0cmVuZ3RoIiwibnVtYmVyT2ZMaWdodHMiLCJHcmlkQ2VsbExheWVyIiwicHJvcHMiLCJ2cyIsImZzIiwibW9kdWxlcyIsInNoYWRlckNhY2hlIiwiY29udGV4dCIsImdsIiwic2V0U3RhdGUiLCJtb2RlbCIsIl9nZXRNb2RlbCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlUG9zaXRpb25zIiwic2l6ZSIsImFjY2Vzc29yIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMiLCJpbnN0YW5jZUNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMiLCJvbGRQcm9wcyIsImNoYW5nZUZsYWdzIiwiaW52YWxpZGF0ZUFsbCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwiaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwicmVtb3ZlIiwidXBkYXRlQXR0cmlidXRlIiwidXBkYXRlVW5pZm9ybXMiLCJnZW9tZXRyeSIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwiaWQiLCJpc0luc3RhbmNlZCIsIm9wYWNpdHkiLCJ2aWV3cG9ydCIsImdldERpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJzZXRVbmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInVuaWZvcm1zIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwiaSIsIm9iamVjdCIsInBvaW50IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFlBQW5CLFFBQXNDLFNBQXRDO0FBQ0EsU0FBUUMsT0FBUixFQUFpQkMsa0JBQWpCLFFBQTBDLHlCQUExQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDOztBQUVBLE9BQU9DLGNBQVAsTUFBMkIsK0JBQTNCO0FBQ0EsT0FBT0MsZ0JBQVAsTUFBNkIsa0NBQTdCO0FBQ0EsT0FBT0MsZ0JBQVAsTUFBNkIsaUNBQTdCOztBQUVBLElBQU1DLGdCQUFnQixDQUFDLEdBQUQsRUFBTSxDQUFOLEVBQVMsR0FBVCxFQUFjLEdBQWQsQ0FBdEI7O0FBRUEsSUFBTUMsZUFBZTtBQUNuQkMsWUFBVSxJQURTO0FBRW5CQyxZQUFVLENBRlM7QUFHbkJDLGtCQUFnQixDQUhHO0FBSW5CQyxZQUFVLElBSlM7QUFLbkJDLFFBQU0sS0FMYTs7QUFPbkJDLGVB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QXdELGdCQUFNQyxJQUFJLENBQVYsSUFBZXpELE1BQU0sQ0FBTixDQUFmO0FBQ0F3RCxnQkFBTUMsSUFBSSxDQUFWLElBQWVHLE9BQU9DLFFBQVAsQ0FBZ0I3RCxNQUFNLENBQU4sQ0FBaEIsSUFBNEJBLE1BQU0sQ0FBTixDQUE1QixHQUF1Q2IsY0FBYyxDQUFkLENBQXREO0FBQ0FzRSxlQUFLbEMsSUFBTDtBQUNEO0FBWGdDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZbEM7Ozs7RUFqSndDL0MsSzs7ZUFBdEJnQyxhOzs7QUFvSnJCQSxjQUFjc0QsU0FBZCxHQUEwQixlQUExQjtBQUNBdEQsY0FBY3BCLFlBQWQsR0FBNkJBLFlBQTdCIiwiZmlsZSI6ImdyaWQtY2VsbC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgQ3ViZUdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7ZnA2NGlmeSwgZW5hYmxlNjRiaXRTdXBwb3J0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuXG5pbXBvcnQgZ3JpZENlbGxWZXJ0ZXggZnJvbSAnLi9ncmlkLWNlbGwtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGdyaWRDZWxsVmVydGV4NjQgZnJvbSAnLi9ncmlkLWNlbGwtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGdyaWRDZWxsRnJhZ21lbnQgZnJvbSAnLi9ncmlkLWNlbGwtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMjU1LCAwLCAyNTUsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY2VsbFNpemU6IDEwMDAsXG4gIGNvdmVyYWdlOiAxLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgZXh0cnVkZWQ6IHRydWUsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGdldEVsZXZhdGlvbjogeCA9PiB4LmVsZXZhdGlvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvcixcblxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFstMTIyLjQ1LCAzNy42NSwgODAwMCwgLTEyMi40NSwgMzcuMjAsIDEwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC40LFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMCwgMC4wLCAwLjgsIDAuMF0sXG4gICAgbnVtYmVyT2ZMaWdodHM6IDJcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZENlbGxMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBHcmlkTGF5ZXIgdGhhdCB0YWtlcyBsYXRpdHVkZSBsb25naXR1ZGUgZGVsdGEgb2YgY2VsbHMgYXMgYSB1bmlmb3JtXG4gICAqIGFuZCB0aGUgbWluIGxhdCBsbmcgb2YgY2VsbHMuIGdyaWQgY2FuIGJlIDNkIHdoZW4gcGFzcyBpbiBhIGhlaWdodFxuICAgKiBhbmQgc2V0IGVuYWJsZTNkIHRvIHRydWVcbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gcHJvcHMuZGF0YSAtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcHMuZXh0cnVkZWQgLSBlbmFibGUgZ3JpZCBlbGV2YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLmNlbGxTaXplIC0gZ3JpZCBjZWxsIHNpemUgaW4gbWV0ZXJzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BzLmdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3IsIHJldHVybmVkIGFzIFttaW5MbmcsIG1pbkxhdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcHMuZ2V0RWxldmF0aW9uIC0gZWxldmF0aW9uIGFjY2Vzc29yXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BzLmdldENvbG9yIC0gY29sb3IgYWNjZXNzb3IsIHJldHVybmVkIGFzIFtyLCBnLCBiLCBhXVxuICAgKi9cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogZ3JpZENlbGxWZXJ0ZXg2NCxcbiAgICAgIGZzOiBncmlkQ2VsbEZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCcsICdsaWdodGluZyddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH0gOiB7XG4gICAgICB2czogZ3JpZENlbGxWZXJ0ZXgsXG4gICAgICBmczogZ3JpZENlbGxGcmFnbWVudCxcbiAgICAgIG1vZHVsZXM6IFsnbGlnaHRpbmcnXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtzaXplOiA0LCBhY2Nlc3NvcjogWydnZXRQb3NpdGlvbicsICdnZXRFbGV2YXRpb24nXSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zfSxcbiAgICAgIGluc3RhbmNlQ29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yc31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cnXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICAvLyBSZS1nZW5lcmF0ZSBtb2RlbCBpZiBnZW9tZXRyeSBjaGFuZ2VkXG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG4gICAgdGhpcy51cGRhdGVVbmlmb3JtcygpO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQ3ViZUdlb21ldHJ5KHt9KTtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlVW5pZm9ybXMoKSB7XG4gICAgY29uc3Qge29wYWNpdHksIGV4dHJ1ZGVkLCBlbGV2YXRpb25TY2FsZSwgY2VsbFNpemUsIGNvdmVyYWdlLCBsaWdodFNldHRpbmdzfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXJ9ID0gdmlld3BvcnQuZ2V0RGlzdGFuY2VTY2FsZXMoKTtcblxuICAgIHRoaXMuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgZXh0cnVkZWQsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIG9wYWNpdHksXG4gICAgICBjZWxsU2l6ZTogY2VsbFNpemUgKiBwaXhlbHNQZXJNZXRlclswXSxcbiAgICAgIGNvdmVyYWdlXG4gICAgfSxcbiAgICBsaWdodFNldHRpbmdzKSk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBzdXBlci5kcmF3KHt1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMpfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb24sIGdldEVsZXZhdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IGVsZXZhdGlvbiA9IGdldEVsZXZhdGlvbihvYmplY3QpIHx8IDA7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBwb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gMDtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGVsZXZhdGlvbjtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzFdKVsxXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IERFRkFVTFRfQ09MT1JbM107XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG59XG5cbkdyaWRDZWxsTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRDZWxsTGF5ZXInO1xuR3JpZENlbGxMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hexagon_cell_layer_vertex_glsl__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__hexagon_cell_layer_vertex_64_glsl__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__ = __webpack_require__(147);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.












function positionsAreEqual(v1, v2) {
  // Hex positions are expected to change entirely, not to maintain some
  // positions and change others. Right now we only check a single vertex,
  // because H3 guarantees order, but even if that wasn't true, this would only
  // return a false positive for adjacent hexagons, which is close enough for
  // our purposes.
  return v1 === v2 || v1 && v2 && v1[0][0] === v2[0][0] && v1[0][1] === v2[0][1];
}

var DEFAULT_COLOR = [255, 0, 255, 255];

var defaultProps = {
  hexagonVertices: null,
  radius: null,
  angle: null,
  coverage: 1,
  elevationScale: 1,
  extruded: true,
  fp64: false,

  getCentroid: function getCentroid(x) {
    return x.centroid;
  },
  getColor: function getColor(x) {
    return x.color;
  },
  getElevation: function getElevation(x) {
    return x.elevation;
  },

  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.4,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [1.2, 0.0, 0.8, 0.0],
    numberOfLights: 2
  }
};

var HexagonCellLayer = function (_Layer) {
  _inherits(HexagonCellLayer, _Layer);

  function HexagonCellLayer(props) {
    _classCallCheck(this, HexagonCellLayer);

    var missingProps = false;
    if (!props.hexagonVertices && (!props.radius || !Number.isFinite(props.angle))) {
      __WEBPACK_IMPORTED_MODULE_3__lib_utils__["a" /* log */].once(0, 'HexagonCellLayer: Either hexagonVertices or radius and angle are ' + 'needed to calculate primitive hexagon.');
      missingProps = true;
    } else if (props.hexagonVertices && (!Array.isArray(props.hexagonVertices) || props.hexagonVertices.length < 6)) {
      __WEBPACK_IMPORTED_MODULE_3__lib_utils__["a" /* log */].once(0, 'HexagonCellLayer: hexagonVertices needs to be an array of 6 points');

      missingProps = true;
    }

    if (missingProps) {
      __WEBPACK_IMPORTED_MODULE_3__lib_utils__["a" /* log */].once(0, 'Now using 1000 meter as default radius, 0 as default angle');
      props.radius = 1000;
      props.angle = 0;
    }

    return _possibleConstructorReturn(this, (HexagonCellLayer.__proto__ || Object.getPrototypeOf(HexagonCellLayer)).call(this, props));
  }

  _createClass(HexagonCellLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_6__hexagon_cell_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64', 'lighting'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_5__hexagon_cell_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__["a" /* default */],
        modules: ['lighting'],
        shaderCache: this.context.shaderCache
      };
    }

    /**
     * DeckGL calls initializeState when GL context is available
     * Essentially a deferred constructor
     */

  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });
      var attributeManager = this.state.attributeManager;
      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 3, accessor: ['getCentroid', 'getElevation'],
          update: this.calculateInstancePositions },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor',
          update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */

      this.updateRadiusAngle();
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64xyLow: {
              size: 2,
              accessor: 'getCentroid',
              update: this.calculateInstancePositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instancePositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(HexagonCellLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonCellLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });

      var viewportChanged = changeFlags.viewportChanged;
      var model = this.state.model;

      // Update the positions in the model if they've changes

      var verticesChanged = !positionsAreEqual(oldProps.hexagonVertices, props.hexagonVertices);

      if (model && (verticesChanged || viewportChanged)) {
        this.updateRadiusAngle();
      }
      this.updateUniforms();
    }
  }, {
    key: 'updateRadiusAngle',
    value: function updateRadiusAngle() {
      var angle = void 0;
      var radius = void 0;
      var hexagonVertices = this.props.hexagonVertices;


      if (Array.isArray(hexagonVertices) && hexagonVertices.length >= 6) {

        // calculate angle and vertices from hexagonVertices if provided
        var vertices = this.props.hexagonVertices;

        var vertex0 = vertices[0];
        var vertex3 = vertices[3];

        // transform to space coordinates
        var spaceCoord0 = this.projectFlat(vertex0);
        var spaceCoord3 = this.projectFlat(vertex3);

        // distance between two close centroids
        var dx = spaceCoord0[0] - spaceCoord3[0];
        var dy = spaceCoord0[1] - spaceCoord3[1];
        var dxy = Math.sqrt(dx * dx + dy * dy);

        // Calculate angle that the perpendicular hexagon vertex axis is tilted
        angle = Math.acos(dx / dxy) * -Math.sign(dy) + Math.PI / 2;
        radius = dxy / 2;
      } else if (this.props.radius && Number.isFinite(this.props.angle)) {

        // if no hexagonVertices provided, try use radius & angle
        var viewport = this.context.viewport;

        var _viewport$getDistance = viewport.getDistanceScales(),
            pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;

        angle = this.props.angle;
        radius = this.props.radius * pixelsPerMeter[0];
      }

      this.setUniforms({
        angle: angle,
        radius: radius
      });
    }
  }, {
    key: 'getCylinderGeometry',
    value: function getCylinderGeometry(radius) {
      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["i" /* CylinderGeometry */]({
        radius: radius,
        topRadius: radius,
        bottomRadius: radius,
        topCap: true,
        bottomCap: true,
        height: 1,
        nradial: 6,
        nvertical: 1
      });
    }
  }, {
    key: 'updateUniforms',
    value: function updateUniforms() {
      var _props = this.props,
          opacity = _props.opacity,
          elevationScale = _props.elevationScale,
          extruded = _props.extruded,
          coverage = _props.coverage,
          lightSettings = _props.lightSettings;


      this.setUniforms(Object.assign({}, {
        extruded: extruded,
        opacity: opacity,
        coverage: coverage,
        elevationScale: elevationScale
      }, lightSettings));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());
      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: this.getCylinderGeometry(1),
        isInstanced: true
      });
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;

      _get(HexagonCellLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonCellLayer.prototype), 'draw', this).call(this, { uniforms: Object.assign({}, uniforms) });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getCentroid = _props2.getCentroid,
          getElevation = _props2.getElevation;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var _getCentroid = getCentroid(object),
              _getCentroid2 = _slicedToArray(_getCentroid, 2),
              lon = _getCentroid2[0],
              lat = _getCentroid2[1];

          var elevation = getElevation(object);
          value[i + 0] = lon;
          value[i + 1] = lat;
          value[i + 2] = elevation || 0;
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64xyLow',
    value: function calculateInstancePositions64xyLow(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getCentroid = _props3.getCentroid;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var position = getCentroid(object);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__["a" /* fp64ify */])(position[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__["a" /* fp64ify */])(position[1])[1];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getColor = _props4.getColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          var color = getColor(object) || DEFAULT_COLOR;

          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return HexagonCellLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (HexagonCellLayer);


HexagonCellLayer.layerName = 'HexagonCellLayer';
HexagonCellLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiYXNzZW1ibGVTaGFkZXJzIiwiR0wiLCJNb2RlbCIsIkN5bGluZGVyR2VvbWV0cnkiLCJsb2ciLCJmcDY0aWZ5IiwiZW5hYmxlNjRiaXRTdXBwb3J0IiwiQ09PUkRJTkFURV9TWVNURU0iLCJoZXhDZWxsVmVydGV4IiwiaGV4Q2VsbFZlcnRleDY0IiwiaGV4Q2VsbEZyYWdtZW50IiwicG9zaXRpb25zQXJlRXF1YWwiLCJ2MSIsInYyIiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsImhleGFnb25WZXJ0aWNlcyIsInJhZGl1cyIsImFuZ2xlIiwiY292ZXJhZ2UiLCJlbGV2YXRpb25TY2FsZSIsImV4dHJ1ZGVkIiwiZnA2NCIsImdldENlbnRyb2lkIiwieCIsImNlbnRyb2lkIiwiZ2V0Q29sb3IiLCJjb2xvciIsImdldEVsZXZhdGlvbiIsImVsZXZhdGlvbiIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiSGV4YWdvbkNlbGxMYXllciIsInByb3BzIiwibWlzc2luZ1Byb3BzIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJvbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJzaGFkZXJDYWNoZSIsImNvbnRleHQiLCJnbCIsInNldFN0YXRlIiwibW9kZWwiLCJfZ2V0TW9kZWwiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBvc2l0aW9ucyIsInNpemUiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIiwiaW5zdGFuY2VDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIiwidXBkYXRlUmFkaXVzQW5nbGUiLCJvbGRQcm9wcyIsImNoYW5nZUZsYWdzIiwiaW52YWxpZGF0ZUFsbCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwiaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwicmVtb3ZlIiwidXBkYXRlQXR0cmlidXRlIiwidmlld3BvcnRDaGFuZ2VkIiwidmVydGljZXNDaGFuZ2VkIiwidXBkYXRlVW5pZm9ybXMiLCJ2ZXJ0aWNlcyIsInZlcnRleDAiLCJ2ZXJ0ZXgzIiwic3BhY2VDb29yZDAiLCJwcm9qZWN0RmxhdCIsInNwYWNlQ29vcmQzIiwiZHgiLCJkeSIsImR4eSIsIk1hdGgiLCJzcXJ0IiwiYWNvcyIsInNpZ24iLCJQSSIsInZpZXdwb3J0IiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJwaXhlbHNQZXJNZXRlciIsInNldFVuaWZvcm1zIiwidG9wUmFkaXVzIiwiYm90dG9tUmFkaXVzIiwidG9wQ2FwIiwiYm90dG9tQ2FwIiwiaGVpZ2h0IiwibnJhZGlhbCIsIm52ZXJ0aWNhbCIsIm9wYWNpdHkiLCJPYmplY3QiLCJhc3NpZ24iLCJzaGFkZXJzIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJnZXRDeWxpbmRlckdlb21ldHJ5IiwiaXNJbnN0YW5jZWQiLCJ1bmlmb3JtcyIsImF0dHJpYnV0ZSIsImRhdGEiLCJ2YWx1ZSIsImkiLCJvYmplY3QiLCJsb24iLCJsYXQiLCJwb3NpdGlvbiIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsS0FBUixRQUFvQixjQUFwQjtBQUNBLFNB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QWU5RSxPQUFPQyxRQUFQLENBQWdCZCxNQUFNLENBQU4sQ0FBaEIsSUFBNEJBLE1BQU0sQ0FBTixDQUE1QixHQUF1Q2IsY0FBYyxDQUFkLENBQXREO0FBQ0F3RyxlQUFLM0QsSUFBTDtBQUNEO0FBWmdDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhbEM7Ozs7RUEvTjJDNUQsSzs7ZUFBekJzQyxnQjs7O0FBa09yQkEsaUJBQWlCc0YsU0FBakIsR0FBNkIsa0JBQTdCO0FBQ0F0RixpQkFBaUJ0QixZQUFqQixHQUFnQ0EsWUFBaEMiLCJmaWxlIjoiaGV4YWdvbi1jZWxsLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBDeWxpbmRlckdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHtmcDY0aWZ5LCBlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbmltcG9ydCBoZXhDZWxsVmVydGV4IGZyb20gJy4vaGV4YWdvbi1jZWxsLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBoZXhDZWxsVmVydGV4NjQgZnJvbSAnLi9oZXhhZ29uLWNlbGwtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGhleENlbGxGcmFnbWVudCBmcm9tICcuL2hleGFnb24tY2VsbC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuZnVuY3Rpb24gcG9zaXRpb25zQXJlRXF1YWwodjEsIHYyKSB7XG4gIC8vIEhleCBwb3NpdGlvbnMgYXJlIGV4cGVjdGVkIHRvIGNoYW5nZSBlbnRpcmVseSwgbm90IHRvIG1haW50YWluIHNvbWVcbiAgLy8gcG9zaXRpb25zIGFuZCBjaGFuZ2Ugb3RoZXJzLiBSaWdodCBub3cgd2Ugb25seSBjaGVjayBhIHNpbmdsZSB2ZXJ0ZXgsXG4gIC8vIGJlY2F1c2UgSDMgZ3VhcmFudGVlcyBvcmRlciwgYnV0IGV2ZW4gaWYgdGhhdCB3YXNuJ3QgdHJ1ZSwgdGhpcyB3b3VsZCBvbmx5XG4gIC8vIHJldHVybiBhIGZhbHNlIHBvc2l0aXZlIGZvciBhZGphY2VudCBoZXhhZ29ucywgd2hpY2ggaXMgY2xvc2UgZW5vdWdoIGZvclxuICAvLyBvdXIgcHVycG9zZXMuXG4gIHJldHVybiB2MSA9PT0gdjIgfHwgKFxuICAgIHYxICYmIHYyICYmIHYxWzBdWzBdID09PSB2MlswXVswXSAmJiB2MVswXVsxXSA9PT0gdjJbMF1bMV1cbiAgKTtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFsyNTUsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBoZXhhZ29uVmVydGljZXM6IG51bGwsXG4gIHJhZGl1czogbnVsbCxcbiAgYW5nbGU6IG51bGwsXG4gIGNvdmVyYWdlOiAxLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgZXh0cnVkZWQ6IHRydWUsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldENlbnRyb2lkOiB4ID0+IHguY2VudHJvaWQsXG4gIGdldENvbG9yOiB4ID0+IHguY29sb3IsXG4gIGdldEVsZXZhdGlvbjogeCA9PiB4LmVsZXZhdGlvbixcblxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFstMTIyLjQ1LCAzNy43NSwgODAwMCwgLTEyMi4wLCAzOC4wMCwgNTAwMF0sXG4gICAgYW1iaWVudFJhdGlvOiAwLjQsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMS4yLCAwLjAsIDAuOCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZXhhZ29uQ2VsbExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgbGV0IG1pc3NpbmdQcm9wcyA9IGZhbHNlO1xuICAgIGlmICghcHJvcHMuaGV4YWdvblZlcnRpY2VzICYmICghcHJvcHMucmFkaXVzIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJvcHMuYW5nbGUpKSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25DZWxsTGF5ZXI6IEVpdGhlciBoZXhhZ29uVmVydGljZXMgb3IgcmFkaXVzIGFuZCBhbmdsZSBhcmUgJyArXG4gICAgICAgICduZWVkZWQgdG8gY2FsY3VsYXRlIHByaW1pdGl2ZSBoZXhhZ29uLicpO1xuICAgICAgbWlzc2luZ1Byb3BzID0gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAocHJvcHMuaGV4YWdvblZlcnRpY2VzICYmICghQXJyYXkuaXNBcnJheShwcm9wcy5oZXhhZ29uVmVydGljZXMpIHx8XG4gICAgICBwcm9wcy5oZXhhZ29uVmVydGljZXMubGVuZ3RoIDwgNikpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uQ2VsbExheWVyOiBoZXhhZ29uVmVydGljZXMgbmVlZHMgdG8gYmUgYW4gYXJyYXkgb2YgNiBwb2ludHMnKTtcblxuICAgICAgbWlzc2luZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1Byb3BzKSB7XG4gICAgICBsb2cub25jZSgwLCAnTm93IHVzaW5nIDEwMDAgbWV0ZXIgYXMgZGVmYXVsdCByYWRpdXMsIDAgYXMgZGVmYXVsdCBhbmdsZScpO1xuICAgICAgcHJvcHMucmFkaXVzID0gMTAwMDtcbiAgICAgIHByb3BzLmFuZ2xlID0gMDtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogaGV4Q2VsbFZlcnRleDY0LFxuICAgICAgZnM6IGhleENlbGxGcmFnbWVudCxcbiAgICAgIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnLCAnbGlnaHRpbmcnXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9IDoge1xuICAgICAgdnM6IGhleENlbGxWZXJ0ZXgsXG4gICAgICBmczogaGV4Q2VsbEZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydsaWdodGluZyddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVja0dMIGNhbGxzIGluaXRpYWxpemVTdGF0ZSB3aGVuIEdMIGNvbnRleHQgaXMgYXZhaWxhYmxlXG4gICAqIEVzc2VudGlhbGx5IGEgZGVmZXJyZWQgY29uc3RydWN0b3JcbiAgICovXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge3NpemU6IDMsIGFjY2Vzc29yOiBbJ2dldENlbnRyb2lkJywgJ2dldEVsZXZhdGlvbiddLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgdGhpcy51cGRhdGVSYWRpdXNBbmdsZSgpO1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0Q2VudHJvaWQnLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbnMgaW4gdGhlIG1vZGVsIGlmIHRoZXkndmUgY2hhbmdlc1xuICAgIGNvbnN0IHZlcnRpY2VzQ2hhbmdlZCA9XG4gICAgICAhcG9zaXRpb25zQXJlRXF1YWwob2xkUHJvcHMuaGV4YWdvblZlcnRpY2VzLCBwcm9wcy5oZXhhZ29uVmVydGljZXMpO1xuXG4gICAgaWYgKG1vZGVsICYmICh2ZXJ0aWNlc0NoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkKSkge1xuICAgICAgdGhpcy51cGRhdGVSYWRpdXNBbmdsZSgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVVuaWZvcm1zKCk7XG4gIH1cblxuICB1cGRhdGVSYWRpdXNBbmdsZSgpIHtcbiAgICBsZXQgYW5nbGU7XG4gICAgbGV0IHJhZGl1cztcbiAgICBjb25zdCB7aGV4YWdvblZlcnRpY2VzfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZXhhZ29uVmVydGljZXMpICYmIGhleGFnb25WZXJ0aWNlcy5sZW5ndGggPj0gNikge1xuXG4gICAgICAvLyBjYWxjdWxhdGUgYW5nbGUgYW5kIHZlcnRpY2VzIGZyb20gaGV4YWdvblZlcnRpY2VzIGlmIHByb3ZpZGVkXG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMucHJvcHMuaGV4YWdvblZlcnRpY2VzO1xuXG4gICAgICBjb25zdCB2ZXJ0ZXgwID0gdmVydGljZXNbMF07XG4gICAgICBjb25zdCB2ZXJ0ZXgzID0gdmVydGljZXNbM107XG5cbiAgICAgIC8vIHRyYW5zZm9ybSB0byBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgY29uc3Qgc3BhY2VDb29yZDAgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDApO1xuICAgICAgY29uc3Qgc3BhY2VDb29yZDMgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDMpO1xuXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjbG9zZSBjZW50cm9pZHNcbiAgICAgIGNvbnN0IGR4ID0gc3BhY2VDb29yZDBbMF0gLSBzcGFjZUNvb3JkM1swXTtcbiAgICAgIGNvbnN0IGR5ID0gc3BhY2VDb29yZDBbMV0gLSBzcGFjZUNvb3JkM1sxXTtcbiAgICAgIGNvbnN0IGR4eSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhbmdsZSB0aGF0IHRoZSBwZXJwZW5kaWN1bGFyIGhleGFnb24gdmVydGV4IGF4aXMgaXMgdGlsdGVkXG4gICAgICBhbmdsZSA9IE1hdGguYWNvcyhkeCAvIGR4eSkgKiAtTWF0aC5zaWduKGR5KSArIE1hdGguUEkgLyAyO1xuICAgICAgcmFkaXVzID0gZHh5IC8gMjtcblxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5yYWRpdXMgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvcHMuYW5nbGUpKSB7XG5cbiAgICAgIC8vIGlmIG5vIGhleGFnb25WZXJ0aWNlcyBwcm92aWRlZCwgdHJ5IHVzZSByYWRpdXMgJiBhbmdsZVxuICAgICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlcn0gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpO1xuXG4gICAgICBhbmdsZSA9IHRoaXMucHJvcHMuYW5nbGU7XG4gICAgICByYWRpdXMgPSB0aGlzLnByb3BzLnJhZGl1cyAqIHBpeGVsc1Blck1ldGVyWzBdO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybXMoe1xuICAgICAgYW5nbGUsXG4gICAgICByYWRpdXNcbiAgICB9KTtcbiAgfVxuXG4gIGdldEN5bGluZGVyR2VvbWV0cnkocmFkaXVzKSB7XG4gICAgcmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KHtcbiAgICAgIHJhZGl1cyxcbiAgICAgIHRvcFJhZGl1czogcmFkaXVzLFxuICAgICAgYm90dG9tUmFkaXVzOiByYWRpdXMsXG4gICAgICB0b3BDYXA6IHRydWUsXG4gICAgICBib3R0b21DYXA6IHRydWUsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICBucmFkaWFsOiA2LFxuICAgICAgbnZlcnRpY2FsOiAxXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVVbmlmb3JtcygpIHtcbiAgICBjb25zdCB7b3BhY2l0eSwgZWxldmF0aW9uU2NhbGUsIGV4dHJ1ZGVkLCBjb3ZlcmFnZSwgbGlnaHRTZXR0aW5nc30gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zZXRVbmlmb3JtcyhPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBleHRydWRlZCxcbiAgICAgIG9wYWNpdHksXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGVsZXZhdGlvblNjYWxlXG4gICAgfSxcbiAgICBsaWdodFNldHRpbmdzKSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmdldEN5bGluZGVyR2VvbWV0cnkoMSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgc3VwZXIuZHJhdyh7dW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zKX0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENlbnRyb2lkLCBnZXRFbGV2YXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBbbG9uLCBsYXRdID0gZ2V0Q2VudHJvaWQob2JqZWN0KTtcbiAgICAgIGNvbnN0IGVsZXZhdGlvbiA9IGdldEVsZXZhdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gbG9uO1xuICAgICAgdmFsdWVbaSArIDFdID0gbGF0O1xuICAgICAgdmFsdWVbaSArIDJdID0gZWxldmF0aW9uIHx8IDA7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDZW50cm9pZH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q2VudHJvaWQob2JqZWN0KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzFdKVsxXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcblxuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogREVGQVVMVF9DT0xPUlszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuSGV4YWdvbkNlbGxMYXllci5sYXllck5hbWUgPSAnSGV4YWdvbkNlbGxMYXllcic7XG5IZXhhZ29uQ2VsbExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scatterplot_layer_vertex_glsl__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__scatterplot_layer_vertex_64_glsl__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__ = __webpack_require__(168);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.












var DEFAULT_COLOR = [0, 0, 0, 255];

var defaultProps = {
  radiusScale: 1, //  point radius in meters
  radiusMinPixels: 0, //  min point radius in pixels
  radiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels
  strokeWidth: 1,
  outline: false,
  fp64: false,

  getPosition: function getPosition(x) {
    return x.position;
  },
  getRadius: function getRadius(x) {
    return x.radius || 1;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  }
};

var ScatterplotLayer = function (_Layer) {
  _inherits(ScatterplotLayer, _Layer);

  function ScatterplotLayer() {
    _classCallCheck(this, ScatterplotLayer);

    return _possibleConstructorReturn(this, (ScatterplotLayer.__proto__ || Object.getPrototypeOf(ScatterplotLayer)).apply(this, arguments));
  }

  _createClass(ScatterplotLayer, [{
    key: 'getShaders',
    value: function getShaders(id) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_6__scatterplot_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_5__scatterplot_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      /* eslint-disable max-len */
      /* deprecated props check */
      this._checkRemovedProp('radius', 'radiusScale');
      this._checkRemovedProp('drawOutline', 'outline');

      this.state.attributeManager.addInstanced({
        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },
        instanceRadius: { size: 1, accessor: 'getRadius', defaultValue: 1, update: this.calculateInstanceRadius },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64xyLow: {
              size: 2,
              accessor: 'getPosition',
              update: this.calculateInstancePositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instancePositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(ScatterplotLayer.prototype.__proto__ || Object.getPrototypeOf(ScatterplotLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var _props = this.props,
          radiusScale = _props.radiusScale,
          radiusMinPixels = _props.radiusMinPixels,
          radiusMaxPixels = _props.radiusMaxPixels,
          outline = _props.outline,
          strokeWidth = _props.strokeWidth;

      this.state.model.render(Object.assign({}, uniforms, {
        outline: outline ? 1 : 0,
        strokeWidth: strokeWidth,
        radiusScale: radiusScale,
        radiusMinPixels: radiusMinPixels,
        radiusMaxPixels: radiusMaxPixels
      }));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      // a square that minimally cover the unit circle
      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];

      return new __WEBPACK_IMPORTED_MODULE_4_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_4_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].TRIANGLE_FAN,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getPosition = _props2.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;

          var position = getPosition(point);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(position, 0);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(position, 1);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(position, 2) || 0;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64xyLow',
    value: function calculateInstancePositions64xyLow(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getPosition = _props3.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;

          var position = getPosition(point);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(position, 0))[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(position, 1))[1];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceRadius',
    value: function calculateInstanceRadius(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getRadius = _props4.getRadius;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var point = _step3.value;

          var radius = getRadius(point);
          value[i++] = isNaN(radius) ? 1 : radius;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props5 = this.props,
          data = _props5.data,
          getColor = _props5.getColor;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var point = _step4.value;

          var color = getColor(point) || DEFAULT_COLOR;
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 0);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 1);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 2);
          value[i++] = isNaN(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 3)) ? 255 : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 3);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);

  return ScatterplotLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (ScatterplotLayer);


ScatterplotLayer.layerName = 'ScatterplotLayer';
ScatterplotLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImFzc2VtYmxlU2hhZGVycyIsIkNPT1JESU5BVEVfU1lTVEVNIiwiZ2V0IiwiZnA2NGlmeSIsImVuYWJsZTY0Yml0U3VwcG9ydCIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsInNjYXR0ZXJwbG90VmVydGV4Iiwic2NhdHRlcnBsb3RWZXJ0ZXg2NCIsInNjYXR0ZXJwbG90RnJhZ21lbnQiLCJERUZBVUxUX0NPTE9SIiwiZGVmYXVsdFByb3BzIiwicmFkaXVzU2NhbGUiLCJyYWRpdXNNaW5QaXhlbHMiLCJyYWRpdXNNYXhQaXhlbHMiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3Ryb2tlV2lkdGgiLCJvdXRsaW5lIiwiZnA2NCIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZ2V0UmFkaXVzIiwicmFkaXVzIiwiZ2V0Q29sb3IiLCJjb2xvciIsIlNjYXR0ZXJwbG90TGF5ZXIiLCJpZCIsInByb3BzIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJzaGFkZXJDYWNoZSIsImNvbnRleHQiLCJnbCIsInNldFN0YXRlIiwibW9kZWwiLCJfZ2V0TW9kZWwiLCJfY2hlY2tSZW1vdmVkUHJvcCIsInN0YXRlIiwiYXR0cmlidXRlTWFuYWdlciIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlUG9zaXRpb25zIiwic2l6ZSIsImFjY2Vzc29yIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMiLCJpbnN0YW5jZVJhZGl1cyIsImRlZmF1bHRWYWx1ZSIsImNhbGN1bGF0ZUluc3RhbmNlUmFkaXVzIiwiaW5zdGFuY2VDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImludmFsaWRhdGVBbGwiLCJwcm9qZWN0aW9uTW9kZSIsIkxOR0xBVCIsImluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyIsInJlbW92ZSIsInVwZGF0ZUF0dHJpYnV0ZSIsInVuaWZvcm1zIiwicmVuZGVyIiwiT2JqZWN0IiwiYXNzaWduIiwic2hhZGVycyIsImdldFNoYWRlcnMiLCJwb3NpdGlvbnMiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiVFJJQU5HTEVfRkFOIiwiRmxvYXQzMkFycmF5IiwiaXNJbnN0YW5jZWQiLCJhdHRyaWJ1dGUiLCJkYXRhIiwidmFsdWUiLCJpIiwicG9pbnQiLCJpc05hTiIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLEtBQVIsUUFBb0IsY0FBcEI7QUFDQSxTQUFRQyxlQUFSLFFBQThCLHVCQUE5QjtBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixvQkFBbEI7QUFDQSxTQUFRQyxPQUFSLEVBQWlCQyxrQkFBakIsUUFBMEMseUJBQTFDO0FBQ0EsU0FBUUMsRUFBUixFQUFZQyxLQUFaLEVBQW1CQyxRQUFuQixRQUFrQyxTQUFsQzs7QUFFQSxPQUFPQyxpQkFBUCxNQUE4QixpQ0FBOUI7QUFDQSxPQUFPQyxtQkFBUCxNQUFnQyxvQ0FBaEM7QUFDQSxPQUFPQyxtQkFBUCxNQUFnQyxtQ0FBaEM7O0FBRUEsSUFBTUMsZ0JBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUF0Qjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxlQUFhLENBRE0sRUFDRjtBQUNqQkMsbUJBQWlCLENBRkUsRUFFQztBQUNwQkMsbUJBQWlCQyxPQUFPQyxnQkFITCxFQUd1QjtBQUMxQ0Ms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QUlDLElBQUksQ0FBUjtBQUhpQztBQUFBO0FBQUE7O0FBQUE7QUFJakMsOEJBQW9CRixJQUFwQixtSUFBMEI7QUFBQSxjQUFmRyxLQUFlOztBQUN4QixjQUFNdEQsUUFBUUQsU0FBU3VELEtBQVQsS0FBbUJ0RSxhQUFqQztBQUNBb0UsZ0JBQU1DLEdBQU4sSUFBYTlFLElBQUl5QixLQUFKLEVBQVcsQ0FBWCxDQUFiO0FBQ0FvRCxnQkFBTUMsR0FBTixJQUFhOUUsSUFBSXlCLEtBQUosRUFBVyxDQUFYLENBQWI7QUFDQW9ELGdCQUFNQyxHQUFOLElBQWE5RSxJQUFJeUIsS0FBSixFQUFXLENBQVgsQ0FBYjtBQUNBb0QsZ0JBQU1DLEdBQU4sSUFBYUUsTUFBTWhGLElBQUl5QixLQUFKLEVBQVcsQ0FBWCxDQUFOLElBQXVCLEdBQXZCLEdBQTZCekIsSUFBSXlCLEtBQUosRUFBVyxDQUFYLENBQTFDO0FBQ0Q7QUFWZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdsQzs7OztFQXpJMkM1QixLOztlQUF6QjZCLGdCOzs7QUE0SXJCQSxpQkFBaUJ1RCxTQUFqQixHQUE2QixrQkFBN0I7QUFDQXZELGlCQUFpQmhCLFlBQWpCLEdBQWdDQSxZQUFoQyIsImZpbGUiOiJzY2F0dGVycGxvdC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHNjYXR0ZXJwbG90VmVydGV4IGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHNjYXR0ZXJwbG90VmVydGV4NjQgZnJvbSAnLi9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgc2NhdHRlcnBsb3RGcmFnbWVudCBmcm9tICcuL3NjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgcmFkaXVzU2NhbGU6IDEsICAvLyAgcG9pbnQgcmFkaXVzIGluIG1ldGVyc1xuICByYWRpdXNNaW5QaXhlbHM6IDAsIC8vICBtaW4gcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICByYWRpdXNNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAvLyBtYXggcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICBzdHJva2VXaWR0aDogMSxcbiAgb3V0bGluZTogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGdldFJhZGl1czogeCA9PiB4LnJhZGl1cyB8fCAxLFxuICBnZXRDb2xvcjogeCA9PiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJwbG90TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoaWQpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpID8ge1xuICAgICAgdnM6IHNjYXR0ZXJwbG90VmVydGV4NjQsXG4gICAgICBmczogc2NhdHRlcnBsb3RGcmFnbWVudCxcbiAgICAgIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9IDoge1xuICAgICAgdnM6IHNjYXR0ZXJwbG90VmVydGV4LFxuICAgICAgZnM6IHNjYXR0ZXJwbG90RnJhZ21lbnQsXG4gICAgICBtb2R1bGVzOiBbXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIC8qIGRlcHJlY2F0ZWQgcHJvcHMgY2hlY2sgKi9cbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCdyYWRpdXMnLCAncmFkaXVzU2NhbGUnKTtcbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCdkcmF3T3V0bGluZScsICdvdXRsaW5lJyk7XG5cbiAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVJhZGl1czoge3NpemU6IDEsIGFjY2Vzc29yOiAnZ2V0UmFkaXVzJywgZGVmYXVsdFZhbHVlOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VSYWRpdXN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3JhZGl1c1NjYWxlLCByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVscywgb3V0bGluZSwgc3Ryb2tlV2lkdGh9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgb3V0bGluZTogb3V0bGluZSA/IDEgOiAwLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHJhZGl1c01pblBpeGVscyxcbiAgICAgIHJhZGl1c01heFBpeGVsc1xuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIC8vIGEgc3F1YXJlIHRoYXQgbWluaW1hbGx5IGNvdmVyIHRoZSB1bml0IGNpcmNsZVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgLTEsIDAsIC0xLCAxLCAwLCAxLCAxLCAwLCAxLCAtMSwgMF07XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9GQU4sXG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldChwb3NpdGlvbiwgMCk7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0KHBvc2l0aW9uLCAxKTtcbiAgICAgIHZhbHVlW2krK10gPSBnZXQocG9zaXRpb24sIDIpIHx8IDA7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShnZXQocG9zaXRpb24sIDApKVsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KGdldChwb3NpdGlvbiwgMSkpWzFdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUmFkaXVzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRSYWRpdXN9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGdldFJhZGl1cyhwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gaXNOYU4ocmFkaXVzKSA/IDEgOiByYWRpdXM7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvaW50KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldChjb2xvciwgMCk7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0KGNvbG9yLCAxKTtcbiAgICAgIHZhbHVlW2krK10gPSBnZXQoY29sb3IsIDIpO1xuICAgICAgdmFsdWVbaSsrXSA9IGlzTmFOKGdldChjb2xvciwgMykpID8gMjU1IDogZ2V0KGNvbG9yLCAzKTtcbiAgICB9XG4gIH1cbn1cblxuU2NhdHRlcnBsb3RMYXllci5sYXllck5hbWUgPSAnU2NhdHRlcnBsb3RMYXllcic7XG5TY2F0dGVycGxvdExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__solid_polygon_layer_vertex_glsl__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__solid_polygon_layer_vertex_64_glsl__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__ = __webpack_require__(176);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.








// Polygon geometry generation is managed by the polygon tesselator







var defaultProps = {
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'polygon') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'geometry.coordinates');
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'elevation') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'properties.height') || 0;
  },
  // Accessor for color
  getColor: function getColor(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'color') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(f, 'properties.color');
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var SolidPolygonLayer = function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_8__solid_polygon_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64', 'lighting'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_7__solid_polygon_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__["a" /* default */],
        modules: ['lighting'],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({
        model: this._getModel(gl),
        numInstances: 0,
        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array
      });

      var attributeManager = this.state.attributeManager;

      var noAlloc = true;
      /* eslint-disable max-len */
      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },
        positions: { size: 3, accessor: 'getElevation', update: this.calculatePositions, noAlloc: noAlloc },
        normals: { size: 3, update: this.calculateNormals, noAlloc: noAlloc },
        colors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors, noAlloc: noAlloc },
        pickingColors: { size: 3, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.add({
            positions64xyLow: { size: 2, update: this.calculatePositionsLow }
          });
        } else {
          attributeManager.remove(['positions64xyLow']);
        }
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          extruded = _props.extruded,
          lightSettings = _props.lightSettings;


      this.state.model.render(Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0
      }, lightSettings));
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;

      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });

      var regenerateModel = this.updateGeometry({ props: props, oldProps: oldProps, changeFlags: changeFlags });

      if (regenerateModel) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'updateGeometry',
    value: function updateGeometry(_ref4) {
      var _this2 = this;

      var props = _ref4.props,
          oldProps = _ref4.oldProps,
          changeFlags = _ref4.changeFlags;

      var geometryConfigChanged = props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe || props.fp64 !== oldProps.fp64;

      // When the geometry config  or the data is changed,
      // tessellator needs to be invoked
      if (changeFlags.dataChanged || geometryConfigChanged) {
        var getPolygon = props.getPolygon,
            extruded = props.extruded,
            wireframe = props.wireframe,
            getElevation = props.getElevation;

        // TODO - avoid creating a temporary array here: let the tesselator iterate

        var polygons = props.data.map(getPolygon);

        this.setState({
          polygonTesselator: !extruded ? new __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__["a" /* PolygonTesselator */]({ polygons: polygons, fp64: this.props.fp64 }) : new __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__["a" /* PolygonTesselatorExtruded */]({ polygons: polygons, wireframe: wireframe,
            getHeight: function getHeight(polygonIndex) {
              return getElevation(_this2.props.data[polygonIndex]);
            },
            fp64: this.props.fp64
          })
        });

        this.state.attributeManager.invalidateAll();
      }

      return geometryConfigChanged;
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__["b" /* Geometry */]({
          drawMode: this.props.wireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      });
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions().positions;
    }
  }, {
    key: 'calculatePositionsLow',
    value: function calculatePositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.positions().positions64xyLow;
    }
  }, {
    key: 'calculateNormals',
    value: function calculateNormals(attribute) {
      attribute.value = this.state.polygonTesselator.normals();
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        getColor: function getColor(polygonIndex) {
          return _this3.props.getColor(_this3.props.data[polygonIndex]);
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (SolidPolygonLayer);


SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJnZXQiLCJHTCIsIk1vZGVsIiwiR2VvbWV0cnkiLCJlbmFibGU2NGJpdFN1cHBvcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsIlBvbHlnb25UZXNzZWxhdG9yIiwiUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCIsInNvbGlkUG9seWdvblZlcnRleCIsInNvbGlkUG9seWdvblZlcnRleDY0Iiwic29saWRQb2x5Z29uRnJhZ21lbnQiLCJkZWZhdWx0UHJvcHMiLCJleHRydWRlZCIsIndpcmVmcmFtZSIsImZwNjQiLCJnZXRQb2x5Z29uIiwiZiIsImdldEVsZXZhdGlvbiIsImdldENvbG9yIiwibGlnaHRTZXR0aW5ncyIsImxpZ2h0c1Bvc2l0aW9uIiwiYW1iaWVudFJhdGlvIiwiZGlmZnVzZVJhdGlvIiwic3BlY3VsYXJSYXRpbyIsImxpZ2h0c1N0cmVuZ3RoIiwibnVtYmVyT2ZMaWdodHMiLCJTb2xpZFBvbHlnb25MYXllciIsInByb3BzIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJzaGFkZXJDYWNoZSIsImNvbnRleHQiLCJnbCIsInNldFN0YXRlIiwibW9kZWwiLCJfZ2V0TW9kZWwiLCJudW1JbnN0YW5jZXMiLCJJbmRleFR5cGUiLCJnZXRFeHRlbnNpb24iLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwibm9BbGxvYyIsImFkZCIsImluZGljZXMiLCJzaXplIiwiaXNJbmRleGVkIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsInBvc2l0aW9ucyIsImFjY2Vzc29yIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwibm9ybWFscyIsImNhbGN1bGF0ZU5vcm1hbHMiLCJjb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUNvbG9ycyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImludmFsaWRhdGVBbGwiLCJwcm9qZWN0aW9uTW9kZSIsIkxOR0xBVCIsInBvc2l0aW9uczY0eHlMb3ciLCJjYWxjdWxhdGVQb3NpdGlvbnNMb3ciLCJyZW1vdmUiLCJ1bmlmb3JtcyIsInJlbmRlciIsIk9iamVjdCIsImFzc2lnbiIsInJlZ2VuZXJhdGVNb2RlbCIsInVwZGF0ZUdlb21ldHJ5IiwidXBkYXRlQXR0cmlidXRlIiwiZ2VvbWV0cnlDb25maWdDaGFuZ2VkIiwiZGF0YUNoYW5nZWQiLCJwb2x5Z29ucyIsImRhdGEiLCJtYXAiLCJwb2x5Z29uVGVzc2VsYXRvciIsImdldEhlaWdodCIsInBvbHlnb25JbmRleCIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwiaWQiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiTElORVMiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhDb3VudCIsImF0dHJpYnV0ZSIsInZhbHVlIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJzZXRWZXJ0ZXhDb3VudCIsImxlbmd0aCIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLEtBQVIsUUFBb0IsY0FBcEI7QUFDQSxTQUFRQyxlQUFSLFFBQThCLHVCQUE5QjtBQUNBLFNBQVFDLEdBQVIsUUFBa0Isb0JBQWxCO0FBQ0EsU0FBUUMsRUFBUixFQUFZQyxLQUFaLEVBQW1CQyxRQUFuQixRQUFrQyxTQUFsQztBQUNBLFNBQVFDLGtCQUFSLFFBQWlDLHlCQUFqQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDOztBQUVBO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0Ms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V0FBS3JELEtBQUwsQ0FBV1IsS0FBWCxDQUFpQjhELGNBQWpCLENBQWdDSixVQUFVQyxLQUFWLENBQWdCSSxNQUFoQixHQUF5QkwsVUFBVTlDLElBQW5FO0FBQ0Q7Ozt1Q0FFa0I4QyxTLEVBQVc7QUFDNUJBLGdCQUFVQyxLQUFWLEdBQWtCLEtBQUtuRCxLQUFMLENBQVd1QyxpQkFBWCxDQUE2Qi9CLFNBQTdCLEdBQXlDQSxTQUEzRDtBQUNEOzs7MENBQ3FCMEMsUyxFQUFXO0FBQy9CQSxnQkFBVUMsS0FBVixHQUFrQixLQUFLbkQsS0FBTCxDQUFXdUMsaUJBQVgsQ0FBNkIvQixTQUE3QixHQUF5Q2dCLGdCQUEzRDtBQUNEOzs7cUNBQ2dCMEIsUyxFQUFXO0FBQzFCQSxnQkFBVUMsS0FBVixHQUFrQixLQUFLbkQsS0FBTCxDQUFXdUMsaUJBQVgsQ0FBNkI1QixPQUE3QixFQUFsQjtBQUNEOzs7b0NBRWV1QyxTLEVBQVc7QUFBQTs7QUFDekJBLGdCQUFVQyxLQUFWLEdBQWtCLEtBQUtuRCxLQUFMLENBQVd1QyxpQkFBWCxDQUE2QjFCLE1BQTdCLENBQW9DO0FBQ3BEdEMsa0JBQVU7QUFBQSxpQkFBZ0IsT0FBS1MsS0FBTCxDQUFXVCxRQUFYLENBQW9CLE9BQUtTLEtBQUwsQ0FBV3FELElBQVgsQ0FBZ0JJLFlBQWhCLENBQXBCLENBQWhCO0FBQUE7QUFEMEMsT0FBcEMsQ0FBbEI7QUFHRDs7QUFFRDs7OzsyQ0FDdUJTLFMsRUFBVztBQUNoQ0EsZ0JBQVVDLEtBQVYsR0FBa0IsS0FBS25ELEtBQUwsQ0FBV3VDLGlCQUFYLENBQTZCdEIsYUFBN0IsRUFBbEI7QUFDRDs7OztFQTlJNEM5RCxLOztlQUExQjRCLGlCOzs7QUFpSnJCQSxrQkFBa0J5RSxTQUFsQixHQUE4QixtQkFBOUI7QUFDQXpFLGtCQUFrQmYsWUFBbEIsR0FBaUNBLFlBQWpDIiwiZmlsZSI6InNvbGlkLXBvbHlnb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbi8vIFBvbHlnb24gZ2VvbWV0cnkgZ2VuZXJhdGlvbiBpcyBtYW5hZ2VkIGJ5IHRoZSBwb2x5Z29uIHRlc3NlbGF0b3JcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3J9IGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3JFeHRydWRlZH0gZnJvbSAnLi9wb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQnO1xuXG5pbXBvcnQgc29saWRQb2x5Z29uVmVydGV4IGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgc29saWRQb2x5Z29uVmVydGV4NjQgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBzb2xpZFBvbHlnb25GcmFnbWVudCBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gV2hldGhlciB0byBleHRydWRlXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgLy8gV2hldGhlciB0byBkcmF3IGEgR0wuTElORVMgd2lyZWZyYW1lIG9mIHRoZSBwb2x5Z29uXG4gIHdpcmVmcmFtZTogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIC8vIEFjY2Vzc29yIGZvciBwb2x5Z29uIGdlb21ldHJ5XG4gIGdldFBvbHlnb246IGYgPT4gZ2V0KGYsICdwb2x5Z29uJykgfHwgZ2V0KGYsICdnZW9tZXRyeS5jb29yZGluYXRlcycpLFxuICAvLyBBY2Nlc3NvciBmb3IgZXh0cnVzaW9uIGhlaWdodFxuICBnZXRFbGV2YXRpb246IGYgPT4gZ2V0KGYsICdlbGV2YXRpb24nKSB8fCBnZXQoZiwgJ3Byb3BlcnRpZXMuaGVpZ2h0JykgfHwgMCxcbiAgLy8gQWNjZXNzb3IgZm9yIGNvbG9yXG4gIGdldENvbG9yOiBmID0+IGdldChmLCAnY29sb3InKSB8fCBnZXQoZiwgJ3Byb3BlcnRpZXMuY29sb3InKSxcblxuICAvLyBPcHRpb25hbCBzZXR0aW5ncyBmb3IgJ2xpZ2h0aW5nJyBzaGFkZXIgbW9kdWxlXG4gIGxpZ2h0U2V0dGluZ3M6IHtcbiAgICBsaWdodHNQb3NpdGlvbjogWy0xMjIuNDUsIDM3Ljc1LCA4MDAwLCAtMTIyLjAsIDM4LjAwLCA1MDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuMDUsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMi4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2xpZFBvbHlnb25MYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpID8ge1xuICAgICAgdnM6IHNvbGlkUG9seWdvblZlcnRleDY0LFxuICAgICAgZnM6IHNvbGlkUG9seWdvbkZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCcsICdsaWdodGluZyddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH0gOiB7XG4gICAgICB2czogc29saWRQb2x5Z29uVmVydGV4LFxuICAgICAgZnM6IHNvbGlkUG9seWdvbkZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydsaWdodGluZyddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCksXG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBJbmRleFR5cGU6IGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheVxuICAgIH0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBub0FsbG9jID0gdHJ1ZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIGlzSW5kZXhlZDogdHJ1ZSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIG5vQWxsb2N9LFxuICAgICAgcG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRFbGV2YXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zLCBub0FsbG9jfSxcbiAgICAgIG5vcm1hbHM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTm9ybWFscywgbm9BbGxvY30sXG4gICAgICBjb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9ycywgbm9BbGxvY30sXG4gICAgICBwaWNraW5nQ29sb3JzOiB7c2l6ZTogMywgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMsIG5vQWxsb2N9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcblxuICAgICAgaWYgKHByb3BzLmZwNjQgJiYgcHJvcHMucHJvamVjdGlvbk1vZGUgPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICAgICAgcG9zaXRpb25zNjR4eUxvdzoge3NpemU6IDIsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnNMb3d9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdwb3NpdGlvbnM2NHh5TG93J1xuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7ZXh0cnVkZWQsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICBleHRydWRlZDogZXh0cnVkZWQgPyAxLjAgOiAwLjBcbiAgICB9LFxuICAgIGxpZ2h0U2V0dGluZ3MpKTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG5cbiAgICBjb25zdCByZWdlbmVyYXRlTW9kZWwgPSB0aGlzLnVwZGF0ZUdlb21ldHJ5KHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG5cbiAgICBpZiAocmVnZW5lcmF0ZU1vZGVsKSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnkoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnlDb25maWdDaGFuZ2VkID0gcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8XG4gICAgICBwcm9wcy53aXJlZnJhbWUgIT09IG9sZFByb3BzLndpcmVmcmFtZSB8fCBwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0O1xuXG4gICAgIC8vIFdoZW4gdGhlIGdlb21ldHJ5IGNvbmZpZyAgb3IgdGhlIGRhdGEgaXMgY2hhbmdlZCxcbiAgICAgLy8gdGVzc2VsbGF0b3IgbmVlZHMgdG8gYmUgaW52b2tlZFxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBnZW9tZXRyeUNvbmZpZ0NoYW5nZWQpIHtcbiAgICAgIGNvbnN0IHtnZXRQb2x5Z29uLCBleHRydWRlZCwgd2lyZWZyYW1lLCBnZXRFbGV2YXRpb259ID0gcHJvcHM7XG5cbiAgICAgIC8vIFRPRE8gLSBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSBhcnJheSBoZXJlOiBsZXQgdGhlIHRlc3NlbGF0b3IgaXRlcmF0ZVxuICAgICAgY29uc3QgcG9seWdvbnMgPSBwcm9wcy5kYXRhLm1hcChnZXRQb2x5Z29uKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBvbHlnb25UZXNzZWxhdG9yOiAhZXh0cnVkZWQgP1xuICAgICAgICAgIG5ldyBQb2x5Z29uVGVzc2VsYXRvcih7cG9seWdvbnMsIGZwNjQ6IHRoaXMucHJvcHMuZnA2NH0pIDpcbiAgICAgICAgICBuZXcgUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCh7cG9seWdvbnMsIHdpcmVmcmFtZSxcbiAgICAgICAgICAgIGdldEhlaWdodDogcG9seWdvbkluZGV4ID0+IGdldEVsZXZhdGlvbih0aGlzLnByb3BzLmRhdGFbcG9seWdvbkluZGV4XSksXG4gICAgICAgICAgICBmcDY0OiB0aGlzLnByb3BzLmZwNjRcbiAgICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29uZmlnQ2hhbmdlZDtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMud2lyZWZyYW1lID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5pbmRpY2VzKCk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBvc2l0aW9ucygpLnBvc2l0aW9ucztcbiAgfVxuICBjYWxjdWxhdGVQb3NpdGlvbnNMb3coYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnMoKS5wb3NpdGlvbnM2NHh5TG93O1xuICB9XG4gIGNhbGN1bGF0ZU5vcm1hbHMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5ub3JtYWxzKCk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5jb2xvcnMoe1xuICAgICAgZ2V0Q29sb3I6IHBvbHlnb25JbmRleCA9PiB0aGlzLnByb3BzLmdldENvbG9yKHRoaXMucHJvcHMuZGF0YVtwb2x5Z29uSW5kZXhdKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cbiAgY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBpY2tpbmdDb2xvcnMoKTtcbiAgfVxufVxuXG5Tb2xpZFBvbHlnb25MYXllci5sYXllck5hbWUgPSAnU29saWRQb2x5Z29uTGF5ZXInO1xuU29saWRQb2x5Z29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geojson__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__choropleth_layer_vertex_glsl__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__choropleth_layer_fragment_glsl__ = __webpack_require__(181);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultProps = {
  getColor: function getColor(feature) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(feature, 'properties.color');
  },
  drawContour: false,
  strokeWidth: 1
};

var ChoroplethLayer = function (_Layer) {
  _inherits(ChoroplethLayer, _Layer);

  function ChoroplethLayer(props) {
    _classCallCheck(this, ChoroplethLayer);

    var _this = _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).call(this, props));

    __WEBPACK_IMPORTED_MODULE_2__lib_utils__["a" /* log */].once('ChoroplethLayer is deprecated. Consider using GeoJsonLayer instead');
    return _this;
  }

  _createClass(ChoroplethLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: __WEBPACK_IMPORTED_MODULE_6__choropleth_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_7__choropleth_layer_fragment_glsl__["a" /* default */]
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;

      attributeManager.add({
        // Primtive attributes
        indices: { size: 1, update: this.calculateIndices, isIndexed: true },
        positions: { size: 3, update: this.calculatePositions },
        colors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].UNSIGNED_BYTE, update: this.calculateColors },
        // Instanced attributes
        pickingColors: {
          size: 3,
          type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: true
        }
      });

      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;

      this.setState({
        model: this.getModel(gl),
        numInstances: 0,
        IndexType: IndexType
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.state.choropleths = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__geojson__["a" /* extractPolygons */])(props.data);
        attributeManager.invalidateAll();
      }

      if (props.drawContour !== oldProps.drawContour) {
        this.state.model.geometry.drawMode = props.drawContour ? __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].LINES : __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].TRIANGLES;
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(this.props.data, ['features', index]) : null;
      info.feature = feature;
      info.object = feature;
      return info;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_4_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_4_luma_gl__["b" /* Geometry */]({
          drawMode: this.props.drawContour ? __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].LINES : __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      });
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this2 = this;

      // adjust index offset for multiple choropleths
      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {
          return count + polygon.length;
        }, 0)]);
      }, [0]);
      var IndexType = this.state.IndexType;

      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {
        throw new Error('Vertex count exceeds browser\'s limit');
      }

      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        return _this2.props.drawContour ?
        // 1. get sequentially ordered indices of each choropleth contour
        // 2. offset them by the number of indices in previous choropleths
        calculateContourIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        }) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous choropleths
        calculateSurfaceIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new IndexType(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["b" /* flatten */])(indices));
      attribute.target = __WEBPACK_IMPORTED_MODULE_4_luma_gl__["c" /* GL */].ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var vertices = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["b" /* flatten */])(this.state.choropleths);
      attribute.value = new Float32Array(vertices);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props = this.props,
          data = _props.data,
          getColor = _props.getColor;

      var features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(data, 'features');
      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var feature = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(features, choropleth.featureIndex);
        var color = getColor(feature) || DEFAULT_COLOR;
        // Ensure alpha is set
        if (isNaN(color[3])) {
          color[3] = DEFAULT_COLOR[3];
        }
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["b" /* flatten */])(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this3 = this;

      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var featureIndex = choropleth.featureIndex;

        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["b" /* flatten */])(colors));
    }
  }]);

  return ChoroplethLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (ChoroplethLayer);


ChoroplethLayer.layerName = 'ChoroplethLayer';
ChoroplethLayer.defaultProps = defaultProps;

/*
 * get vertex indices for drawing choropleth contour
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateContourIndices(choropleth) {
  var offset = 0;

  return choropleth.reduce(function (acc, polygon) {
    var numVertices = polygon.length;

    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]
    var indices = [].concat(_toConsumableArray(acc), [offset]);
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset + numVertices - 1);

    offset += numVertices;
    return indices;
  }, []);
}

/*
 * get vertex indices for drawing choropleth mesh
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(choropleth) {
  var holes = null;

  if (choropleth.length > 1) {
    holes = choropleth.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, choropleth.length);
  }

  return __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["b" /* flatten */])(choropleth), holes, 3);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJnZXQiLCJmbGF0dGVuIiwibG9nIiwiZXh0cmFjdFBvbHlnb25zIiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwiZWFyY3V0IiwiY2hvcm9wbGV0aFZlcnRleCIsImNob3JvcGxldGhGcmFnbWVudCIsIkRFRkFVTFRfQ09MT1IiLCJkZWZhdWx0UHJvcHMiLCJnZXRDb2xvciIsImZlYXR1cmUiLCJkcmF3Q29udG91ciIsInN0cm9rZVdpZHRoIiwiQ2hvcm9wbGV0aExheWVyIiwicHJvcHMiLCJvbmNlIiwidnMiLCJmcyIsImdsIiwiY29udGV4dCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZCIsImluZGljZXMiLCJzaXplIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImlzSW5kZXhlZCIsInBvc2l0aW9ucyIsImNhbGN1bGF0ZVBvc2l0aW9ucyIsImNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlQ29sb3JzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJub0FsbG9jIiwiSW5kZXhUeXBlIiwiZ2V0RXh0ZW5zaW9uIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsInNldFN0YXRlIiwibW9kZWwiLCJnZXRNb2RlbCIsIm51bUluc3RhbmNlcyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImNob3JvcGxldGhzIiwiZGF0YSIsImludmFsaWRhdGVBbGwiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiTElORVMiLCJUUklBTkdMRVMiLCJ1bmlmb3JtcyIsImxpbmVXaWR0aCIsInNjcmVlblRvRGV2aWNlUGl4ZWxzIiwicmVuZGVyIiwib3B0cyIsImluZm8iLCJpbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsImNvbG9yIiwib2JqZWN0Iiwic2hhZGVycyIsImdldFNoYWRlcnMiLCJpZCIsInZlcnRleENvdW50IiwiYXR0cmlidXRlIiwib2Zmc2V0cyIsInJlZHVjZSIsImFjYyIsImNob3JvcGxldGgiLCJsZW5ndGgiLCJjb3VudCIsInBvbHlnb24iLCJFcnJvciIsIm1hcCIsImNob3JvcGxldGhJbmRleCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJ2YWx1ZSIsInRhcmdldCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwic2V0VmVydGV4Q291bnQiLCJ2ZXJ0aWNlcyIsIkZsb2F0MzJBcnJheSIsImZlYXR1cmVzIiwiZmVhdHVyZUluZGV4IiwiaXNOYU4iLCJVaW50OEFycmF5IiwiTWF0aCIsImZsb29yIiwibGF5ZXJOYW1lIiwib2Zmc2V0IiwibnVtVmVydGljZXMiLCJpIiwicHVzaCIsImhvbGVzIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLEtBQVIsUUFBb0IsY0FBcEI7QUFDQSxTQUFRQyxlQUFSLFFBQThCLHVCQUE5QjtBQUNBLFNBQVFDLEdBQVIsRUFBYUMsT0FBYixFQUFzQkMsR0FBdEIsUUFBZ0Msb0JBQWhDO0FBQ0EsU0FBUUMsZUFBUixRQUE4QixXQUE5QjtBQUNBLFNBQVFDLEVBQVIsRUFBWUMsS0FBWixFQUFtQkMsUUFBbkIsUUFBa0MsU0FBbEM7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLE9BQU9DLGdCQUFQLE1BQTZCLGdDQUE3QjtBQUNBLE9BQU9DLGtCQUFQLE1BQStCLGtDQUEvQjs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEdBQVAs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QUFYLEdBQW9CLENBQXhCLEVBQTJCO0FBQ3pCeUIsWUFBUTFCLFdBQVdGLE1BQVgsQ0FDTixVQUFDQyxHQUFELEVBQU1JLE9BQU47QUFBQSwwQ0FBc0JKLEdBQXRCLElBQTJCQSxJQUFJQSxJQUFJRSxNQUFKLEdBQWEsQ0FBakIsSUFBc0JFLFFBQVFGLE1BQXpEO0FBQUEsS0FETSxFQUVOLENBQUMsQ0FBRCxDQUZNLEVBR04wQixLQUhNLENBR0EsQ0FIQSxFQUdHM0IsV0FBV0MsTUFIZCxDQUFSO0FBSUQ7O0FBRUQsU0FBT3RFLE9BQU9OLFFBQVEyRSxVQUFSLENBQVAsRUFBNEIwQixLQUE1QixFQUFtQyxDQUFuQyxDQUFQO0FBQ0QiLCJmaWxlIjoiY2hvcm9wbGV0aC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge2dldCwgZmxhdHRlbiwgbG9nfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHtleHRyYWN0UG9seWdvbnN9IGZyb20gJy4vZ2VvanNvbic7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG5pbXBvcnQgY2hvcm9wbGV0aFZlcnRleCBmcm9tICcuL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGNob3JvcGxldGhGcmFnbWVudCBmcm9tICcuL2Nob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGdldENvbG9yOiBmZWF0dXJlID0+IGdldChmZWF0dXJlLCAncHJvcGVydGllcy5jb2xvcicpLFxuICBkcmF3Q29udG91cjogZmFsc2UsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9yb3BsZXRoTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgbG9nLm9uY2UoJ0Nob3JvcGxldGhMYXllciBpcyBkZXByZWNhdGVkLiBDb25zaWRlciB1c2luZyBHZW9Kc29uTGF5ZXIgaW5zdGVhZCcpO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IGNob3JvcGxldGhWZXJ0ZXgsXG4gICAgICBmczogY2hvcm9wbGV0aEZyYWdtZW50XG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICAvLyBQcmltdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIGlzSW5kZXhlZDogdHJ1ZX0sXG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnN9LFxuICAgICAgLy8gSW5zdGFuY2VkIGF0dHJpYnV0ZXNcbiAgICAgIHBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMsXG4gICAgICAgIG5vQWxsb2M6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IEluZGV4VHlwZSA9IGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpLFxuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgSW5kZXhUeXBlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5zdGF0ZS5jaG9yb3BsZXRocyA9IGV4dHJhY3RQb2x5Z29ucyhwcm9wcy5kYXRhKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5kcmF3Q29udG91ciAhPT0gb2xkUHJvcHMuZHJhd0NvbnRvdXIpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuZ2VvbWV0cnkuZHJhd01vZGUgPSBwcm9wcy5kcmF3Q29udG91ciA/IEdMLkxJTkVTIDogR0wuVFJJQU5HTEVTO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuc2NyZWVuVG9EZXZpY2VQaXhlbHModGhpcy5wcm9wcy5zdHJva2VXaWR0aCk7XG4gICAgZ2wubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIC8vIFNldHRpbmcgbGluZSB3aWR0aCBiYWNrIHRvIDEgaXMgaGVyZSB0byB3b3JrYXJvdW5kIGEgR29vZ2xlIENocm9tZSBidWdcbiAgICAvLyBnbC5jbGVhcigpIGFuZCBnbC5pc0VuYWJsZWQoKSB3aWxsIHJldHVybiBHTF9JTlZBTElEX1ZBTFVFIGV2ZW4gd2l0aFxuICAgIC8vIGNvcnJlY3QgcGFyYW1ldGVyXG4gICAgLy8gVGhpcyBpcyBub3QgaGFwcGVuaW5nIG9uIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgIGdsLmxpbmVXaWR0aCgxLjApO1xuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVjb2RlUGlja2luZ0NvbG9yKGluZm8uY29sb3IpO1xuICAgIGNvbnN0IGZlYXR1cmUgPSBpbmRleCA+PSAwID8gZ2V0KHRoaXMucHJvcHMuZGF0YSwgWydmZWF0dXJlcycsIGluZGV4XSkgOiBudWxsO1xuICAgIGluZm8uZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoXG4gICAgICAoYWNjLCBjaG9yb3BsZXRoKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICtcbiAgICAgICAgY2hvcm9wbGV0aC5yZWR1Y2UoKGNvdW50LCBwb2x5Z29uKSA9PiBjb3VudCArIHBvbHlnb24ubGVuZ3RoLCAwKV0sXG4gICAgICBbMF1cbiAgICApO1xuICAgIGNvbnN0IHtJbmRleFR5cGV9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV0gPiA2NTUzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGNob3JvcGxldGggY29udG91clxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdKSA6XG4gICAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pXG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBJbmRleFR5cGUoZmxhdHRlbihpbmRpY2VzKSk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBnZXQoZGF0YSwgJ2ZlYXR1cmVzJyk7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBnZXQoZmVhdHVyZXMsIGNob3JvcGxldGguZmVhdHVyZUluZGV4KTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihmZWF0dXJlKSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgICAvLyBFbnN1cmUgYWxwaGEgaXMgc2V0XG4gICAgICAgIGlmIChpc05hTihjb2xvclszXSkpIHtcbiAgICAgICAgICBjb2xvclszXSA9IERFRkFVTFRfQ09MT1JbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBVaW50OEFycmF5KGZsYXR0ZW4oY29sb3JzKSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7ZmVhdHVyZUluZGV4fSA9IGNob3JvcGxldGg7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IFswLCAwLCAwXSA6IFtcbiAgICAgICAgICAoZmVhdHVyZUluZGV4ICsgMSkgJSAyNTYsXG4gICAgICAgICAgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgICAgIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hvcm9wbGV0aC5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcCh2ZXJ0ZXggPT4gY29sb3IpKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgfVxufVxuXG5DaG9yb3BsZXRoTGF5ZXIubGF5ZXJOYW1lID0gJ0Nob3JvcGxldGhMYXllcic7XG5DaG9yb3BsZXRoTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggY29udG91clxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgcmV0dXJuIGNob3JvcGxldGgucmVkdWNlKChhY2MsIHBvbHlnb24pID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgZ2wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0yLCBuLTIsIG4tMV1cbiAgICBjb25zdCBpbmRpY2VzID0gWy4uLmFjYywgb2Zmc2V0XTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyBudW1WZXJ0aWNlcyAtIDEpO1xuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9LCBbXSk7XG59XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBtZXNoXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkge1xuICBsZXQgaG9sZXMgPSBudWxsO1xuXG4gIGlmIChjaG9yb3BsZXRoLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IGNob3JvcGxldGgucmVkdWNlKFxuICAgICAgKGFjYywgcG9seWdvbikgPT4gWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoXSxcbiAgICAgIFswXVxuICAgICkuc2xpY2UoMSwgY2hvcm9wbGV0aC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGVhcmN1dChmbGF0dGVuKGNob3JvcGxldGgpLCBob2xlcywgMyk7XG59XG4iXX0=

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export glArrayFromType */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable guard-for-in */




var LOG_START_END_PRIORITY = 1;
var LOG_DETAIL_PRIORITY = 2;

function noop() {}

/* eslint-disable complexity */
function glArrayFromType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].FLOAT:
      return Float32Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_SHORT:
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_SHORT_5_6_5:
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_SHORT_4_4_4_4:
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_INT:
      return Uint32Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].BYTE:
      return Int8Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].SHORT:
      return Int16Array;
    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */

// Default loggers
var logFunctions = {
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        id = _ref2.id;

    __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].time(level, 'Updated attributes for ' + id);
  },
  onLog: function onLog(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].log(level, message);
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id;

    __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].timeEnd(level, 'Updated attributes for ' + id);
  }
};

var AttributeManager = function () {
  _createClass(AttributeManager, null, [{
    key: 'setDefaultLogFunctions',

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }
      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }
      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }

    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     *
     * Summary:
     * - keeps track of valid state for each attribute
     * - auto reallocates attributes when needed
     * - auto updates attributes with registered updater functions
     * - allows overriding with application supplied buffers
     *
     * Limitations:
     * - There are currently no provisions for only invalidating a range of
     *   indices in an attribute.
     *
     * @class
     * @param {Object} [props]
     * @param {String} [props.id] - identifier (for debugging)
     */

  }]);

  function AttributeManager() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === undefined ? 'attribute-manager' : _ref6$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.attributes = {};
    this.updateTriggers = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
      * Removes attributes
      * Takes an array of attribute names and delete them from
      * the attribute map if they exists
      *
      * @example
      * attributeManager.remove(['position']);
      *
      * @param {Object} attributeNameArray - attribute name array (see above)
      */

  }, {
    key: 'remove',
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];
        if (this.attributes[name] !== undefined) {
          delete this.attributes[name];
        }
      }
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var attributesToUpdate = updateTriggers[triggerName];

      if (!attributesToUpdate) {
        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');
        __WEBPACK_IMPORTED_MODULE_2_assert___default()(attributesToUpdate, message);
      }
      attributesToUpdate.forEach(function (name) {
        var attribute = attributes[name];
        if (attribute) {
          attribute.needsUpdate = true;
        }
      });
      // For performance tuning
      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id,
        id: this.identifier
      });
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref7.data,
          numInstances = _ref7.numInstances,
          _ref7$props = _ref7.props,
          props = _ref7$props === undefined ? {} : _ref7$props,
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === undefined ? {} : _ref7$buffers,
          _ref7$context = _ref7.context,
          context = _ref7$context === undefined ? {} : _ref7$context,
          _ref7$ignoreUnknownAt = _ref7.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref7$ignoreUnknownAt === undefined ? false : _ref7$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        logFunctions.onUpdateStart({ level: LOG_START_END_PRIORITY, id: this.id });
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        logFunctions.onUpdateEnd({ level: LOG_START_END_PRIORITY, id: this.id });
      }
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref8) {
      var _ref8$clearChangedFla = _ref8.clearChangedFlags,
          clearChangedFlags = _ref8$clearChangedFla === undefined ? false : _ref8$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$clearRedrawFlag = _ref9.clearRedrawFlags,
          clearRedrawFlags = _ref9$clearRedrawFlag === undefined ? false : _ref9$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // use attribute name as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      __WEBPACK_IMPORTED_MODULE_2_assert___default()(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$buffers = _ref10.buffers,
          buffers = _ref10$buffers === undefined ? {} : _ref10$buffers,
          _ref10$ignoreUnknownA = _ref10.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref10$ignoreUnknownA === undefined ? false : _ref10$ignoreUnknownA;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          if (!(buffer instanceof Float32Array)) {
            throw new Error('Attribute properties must be of type Float32Array');
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref11) {
      var numInstances = _ref11.numInstances;
      var attributes = this.attributes;

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref12) {
      var numInstances = _ref12.numInstances,
          data = _ref12.data,
          props = _ref12.props,
          context = _ref12.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = glArrayFromType(attribute.type || __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          logFunctions.onLog({
            level: LOG_DETAIL_PRIORITY,
            message: this.id + ':' + attributeName + ' allocated ' + allocCount,
            id: this.id
          });
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref13) {
      var attribute = _ref13.attribute,
          attributeName = _ref13.attributeName,
          numInstances = _ref13.numInstances,
          data = _ref13.data,
          props = _ref13.props,
          context = _ref13.context;
      var update = attribute.update,
          accessor = attribute.accessor;

      if (update) {
        // Custom updater - typically for non-instanced layers
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' updating ' + numInstances,
          id: this.id
        });
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' missing update function',
          id: this.id
        });
      }

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref14) {
      var attribute = _ref14.attribute,
          data = _ref14.data,
          props = _ref14.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (AttributeManager);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanMiXSwibmFtZXMiOlsiR0wiLCJsb2ciLCJhc3NlcnQiLCJMT0dfU1RBUlRfRU5EX1BSSU9SSVRZIiwiTE9HX0RFVEFJTF9QUklPUklUWSIsIm5vb3AiLCJnbEFycmF5RnJvbVR5cGUiLCJnbFR5cGUiLCJjbGFtcGVkIiwiRkxPQVQiLCJGbG9hdDMyQXJyYXkiLCJVTlNJR05FRF9TSE9SVCIsIlVOU0lHTkVEX1NIT1JUXzVfNl81IiwiVU5TSUdORURfU0hPUlRfNF80XzRfNCIsIlVOU0lHTkVEX1NIT1JUXzVfNV81XzEiLCJVaW50MTZBcnJheSIsIlVOU0lHTkVEX0lOVCIsIlVpbnQzMkFycmF5IiwiVU5TSUdORURfQllURSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDhBcnJheSIsIkJZVEUiLCJJbnQ4QXJyYXkiLCJTSE9SVCIsIkludDE2QXJyYXkiLCJJTlQiLCJJbnQzMkFycmF5IiwiRXJyb3IiLCJsb2dGdW5jdGlvbnMiLCJvblVwZGF0ZVN0YXJ0IiwibGV2ZWwiLCJpZCIsInRpbWUiLCJvbkxvZyIsIm1lc3NhZ2UiLCJvblVwZGF0ZUVuZCIsInRpbWVFbmQiLCJBdHRyaWJ1dGVNYW5hZ2VyIiwidW5kZWZpbmVkIiwiYXR0cmlidXRlcyIsInVwZGF0ZVRyaWdnZXJzIiwiYWxsb2NlZEluc3RhbmNlcyIsIm5lZWRzUmVkcmF3IiwidXNlckRhdGEiLCJPYmplY3QiLCJzZWFsIiwidXBkYXRlcnMiLCJfYWRkIiwiYXR0cmlidXRlTmFtZUFycmF5IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJ0cmlnZ2VyTmFtZSIsImF0dHJpYnV0ZXNUb1VwZGF0ZSIsImtleXMiLCJqb2luIiwiZm9yRWFjaCIsImF0dHJpYnV0ZSIsIm5lZWRzVXBkYXRlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZU5hbWUiLCJpbnZhbGlkYXRlIiwiZGF0YSIsIm51bUluc3RhbmNlcyIsInByb3BzIiwiYnVmZmVycyIsImNvbnRleHQiLCJpZ25vcmVVbmtub3duQXR0cmlidXRlcyIsIl9jaGVja0V4dGVybmFsQnVmZmVycyIsIl9zZXRFeHRlcm5hbEJ1ZmZlcnMiLCJfYW5hbHl6ZUJ1ZmZlcnMiLCJfdXBkYXRlQnVmZmVycyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJjaGFuZ2VkIiwiY2xlYXJSZWRyYXdGbGFncyIsInJlZHJhdyIsImluc3RhbmNlZCIsIl9leHRyYVByb3BzIiwibmV3QXR0cmlidXRlcyIsImFzc2lnbiIsImlzSW5kZXhlZCIsImVsZW1lbnRzIiwic2l6ZSIsInZhbHVlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwiX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbiIsIl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcyIsInRyaWdnZXJzIiwiYWNjZXNzb3IiLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3Nvck5hbWUiLCJwdXNoIiwiaGFzVXBkYXRlciIsIm5vQWxsb2MiLCJ1cGRhdGUiLCJidWZmZXJNYXAiLCJidWZmZXIiLCJhdXRvIiwiYWxsb2NDb3VudCIsIk1hdGgiLCJtYXgiLCJBcnJheVR5cGUiLCJ0eXBlIiwiX3VwZGF0ZUJ1ZmZlciIsImNhbGwiLCJfY2hlY2tBdHRyaWJ1dGVBcnJheSIsIl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yIiwiYWNjZXNzb3JGdW5jIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Iiwib2JqZWN0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRQSxFQUFSLFFBQWlCLFNBQWpCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixTQUFs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QWhpQmtCdkIsZ0IiLCJmaWxlIjoiYXR0cmlidXRlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTE9HX1NUQVJUX0VORF9QUklPUklUWSA9IDE7XG5jb25zdCBMT0dfREVUQUlMX1BSSU9SSVRZID0gMjtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBnbEFycmF5RnJvbVR5cGUoZ2xUeXBlLCB7Y2xhbXBlZCA9IHRydWV9ID0ge30pIHtcbiAgLy8gU29ydGVkIGluIHNvbWUgb3JkZXIgb2YgbGlrZWxpaG9vZCB0byByZWR1Y2UgYW1vdW50IG9mIGNvbXBhcmlzb25zXG4gIHN3aXRjaCAoZ2xUeXBlKSB7XG4gIGNhc2UgR0wuRkxPQVQ6XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVDpcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF81XzZfNTpcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF80XzRfNF80OlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE6XG4gICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICBjYXNlIEdMLlVOU0lHTkVEX0lOVDpcbiAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gIGNhc2UgR0wuVU5TSUdORURfQllURTpcbiAgICByZXR1cm4gY2xhbXBlZCA/IFVpbnQ4Q2xhbXBlZEFycmF5IDogVWludDhBcnJheTtcbiAgY2FzZSBHTC5CWVRFOlxuICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gIGNhc2UgR0wuU0hPUlQ6XG4gICAgcmV0dXJuIEludDE2QXJyYXk7XG4gIGNhc2UgR0wuSU5UOlxuICAgIHJldHVybiBJbnQzMkFycmF5O1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlZHVjZSB0eXBlIGZyb20gYXJyYXknKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8vIERlZmF1bHQgbG9nZ2Vyc1xuY29uc3QgbG9nRnVuY3Rpb25zID0ge1xuICBvblVwZGF0ZVN0YXJ0OiAoe2xldmVsLCBpZH0pID0+IHtcbiAgICBsb2cudGltZShsZXZlbCwgYFVwZGF0ZWQgYXR0cmlidXRlcyBmb3IgJHtpZH1gKTtcbiAgfSxcbiAgb25Mb2c6ICh7bGV2ZWwsIG1lc3NhZ2V9KSA9PiB7XG4gICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH0sXG4gIG9uVXBkYXRlRW5kOiAoe2xldmVsLCBpZH0pID0+IHtcbiAgICBsb2cudGltZUVuZChsZXZlbCwgYFVwZGF0ZWQgYXR0cmlidXRlcyBmb3IgJHtpZH1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBTZXRzIGxvZyBmdW5jdGlvbnMgdG8gaGVscCB0cmFjZSBvciB0aW1lIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgKiBEZWZhdWx0IGxvZ2dpbmcgdXNlcyBkZWNrIGxvZ2dlci5cbiAgICpcbiAgICogYG9uTG9nYCBpcyBjYWxsZWQgZm9yIGVhY2ggYXR0cmlidXRlLlxuICAgKlxuICAgKiBUbyBlbmFibGUgZGV0YWlsZWQgY29udHJvbCBvZiB0aW1taW5nIGFuZCBlLmcuIGhpZXJhcmNoaWNhbCBsb2dnaW5nLFxuICAgKiBob29rcyBhcmUgYWxzbyBwcm92aWRlZCBmb3IgdXBkYXRlIHN0YXJ0IGFuZCBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uTG9nPV0gLSBjYWxsZWQgdG8gcHJpbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlU3RhcnQ9XSAtIGNhbGxlZCBiZWZvcmUgdXBkYXRlKCkgc3RhcnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZUVuZD1dIC0gY2FsbGVkIGFmdGVyIHVwZGF0ZSgpIGVuZHNcbiAgICovXG4gIHN0YXRpYyBzZXREZWZhdWx0TG9nRnVuY3Rpb25zKHtcbiAgICBvbkxvZyxcbiAgICBvblVwZGF0ZVN0YXJ0LFxuICAgIG9uVXBkYXRlRW5kXG4gIH0gPSB7fSkge1xuICAgIGlmIChvbkxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25Mb2cgPSBvbkxvZyB8fCBub29wO1xuICAgIH1cbiAgICBpZiAob25VcGRhdGVTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVTdGFydCA9IG9uVXBkYXRlU3RhcnQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKG9uVXBkYXRlRW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ0Z1bmN0aW9ucy5vblVwZGF0ZUVuZCA9IG9uVXBkYXRlRW5kIHx8IG5vb3A7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQXV0b21hdGVkIGF0dHJpYnV0ZSBnZW5lcmF0aW9uIGFuZCBtYW5hZ2VtZW50LiBTdWl0YWJsZSB3aGVuIGEgc2V0IG9mXG4gICAqIHZlcnRleCBzaGFkZXIgYXR0cmlidXRlcyBhcmUgZ2VuZXJhdGVkIGJ5IGl0ZXJhdGlvbiBvdmVyIGEgZGF0YSBhcnJheSxcbiAgICogYW5kIHVwZGF0ZXMgdG8gdGhlc2UgYXR0cmlidXRlcyBhcmUgbmVlZGVkIGVpdGhlciB3aGVuIHRoZSBkYXRhIGl0c2VsZlxuICAgKiBjaGFuZ2VzLCBvciB3aGVuIG90aGVyIGRhdGEgcmVsZXZhbnQgdG8gdGhlIGNhbGN1bGF0aW9ucyBjaGFuZ2UuXG4gICAqXG4gICAqIC0gRmlyc3QgdGhlIGFwcGxpY2F0aW9uIHJlZ2lzdGVycyBkZXNjcmlwdGlvbnMgb2YgaXRzIGR5bmFtaWMgdmVydGV4XG4gICAqICAgYXR0cmlidXRlcyB1c2luZyBBdHRyaWJ1dGVNYW5hZ2VyLmFkZCgpLlxuICAgKiAtIFRoZW4sIHdoZW4gYW55IGNoYW5nZSB0aGF0IGFmZmVjdHMgYXR0cmlidXRlcyBpcyBkZXRlY3RlZCBieSB0aGVcbiAgICogICBhcHBsaWNhdGlvbiwgdGhlIGFwcCB3aWxsIGNhbGwgQXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCkuXG4gICAqIC0gRmluYWxseSBiZWZvcmUgaXQgcmVuZGVycywgaXQgY2FsbHMgQXR0cmlidXRlTWFuYWdlci51cGRhdGUoKSB0b1xuICAgKiAgIGVuc3VyZSB0aGF0IGF0dHJpYnV0ZXMgYXJlIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBpZiBhbnl0aGluZyBoYXMgYmVlblxuICAgKiAgIGludmFsaWRhdGVkLlxuICAgKlxuICAgKiBUaGUgYXBwbGljYXRpb24gcHJvdmlkZWQgdXBkYXRlIGZ1bmN0aW9ucyBkZXNjcmliZSBob3cgYXR0cmlidXRlc1xuICAgKiBzaG91bGQgYmUgdXBkYXRlZCBmcm9tIGEgZGF0YSBhcnJheSBhbmQgYXJlIGV4cGVjdGVkIHRvIHRyYXZlcnNlXG4gICAqIHRoYXQgZGF0YSBhcnJheSAob3IgaXRlcmFibGUpIGFuZCBmaWxsIGluIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBhdHRyaWJ1dGUgbWFuYWdlciBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGRvIGFkdmFuY2VkXG4gICAqIGNoYW5nZSBkZXRlY3Rpb24sIGJ1dCBpbnN0ZWFkIG1ha2VzIGl0IGVhc3kgdG8gYnVpbGQgc3VjaCBkZXRlY3Rpb25cbiAgICogYnkgb2ZmZXJpbmcgdGhlIGFiaWxpdHkgdG8gXCJpbnZhbGlkYXRlXCIgZWFjaCBhdHRyaWJ1dGUgc2VwYXJhdGVseS5cbiAgICpcbiAgICogU3VtbWFyeTpcbiAgICogLSBrZWVwcyB0cmFjayBvZiB2YWxpZCBzdGF0ZSBmb3IgZWFjaCBhdHRyaWJ1dGVcbiAgICogLSBhdXRvIHJlYWxsb2NhdGVzIGF0dHJpYnV0ZXMgd2hlbiBuZWVkZWRcbiAgICogLSBhdXRvIHVwZGF0ZXMgYXR0cmlidXRlcyB3aXRoIHJlZ2lzdGVyZWQgdXBkYXRlciBmdW5jdGlvbnNcbiAgICogLSBhbGxvd3Mgb3ZlcnJpZGluZyB3aXRoIGFwcGxpY2F0aW9uIHN1cHBsaWVkIGJ1ZmZlcnNcbiAgICpcbiAgICogTGltaXRhdGlvbnM6XG4gICAqIC0gVGhlcmUgYXJlIGN1cnJlbnRseSBubyBwcm92aXNpb25zIGZvciBvbmx5IGludmFsaWRhdGluZyBhIHJhbmdlIG9mXG4gICAqICAgaW5kaWNlcyBpbiBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BzLmlkXSAtIGlkZW50aWZpZXIgKGZvciBkZWJ1Z2dpbmcpXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7aWQgPSAnYXR0cmlidXRlLW1hbmFnZXInfSA9IHt9KSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSAtMTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG5cbiAgICAvLyBGb3IgZGVidWdnaW5nIHNhbml0eSwgcHJldmVudCB1bmluaXRpYWxpemVkIG1lbWJlcnNcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogVGFrZXMgYSBtYXAgb2YgYXR0cmlidXRlIGRlc2NyaXB0b3Igb2JqZWN0c1xuICAgKiAtIGtleXMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgKiAtIHZhbHVlcyBhcmUgb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZSBmaWVsZHNcbiAgICpcbiAgICogYXR0cmlidXRlLnNpemUgLSBudW1iZXIgb2YgZWxlbWVudHMgcGVyIG9iamVjdFxuICAgKiBhdHRyaWJ1dGUudXBkYXRlciAtIG51bWJlciBvZiBlbGVtZW50c1xuICAgKiBhdHRyaWJ1dGUuaW5zdGFuY2VkPTAgLSBpcyB0aGlzIGlzIGFuIGluc3RhbmNlZCBhdHRyaWJ1dGUgKGEuay5hLiBkaXZpc29yKVxuICAgKiBhdHRyaWJ1dGUubm9BbGxvYz1mYWxzZSAtIGlmIHRoaXMgYXR0cmlidXRlIHNob3VsZCBub3QgYmUgYWxsb2NhdGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICogICBwb3NpdGlvbnM6IHtzaXplOiAyLCB1cGRhdGU6IGNhbGN1bGF0ZVBvc2l0aW9uc31cbiAgICogICBjb2xvcnM6IHtzaXplOiAzLCB1cGRhdGU6IGNhbGN1bGF0ZUNvbG9yc31cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIGRlbGV0ZSB0aGVtIGZyb21cbiAgICogdGhlIGF0dHJpYnV0ZSBtYXAgaWYgdGhleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbiddKTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZU5hbWVBcnJheSAtIGF0dHJpYnV0ZSBuYW1lIGFycmF5IChzZWUgYWJvdmUpXG4gICAqL1xuICByZW1vdmUoYXR0cmlidXRlTmFtZUFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOYW1lQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lQXJyYXlbaV07XG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBNYXJrcyBhbiBhdHRyaWJ1dGUgZm9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJpZ2dlck5hbWU6IGF0dHJpYnV0ZSBvciBhY2Nlc3NvciBuYW1lXG4gICAqL1xuICBpbnZhbGlkYXRlKHRyaWdnZXJOYW1lKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIHVwZGF0ZVRyaWdnZXJzfSA9IHRoaXM7XG4gICAgY29uc3QgYXR0cmlidXRlc1RvVXBkYXRlID0gdXBkYXRlVHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuXG4gICAgaWYgKCFhdHRyaWJ1dGVzVG9VcGRhdGUpIHtcbiAgICAgIGxldCBtZXNzYWdlID1cbiAgICAgICAgYGludmFsaWRhdGluZyBub24tZXhpc3RlbnQgYXR0cmlidXRlICR7dHJpZ2dlck5hbWV9IGZvciAke3RoaXMuaWR9XFxuYDtcbiAgICAgIG1lc3NhZ2UgKz0gYFZhbGlkIGF0dHJpYnV0ZXM6ICR7T2JqZWN0LmtleXMoYXR0cmlidXRlcykuam9pbignLCAnKX1gO1xuICAgICAgYXNzZXJ0KGF0dHJpYnV0ZXNUb1VwZGF0ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXNUb1VwZGF0ZS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgdHVuaW5nXG4gICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgbWVzc2FnZTogYGludmFsaWRhdGVkIGF0dHJpYnV0ZSAke2F0dHJpYnV0ZXNUb1VwZGF0ZX0gZm9yICR7dGhpcy5pZH1gLFxuICAgICAgaWQ6IHRoaXMuaWRlbnRpZmllclxuICAgIH0pO1xuICB9XG5cbiAgaW52YWxpZGF0ZUFsbCgpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgYXR0cmlidXRlIGJ1ZmZlcnMgYXJlIHVwZGF0ZWQgZnJvbSBwcm9wcyBvciBkYXRhLlxuICAgKlxuICAgKiBOb3RlOiBBbnkgcHJlYWxsb2NhdGVkIGJ1ZmZlcnMgaW4gXCJidWZmZXJzXCIgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBhdHRyaWJ1dGVcbiAgICogbmFtZXMgd2lsbCBiZSB1c2VkLiBObyB1cGRhdGUgd2lsbCBoYXBwZW4gaW4gdGhpcyBjYXNlLlxuICAgKiBOb3RlOiBDYWxscyBvblVwZGF0ZVN0YXJ0IGFuZCBvblVwZGF0ZUVuZCBsb2cgY2FsbGJhY2tzIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgdXBkYXRlKHtcbiAgICBkYXRhLFxuICAgIG51bUluc3RhbmNlcyxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBjb250ZXh0ID0ge30sXG4gICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICAvLyBGaXJzdCBhcHBseSBhbnkgYXBwbGljYXRpb24gcHJvdmlkZWQgYnVmZmVyc1xuICAgIHRoaXMuX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKHtidWZmZXJzLCBpZ25vcmVVbmtub3duQXR0cmlidXRlc30pO1xuICAgIHRoaXMuX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJzKTtcblxuICAgIC8vIE9ubHkgaW5pdGlhdGUgYWxsb2MvdXBkYXRlIChhbmQgbG9nZ2luZykgaWYgYWN0dWFsbHkgbmVlZGVkXG4gICAgaWYgKHRoaXMuX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSkge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlU3RhcnQoe2xldmVsOiBMT0dfU1RBUlRfRU5EX1BSSU9SSVRZLCBpZDogdGhpcy5pZH0pO1xuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlRW5kKHtsZXZlbDogTE9HX1NUQVJUX0VORF9QUklPUklUWSwgaWQ6IHRoaXMuaWR9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIE5vdGU6IEZvcm1hdCBtYXRjaGVzIGx1bWEuZ2wgTW9kZWwvUHJvZ3JhbS5zZXRBdHRyaWJ1dGVzKClcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoYW5nZWQgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIFRoaXMgaW5kaWNhdGVzIHdoaWNoIFdlYkdMQnVnZ2VycyBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFncyA9IGZhbHNlfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuY2hhbmdlZCkge1xuICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IGF0dHJpYnV0ZS5jaGFuZ2VkICYmICFjbGVhckNoYW5nZWRGbGFncztcbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkQXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWRyYXcgZmxhZywgb3B0aW9uYWxseSBjbGVhcmluZyBpdC5cbiAgICogUmVkcmF3IGZsYWcgd2lsbCBiZSBzZXQgaWYgYW55IGF0dHJpYnV0ZXMgYXR0cmlidXRlcyBjaGFuZ2VkIHNpbmNlXG4gICAqIGZsYWcgd2FzIGxhc3QgY2xlYXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuY2xlYXJSZWRyYXdGbGFncz1mYWxzZV0gLSB3aGV0aGVyIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gd2hldGhlciBhIHJlZHJhdyBpcyBuZWVkZWQuXG4gICAqL1xuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgbGV0IHJlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZWRyYXcgZmxhZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZWRyYXc9dHJ1ZVxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGVNYW5hZ2VyfSAtIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkSW5zdGFuY2VkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHtpbnN0YW5jZWQ6IDF9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFVzZWQgdG8gcmVnaXN0ZXIgYW4gYXR0cmlidXRlXG4gIF9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSwgX2V4dHJhUHJvcHMgPSB7fSkge1xuXG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcGFyYXRlIHVwZGF0ZSBmdW5jdGlvbiBtYXBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgY29weSBhbnkgYXR0cmlidXRlcyBmcm9tIHRoYXQgbWFwIGludG8gdGhlIG1haW4gbWFwXG4gICAgICAvLyBUT0RPIC0gQXR0cmlidXRlIG1hcHMgYXJlIGEgZGVwcmVjYXRlZCBmZWF0dXJlLCByZW1vdmVcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHVwZGF0ZXJzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sIHVwZGF0ZXJzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgY29uc3QgaXNJbmRleGVkID0gYXR0cmlidXRlLmlzSW5kZXhlZCB8fCBhdHRyaWJ1dGUuZWxlbWVudHM7XG4gICAgICBjb25zdCBzaXplID0gKGF0dHJpYnV0ZS5lbGVtZW50cyAmJiAxKSB8fCBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlIHx8IG51bGw7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF0dHJpYnV0ZSBkZXNjcmlwdG9yLCB3aXRoIFdlYkdMIGFuZCBtZXRhZGF0YSBmaWVsZHNcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZmllbGRzIGFyZSBwcmVzZW50IGJlZm9yZSBPYmplY3Quc2VhbCgpXG4gICAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgdXNlckRhdGE6IHt9ICAgICAgICAvLyBSZXNlcnZlZCBmb3IgYXBwbGljYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWV0YWRhdGFcbiAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICB7XG4gICAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgICBpc0V4dGVybmFsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc0FsbG9jOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc1VwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG5cbiAgICAgICAgICAvLyBMdW1hIGZpZWxkc1xuICAgICAgICAgIGlzSW5kZXhlZCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIF9leHRyYVByb3BzXG4gICAgICApO1xuICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICBPYmplY3Quc2VhbChhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQ2hlY2sgYWxsIGZpZWxkcyBhbmQgZ2VuZXJhdGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgICAgdGhpcy5fdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAvLyBBZGQgdG8gYm90aCBhdHRyaWJ1dGVzIGxpc3QgKGZvciByZWdpc3RyYXRpb24gd2l0aCBtb2RlbClcbiAgICAgIG5ld0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVEYXRhO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCk7XG4gIH1cblxuICAvLyBidWlsZCB1cGRhdGVUcmlnZ2VyIG5hbWUgdG8gYXR0cmlidXRlIG5hbWUgbWFwcGluZ1xuICBfbWFwVXBkYXRlVHJpZ2dlcnNUb0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGxldCB7YWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuXG4gICAgICAvLyB1c2UgYXR0cmlidXRlIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICB0cmlnZ2Vyc1thdHRyaWJ1dGVOYW1lXSA9IFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gdXNlIGFjY2Vzc29yIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2Nlc3NvciA9IFthY2Nlc3Nvcl07XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhY2Nlc3NvcikpIHtcbiAgICAgICAgYWNjZXNzb3IuZm9yRWFjaChhY2Nlc3Nvck5hbWUgPT4ge1xuICAgICAgICAgIGlmICghdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSkge1xuICAgICAgICAgICAgdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB0cmlnZ2VycztcbiAgfVxuXG4gIF92YWxpZGF0ZUF0dHJpYnV0ZURlZmluaXRpb24oYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSB7XG4gICAgYXNzZXJ0KGF0dHJpYnV0ZS5zaXplID49IDEgJiYgYXR0cmlidXRlLnNpemUgPD0gNCxcbiAgICAgIGBBdHRyaWJ1dGUgZGVmaW5pdGlvbiBmb3IgJHthdHRyaWJ1dGVOYW1lfSBpbnZhbGlkIHNpemVgKTtcblxuICAgIC8vIENoZWNrIHRoYXQgZWl0aGVyICdhY2Nlc3Nvcicgb3IgJ3VwZGF0ZScgaXMgYSB2YWxpZCBmdW5jdGlvblxuICAgIGNvbnN0IGhhc1VwZGF0ZXIgPSBhdHRyaWJ1dGUubm9BbGxvYyB8fFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZS51cGRhdGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGUuYWNjZXNzb3IgPT09ICdzdHJpbmcnO1xuICAgIGlmICghaGFzVXBkYXRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgJHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHVwZGF0ZSBvciBhY2Nlc3NvcmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrcyB0aGF0IGFueSBhdHRyaWJ1dGUgYnVmZmVycyBpbiBwcm9wcyBhcmUgdmFsaWRcbiAgLy8gTm90ZTogVGhpcyBpcyBqdXN0IHRvIGhlbHAgYXBwIGNhdGNoIG1pc3Rha2VzXG4gIF9jaGVja0V4dGVybmFsQnVmZmVycyh7XG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYnVmZmVycykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlICYmICFpZ25vcmVVbmtub3duQXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIHByb3AgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gY29uc3QgYnVmZmVyID0gYnVmZmVyc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIC8vIFRPRE8gLSBjaGVjayBidWZmZXIgdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgYnVmZmVycyBmb3IgdGhlIHN1cHBsaWVkIGF0dHJpYnV0ZXNcbiAgLy8gVXBkYXRlIGF0dHJpYnV0ZSBidWZmZXJzIGZyb20gYW55IGF0dHJpYnV0ZXMgaW4gcHJvcHNcbiAgLy8gRGV0YWNoIGFueSBwcmV2aW91c2x5IHNldCBidWZmZXJzLCBtYXJraW5nIGFsbFxuICAvLyBBdHRyaWJ1dGVzIGZvciBhdXRvIGFsbG9jYXRpb25cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJNYXApIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgbnVtSW5zdGFuY2VzfSA9IHRoaXM7XG5cbiAgICAvLyBDb3B5IHRoZSByZWZzIG9mIGFueSBzdXBwbGllZCBidWZmZXJzIGluIHRoZSBwcm9wc1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSBmYWxzZTtcbiAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3BlcnRpZXMgbXVzdCBiZSBvZiB0eXBlIEZsb2F0MzJBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuYXV0byAmJiBidWZmZXIubGVuZ3RoIDw9IG51bUluc3RhbmNlcyAqIGF0dHJpYnV0ZS5zaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcCBhcnJheSBtdXN0IG1hdGNoIGxlbmd0aCBhbmQgc2l6ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSAhPT0gYnVmZmVyKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gYnVmZmVyO1xuICAgICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyogQ2hlY2tzIHRoYXQgdHlwZWQgYXJyYXlzIGZvciBhdHRyaWJ1dGVzIGFyZSBiaWcgZW5vdWdoXG4gICAqIHNldHMgYWxsb2MgZmxhZyBpZiBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbnkgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAqL1xuICBfYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGFzc2VydChudW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCwgJ251bUluc3RhbmNlcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgYWxsb2NhdGlvbnMgb3IgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIpIHtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byByZWFsbG9jYXRlIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheT9cbiAgICAgICAgY29uc3QgbmVlZHNBbGxvYyA9XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplIDwgbnVtSW5zdGFuY2VzO1xuICAgICAgICBpZiAobmVlZHNBbGxvYyAmJiAoYXR0cmlidXRlLnVwZGF0ZSB8fCBhdHRyaWJ1dGUuYWNjZXNzb3IpKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSB0cnVlO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZWRzVXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENhbGxzIHVwZGF0ZSBvbiBhbnkgYnVmZmVycyB0aGF0IG5lZWQgdXBkYXRlXG4gICAqIFRPRE8/IC0gSWYgYXBwIHN1cHBsaWVkIGFsbCBhdHRyaWJ1dGVzLCBubyBuZWVkIHRvIGl0ZXJhdGUgb3ZlciBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcblxuICAgIC8vIEFsbG9jYXRlIGF0IGxlYXN0IG9uZSBlbGVtZW50IHRvIGVuc3VyZSBhIHZhbGlkIGJ1ZmZlclxuICAgIGNvbnN0IGFsbG9jQ291bnQgPSBNYXRoLm1heChudW1JbnN0YW5jZXMsIDEpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHR5cGVkIGFycmF5IGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc0FsbG9jKSB7XG4gICAgICAgIGNvbnN0IEFycmF5VHlwZSA9IGdsQXJyYXlGcm9tVHlwZShhdHRyaWJ1dGUudHlwZSB8fCBHTC5GTE9BVCk7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBBcnJheVR5cGUoYXR0cmlidXRlLnNpemUgKiBhbGxvY0NvdW50KTtcbiAgICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgICAgICBtZXNzYWdlOiBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IGFsbG9jYXRlZCAke2FsbG9jQ291bnR9YCxcbiAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCB1cGRhdGVyIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVCdWZmZXIoe2F0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSwgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IGFsbG9jQ291bnQ7XG4gIH1cblxuICBfdXBkYXRlQnVmZmVyKHthdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUsIG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge3VwZGF0ZSwgYWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIC8vIEN1c3RvbSB1cGRhdGVyIC0gdHlwaWNhbGx5IGZvciBub24taW5zdGFuY2VkIGxheWVyc1xuICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgbGV2ZWw6IExPR19ERVRBSUxfUFJJT1JJVFksXG4gICAgICAgIG1lc3NhZ2U6IGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gdXBkYXRpbmcgJHtudW1JbnN0YW5jZXN9YCxcbiAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlLmNhbGwoY29udGV4dCwgYXR0cmlidXRlLCB7ZGF0YSwgcHJvcHMsIG51bUluc3RhbmNlc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzb3IpIHtcbiAgICAgIC8vIFN0YW5kYXJkIHVwZGF0ZXJcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3Ioe2F0dHJpYnV0ZSwgZGF0YSwgcHJvcHN9KTtcbiAgICAgIHRoaXMuX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgbGV2ZWw6IExPR19ERVRBSUxfUFJJT1JJVFksXG4gICAgICAgIG1lc3NhZ2U6IGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gLFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pIHtcbiAgICBjb25zdCB7YWNjZXNzb3IsIHZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBhY2Nlc3NvckZ1bmMgPSBwcm9wc1thY2Nlc3Nvcl07XG5cbiAgICBhc3NlcnQodHlwZW9mIGFjY2Vzc29yRnVuYyA9PT0gJ2Z1bmN0aW9uJywgYGFjY2Vzc29yIFwiJHthY2Nlc3Nvcn1cIiBpcyBub3QgYSBmdW5jdGlvbmApO1xuXG4gICAgbGV0IHtkZWZhdWx0VmFsdWUgPSBbMCwgMCwgMCwgMF19ID0gYXR0cmlidXRlO1xuICAgIGRlZmF1bHRWYWx1ZSA9IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IFtkZWZhdWx0VmFsdWVdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBsZXQgb2JqZWN0VmFsdWUgPSBhY2Nlc3NvckZ1bmMob2JqZWN0KTtcbiAgICAgIG9iamVjdFZhbHVlID0gQXJyYXkuaXNBcnJheShvYmplY3RWYWx1ZSkgPyBvYmplY3RWYWx1ZSA6IFtvYmplY3RWYWx1ZV07XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCwgZGVmYXVsdC1jYXNlICovXG4gICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgIGNhc2UgNDogdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzNdKSA/IG9iamVjdFZhbHVlWzNdIDogZGVmYXVsdFZhbHVlWzNdO1xuICAgICAgY2FzZSAzOiB2YWx1ZVtpICsgMl0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMl0pID8gb2JqZWN0VmFsdWVbMl0gOiBkZWZhdWx0VmFsdWVbMl07XG4gICAgICBjYXNlIDI6IHZhbHVlW2kgKyAxXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsxXSkgPyBvYmplY3RWYWx1ZVsxXSA6IGRlZmF1bHRWYWx1ZVsxXTtcbiAgICAgIGNhc2UgMTogdmFsdWVbaSArIDBdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzBdKSA/IG9iamVjdFZhbHVlWzBdIDogZGVmYXVsdFZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCB2YWxpZCA9XG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzFdKSAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMl0pICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGZvciAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = count;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var ERR_NOT_OBJECT = 'count(): argument not an object';
var ERR_NOT_CONTAINER = 'count(): argument not a container';

/**
 * Deduces numer of elements in a JavaScript container.
 * - Auto-deduction for ES6 containers that define a count() method
 * - Auto-deduction for ES6 containers that define a size member
 * - Auto-deduction for Classic Arrays via the built-in length attribute
 * - Also handles objects, although note that this an O(N) operation
 */
function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }

  // Check if ES6 collection "count" function is available
  if (typeof container.count === 'function') {
    return container.count();
  }

  // Check if ES6 collection "size" attribute is set
  if (Number.isFinite(container.size)) {
    return container.size;
  }

  // Check if array length attribute is set
  // Note: checking this last since some ES6 collections (Immutable.js)
  // emit profuse warnings when trying to access `length` attribute
  if (Number.isFinite(container.length)) {
    return container.length;
  }

  // Note that getting the count of an object is O(N)
  if (isPlainObject(container)) {
    var counter = 0;
    for (var key in container) {
      // eslint-disable-line
      counter++;
    }
    return counter;
  }

  throw new Error(ERR_NOT_CONTAINER);
}

/**
 * Checks if argument is a plain object (not a class or array etc)
 * @param {*} value - JavaScript value to be tested
 * @return {Boolean} - true if argument is a plain JavaScript object
 */
function isPlainObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Object;
}

/**
 * Checks if argument is an indexable object (not a primitive value, nor null)
 * @param {*} value - JavaScript value to be tested
 * @return {Boolean} - true if argument is a JavaScript object
 */
function isObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvY291bnQuanMiXSwibmFtZXMiOlsiRVJSX05PVF9PQkpFQ1QiLCJFUlJfTk9UX0NPTlRBSU5FUiIsImNvdW50IiwiY29udGFpbmVyIiwiaXNPYmplY3QiLCJFcnJvciIsIk51bWJlciIsImlzRmluaXRlIiwic2l6ZSIsImxlbmd0aCIsImlzUGxhaW5PYmplY3QiLCJjb3VudGVyIiwia2V5IiwidmFsdWUiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNQSxpQkFBaUIsaUNBQXZCO0FBQ0EsSUFBTUMsb0JBQW9CLG1DQUExQjs7QUFFQTs7Ozs7OztBQU9BLE9BQU8sU0FBU0MsS0FBVCxDQUFlQyxTQUFmLEVBQTBCO0FBQy9CLE1BQUksQ0FBQ0MsU0FBU0QsU0FBVCxDQUFMLEVBQTBCO0FBQ3hCLFVBQU0sSUFBSUUsS0FBSixDQUFVTCxjQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBLE1BQUksT0FBT0csVUFBVUQsS0FBakIsS0FBMkIsVUFBL0IsRUFBMkM7QUFDekMsV0FBT0MsVUFBVUQsS0FBVixFQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJSSxPQUFPQyxRQUFQLENBQWdCSixVQUFVSyxJQUExQixDQUFKLEVBQXFDO0FBQ25DLFdBQU9MLFVBQVVLLElBQWpCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSUYsT0FBT0MsUUFBUCxDQUFnQkosVUFBVU0sTUFBMUIsQ0FBSixFQUF1QztBQUNyQyxXQUFPTixVQUFVTSxNQUFqQjtBQUNEOztBQUVEO0FBQ0EsTUFBSUMsY0FBY1AsU0FBZCxDQUFKLEVBQThCO0FBQzVCLFFBQUlRLFVBQVUsQ0FBZDtBQUNBLFNBQUssSUFBTUMsR0FBWCxJQUFrQlQsU0FBbEIsRUFBNkI7QUFBRTtBQUM3QlE7QUFDRDtBQUNELFdBQU9BLE9BQVA7QUFDRDs7QUFFRCxRQUFNLElBQUlOLEtBQUosQ0FBVUosaUJBQVYsQ0FBTjtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNTLGFBQVQsQ0FBdUJHLEtBQXZCLEVBQThCO0FBQzVCLFNBQU9BLFVBQVUsSUFBVixJQUFrQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQW5DLElBQStDQSxNQUFNQyxXQUFOLEtBQXNCQyxNQUE1RTtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNYLFFBQVQsQ0FBa0JTLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU9BLFVBQVUsSUFBVixJQUFrQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQTFDO0FBQ0QiLCJmaWxlIjoiY291bnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgRVJSX05PVF9PQkpFQ1QgPSAnY291bnQoKTogYXJndW1lbnQgbm90IGFuIG9iamVjdCc7XG5jb25zdCBFUlJfTk9UX0NPTlRBSU5FUiA9ICdjb3VudCgpOiBhcmd1bWVudCBub3QgYSBjb250YWluZXInO1xuXG4vKipcbiAqIERlZHVjZXMgbnVtZXIgb2YgZWxlbWVudHMgaW4gYSBKYXZhU2NyaXB0IGNvbnRhaW5lci5cbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgY291bnQoKSBtZXRob2RcbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICogLSBBbHNvIGhhbmRsZXMgb2JqZWN0cywgYWx0aG91Z2ggbm90ZSB0aGF0IHRoaXMgYW4gTyhOKSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50KGNvbnRhaW5lcikge1xuICBpZiAoIWlzT2JqZWN0KGNvbnRhaW5lcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9PQkpFQ1QpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgRVM2IGNvbGxlY3Rpb24gXCJjb3VudFwiIGZ1bmN0aW9uIGlzIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIGNvbnRhaW5lci5jb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250YWluZXIuY291bnQoKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIEVTNiBjb2xsZWN0aW9uIFwic2l6ZVwiIGF0dHJpYnV0ZSBpcyBzZXRcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShjb250YWluZXIuc2l6ZSkpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLnNpemU7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhcnJheSBsZW5ndGggYXR0cmlidXRlIGlzIHNldFxuICAvLyBOb3RlOiBjaGVja2luZyB0aGlzIGxhc3Qgc2luY2Ugc29tZSBFUzYgY29sbGVjdGlvbnMgKEltbXV0YWJsZS5qcylcbiAgLy8gZW1pdCBwcm9mdXNlIHdhcm5pbmdzIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBgbGVuZ3RoYCBhdHRyaWJ1dGVcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShjb250YWluZXIubGVuZ3RoKSkge1xuICAgIHJldHVybiBjb250YWluZXIubGVuZ3RoO1xuICB9XG5cbiAgLy8gTm90ZSB0aGF0IGdldHRpbmcgdGhlIGNvdW50IG9mIGFuIG9iamVjdCBpcyBPKE4pXG4gIGlmIChpc1BsYWluT2JqZWN0KGNvbnRhaW5lcikpIHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGFpbmVyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9DT05UQUlORVIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCAobm90IGEgY2xhc3Mgb3IgYXJyYXkgZXRjKVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEphdmFTY3JpcHQgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgYXJndW1lbnQgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFyZ3VtZW50IGlzIGFuIGluZGV4YWJsZSBvYmplY3QgKG5vdCBhIHByaW1pdGl2ZSB2YWx1ZSwgbm9yIG51bGwpXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gSmF2YVNjcmlwdCB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBhcmd1bWVudCBpcyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4iXX0=

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




var OrthographicViewport = function (_Viewport) {
  _inherits(OrthographicViewport, _Viewport);

  function OrthographicViewport(_ref) {
    var width = _ref.width,
        height = _ref.height,
        _ref$eye = _ref.eye,
        eye = _ref$eye === undefined ? [0, 0, 1] : _ref$eye,
        _ref$lookAt = _ref.lookAt,
        lookAt = _ref$lookAt === undefined ? [0, 0, 0] : _ref$lookAt,
        _ref$up = _ref.up,
        up = _ref$up === undefined ? [0, 1, 0] : _ref$up,
        _ref$near = _ref.near,
        near = _ref$near === undefined ? 1 : _ref$near,
        _ref$far = _ref.far,
        far = _ref$far === undefined ? 100 : _ref$far,
        left = _ref.left,
        top = _ref.top,
        _ref$right = _ref.right,
        right = _ref$right === undefined ? null : _ref$right,
        _ref$bottom = _ref.bottom,
        bottom = _ref$bottom === undefined ? null : _ref$bottom;

    _classCallCheck(this, OrthographicViewport);

    right = Number.isFinite(right) ? right : left + width;
    bottom = Number.isFinite(bottom) ? bottom : top + height;
    return _possibleConstructorReturn(this, (OrthographicViewport.__proto__ || Object.getPrototypeOf(OrthographicViewport)).call(this, {
      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].lookAt([], eye, lookAt, up),
      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].ortho([], left, right, bottom, top, near, far),
      width: width,
      height: height
    }));
  }

  return OrthographicViewport;
}(__WEBPACK_IMPORTED_MODULE_0__viewport__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (OrthographicViewport);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL29ydGhvZ3JhcGhpYy12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJWaWV3cG9ydCIsIm1hdDQiLCJPcnRob2dyYXBoaWNWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiZXllIiwibG9va0F0IiwidXAiLCJuZWFyIiwiZmFyIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsIm9ydGhvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsU0FBUUMsSUFBUixRQUFtQixXQUFuQjs7SUFFcUJDLG9COzs7QUFDbkIsc0NBZ0JHO0FBQUEsUUFkREMsS0FjQyxRQWREQSxLQWNDO0FBQUEsUUFiREMsTUFhQyxRQWJEQSxNQWFDO0FBQUEsd0JBWERDLEdBV0M7QUFBQSxRQVhEQSxHQVdDLDRCQVhLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBV0w7QUFBQSwyQkFWREMsTUFVQztBQUFBLFFBVkRBLE1BVUMsK0JBVlEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FVUjtBQUFBLHVCQVREQyxFQVNDO0FBQUEsUUFUREEsRUFTQywyQkFUSSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQVNKO0FBQUEseUJBUERDLElBT0M7QUFBQSxRQVBEQSxJQU9DLDZCQVBNLENBT047QUFBQSx3QkFOREMsR0FNQztBQUFBLFFBTkRBLEdBTUMsNEJBTkssR0FNTDtBQUFBLFFBTERDLElBS0MsUUFMREEsSUFLQztBQUFBLFFBSkRDLEdBSUMsUUFKREEsR0FJQztBQUFBLDBCQUZEQyxLQUVDO0FBQUEsUUFGREEsS0FFQyw4QkFGTyxJQUVQO0FBQUEsMkJBRERDLE1BQ0M7QUFBQSxRQUREQSxNQUNDLCtCQURRLElBQ1I7O0FBQUE7O0FBQ0RELFlBQVFFLE9BQU9DLFFBQVAsQ0FBZ0JILEtBQWhCLElBQXlCQSxLQUF6QixHQUFpQ0YsT0FBT1AsS0FBaEQ7QUFDQVUsYUFBU0MsT0FBT0MsUUFBUCxDQUFnQkYsTUFBaEIsSUFBMEJBLE1BQTFCLEdBQW1DRixNQUFNUCxNQUFsRDtBQUZDLHVJQUdLO0FBQ0pZLGtCQUFZZixLQUFLSyxNQUFMLENBQVksRUFBWixFQUFnQkQsR0FBaEIsRUFBcUJDLE1BQXJCLEVBQTZCQyxFQUE3QixDQURSO0FBRUpVLHdCQUFrQmhCLEtBQUtpQixLQUFMLENBQVcsRUFBWCxFQUFlUixJQUFmLEVBQXFCRSxLQUFyQixFQUE0QkMsTUFBNUIsRUFBb0NGLEdBQXBDLEVBQXlDSCxJQUF6QyxFQUErQ0MsR0FBL0MsQ0FGZDtBQUdKTixrQkFISTtBQUlKQztBQUpJLEtBSEw7QUFTRjs7O0VBMUIrQ0osUTs7ZUFBN0JFLG9CIiwiZmlsZSI6Im9ydGhvZ3JhcGhpYy12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDR9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ3JhcGhpY1ZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gdmlld3BvcnQgYXJndW1lbnRzXG4gICAgd2lkdGgsIC8vIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICAvLyB2aWV3IG1hdHJpeCBhcmd1bWVudHNcbiAgICBleWUgPSBbMCwgMCwgMV0sIC8vIERlZmluZXMgZXllIHBvc2l0aW9uLCBkZWZhdWx0IHVuaXQgZGlzdGFuY2UgYWxvbmcgeiBheGlzXG4gICAgbG9va0F0ID0gWzAsIDAsIDBdLCAvLyBXaGljaCBwb2ludCBpcyBjYW1lcmEgbG9va2luZyBhdCwgZGVmYXVsdCBvcmlnaW5cbiAgICB1cCA9IFswLCAxLCAwXSwgLy8gRGVmaW5lcyB1cCBkaXJlY3Rpb24sIGRlZmF1bHQgcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gcHJvamVjdGlvbiBtYXRyaXggYXJndW1lbnRzXG4gICAgbmVhciA9IDEsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBmYXIgPSAxMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuICAgIGxlZnQsIC8vIExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICB0b3AsIC8vIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZFxuICAgIHJpZ2h0ID0gbnVsbCwgLy8gUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICBib3R0b20gPSBudWxsIC8vIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICB9KSB7XG4gICAgcmlnaHQgPSBOdW1iZXIuaXNGaW5pdGUocmlnaHQpID8gcmlnaHQgOiBsZWZ0ICsgd2lkdGg7XG4gICAgYm90dG9tID0gTnVtYmVyLmlzRmluaXRlKGJvdHRvbSkgPyBib3R0b20gOiB0b3AgKyBoZWlnaHQ7XG4gICAgc3VwZXIoe1xuICAgICAgdmlld01hdHJpeDogbWF0NC5sb29rQXQoW10sIGV5ZSwgbG9va0F0LCB1cCksXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBtYXQ0Lm9ydGhvKFtdLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




var DEGREES_TO_RADIANS = Math.PI / 180;

var PerspectiveViewport = function (_Viewport) {
  _inherits(PerspectiveViewport, _Viewport);

  function PerspectiveViewport(_ref) {
    var width = _ref.width,
        height = _ref.height,
        eye = _ref.eye,
        _ref$lookAt = _ref.lookAt,
        lookAt = _ref$lookAt === undefined ? [0, 0, 0] : _ref$lookAt,
        _ref$up = _ref.up,
        up = _ref$up === undefined ? [0, 1, 0] : _ref$up,
        _ref$fovy = _ref.fovy,
        fovy = _ref$fovy === undefined ? 75 : _ref$fovy,
        _ref$near = _ref.near,
        near = _ref$near === undefined ? 1 : _ref$near,
        _ref$far = _ref.far,
        far = _ref$far === undefined ? 100 : _ref$far,
        _ref$aspect = _ref.aspect,
        aspect = _ref$aspect === undefined ? null : _ref$aspect;

    _classCallCheck(this, PerspectiveViewport);

    var fovyRadians = fovy * DEGREES_TO_RADIANS;
    aspect = Number.isFinite(aspect) ? aspect : width / height;
    return _possibleConstructorReturn(this, (PerspectiveViewport.__proto__ || Object.getPrototypeOf(PerspectiveViewport)).call(this, {
      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].lookAt([], eye, lookAt, up),
      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].perspective([], fovyRadians, aspect, near, far),
      width: width,
      height: height
    }));
  }

  return PerspectiveViewport;
}(__WEBPACK_IMPORTED_MODULE_0__viewport__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (PerspectiveViewport);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3BlcnNwZWN0aXZlLXZpZXdwb3J0LmpzIl0sIm5hbWVzIjpbIlZpZXdwb3J0IiwibWF0NCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIk1hdGgiLCJQSSIsIlBlcnNwZWN0aXZlVmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsImV5ZSIsImxvb2tBdCIsInVwIiwiZm92eSIsIm5lYXIiLCJmYXIiLCJhc3BlY3QiLCJmb3Z5UmFkaWFucyIsIk51bWJlciIsImlzRmluaXRlIiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJwZXJzcGVjdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsUUFBUCxNQUFxQixZQUFyQjtBQUNBLFNBQVFDLElBQVIsUUFBbUIsV0FBbkI7O0FBRUEsSUFBTUMscUJBQXFCQyxLQUFLQyxFQUFMLEdBQVUsR0FBckM7O0lBRXFCQyxtQjs7O0FBQ25CLHFDQWNHO0FBQUEsUUFaREMsS0FZQyxRQVpEQSxLQVlDO0FBQUEsUUFYREMsTUFXQyxRQVhEQSxNQVdDO0FBQUEsUUFUREMsR0FTQyxRQVREQSxHQVNDO0FBQUEsMkJBUkRDLE1BUUM7QUFBQSxRQVJEQSxNQVFDLCtCQVJRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBUVI7QUFBQSx1QkFQREMsRUFPQztBQUFBLFFBUERBLEVBT0MsMkJBUEksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FPSjtBQUFBLHlCQUxEQyxJQUtDO0FBQUEsUUFMREEsSUFLQyw2QkFMTSxFQUtOO0FBQUEseUJBSkRDLElBSUM7QUFBQSxRQUpEQSxJQUlDLDZCQUpNLENBSU47QUFBQSx3QkFIREMsR0FHQztBQUFBLFFBSERBLEdBR0MsNEJBSEssR0FHTDtBQUFBLDJCQUREQyxNQUNDO0FBQUEsUUFEREEsTUFDQywrQkFEUSxJQUNSOztBQUFBOztBQUNELFFBQU1DLGNBQWNKLE9BQU9ULGtCQUEzQjtBQUNBWSxhQUFTRSxPQUFPQyxRQUFQLENBQWdCSCxNQUFoQixJQUEwQkEsTUFBMUIsR0FBbUNSLFFBQVFDLE1BQXBEO0FBRkMscUlBR0s7QUFDSlcsa0JBQVlqQixLQUFLUSxNQUFMLENBQVksRUFBWixFQUFnQkQsR0FBaEIsRUFBcUJDLE1BQXJCLEVBQTZCQyxFQUE3QixDQURSO0FBRUpTLHdCQUFrQmxCLEtBQUttQixXQUFMLENBQWlCLEVBQWpCLEVBQXFCTCxXQUFyQixFQUFrQ0QsTUFBbEMsRUFBMENGLElBQTFDLEVBQWdEQyxHQUFoRCxDQUZkO0FBR0pQLGtCQUhJO0FBSUpDO0FBSkksS0FITDtBQVNGOzs7RUF4QjhDUCxROztlQUE1QkssbUIiLCJmaWxlIjoicGVyc3BlY3RpdmUtdmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuaW1wb3J0IHttYXQ0fSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzcGVjdGl2ZVZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gdmlld3BvcnQgYXJndW1lbnRzXG4gICAgd2lkdGgsIC8vIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICAvLyB2aWV3IG1hdHJpeCBhcmd1bWVudHNcbiAgICBleWUsIC8vIERlZmluZXMgZXllIHBvc2l0aW9uXG4gICAgbG9va0F0ID0gWzAsIDAsIDBdLCAvLyBXaGljaCBwb2ludCBpcyBjYW1lcmEgbG9va2luZyBhdCwgZGVmYXVsdCBvcmlnaW5cbiAgICB1cCA9IFswLCAxLCAwXSwgLy8gRGVmaW5lcyB1cCBkaXJlY3Rpb24sIGRlZmF1bHQgcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gcHJvamVjdGlvbiBtYXRyaXggYXJndW1lbnRzXG4gICAgZm92eSA9IDc1LCAvLyBGaWVsZCBvZiB2aWV3IGNvdmVyZWQgYnkgY2FtZXJhXG4gICAgbmVhciA9IDEsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBmYXIgPSAxMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZFxuICAgIGFzcGVjdCA9IG51bGwgLy8gQXNwZWN0IHJhdGlvIChzZXQgdG8gdmlld3BvcnQgd2lkaHQvaGVpZ2h0KVxuICB9KSB7XG4gICAgY29uc3QgZm92eVJhZGlhbnMgPSBmb3Z5ICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIGFzcGVjdCA9IE51bWJlci5pc0Zpbml0ZShhc3BlY3QpID8gYXNwZWN0IDogd2lkdGggLyBoZWlnaHQ7XG4gICAgc3VwZXIoe1xuICAgICAgdmlld01hdHJpeDogbWF0NC5sb29rQXQoW10sIGV5ZSwgbG9va0F0LCB1cCksXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBtYXQ0LnBlcnNwZWN0aXZlKFtdLCBmb3Z5UmFkaWFucywgYXNwZWN0LCBuZWFyLCBmYXIpLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9KTtcbiAgfVxufVxuIl19

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getFov */
/* unused harmony export getClippingPlanes */
/* unused harmony export makeProjectionMatrixFromMercatorParams */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties




// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = makeUncenteredViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales
    });

    // Make a centered version of the matrix for projection modes without an offset
    var center = projectFlat([longitude, latitude], scale);

    var viewMatrix = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].translate(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__["b" /* createMat4 */])(), viewMatrixUncentered, [-center[0], -center[1], 0]);

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Save calculated values
    _this.scale = scale;
    _this.center = center;
    _this.viewMatrixUncentered = viewMatrixUncentered;
    _this._distanceScales = distanceScales;

    // Bind methods
    _this.getDistanceScales = _this.getDistanceScales.bind(_this);
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }
  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var c = this.project(lngLat, { topLeft: false });
      var coordCenter = this.project([this.longitude, this.latitude], { topLeft: false });
      var coordAtPoint = pos;
      var translate = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["vec2"].sub([], coordAtPoint, c);
      var newPos = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["vec2"].sub([], coordCenter, translate);
      var newLngLat = this.unproject(newPos, { topLeft: false });

      return newLngLat;
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(__WEBPACK_IMPORTED_MODULE_0__viewport__["a" /* default */]);

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */


/* harmony default export */ __webpack_exports__["a"] = (WebMercatorViewport);
function projectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      lng = _ref4[0],
      lat = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref5, scale) {
  var _ref6 = _slicedToArray(_ref5, 2),
      x = _ref6[0],
      y = _ref6[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref7) {
  var latitude = _ref7.latitude,
      longitude = _ref7.longitude,
      scale = _ref7.scale;

  __WEBPACK_IMPORTED_MODULE_2_assert___default()(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale), ERR_ARGUMENT);
  // Approximately 111km per degree at equator
  var METERS_PER_DEGREE = 111000;

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["vec2"].distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["vec2"].distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
function makeProjectionMatrixFromMercatorParams(_ref10) {
  var width = _ref10.width,
      height = _ref10.height,
      pitch = _ref10.pitch,
      altitude = _ref10.altitude,
      _ref10$farZMultiplier = _ref10.farZMultiplier,
      farZMultiplier = _ref10$farZMultiplier === undefined ? 10 : _ref10$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].perspective(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__["b" /* createMat4 */])(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

function makeUncenteredViewMatrixFromMercatorParams(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      center = _ref11.center;

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__["b" /* createMat4 */])();

  // Move camera to altitude
  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["mat4"].rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);

  return vm;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJWaWV3cG9ydCIsImNyZWF0ZU1hdDQiLCJtYXQ0IiwidmVjMiIsImFzc2VydCIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJXT1JMRF9TQ0FMRSIsIkRFRkFVTFRfTUFQX1NUQVRFIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJFUlJfQVJHVU1FTlQiLCJXZWJNZXJjYXRvclZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJmYXJaTXVsdGlwbGllciIsInVuZGVmaW5lZCIsInNjYWxlIiwicG93IiwibWF4IiwiZGlzdGFuY2VTY2FsZXMiLCJjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyIsInByb2plY3Rpb25NYXRyaXgiLCJtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwibWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwiY2VudGVyIiwicHJvamVjdEZsYXQiLCJ2aWV3TWF0cml4IiwidHJhbnNsYXRlIiwiX2Rpc3RhbmNlU2NhbGVzIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJiaW5kIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsIk9iamVjdCIsImZyZWV6ZSIsImxuZ0xhdCIsInh5IiwidW5wcm9qZWN0RmxhdCIsInBvcyIsImMiLCJwcm9qZWN0IiwidG9wTGVmdCIsImNvb3JkQ2VudGVyIiwiY29vcmRBdFBvaW50Iiwic3ViIiwibmV3UG9zIiwibmV3TG5nTGF0IiwidW5wcm9qZWN0IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwaXhlbHNQZXJNZXRlciIsImRlZ3JlZXNQZXJQaXhlbCIsImRlbHRhTG5nIiwiZGVsdGFMYXQiLCJsZW5ndGgiLCJkZWx0YUxuZ0xhdFoiLCJkZWx0YVoiLCJwaXhlbHNQZXJEZWdyZWUiLCJtZXRlcnNQZXJQaXhlbCIsImRlbHRhWCIsImRlbHRhWSIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIiwibGFtYmRhMiIsInBoaTIiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwiaXNOYU4iLCJNRVRFUlNfUEVSX0RFR1JFRSIsImxhdENvc2luZSIsImNvcyIsIm1ldGVyc1BlckRlZ3JlZSIsInBpeGVsc1BlckRlZ3JlZVgiLCJkaXN0YW5jZSIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsImdldEZvdiIsImdldENsaXBwaW5nUGxhbmVzIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwibmVhcloiLCJmb3YiLCJwZXJzcGVjdGl2ZSIsInZtIiwicm90YXRlWCIsInJvdGF0ZVoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBT0EsUUFBUCxJQUFrQkMsVUFBbEIsUUFBbUMsWUFBbkM7QUFDQSxTQUFRQyxJQUFSLEVBQWNDLElBQWQsUUFBeUIsV0FBekI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBO0FBQ0EsSUFBTUMsS0FBS0MsS0FBS0QsRUFBaEI7QUFDQSxJQUFNRSxPQUFPRixLQUFLLENBQWxCO0FBQ0EsSUFBTUcscUJBQXFCSCxLQUFLLEdBQWhD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LGdCQUFQO0FBQ0Q7O0FBRUQsU0FBU0csMENBQVQsU0FVRztBQUFBLE1BVERaLEtBU0MsVUFUREEsS0FTQztBQUFBLE1BUkRDLE1BUUMsVUFSREEsTUFRQztBQUFBLE1BUERSLFNBT0MsVUFQREEsU0FPQztBQUFBLE1BTkRELFFBTUMsVUFOREEsUUFNQztBQUFBLE1BTERFLElBS0MsVUFMREEsSUFLQztBQUFBLE1BSkRDLEtBSUMsVUFKREEsS0FJQztBQUFBLE1BSERDLE9BR0MsVUFIREEsT0FHQztBQUFBLE1BRkRDLFFBRUMsVUFGREEsUUFFQztBQUFBLE1BRERnQixNQUNDLFVBRERBLE1BQ0M7O0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTJFLEtBQUs1RyxZQUFYOztBQUVBO0FBQ0FDLE9BQUttQyxTQUFMLENBQWV3RSxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQzNGLFFBQVIsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBaEIsT0FBS3VCLEtBQUwsQ0FBV29GLEVBQVgsRUFBZUEsRUFBZixFQUFtQixDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsRUFBUSxJQUFJdkYsTUFBWixDQUFuQjs7QUFFQTtBQUNBcEIsT0FBSzRHLE9BQUwsQ0FBYUQsRUFBYixFQUFpQkEsRUFBakIsRUFBcUI3RixRQUFRUixrQkFBN0I7QUFDQU4sT0FBSzZHLE9BQUwsQ0FBYUYsRUFBYixFQUFpQkEsRUFBakIsRUFBcUIsQ0FBQzVGLE9BQUQsR0FBV1Qsa0JBQWhDOztBQUVBLFNBQU9xRyxFQUFQO0FBQ0QiLCJmaWxlIjoid2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlXG4vLyBtYXAgdmlldyBwcm9wZXJ0aWVzXG5pbXBvcnQgVmlld3BvcnQsIHtjcmVhdGVNYXQ0fSBmcm9tICcuL3ZpZXdwb3J0JztcbmltcG9ydCB7bWF0NCwgdmVjMn0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gQ09OU1RBTlRTXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuY29uc3QgRVJSX0FSR1VNRU5UID0gJ0lsbGVnYWwgYXJndW1lbnQgdG8gV2ViTWVyY2F0b3JWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG5cbiAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBmYXJaTXVsdGlwbGllciA9IDEwXG4gIH0gPSB7fSkge1xuICAgIC8vIFZpZXdwb3J0IC0gc3VwcG9ydCB1bmRlZmluZWQgYXJndW1lbnRzXG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBERUZBVUxUX01BUF9TVEFURS53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB6b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgbGF0aXR1ZGUgPSBsYXRpdHVkZSAhPT0gdW5kZWZpbmVkID8gbGF0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sYXRpdHVkZTtcbiAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICBiZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgcGl0Y2ggPSBwaXRjaCAhPT0gdW5kZWZpbmVkID8gcGl0Y2ggOiBERUZBVUxUX01BUF9TVEFURS5waXRjaDtcbiAgICBhbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KTtcblxuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcblxuICAgIC8vIFRoZSB1bmNlbnRlcmVkIG1hdHJpeCBhbGxvd3MgdXMgdHdvIG1vdmUgdGhlIGNlbnRlciBhZGRpdGlvbiB0byB0aGVcbiAgICAvLyBzaGFkZXIgKGNoZWFwKSB3aGljaCBnaXZlcyBhIGNvb3JkaW5hdGUgc3lzdGVtIHRoYXQgaGFzIGl0cyBjZW50ZXIgaW5cbiAgICAvLyB0aGUgbGF5ZXIncyBjZW50ZXIgcG9zaXRpb24uIFRoaXMgbWFrZXMgcm90YXRpb25zIGFuZCBvdGhlciBtb2RlbE1hdHJ4XG4gICAgLy8gdHJhbnNmb3JtcyBtdWNoIG1vcmUgdXNlZnVsLlxuICAgIGNvbnN0IHZpZXdNYXRyaXhVbmNlbnRlcmVkID0gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBkaXN0YW5jZVNjYWxlc1xuICAgIH0pO1xuXG4gICAgLy8gTWFrZSBhIGNlbnRlcmVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeCBmb3IgcHJvamVjdGlvbiBtb2RlcyB3aXRob3V0IGFuIG9mZnNldFxuICAgIGNvbnN0IGNlbnRlciA9IHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgc2NhbGUpO1xuXG4gICAgY29uc3Qgdmlld01hdHJpeCA9IG1hdDQudHJhbnNsYXRlKFxuICAgICAgY3JlYXRlTWF0NCgpLCB2aWV3TWF0cml4VW5jZW50ZXJlZCwgWy1jZW50ZXJbMF0sIC1jZW50ZXJbMV0sIDBdKTtcblxuICAgIHN1cGVyKHt3aWR0aCwgaGVpZ2h0LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSk7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICAvLyBTYXZlIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIHRoaXMudmlld01hdHJpeFVuY2VudGVyZWQgPSB2aWV3TWF0cml4VW5jZW50ZXJlZDtcbiAgICB0aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgLy8gQmluZCBtZXRob2RzXG4gICAgdGhpcy5nZXREaXN0YW5jZVNjYWxlcyA9IHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMgPSB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1ldGVyc1RvTG5nTGF0ID0gdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdC5iaW5kKHRoaXMpO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBfdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgfVxuXG4gIGdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3QgYyA9IHRoaXMucHJvamVjdChsbmdMYXQsIHt0b3BMZWZ0OiBmYWxzZX0pO1xuICAgIGNvbnN0IGNvb3JkQ2VudGVyID0gdGhpcy5wcm9qZWN0KFt0aGlzLmxvbmdpdHVkZSwgdGhpcy5sYXRpdHVkZV0sIHt0b3BMZWZ0OiBmYWxzZX0pO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHBvcztcbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyLnN1YihbXSwgY29vcmRBdFBvaW50LCBjKTtcbiAgICBjb25zdCBuZXdQb3MgPSB2ZWMyLnN1YihbXSwgY29vcmRDZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgY29uc3QgbmV3TG5nTGF0ID0gdGhpcy51bnByb2plY3QobmV3UG9zLCB7dG9wTGVmdDogZmFsc2V9KTtcblxuICAgIHJldHVybiBuZXdMbmdMYXQ7XG4gIH1cblxuICAvKlxuICBnZXRMbmdMYXRBdFZpZXdwb3J0UG9zaXRpb24obG5nbGF0LCB4eSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHh5KTtcbiAgICBjb25zdCBjb29yZENlbnRlciA9IHRoaXMucG9pbnRDb29yZGluYXRlKHRoaXMuY2VudGVyUG9pbnQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgfVxuICAqL1xuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW2RlbHRhTG5nLCBkZWx0YUxhdF0gOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGxuZ2xhdCBvZmZzZXQgdG8gYSBtZXRlciBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBkZWx0YUxuZ0xhdFogLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqL1xuICBsbmdMYXREZWx0YVRvTWV0ZXJzKGRlbHRhTG5nTGF0Wikge1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gZGVsdGFMbmdMYXRaO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGVsdGFMbmcpICYmIE51bWJlci5pc0Zpbml0ZShkZWx0YUxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhWiksXG4gICAgICBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJEZWdyZWUsIG1ldGVyc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhWCA9IGRlbHRhTG5nICogcGl4ZWxzUGVyRGVncmVlWzBdICogbWV0ZXJzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFZID0gZGVsdGFMYXQgKiBwaXhlbHNQZXJEZWdyZWVbMV0gKiBtZXRlcnNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4gZGVsdGFMbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFtkZWx0YVgsIGRlbHRhWV0gOiBbZGVsdGFYLCBkZWx0YVksIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWV0ZXIgZGVsdGEgdG8gYSBiYXNlIGxuZ2xhdCBjb29yZGluYXRlLCByZXR1cm5pbmcgYSBuZXcgbG5nbGF0IGFycmF5XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgbG5nTGF0WiAtIGJhc2UgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgY29uc3QgW2xuZywgbGF0LCBaID0gMF0gPSBsbmdMYXRaO1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID9cbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXRdIDpcbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXQsIFogKyBkZWx0YVpdO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIF9nZXRQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9ICh4IC8gc2NhbGUpICogKDIgKiBQSSkgLSBQSTtcbiAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFBJIC0gKHkgLyBzY2FsZSkgKiAoMiAqIFBJKSkpIC0gUElfNCk7XG4gIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pIHtcbiAgYXNzZXJ0KCFpc05hTihsYXRpdHVkZSkgJiYgIWlzTmFOKGxvbmdpdHVkZSkgJiYgIWlzTmFOKHNjYWxlKSwgRVJSX0FSR1VNRU5UKTtcbiAgLy8gQXBwcm94aW1hdGVseSAxMTFrbSBwZXIgZGVncmVlIGF0IGVxdWF0b3JcbiAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG5cbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBNYXRoLlBJIC8gMTgwKTtcblxuICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgKyAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpXG4gICk7XG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbGF0aXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVZID0gdmVjMi5kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0sIHNjYWxlKSxcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0sIHNjYWxlKVxuICApO1xuXG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWSA9IHBpeGVsc1BlckRlZ3JlZVkgLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWiA9IChwaXhlbHNQZXJNZXRlclggKyBwaXhlbHNQZXJNZXRlclkpIC8gMjtcbiAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbcGl4ZWxzUGVyTWV0ZXJYLCBwaXhlbHNQZXJNZXRlclksIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIHBpeGVsc1Blck1ldGVyWl07XG4gIGNvbnN0IGRlZ3JlZXNQZXJQaXhlbCA9IFsxIC8gcGl4ZWxzUGVyRGVncmVlWCwgMSAvIHBpeGVsc1BlckRlZ3JlZVksIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIC8vIE1haW4gcmVzdWx0cywgdXNlZCBmb3IgY29udmVydGluZyBtZXRlcnMgdG8gbGF0bG5nIGRlbHRhcyBhbmQgc2NhbGluZyBvZmZzZXRzXG4gIHJldHVybiB7XG4gICAgcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWwsXG4gICAgcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbFxuICB9O1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KSB7XG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAvLyBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIGFsdGl0dWRlKTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9XG4gICAgTWF0aC5zaW4oaGFsZkZvdikgKiBhbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gaGFsZkZvdik7XG5cbiAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICBjb25zdCBmYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGFsdGl0dWRlO1xuXG4gIHJldHVybiB7ZmFyWiwgbmVhclo6IDAuMX07XG59XG5cbi8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSAoVklFVykgU1BBQ0UgVE8gQ0xJUFNQQUNFXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICBjZW50ZXJcbn0pIHtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0LnNjYWxlKHZtLCB2bSwgWzEsIC0xLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgcmV0dXJuIHZtO1xufVxuIl19

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = autobind;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var PREDEFINED = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];

/**
 * Binds the "this" argument of all functions on a class instance to the instance
 * @param {Object} obj - class instance (typically a react component)
 */
function autobind(obj) {
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!PREDEFINED.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9hdXRvYmluZC5qcyJdLCJuYW1lcyI6WyJQUkVERUZJTkVEIiwiYXV0b2JpbmQiLCJvYmoiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsImZpbmQiLCJuYW1lIiwiYmluZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTUEsYUFBYSxDQUNqQixhQURpQixFQUNGLFFBREUsRUFDUSxvQkFEUixFQUM4QixtQkFEOUIsRUFFakIsMkJBRmlCLEVBRVksdUJBRlosRUFFcUMscUJBRnJDLEVBR2pCLG9CQUhpQixFQUdLLHNCQUhMLENBQW5COztBQU1BOzs7O0FBSUEsZUFBZSxTQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNwQyxNQUFNQyxRQUFRQyxPQUFPQyxjQUFQLENBQXNCSCxHQUF0QixDQUFkO0FBQ0EsTUFBTUksWUFBWUYsT0FBT0csbUJBQVAsQ0FBMkJKLEtBQTNCLENBQWxCO0FBRm9DO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsVUFHekJLLEdBSHlCOztBQUlsQyxVQUFJLE9BQU9OLElBQUlNLEdBQUosQ0FBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQyxZQUFJLENBQUNSLFdBQVdTLElBQVgsQ0FBZ0I7QUFBQSxpQkFBUUQsUUFBUUUsSUFBaEI7QUFBQSxTQUFoQixDQUFMLEVBQTRDO0FBQzFDUixjQUFJTSxHQUFKLElBQVdOLElBQUlNLEdBQUosRUFBU0csSUFBVCxDQUFjVCxHQUFkLENBQVg7QUFDRDtBQUNGO0FBUmlDOztBQUdwQyx5QkFBa0JJLFNBQWxCLDhIQUE2QjtBQUFBO0FBTTVCO0FBVG1DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVckMiLCJmaWxlIjoiYXV0b2JpbmQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuY29uc3QgUFJFREVGSU5FRCA9IFtcbiAgJ2NvbnN0cnVjdG9yJywgJ3JlbmRlcicsICdjb21wb25lbnRXaWxsTW91bnQnLCAnY29tcG9uZW50RGlkTW91bnQnLFxuICAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsICdzaG91bGRDb21wb25lbnRVcGRhdGUnLCAnY29tcG9uZW50V2lsbFVwZGF0ZScsXG4gICdjb21wb25lbnREaWRVcGRhdGUnLCAnY29tcG9uZW50V2lsbFVubW91bnQnXG5dO1xuXG4vKipcbiAqIEJpbmRzIHRoZSBcInRoaXNcIiBhcmd1bWVudCBvZiBhbGwgZnVuY3Rpb25zIG9uIGEgY2xhc3MgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gY2xhc3MgaW5zdGFuY2UgKHR5cGljYWxseSBhIHJlYWN0IGNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQob2JqKSB7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgcHJvcE5hbWVzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCFQUkVERUZJTkVELmZpbmQobmFtZSA9PiBrZXkgPT09IG5hbWUpKSB7XG4gICAgICAgIG9ialtrZXldID0gb2JqW2tleV0uYmluZChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__autobind__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__webgl_renderer__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__experimental__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_viewports__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_events_event_manager__ = __webpack_require__(208);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.












function noop() {}

var propTypes = {
  id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  width: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  height: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  layers: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(__WEBPACK_IMPORTED_MODULE_4__lib__["a" /* Layer */])).isRequired,
  effects: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(__WEBPACK_IMPORTED_MODULE_5__experimental__["a" /* Effect */])),
  gl: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  debug: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  pickingRadius: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  viewport: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.instanceOf(__WEBPACK_IMPORTED_MODULE_7__lib_viewports__["b" /* Viewport */]),
  onWebGLInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onAfterRender: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerHover: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerDragStart: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerDragMove: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerDragEnd: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onLayerDragCancel: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var defaultProps = {
  id: 'deckgl-overlay',
  debug: false,
  pickingRadius: 0,
  gl: null,
  effects: [],
  onWebGLInitialized: noop,
  onLayerClick: noop,
  onLayerHover: noop,
  onAfterRender: noop,
  onLayerDragStart: noop,
  onLayerDragMove: noop,
  onLayerDragEnd: noop,
  onLayerDragCancel: noop
};

var DeckGL = function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    _classCallCheck(this, DeckGL);

    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));

    _this.state = {};
    _this.needsRedraw = true;
    _this.eventManager = null;
    _this.layerManager = null;
    _this.effectManager = null;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__autobind__["a" /* default */])(_this);
    return _this;
  }

  _createClass(DeckGL, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this._updateLayers(nextProps);
    }
  }, {
    key: '_updateLayers',
    value: function _updateLayers(nextProps) {
      var width = nextProps.width,
          height = nextProps.height,
          latitude = nextProps.latitude,
          longitude = nextProps.longitude,
          zoom = nextProps.zoom,
          pitch = nextProps.pitch,
          bearing = nextProps.bearing,
          altitude = nextProps.altitude;
      var viewport = nextProps.viewport;

      // If Viewport is not supplied, create one from mercator props

      viewport = viewport || new __WEBPACK_IMPORTED_MODULE_7__lib_viewports__["a" /* WebMercatorViewport */]({
        width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude
      });

      if (this.layerManager) {
        this.layerManager.setViewport(viewport).updateLayers({ newLayers: nextProps.layers });
      }
    }
  }, {
    key: '_onRendererInitialized',
    value: function _onRendererInitialized(_ref) {
      var gl = _ref.gl,
          canvas = _ref.canvas;

      gl.enable(__WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].BLEND);
      gl.blendFunc(__WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].ONE_MINUS_SRC_ALPHA);

      // Enable polygon offset
      gl.enable(__WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].POLYGON_OFFSET_FILL);

      this.props.onWebGLInitialized(gl);

      // Note: avoid React setState due GL animation loop / setState timing issue
      this.layerManager = new __WEBPACK_IMPORTED_MODULE_4__lib__["c" /* LayerManager */]({ gl: gl });
      this.effectManager = new __WEBPACK_IMPORTED_MODULE_5__experimental__["b" /* EffectManager */]({ gl: gl, layerManager: this.layerManager });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._updateLayers(this.props);

      // Check if a mouse event has been specified and that at least one of the layers is pickable
      var hasEvent = this.props.onLayerClick !== noop || this.props.onLayerHover !== noop || this.props.onLayerDragStart !== noop || this.props.onLayerDragMove !== noop || this.props.onLayerDragEnd !== noop || this.props.onLayerDragCancel !== noop;
      var hasPickableLayer = this.layerManager.layers.map(function (l) {
        return l.props.pickable;
      }).includes(true);
      if (this.layerManager.layers.length && hasEvent && !hasPickableLayer) {
        __WEBPACK_IMPORTED_MODULE_8__lib_utils__["a" /* log */].once(1, 'You have supplied a mouse event handler but none of your layers set the `pickable` flag.');
      }

      // TODO: add handlers on demand at runtime, not all at once on init
      this.eventManager = new __WEBPACK_IMPORTED_MODULE_9__utils_events_event_manager__["a" /* default */](canvas, {
        events: {
          click: this._onClick,
          mousemove: this._onMouseMove,
          dragstart: this._onDragEvent,
          dragmove: this._onDragEvent,
          dragend: this._onDragEvent,
          dragcancel: this._onDragCancel
        }
      });
    }

    // Route events to layers

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      // use offsetX|Y for relative position to the container, drop event if falsy
      if (!event || !event.srcEvent || !Number.isFinite(event.srcEvent.offsetX)) {
        return;
      }
      var _event$srcEvent = event.srcEvent,
          x = _event$srcEvent.offsetX,
          y = _event$srcEvent.offsetY;

      var radius = this.props.pickingRadius;
      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, radius: radius, mode: 'click' });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        // Event.event holds the original MouseEvent object
        this.props.onLayerClick(firstInfo, selectedInfos, event.srcEvent);
      }
    }

    // Route events to layers

  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      // use offsetX|Y for relative position to the container, drop event if falsy
      if (!event || !event.srcEvent || !Number.isFinite(event.srcEvent.offsetX)) {
        return;
      }
      var _event$srcEvent2 = event.srcEvent,
          x = _event$srcEvent2.offsetX,
          y = _event$srcEvent2.offsetY;

      var radius = this.props.pickingRadius;
      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, radius: radius, mode: 'hover' });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        // Event.event holds the original MouseEvent object
        this.props.onLayerHover(firstInfo, selectedInfos, event.srcEvent);
      }
    }
  }, {
    key: '_onDragEvent',
    value: function _onDragEvent(event, explicitType) {
      // use offsetX|Y for relative position to the container, drop event if falsy
      if (!event || !event.srcEvent || !Number.isFinite(event.srcEvent.offsetX)) {
        return;
      }
      var _event$srcEvent3 = event.srcEvent,
          x = _event$srcEvent3.offsetX,
          y = _event$srcEvent3.offsetY;

      var type = typeof explicitType === 'string' ? explicitType : event.srcEvent.type;
      var mode = void 0;
      var layerEventHandler = void 0;
      switch (type) {
        case 'mousedown':
          mode = 'dragstart';
          layerEventHandler = this.props.onLayerDragStart;
          break;
        case 'mousemove':
          mode = 'dragmove';
          layerEventHandler = this.props.onLayerDragMove;
          break;
        case 'dragcancel':
          mode = 'dragcancel';
          layerEventHandler = this.props.onLayerDragCancel;
          break;
        case 'mouseup':
          mode = 'dragend';
          layerEventHandler = this.props.onLayerDragEnd;
          break;
        default:
          mode = null;
          layerEventHandler = null;
      }

      if (mode) {
        var radius = this.props.pickingRadius;
        var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, radius: radius, mode: mode });
        if (selectedInfos.length) {
          var firstInfo = selectedInfos.find(function (info) {
            return info.index >= 0;
          });
          // srcEvent holds the original MouseEvent object
          layerEventHandler(firstInfo, selectedInfos, event.srcEvent);
        }
      }
    }
  }, {
    key: '_onDragCancel',
    value: function _onDragCancel(event) {
      // rewrite event type for dragcancel / dragend disambiguation
      this._onDragEvent(event, 'dragcancel');
    }
  }, {
    key: '_onRenderFrame',
    value: function _onRenderFrame(_ref2) {
      var gl = _ref2.gl;

      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });
      if (!redraw) {
        return;
      }

      // clear depth and color buffers
      gl.clear(__WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_6_luma_gl__["c" /* GL */].DEPTH_BUFFER_BIT);

      this.effectManager.preDraw();
      this.layerManager.drawLayers({ pass: 'primary' });
      this.effectManager.draw();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          gl = _props.gl,
          debug = _props.debug;


      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(__WEBPACK_IMPORTED_MODULE_3__webgl_renderer__["a" /* default */], Object.assign({}, this.props, {
        width: width,
        height: height,
        gl: gl,
        debug: debug,
        viewport: { x: 0, y: 0, width: width, height: height },
        onRendererInitialized: this._onRendererInitialized,
        onNeedRedraw: this._onNeedRedraw,
        onRenderFrame: this._onRenderFrame,
        onMouseMove: this._onMouseMove,
        onClick: this._onClick
      }));
    }
  }]);

  return DeckGL;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (DeckGL);


DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9kZWNrZ2wuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvcFR5cGVzIiwiYXV0b2JpbmQiLCJXZWJHTFJlbmRlcmVyIiwiTGF5ZXJNYW5hZ2VyIiwiTGF5ZXIiLCJFZmZlY3RNYW5hZ2VyIiwiRWZmZWN0IiwiR0wiLCJWaWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJsb2ciLCJFdmVudE1hbmFnZXIiLCJub29wIiwicHJvcFR5cGVzIiwiaWQiLCJzdHJpbmciLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsYXllcnMiLCJhcnJheU9mIiwiaW5zdGFuY2VPZiIsImVmZmVjdHMiLCJnbCIsIm9iamVjdCIsImRlYnVnIiwiYm9vbCIsInBpY2tpbmdSYWRpdXMiLCJ2aWV3cG9ydCIsIm9uV2ViR0xJbml0aWFsaXplZCIsImZ1bmMiLCJvbkFmdGVyUmVuZGVyIiwib25MYXllckNsaWNrIiwib25MYXllckhvdmVyIiwib25MYXllckRyYWdTdGFydCIsIm9uTGF5ZXJEcmFnTW92ZSIsIm9uTGF5ZXJEcmFnRW5kIiwib25MYXllckRyYWdDYW5jZWwiLCJkZWZhdWx0UHJvcHMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwibmVlZHNSZWRyYXciLCJldmVudE1hbmFnZXIiLCJsYXllck1hbmFnZXIiLCJlZmZlY3RNYW5hZ2VyIiwibmV4dFByb3BzIiwiX3VwZGF0ZUxheWVycyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwic2V0Vmlld3BvcnQiLCJ1cGRhdGVMYXllcnMiLCJuZXdMYXllcnMiLCJjYW52YXMiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuYyIsIlNSQ19BTFBIQSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwiZWZmZWN0IiwiYWRkRWZmZWN0IiwiaGFzRXZlbnQiLCJoYXNQaWNrYWJsZUxheWVyIiwibWFwIiwibCIsInBpY2thYmxlIiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJvbmNlIiwiZXZlbnRzIiwiY2xpY2siLCJfb25DbGljayIsIm1vdXNlbW92ZSIsIl9vbk1vdXNlTW92ZSIsImRyYWdzdGFydCIsIl9vbkRyYWdFdmVudCIsImRyYWdtb3ZlIiwiZHJhZ2VuZCIsImRyYWdjYW5jZWwiLCJfb25EcmFnQ2FuY2VsIiwiZXZlbnQiLCJzcmNFdmVudCIsIk51bWJlciIsImlzRmluaXRlIiwib2Zmc2V0WCIsIngiLCJ5Iiwib2Zmc2V0WSIsInJhZGl1cyIsInNlbGVjdGVkSW5mb3MiLCJwaWNrTGF5ZXIiLCJtb2RlIiwiZmlyc3RJbmZvIiwiZmluZCIsImluZm8iLCJpbmRleCIsImV4cGxpY2l0VHlwZSIsInR5cGUiLCJsYXllckV2ZW50SGFuZGxlciIsInJlZHJhdyIsImNsZWFyUmVkcmF3RmxhZ3MiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwicHJlRHJhdyIsImRyYXdMYXllcnMiLCJwYXNzIiwiZHJhdyIsIk9iamVjdCIsImFzc2lnbiIsIm9uUmVuZGVyZXJJbml0aWFsaXplZCIsIl9vblJlbmRlcmVySW5pdGlhbGl6ZWQiLCJvbk5lZWRSZWRyYXciLCJfb25OZWVkUmVkcmF3Iiwib25SZW5kZXJGcmFtZSIsIl9vblJlbmRlckZyYW1lIiwib25Nb3VzZU1vdmUiLCJvbkNsaWNrIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEtBQVAsSUFBZUMsYUFBZixRQUFtQyxPQUFuQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsYUFBUCxNQUEw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Q0F6QixLQURBLFVBQ0FBLEtBREE7QUFBQSxVQUNPRyxNQURQLFVBQ09BLE1BRFA7QUFBQSxVQUNlSyxFQURmLFVBQ2VBLEVBRGY7QUFBQSxVQUNtQkUsS0FEbkIsVUFDbUJBLEtBRG5COzs7QUFHUCxhQUFPM0IsY0FBY0csYUFBZCxFQUE2QmdILE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUsxRSxLQUF2QixFQUE4QjtBQUNoRXpCLG9CQURnRTtBQUVoRUcsc0JBRmdFO0FBR2hFSyxjQUhnRTtBQUloRUUsb0JBSmdFO0FBS2hFRyxrQkFBVSxFQUFDOEQsR0FBRyxDQUFKLEVBQU9DLEdBQUcsQ0FBVixFQUFhNUUsWUFBYixFQUFvQkcsY0FBcEIsRUFMc0Q7QUFNaEVpRywrQkFBdUIsS0FBS0Msc0JBTm9DO0FBT2hFQyxzQkFBYyxLQUFLQyxhQVA2QztBQVFoRUMsdUJBQWUsS0FBS0MsY0FSNEM7QUFTaEVDLHFCQUFhLEtBQUszQyxZQVQ4QztBQVVoRTRDLGlCQUFTLEtBQUs5QztBQVZrRCxPQUE5QixDQUE3QixDQUFQO0FBWUQ7Ozs7RUEzTGlDL0UsTUFBTThILFM7O2VBQXJCcEYsTTs7O0FBOExyQkEsT0FBTzNCLFNBQVAsR0FBbUJBLFNBQW5CO0FBQ0EyQixPQUFPRCxZQUFQLEdBQXNCQSxZQUF0QiIsImZpbGUiOiJkZWNrZ2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFJlYWN0LCB7Y3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL2F1dG9iaW5kJztcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gJy4vd2ViZ2wtcmVuZGVyZXInO1xuaW1wb3J0IHtMYXllck1hbmFnZXIsIExheWVyfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHtFZmZlY3RNYW5hZ2VyLCBFZmZlY3R9IGZyb20gJy4uL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7Vmlld3BvcnQsIFdlYk1lcmNhdG9yVmlld3BvcnR9IGZyb20gJy4uL2xpYi92aWV3cG9ydHMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uL2xpYi91dGlscyc7XG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4uL3V0aWxzL2V2ZW50cy9ldmVudC1tYW5hZ2VyJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXllcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKExheWVyKSkuaXNSZXF1aXJlZCxcbiAgZWZmZWN0czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoRWZmZWN0KSksXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG4gIHBpY2tpbmdSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihWaWV3cG9ydCksXG4gIG9uV2ViR0xJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQWZ0ZXJSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVySG92ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVyRHJhZ1N0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckRyYWdNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckRyYWdFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVyRHJhZ0NhbmNlbDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgaWQ6ICdkZWNrZ2wtb3ZlcmxheScsXG4gIGRlYnVnOiBmYWxzZSxcbiAgcGlja2luZ1JhZGl1czogMCxcbiAgZ2w6IG51bGwsXG4gIGVmZmVjdHM6IFtdLFxuICBvbldlYkdMSW5pdGlhbGl6ZWQ6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbm9vcCxcbiAgb25MYXllckhvdmVyOiBub29wLFxuICBvbkFmdGVyUmVuZGVyOiBub29wLFxuICBvbkxheWVyRHJhZ1N0YXJ0OiBub29wLFxuICBvbkxheWVyRHJhZ01vdmU6IG5vb3AsXG4gIG9uTGF5ZXJEcmFnRW5kOiBub29wLFxuICBvbkxheWVyRHJhZ0NhbmNlbDogbm9vcFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVja0dMIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLmxheWVyTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbnVsbDtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJzKG5leHRQcm9wcyk7XG4gIH1cblxuICBfdXBkYXRlTGF5ZXJzKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZywgYWx0aXR1ZGV9ID0gbmV4dFByb3BzO1xuICAgIGxldCB7dmlld3BvcnR9ID0gbmV4dFByb3BzO1xuXG4gICAgLy8gSWYgVmlld3BvcnQgaXMgbm90IHN1cHBsaWVkLCBjcmVhdGUgb25lIGZyb20gbWVyY2F0b3IgcHJvcHNcbiAgICB2aWV3cG9ydCA9IHZpZXdwb3J0IHx8IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nLCBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlclxuICAgICAgICAuc2V0Vmlld3BvcnQodmlld3BvcnQpXG4gICAgICAgIC51cGRhdGVMYXllcnMoe25ld0xheWVyczogbmV4dFByb3BzLmxheWVyc30pO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbmRlcmVySW5pdGlhbGl6ZWQoe2dsLCBjYW52YXN9KSB7XG4gICAgZ2wuZW5hYmxlKEdMLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoR0wuU1JDX0FMUEhBLCBHTC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIC8vIEVuYWJsZSBwb2x5Z29uIG9mZnNldFxuICAgIGdsLmVuYWJsZShHTC5QT0xZR09OX09GRlNFVF9GSUxMKTtcblxuICAgIHRoaXMucHJvcHMub25XZWJHTEluaXRpYWxpemVkKGdsKTtcblxuICAgIC8vIE5vdGU6IGF2b2lkIFJlYWN0IHNldFN0YXRlIGR1ZSBHTCBhbmltYXRpb24gbG9vcCAvIHNldFN0YXRlIHRpbWluZyBpc3N1ZVxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbmV3IExheWVyTWFuYWdlcih7Z2x9KTtcbiAgICB0aGlzLmVmZmVjdE1hbmFnZXIgPSBuZXcgRWZmZWN0TWFuYWdlcih7Z2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXJ9KTtcblxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMucHJvcHMuZWZmZWN0cykge1xuICAgICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmFkZEVmZmVjdChlZmZlY3QpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVycyh0aGlzLnByb3BzKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbW91c2UgZXZlbnQgaGFzIGJlZW4gc3BlY2lmaWVkIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgbGF5ZXJzIGlzIHBpY2thYmxlXG4gICAgY29uc3QgaGFzRXZlbnQgPVxuICAgICAgdGhpcy5wcm9wcy5vbkxheWVyQ2xpY2sgIT09IG5vb3AgfHxcbiAgICAgIHRoaXMucHJvcHMub25MYXllckhvdmVyICE9PSBub29wIHx8XG4gICAgICB0aGlzLnByb3BzLm9uTGF5ZXJEcmFnU3RhcnQgIT09IG5vb3AgfHxcbiAgICAgIHRoaXMucHJvcHMub25MYXllckRyYWdNb3ZlICE9PSBub29wIHx8XG4gICAgICB0aGlzLnByb3BzLm9uTGF5ZXJEcmFnRW5kICE9PSBub29wIHx8XG4gICAgICB0aGlzLnByb3BzLm9uTGF5ZXJEcmFnQ2FuY2VsICE9PSBub29wO1xuICAgIGNvbnN0IGhhc1BpY2thYmxlTGF5ZXIgPSB0aGlzLmxheWVyTWFuYWdlci5sYXllcnMubWFwKGwgPT4gbC5wcm9wcy5waWNrYWJsZSkuaW5jbHVkZXModHJ1ZSk7XG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyLmxheWVycy5sZW5ndGggJiYgaGFzRXZlbnQgJiYgIWhhc1BpY2thYmxlTGF5ZXIpIHtcbiAgICAgIGxvZy5vbmNlKFxuICAgICAgICAxLFxuICAgICAgICAnWW91IGhhdmUgc3VwcGxpZWQgYSBtb3VzZSBldmVudCBoYW5kbGVyIGJ1dCBub25lIG9mIHlvdXIgbGF5ZXJzIHNldCB0aGUgYHBpY2thYmxlYCBmbGFnLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIGhhbmRsZXJzIG9uIGRlbWFuZCBhdCBydW50aW1lLCBub3QgYWxsIGF0IG9uY2Ugb24gaW5pdFxuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcihjYW52YXMsIHtcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdFdmVudCxcbiAgICAgICAgZHJhZ21vdmU6IHRoaXMuX29uRHJhZ0V2ZW50LFxuICAgICAgICBkcmFnZW5kOiB0aGlzLl9vbkRyYWdFdmVudCxcbiAgICAgICAgZHJhZ2NhbmNlbDogdGhpcy5fb25EcmFnQ2FuY2VsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBSb3V0ZSBldmVudHMgdG8gbGF5ZXJzXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgLy8gdXNlIG9mZnNldFh8WSBmb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIGNvbnRhaW5lciwgZHJvcCBldmVudCBpZiBmYWxzeVxuICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LnNyY0V2ZW50IHx8ICFOdW1iZXIuaXNGaW5pdGUoZXZlbnQuc3JjRXZlbnQub2Zmc2V0WCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge3NyY0V2ZW50OiB7b2Zmc2V0WDogeCwgb2Zmc2V0WTogeX19ID0gZXZlbnQ7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5wcm9wcy5waWNraW5nUmFkaXVzO1xuICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLmxheWVyTWFuYWdlci5waWNrTGF5ZXIoe3gsIHksIHJhZGl1cywgbW9kZTogJ2NsaWNrJ30pO1xuICAgIGlmIChzZWxlY3RlZEluZm9zLmxlbmd0aCkge1xuICAgICAgY29uc3QgZmlyc3RJbmZvID0gc2VsZWN0ZWRJbmZvcy5maW5kKGluZm8gPT4gaW5mby5pbmRleCA+PSAwKTtcbiAgICAgIC8vIEV2ZW50LmV2ZW50IGhvbGRzIHRoZSBvcmlnaW5hbCBNb3VzZUV2ZW50IG9iamVjdFxuICAgICAgdGhpcy5wcm9wcy5vbkxheWVyQ2xpY2soZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBldmVudC5zcmNFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUm91dGUgZXZlbnRzIHRvIGxheWVyc1xuICBfb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAvLyB1c2Ugb2Zmc2V0WHxZIGZvciByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgY29udGFpbmVyLCBkcm9wIGV2ZW50IGlmIGZhbHN5XG4gICAgaWYgKCFldmVudCB8fCAhZXZlbnQuc3JjRXZlbnQgfHwgIU51bWJlci5pc0Zpbml0ZShldmVudC5zcmNFdmVudC5vZmZzZXRYKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7c3JjRXZlbnQ6IHtvZmZzZXRYOiB4LCBvZmZzZXRZOiB5fX0gPSBldmVudDtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnByb3BzLnBpY2tpbmdSYWRpdXM7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmZvcyA9IHRoaXMubGF5ZXJNYW5hZ2VyLnBpY2tMYXllcih7eCwgeSwgcmFkaXVzLCBtb2RlOiAnaG92ZXInfSk7XG4gICAgaWYgKHNlbGVjdGVkSW5mb3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApO1xuICAgICAgLy8gRXZlbnQuZXZlbnQgaG9sZHMgdGhlIG9yaWdpbmFsIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgICB0aGlzLnByb3BzLm9uTGF5ZXJIb3ZlcihmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LnNyY0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnRXZlbnQoZXZlbnQsIGV4cGxpY2l0VHlwZSkge1xuICAgIC8vIHVzZSBvZmZzZXRYfFkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBjb250YWluZXIsIGRyb3AgZXZlbnQgaWYgZmFsc3lcbiAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5zcmNFdmVudCB8fCAhTnVtYmVyLmlzRmluaXRlKGV2ZW50LnNyY0V2ZW50Lm9mZnNldFgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtzcmNFdmVudDoge29mZnNldFg6IHgsIG9mZnNldFk6IHl9fSA9IGV2ZW50O1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZXhwbGljaXRUeXBlID09PSAnc3RyaW5nJyA/IGV4cGxpY2l0VHlwZSA6IGV2ZW50LnNyY0V2ZW50LnR5cGU7XG4gICAgbGV0IG1vZGU7XG4gICAgbGV0IGxheWVyRXZlbnRIYW5kbGVyO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICBtb2RlID0gJ2RyYWdzdGFydCc7XG4gICAgICBsYXllckV2ZW50SGFuZGxlciA9IHRoaXMucHJvcHMub25MYXllckRyYWdTdGFydDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICBtb2RlID0gJ2RyYWdtb3ZlJztcbiAgICAgIGxheWVyRXZlbnRIYW5kbGVyID0gdGhpcy5wcm9wcy5vbkxheWVyRHJhZ01vdmU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkcmFnY2FuY2VsJzpcbiAgICAgIG1vZGUgPSAnZHJhZ2NhbmNlbCc7XG4gICAgICBsYXllckV2ZW50SGFuZGxlciA9IHRoaXMucHJvcHMub25MYXllckRyYWdDYW5jZWw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgIG1vZGUgPSAnZHJhZ2VuZCc7XG4gICAgICBsYXllckV2ZW50SGFuZGxlciA9IHRoaXMucHJvcHMub25MYXllckRyYWdFbmQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbW9kZSA9IG51bGw7XG4gICAgICBsYXllckV2ZW50SGFuZGxlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMucHJvcHMucGlja2luZ1JhZGl1cztcbiAgICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLmxheWVyTWFuYWdlci5waWNrTGF5ZXIoe3gsIHksIHJhZGl1cywgbW9kZX0pO1xuICAgICAgaWYgKHNlbGVjdGVkSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCk7XG4gICAgICAgIC8vIHNyY0V2ZW50IGhvbGRzIHRoZSBvcmlnaW5hbCBNb3VzZUV2ZW50IG9iamVjdFxuICAgICAgICBsYXllckV2ZW50SGFuZGxlcihmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LnNyY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfb25EcmFnQ2FuY2VsKGV2ZW50KSB7XG4gICAgLy8gcmV3cml0ZSBldmVudCB0eXBlIGZvciBkcmFnY2FuY2VsIC8gZHJhZ2VuZCBkaXNhbWJpZ3VhdGlvblxuICAgIHRoaXMuX29uRHJhZ0V2ZW50KGV2ZW50LCAnZHJhZ2NhbmNlbCcpO1xuICB9XG5cbiAgX29uUmVuZGVyRnJhbWUoe2dsfSkge1xuICAgIGNvbnN0IHJlZHJhdyA9IHRoaXMubGF5ZXJNYW5hZ2VyLm5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzOiB0cnVlfSk7XG4gICAgaWYgKCFyZWRyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBkZXB0aCBhbmQgY29sb3IgYnVmZmVyc1xuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgIHRoaXMuZWZmZWN0TWFuYWdlci5wcmVEcmF3KCk7XG4gICAgdGhpcy5sYXllck1hbmFnZXIuZHJhd0xheWVycyh7cGFzczogJ3ByaW1hcnknfSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmRyYXcoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2wsIGRlYnVnfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXZWJHTFJlbmRlcmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGdsLFxuICAgICAgZGVidWcsXG4gICAgICB2aWV3cG9ydDoge3g6IDAsIHk6IDAsIHdpZHRoLCBoZWlnaHR9LFxuICAgICAgb25SZW5kZXJlckluaXRpYWxpemVkOiB0aGlzLl9vblJlbmRlcmVySW5pdGlhbGl6ZWQsXG4gICAgICBvbk5lZWRSZWRyYXc6IHRoaXMuX29uTmVlZFJlZHJhdyxcbiAgICAgIG9uUmVuZGVyRnJhbWU6IHRoaXMuX29uUmVuZGVyRnJhbWUsXG4gICAgICBvbk1vdXNlTW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSkpO1xuICB9XG59XG5cbkRlY2tHTC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5EZWNrR0wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__ = __webpack_require__(199);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__ = __webpack_require__(205);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "project", function() { return __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__ = __webpack_require__(203);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "project64", function() { return __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__ = __webpack_require__(201);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "lighting", function() { return __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__["a"]; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Load shader chunks




//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvc2hhZGVyLWNodW5rcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsbUJBQWQ7QUFDQSxjQUFjLHNCQUFkO0FBQ0EsY0FBYyx3QkFBZDtBQUNBLGNBQWMsdUJBQWQiLCJmaWxlIjoic2hhZGVyLWNodW5rcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBMb2FkIHNoYWRlciBjaHVua3NcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9mcDY0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0NjQnO1xuZXhwb3J0ICogZnJvbSAnLi4vc2hhZGVybGliL2xpZ2h0aW5nJztcbiJdfQ==

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// getValue takes an array of points returns a value to sort the bins on.
// by default it returns the number of points
// this is where to pass in a function to color the bins by
// avg/mean/max of specific value of the point
var defaultGetValue = function defaultGetValue(points) {
  return points.length;
};

var BinSorter = function () {
  function BinSorter() {
    var bins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var getValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetValue;

    _classCallCheck(this, BinSorter);

    this.sortedBins = this.getSortedBins(bins, getValue);
    this.maxCount = this.getMaxCount();
    this.binMap = this.getBinMap();
  }

  /**
   * Get an array of object with sorted values and index of bins
   * @param {Array} bins
   * @param {Function} getValue
   * @return {Array} array of values and index lookup
   */


  _createClass(BinSorter, [{
    key: "getSortedBins",
    value: function getSortedBins(bins, getValue) {
      return bins.map(function (h, i) {
        return {
          i: Number.isFinite(h.index) ? h.index : i,
          value: getValue(h.points),
          counts: h.points.length
        };
      }).sort(function (a, b) {
        return a.value - b.value;
      });
    }

    /**
     * Get range of values of all bins
     * @param {Number[]} range
     * @param {Number} range[0] - lower bound
     * @param {Number} range[1] - upper bound
     * @return {Array} array of new value range
     */

  }, {
    key: "getValueRange",
    value: function getValueRange(_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          lower = _ref2[0],
          upper = _ref2[1];

      var len = this.sortedBins.length;
      if (!len) {
        return [0, 0];
      }
      var lowerIdx = Math.ceil(lower / 100 * (len - 1));
      var upperIdx = Math.floor(upper / 100 * (len - 1));

      return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
    }

    /**
     * Get ths max count of all bins
     * @return {Number | Boolean} max count
     */

  }, {
    key: "getMaxCount",
    value: function getMaxCount() {
      return Math.max.apply(null, this.sortedBins.map(function (b) {
        return b.counts;
      }));
    }

    /**
     * Get a mapping from cell/hexagon index to sorted bin
     * This is used to retrieve bin value for color calculation
     * @return {Object} bin index to sortedBins
     */

  }, {
    key: "getBinMap",
    value: function getBinMap() {
      return this.sortedBins.reduce(function (mapper, curr) {
        return Object.assign(mapper, _defineProperty({}, curr.i, curr));
      }, {});
    }
  }]);

  return BinSorter;
}();

/* harmony default export */ __webpack_exports__["a"] = (BinSorter);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9iaW4tc29ydGVyLmpzIl0sIm5hbWVzIjpbImRlZmF1bHRHZXRWYWx1ZSIsInBvaW50cyIsImxlbmd0aCIsIkJpblNvcnRlciIsImJpbnMiLCJnZXRWYWx1ZSIsInNvcnRlZEJpbnMiLCJnZXRTb3J0ZWRCaW5zIiwibWF4Q291bnQiLCJnZXRNYXhDb3VudCIsImJpbk1hcCIsImdldEJpbk1hcCIsIm1hcCIsImgiLCJpIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpbmRleCIsInZhbHVlIiwiY291bnRzIiwic29ydCIsImEiLCJiIiwibG93ZXIiLCJ1cHBlciIsImxlbiIsImxvd2VySWR4IiwiTWF0aCIsImNlaWwiLCJ1cHBlcklkeCIsImZsb29yIiwibWF4IiwiYXBwbHkiLCJyZWR1Y2UiLCJtYXBwZXIiLCJjdXJyIiwiT2JqZWN0IiwiYXNzaWduIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsa0JBQWtCLFNBQWxCQSxlQUFrQjtBQUFBLFNBQVVDLE9BQU9DLE1BQWpCO0FBQUEsQ0FBeEI7O0lBRXFCQyxTO0FBQ25CLHVCQUFtRDtBQUFBLFFBQXZDQyxJQUF1Qyx1RUFBaEMsRUFBZ0M7QUFBQSxRQUE1QkMsUUFBNEIsdUVBQWpCTCxlQUFpQjs7QUFBQTs7QUFDakQsU0FBS00sVUFBTCxHQUFrQixLQUFLQyxhQUFMLENBQW1CSCxJQUFuQixFQUF5QkMsUUFBekIsQ0FBbEI7QUFDQSxTQUFLRyxRQUFMLEdBQWdCLEtBQUtDLFdBQUwsRUFBaEI7QUFDQSxTQUFLQyxNQUFMLEdBQWMsS0FBS0MsU0FBTCxFQUFkO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7a0NBTWNQLEksRUFBTUMsUSxFQUFVO0FBQzVCLGFBQU9ELEtBQ0pRLEdBREksQ0FDQSxVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxlQUFXO0FBQ2RBLGFBQUdDLE9BQU9DLFFBQVAsQ0FBZ0JILEVBQUVJLEtBQWxCLElBQTJCSixFQUFFSSxLQUE3QixHQUFxQ0gsQ0FEMUI7QUFFZEksaUJBQU9iLFNBQVNRLEVBQUVaLE1BQVgsQ0FGTztBQUdka0Isa0JBQVFOLEVBQUVaLE1BQUYsQ0FBU0M7QUFISCxTQUFYO0FBQUEsT0FEQSxFQU1Ka0IsSUFOSSxDQU1DLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGVBQVVELEVBQUVILEtBQUYsR0FBVUksRUFBRUosS0FBdEI7QUFBQSxPQU5ELENBQVA7QUFPRDs7QUFFRDs7Ozs7Ozs7Ozt3Q0FPOEI7QUFBQTtBQUFBLFVBQWZLLEtBQWU7QUFBQSxVQUFSQyxLQUFROztBQUM1QixVQUFNQyxNQUFNLEtBQUtuQixVQUFMLENBQWdCSixNQUE1QjtBQUNBLFVBQUksQ0FBQ3VCLEdBQUwsRUFBVTtBQUNSLGVBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFQO0FBQ0Q7QUFDRCxVQUFNQyxXQUFXQyxLQUFLQyxJQUFMLENBQVVMLFFBQVEsR0FBUixJQUFlRSxNQUFNLENBQXJCLENBQVYsQ0FBakI7QUFDQSxVQUFNSSxXQUFXRixLQUFLRyxLQUFMLENBQVdOLFFBQVEsR0FBUixJQUFlQyxNQUFNLENBQXJCLENBQVgsQ0FBakI7O0FBRUEsYUFBTyxDQUFDLEtBQUtuQixVQUFMLENBQWdCb0IsUUFBaEIsRUFBMEJSLEtBQTNCLEVBQWtDLEtBQUtaLFVBQUwsQ0FBZ0J1QixRQUFoQixFQUEwQlgsS0FBNUQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O2tDQUljO0FBQ1osYUFBT1MsS0FBS0ksR0FBTCxDQUFTQyxLQUFULENBQWUsSUFBZixFQUFxQixLQUFLMUIsVUFBTCxDQUFnQk0sR0FBaEIsQ0FBb0I7QUFBQSxlQUFLVSxFQUFFSCxNQUFQO0FBQUEsT0FBcEIsQ0FBckIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztnQ0FLWTtBQUNWLGFBQU8sS0FBS2IsVUFBTCxDQUFnQjJCLE1BQWhCLENBQXVCLFVBQUNDLE1BQUQsRUFBU0MsSUFBVDtBQUFBLGVBQWtCQyxPQUFPQyxNQUFQLENBQWNILE1BQWQsc0JBQzdDQyxLQUFLckIsQ0FEd0MsRUFDcENxQixJQURvQyxFQUFsQjtBQUFBLE9BQXZCLEVBRUgsRUFGRyxDQUFQO0FBR0Q7Ozs7OztlQTFEa0JoQyxTIiwiZmlsZSI6ImJpbi1zb3J0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gZ2V0VmFsdWUgdGFrZXMgYW4gYXJyYXkgb2YgcG9pbnRzIHJldHVybnMgYSB2YWx1ZSB0byBzb3J0IHRoZSBiaW5zIG9uLlxuLy8gYnkgZGVmYXVsdCBpdCByZXR1cm5zIHRoZSBudW1iZXIgb2YgcG9pbnRzXG4vLyB0aGlzIGlzIHdoZXJlIHRvIHBhc3MgaW4gYSBmdW5jdGlvbiB0byBjb2xvciB0aGUgYmlucyBieVxuLy8gYXZnL21lYW4vbWF4IG9mIHNwZWNpZmljIHZhbHVlIG9mIHRoZSBwb2ludFxuY29uc3QgZGVmYXVsdEdldFZhbHVlID0gcG9pbnRzID0+IHBvaW50cy5sZW5ndGg7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpblNvcnRlciB7XG4gIGNvbnN0cnVjdG9yKGJpbnMgPSBbXSwgZ2V0VmFsdWUgPSBkZWZhdWx0R2V0VmFsdWUpIHtcbiAgICB0aGlzLnNvcnRlZEJpbnMgPSB0aGlzLmdldFNvcnRlZEJpbnMoYmlucywgZ2V0VmFsdWUpO1xuICAgIHRoaXMubWF4Q291bnQgPSB0aGlzLmdldE1heENvdW50KCk7XG4gICAgdGhpcy5iaW5NYXAgPSB0aGlzLmdldEJpbk1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBvYmplY3Qgd2l0aCBzb3J0ZWQgdmFsdWVzIGFuZCBpbmRleCBvZiBiaW5zXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJpbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0VmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHZhbHVlcyBhbmQgaW5kZXggbG9va3VwXG4gICAqL1xuICBnZXRTb3J0ZWRCaW5zKGJpbnMsIGdldFZhbHVlKSB7XG4gICAgcmV0dXJuIGJpbnNcbiAgICAgIC5tYXAoKGgsIGkpID0+ICh7XG4gICAgICAgIGk6IE51bWJlci5pc0Zpbml0ZShoLmluZGV4KSA/IGguaW5kZXggOiBpLFxuICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoaC5wb2ludHMpLFxuICAgICAgICBjb3VudHM6IGgucG9pbnRzLmxlbmd0aFxuICAgICAgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCByYW5nZSBvZiB2YWx1ZXMgb2YgYWxsIGJpbnNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gcmFuZ2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlWzBdIC0gbG93ZXIgYm91bmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlWzFdIC0gdXBwZXIgYm91bmRcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIG5ldyB2YWx1ZSByYW5nZVxuICAgKi9cbiAgZ2V0VmFsdWVSYW5nZShbbG93ZXIsIHVwcGVyXSkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuc29ydGVkQmlucy5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIGNvbnN0IGxvd2VySWR4ID0gTWF0aC5jZWlsKGxvd2VyIC8gMTAwICogKGxlbiAtIDEpKTtcbiAgICBjb25zdCB1cHBlcklkeCA9IE1hdGguZmxvb3IodXBwZXIgLyAxMDAgKiAobGVuIC0gMSkpO1xuXG4gICAgcmV0dXJuIFt0aGlzLnNvcnRlZEJpbnNbbG93ZXJJZHhdLnZhbHVlLCB0aGlzLnNvcnRlZEJpbnNbdXBwZXJJZHhdLnZhbHVlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhzIG1heCBjb3VudCBvZiBhbGwgYmluc1xuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCb29sZWFufSBtYXggY291bnRcbiAgICovXG4gIGdldE1heENvdW50KCkge1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnNvcnRlZEJpbnMubWFwKGIgPT4gYi5jb3VudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBtYXBwaW5nIGZyb20gY2VsbC9oZXhhZ29uIGluZGV4IHRvIHNvcnRlZCBiaW5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHJldHJpZXZlIGJpbiB2YWx1ZSBmb3IgY29sb3IgY2FsY3VsYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBiaW4gaW5kZXggdG8gc29ydGVkQmluc1xuICAgKi9cbiAgZ2V0QmluTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnNvcnRlZEJpbnMucmVkdWNlKChtYXBwZXIsIGN1cnIpID0+IE9iamVjdC5hc3NpZ24obWFwcGVyLCB7XG4gICAgICBbY3Vyci5pXTogY3VyclxuICAgIH0pLCB7fSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultColorRange; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jb2xvci11dGlscy5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0Q29sb3JSYW5nZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxJQUFNQSxvQkFBb0IsQ0FDL0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FEK0IsRUFFL0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FGK0IsRUFHL0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEVBQVgsQ0FIK0IsRUFJL0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEVBQVgsQ0FKK0IsRUFLL0IsQ0FBQyxHQUFELEVBQU0sRUFBTixFQUFVLEVBQVYsQ0FMK0IsRUFNL0IsQ0FBQyxHQUFELEVBQU0sQ0FBTixFQUFTLEVBQVQsQ0FOK0IsQ0FBMUIiLCJmaWxlIjoiY29sb3ItdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb2xvclJhbmdlID0gW1xuICBbMjU1LCAyNTUsIDE3OF0sXG4gIFsyNTQsIDIxNywgMTE4XSxcbiAgWzI1NCwgMTc4LCA3Nl0sXG4gIFsyNTMsIDE0MSwgNjBdLFxuICBbMjQwLCA1OSwgMzJdLFxuICBbMTg5LCAwLCAzOF1cbl07XG4iXX0=

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = linearScale;
/* harmony export (immutable) */ __webpack_exports__["a"] = quantizeScale;
/* unused harmony export clamp */
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Linear scale maps continuous domain to continuous range
function linearScale(domain, range, value) {

  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
}

// Quantize scale is similar to linear scales,
// except it uses a discrete rather than continuous range
function quantizeScale(domain, range, value) {
  var step = (domain[1] - domain[0]) / range.length;
  var idx = Math.floor((value - domain[0]) / step);
  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);

  return range[clampIdx];
}

function clamp(_ref, value) {
  var _ref2 = _slicedToArray(_ref, 2),
      min = _ref2[0],
      max = _ref2[1];

  return Math.min(max, Math.max(min, value));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zY2FsZS11dGlscy5qcyJdLCJuYW1lcyI6WyJsaW5lYXJTY2FsZSIsImRvbWFpbiIsInJhbmdlIiwidmFsdWUiLCJxdWFudGl6ZVNjYWxlIiwic3RlcCIsImxlbmd0aCIsImlkeCIsIk1hdGgiLCJmbG9vciIsImNsYW1wSWR4IiwibWF4IiwibWluIiwiY2xhbXAiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLFNBQVNBLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCQyxLQUE3QixFQUFvQ0MsS0FBcEMsRUFBMkM7O0FBRWhELFNBQU8sQ0FBQ0EsUUFBUUYsT0FBTyxDQUFQLENBQVQsS0FBdUJBLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBbkMsS0FBaURDLE1BQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sQ0FBNUQsSUFBd0VBLE1BQU0sQ0FBTixDQUEvRTtBQUNEOztBQUVEO0FBQ0E7QUFDQSxPQUFPLFNBQVNFLGFBQVQsQ0FBdUJILE1BQXZCLEVBQStCQyxLQUEvQixFQUFzQ0MsS0FBdEMsRUFBNkM7QUFDbEQsTUFBTUUsT0FBTyxDQUFDSixPQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLENBQWIsSUFBMEJDLE1BQU1JLE1BQTdDO0FBQ0EsTUFBTUMsTUFBTUMsS0FBS0MsS0FBTCxDQUFXLENBQUNOLFFBQVFGLE9BQU8sQ0FBUCxDQUFULElBQXNCSSxJQUFqQyxDQUFaO0FBQ0EsTUFBTUssV0FBV0YsS0FBS0csR0FBTCxDQUFTSCxLQUFLSSxHQUFMLENBQVNMLEdBQVQsRUFBY0wsTUFBTUksTUFBTixHQUFlLENBQTdCLENBQVQsRUFBMEMsQ0FBMUMsQ0FBakI7O0FBRUEsU0FBT0osTUFBTVEsUUFBTixDQUFQO0FBQ0Q7O0FBRUQsT0FBTyxTQUFTRyxLQUFULE9BQTJCVixLQUEzQixFQUFrQztBQUFBO0FBQUEsTUFBbEJTLEdBQWtCO0FBQUEsTUFBYkQsR0FBYTs7QUFDdkMsU0FBT0gsS0FBS0ksR0FBTCxDQUFTRCxHQUFULEVBQWNILEtBQUtHLEdBQUwsQ0FBU0MsR0FBVCxFQUFjVCxLQUFkLENBQWQsQ0FBUDtBQUNEIiwiZmlsZSI6InNjYWxlLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIExpbmVhciBzY2FsZSBtYXBzIGNvbnRpbnVvdXMgZG9tYWluIHRvIGNvbnRpbnVvdXMgcmFuZ2VcbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJTY2FsZShkb21haW4sIHJhbmdlLCB2YWx1ZSkge1xuXG4gIHJldHVybiAodmFsdWUgLSBkb21haW5bMF0pIC8gKGRvbWFpblsxXSAtIGRvbWFpblswXSkgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKyByYW5nZVswXTtcbn1cblxuLy8gUXVhbnRpemUgc2NhbGUgaXMgc2ltaWxhciB0byBsaW5lYXIgc2NhbGVzLFxuLy8gZXhjZXB0IGl0IHVzZXMgYSBkaXNjcmV0ZSByYXRoZXIgdGhhbiBjb250aW51b3VzIHJhbmdlXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVTY2FsZShkb21haW4sIHJhbmdlLCB2YWx1ZSkge1xuICBjb25zdCBzdGVwID0gKGRvbWFpblsxXSAtIGRvbWFpblswXSkgLyByYW5nZS5sZW5ndGg7XG4gIGNvbnN0IGlkeCA9IE1hdGguZmxvb3IoKHZhbHVlIC0gZG9tYWluWzBdKSAvIHN0ZXApO1xuICBjb25zdCBjbGFtcElkeCA9IE1hdGgubWF4KE1hdGgubWluKGlkeCwgcmFuZ2UubGVuZ3RoIC0gMSksIDApO1xuXG4gIHJldHVybiByYW5nZVtjbGFtcElkeF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcChbbWluLCBtYXhdLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG4iXX0=

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return Hammer;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, INFINITY) : [];
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = flattenDeep;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return requestAnimationFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return cancelAnimationFrame; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl__ = __webpack_require__(20);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global window, setTimeout, clearTimeout */



// Node.js polyfills for requestAnimationFrame and cancelAnimationFrame
var requestAnimationFrame = function requestAnimationFrame(callback) {
  return __WEBPACK_IMPORTED_MODULE_0__utils__["isBrowser"] ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
};

var cancelAnimationFrame = function cancelAnimationFrame(timerId) {
  return __WEBPACK_IMPORTED_MODULE_0__utils__["isBrowser"] ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
};

var AnimationLoop = function () {
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  function AnimationLoop() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$onCreateContext = _ref.onCreateContext,
        onCreateContext = _ref$onCreateContext === undefined ? function (opts) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__webgl__["createGLContext"])(opts);
    } : _ref$onCreateContext,
        _ref$onInitialize = _ref.onInitialize,
        onInitialize = _ref$onInitialize === undefined ? null : _ref$onInitialize,
        _ref$onRender = _ref.onRender,
        onRender = _ref$onRender === undefined ? null : _ref$onRender,
        _ref$onFinalize = _ref.onFinalize,
        onFinalize = _ref$onFinalize === undefined ? null : _ref$onFinalize,
        _ref$gl = _ref.gl,
        gl = _ref$gl === undefined ? null : _ref$gl,
        _ref$width = _ref.width,
        width = _ref$width === undefined ? null : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? null : _ref$height,
        _ref$autoResizeViewpo = _ref.autoResizeViewport,
        autoResizeViewport = _ref$autoResizeViewpo === undefined ? true : _ref$autoResizeViewpo,
        _ref$autoResizeCanvas = _ref.autoResizeCanvas,
        autoResizeCanvas = _ref$autoResizeCanvas === undefined ? true : _ref$autoResizeCanvas,
        _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _ref$autoResizeDrawin === undefined ? true : _ref$autoResizeDrawin,
        _ref$useDevicePixelRa = _ref.useDevicePixelRatio,
        useDevicePixelRatio = _ref$useDevicePixelRa === undefined ? true : _ref$useDevicePixelRa;

    _classCallCheck(this, AnimationLoop);

    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._renderFrame = this._renderFrame.bind(this);

    this.update({
      autoResizeViewport: autoResizeViewport,
      autoResizeCanvas: autoResizeCanvas,
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixelRatio: useDevicePixelRatio
    });

    this._onCreateContext = onCreateContext;

    this._onInitialize = onInitialize;
    this._onRender = onRender;
    this._onFinalize = onFinalize;

    this.width = width;
    this.height = height;

    this.gl = gl;

    return this;
  }

  // Update parameters (TODO - should these be specified in `start`?)


  _createClass(AnimationLoop, [{
    key: 'update',
    value: function update(_ref2) {
      var _ref2$autoResizeDrawi = _ref2.autoResizeDrawingBuffer,
          autoResizeDrawingBuffer = _ref2$autoResizeDrawi === undefined ? true : _ref2$autoResizeDrawi,
          _ref2$autoResizeCanva = _ref2.autoResizeCanvas,
          autoResizeCanvas = _ref2$autoResizeCanva === undefined ? true : _ref2$autoResizeCanva,
          _ref2$autoResizeViewp = _ref2.autoResizeViewport,
          autoResizeViewport = _ref2$autoResizeViewp === undefined ? true : _ref2$autoResizeViewp,
          _ref2$useDevicePixelR = _ref2.useDevicePixelRatio,
          useDevicePixelRatio = _ref2$useDevicePixelR === undefined ? true : _ref2$useDevicePixelR;

      this.autoResizeViewport = autoResizeViewport;
      this.autoResizeCanvas = autoResizeCanvas;
      this.autoResizeDrawingBuffer = autoResizeDrawingBuffer;
      this.useDevicePixelRatio = useDevicePixelRatio;
      return this;
    }

    // Starts a render loop if not already running
    // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)

  }, {
    key: 'start',
    value: function start() {
      var _this = this;

      var contextParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this._animationFrameId) {

        // Wait for start promise before rendering frame
        this._startPromise = __WEBPACK_IMPORTED_MODULE_0__utils__["pageLoadPromise"].then(function () {
          // Create the context
          _this.gl = _this.gl || contextParams.gl || _this._onCreateContext(contextParams);
          if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__webgl__["isWebGLContext"])(_this.gl)) {
            throw new Error('AnimationLoop.onCreateContext - illegal context returned');
          }
          _this._initializeContext();
          // Note: onIntialize can return a promise (in case it needs to load resources)
          return _this._onInitialize(_this._context) || {};
        }).then(function () {
          var appContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _this._addAppDataToContext(appContext);
          if (!_this._animationFrameId) {
            _this._animationFrameId = requestAnimationFrame(_this._renderFrame);
          }
        });
      }
      return this;
    }

    // Stops a render loop if already running, finalizing

  }, {
    key: 'stop',
    value: function stop() {
      if (this._animationFrameId) {
        this._finalizeContext();
        cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = null;
      }
      return this;
    }

    // Resize canvas in "CSS coordinates" (may be different from device coords)
    // NOTE: No effect on headless contexts
    // @param {Number} width, height - new width and height of canvas in CSS coordinates

  }, {
    key: 'resizeCanvas',
    value: function resizeCanvas(width, height) {
      this._resizeCanvas(width, height);
      return this;
    }

    // PRIVATE METHODS

    // Initialize the context object that will be passed to app callbacks

  }, {
    key: '_initializeContext',
    value: function _initializeContext() {
      if (!this._context) {
        this._context = {
          gl: this.gl,
          canvas: this.gl.canvas,
          stop: this.stop,
          tick: 0,
          tock: 0
        };
      }
      this._updateContext();
    }

    // Update the context object that will be passed to app callbacks

  }, {
    key: '_updateContext',
    value: function _updateContext() {
      // Context width and height represent drawing buffer width and height
      var canvas = this._context.canvas;

      this._context.width = canvas.width;
      this._context.height = canvas.height;
      this._context.aspect = canvas.width / canvas.height;
    }
  }, {
    key: '_finalizeContext',
    value: function _finalizeContext() {}

    // Add application's data to the app context object

  }, {
    key: '_addAppDataToContext',
    value: function _addAppDataToContext(appContext) {
      if ((typeof appContext === 'undefined' ? 'undefined' : _typeof(appContext)) === 'object' && appContext !== null) {
        this._context = Object.assign({}, appContext, this._context);
      }
    }

    /**
     * @private
     * Handles a render loop frame- updates context and calls the application
     * callback
     */

  }, {
    key: '_renderFrame',
    value: function _renderFrame() {
      var canvas = this._context.canvas;


      if (this._onSetupFrame) {
        this._onSetupFrame(this._context);
      } else {
        this._resizeCanvasDrawingBuffer(canvas);
        // Default viewport setup
        if (this.autoResizeViewport) {
          this.gl.viewport(0, 0, canvas.width, canvas.height);
        }
      }

      this._updateContext();
      this._onRender(this._context);

      // Increment tick
      this._context.tick++;

      // Request another render frame (now )
      this._animationFrameId = requestAnimationFrame(this._renderFrame);
    }

    // Resize canvas in "CSS coordinates" (may be different from device coords)
    // NOTE: No effect on headless contexts
    // @param {Number} width, height - new width and height of canvas in CSS coordinates

  }, {
    key: '_resizeCanvas',
    value: function _resizeCanvas(width, height) {
      var canvas = this._context.canvas;
      // if (canvas) {
      //   // Lookup the size the browser is displaying the canvas.
      //   var displayWidth = canvas.clientWidth;
      //   var displayHeight = canvas.clientHeight;

      //   // Check if the canvas is not the same size.
      //   if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
      //     // Make the canvas the same size
      //     canvas.width  = displayWidth;
      //     canvas.height = displayHeight;
      //   }
      // }

      if (canvas) {
        if (this.autoResizeDrawingBuffer) {
          var cssToDevicePixels = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;

          // Lookup the size the browser is displaying the canvas in CSS pixels
          // and compute a size needed to make our drawingbuffer match it in
          // device pixels.
          var displayWidth = Math.floor(width * cssToDevicePixels);
          var displayHeight = Math.floor(height * cssToDevicePixels);

          // Check if the canvas is not the same size.
          if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;
          }
        }

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
      return this;
    }

    // Resize the render buffer of the canvas to match canvas client size
    // multiplying with dpr (Optionally can be turned off)
    // http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

  }, {
    key: '_resizeCanvasDrawingBuffer',
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        var canvas = this._context.canvas;

        var cssToDevicePixels = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;

        // Lookup the size the browser is displaying the canvas in CSS pixels
        // and compute a size needed to make our drawingbuffer match it in
        // device pixels.
        var oldWidth = window.innerWidth;
        var oldHeight = window.innerHeight;
        var displayWidth = Math.floor(oldWidth * cssToDevicePixels);
        var displayHeight = Math.floor(oldHeight * cssToDevicePixels);

        // Check if the canvas is not the same size.
        if (oldWidth !== displayWidth || oldHeight !== displayHeight) {
          // Make the canvas the same size
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          canvas.style.width = oldWidth;
          canvas.style.height = oldHeight;
        }
      }
    }

    /**
     * Resize canvas drawing buffer
     * NOTE: The drawing buffer will be scaled to the viewport
     * for best visual results, usually set to either:
     *  canvas CSS width x canvas CSS height
     *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
     * TODO - add separate call for headless contexts
     * @param {Number} width - new width of canvas in CSS coordinates
     * @param {Number} height - new height of canvas in CSS coordinates
     * @return {Renderer} - returns self for chaining
     */

  }, {
    key: '_resizeDrawingBuffer',
    value: function _resizeDrawingBuffer(width, height) {
      var canvas = this._context.canvas;

      if (canvas) {
        canvas.width = width;
        canvas.height = height;
        this.autoResizeDrawingBuffer = false;
      }
      return this;
    }
  }]);

  return AnimationLoop;
}();

/* harmony default export */ __webpack_exports__["a"] = (AnimationLoop);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2FuaW1hdGlvbi1sb29wLmpzIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsInBhZ2VMb2FkUHJvbWlzZSIsImNyZWF0ZUdMQ29udGV4dCIsImlzV2ViR0xDb250ZXh0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2luZG93IiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0aW1lcklkIiwiY2xlYXJUaW1lb3V0IiwiQW5pbWF0aW9uTG9vcCIsIm9uQ3JlYXRlQ29udGV4dCIsIm9wdHMiLCJvbkluaXRpYWxpemUiLCJvblJlbmRlciIsIm9uRmluYWxpemUiLCJnbCIsIndpZHRoIiwiaGVpZ2h0IiwiYXV0b1Jlc2l6ZVZpZXdwb3J0IiwiYXV0b1Jlc2l6ZUNhbnZhcyIsImF1dG9SZXNpemVEcmF3aW5nQnVmZmVyIiwidXNlRGV2aWNlUGl4ZWxSYXRpbyIsInN0YXJ0IiwiYmluZCIsInN0b3AiLCJfcmVuZGVyRnJhbWUiLCJ1cGRhdGUiLCJfb25DcmVhdGVDb250ZXh0IiwiX29uSW5pdGlhbGl6ZSIsIl9vblJlbmRlciIsIl9vbkZpbmFsaXplIiwiY29udGV4dFBhcmFtcyIsIl9hbmltYXRpb25GcmFtZUlkIiwiX3N0YXJ0UHJvbWlzZSIsInRoZW4iLCJFcnJvciIsIl9pbml0aWFsaXplQ29udGV4dCIsIl9jb250ZXh0IiwiYXBwQ29udGV4dCIsIl9hZGRBcHBEYXRhVG9Db250ZXh0IiwiX2ZpbmFsaXplQ29udGV4dCIsIl9yZXNpemVDYW52YXMiLCJjYW52YXMiLCJ0aWNrIiwidG9jayIsIl91cGRhdGVDb250ZXh0IiwiYXNwZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwiX29uU2V0dXBGcmFtZSIsIl9yZXNpemVDYW52YXNEcmF3aW5nQnVmZmVyIiwidmlld3BvcnQiLCJjc3NUb0RldmljZVBpeGVscyIsImRldmljZVBpeGVsUmF0aW8iLCJkaXNwbGF5V2lkdGgiLCJNYXRoIiwiZmxvb3IiLCJkaXNwbGF5SGVpZ2h0Iiwic3R5bGUiLCJvbGRXaWR0aCIsImlubmVyV2lkdGgiLCJvbGRIZWlnaHQiLCJpbm5lckhlaWdodCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxTQUFRQSxTQUFSLEVBQW1CQyxlQUFuQixRQUF5QyxVQUF6QztBQUNBLFNBQVFDLGVBQVIsRUFBeUJDLGNBQXpCLFFBQThDLFVBQTlDOztBQUVBO0FBQ0EsT0FBTyxJQUFNQyx3QkFBd0IsU0FBeEJBLHFCQUF3QjtBQUFBLFNBQ25DSixZQUFZSyxPQUFPRCxxQkFBUCxDQUE2QkUsUUFBN0IsQ0FBWixHQUFxREMsV0FBV0QsUUFBWCxFQUFxQixPQUFPLEVBQTVCLENBRGxCO0FBQUEsQ0FBOUI7O0FBR1AsT0FBTyxJQUFNRSx1QkFBdUIsU0FBdkJBLG9CQUF1QjtBQUFBLFNBQ2xDUixZQUFZSyxPQUFPRyxvQkFBUCxDQUE0QkMsT0FBNUIsQ0FBWixHQUFtREMsYUFBYUQsT0FBYixDQURqQjtBQUFBLENBQTdCOztJQUdjRSxhO0FBQ25COzs7QUFHQSwyQkFhUTtBQUFBLG1GQUFKLEVBQUk7QUFBQSxvQ0FaTkMsZUFZTTtBQUFBLFFBWk5BLGVBWU0sd0NBWlk7QUFBQSxhQUFRVixnQkFBZ0JXLElBQWhCLENBQVI7QUFBQSxLQVlaO0FBQUEsaUNBWE5DLFlBV007QUFBQSxRQVhOQSxZQVdNLHFDQVhTLElBV1Q7QUFBQSw2QkFWTkMsUUFVTTtBQUFBLFFBVk5BLFFBVU0saUNBVkssSUFVTDtBQUFBLCtCQVROQyxVQVNNO0FBQUEsUUFUTkEsVUFTTSxtQ0FUTyxJQVNQO0FBQUEsdUJBUE5DLEVBT007QUFBQSxRQVBOQSxFQU9NLDJCQVBELElBT0M7QUFBQSwwQkFOTkMsS0FNTTtBQUFBLFFBTk5BLEtBTU0sOEJBTkUsSUFNRjtBQUFBLDJCQUxOQyxNQUtNO0FBQUEsUUFMTkEsTUFLTSwrQkFMRyxJQUtIO0FBQUEscUNBSk5DLGtCQUlNO0FBQUEsUUFKTkEsa0JBSU0seUNBSmUsSUFJZjtBQUFBLHFDQUhOQyxnQkFHTTtBQUFBLFFB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ImFuaW1hdGlvbi1sb29wLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdywgc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0ICovXG5pbXBvcnQge2lzQnJvd3NlciwgcGFnZUxvYWRQcm9taXNlfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge2NyZWF0ZUdMQ29udGV4dCwgaXNXZWJHTENvbnRleHR9IGZyb20gJy4uL3dlYmdsJztcblxuLy8gTm9kZS5qcyBwb2x5ZmlsbHMgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgY2FuY2VsQW5pbWF0aW9uRnJhbWVcbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBjYWxsYmFjayA9PlxuICBpc0Jyb3dzZXIgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSA6IHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cbmV4cG9ydCBjb25zdCBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHRpbWVySWQgPT5cbiAgaXNCcm93c2VyID8gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVySWQpIDogY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25Mb29wIHtcbiAgLypcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gaWYgcHJvdmlkZWQsIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBwYXNzZWQgdG8gY29udGV4dFxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG9uQ3JlYXRlQ29udGV4dCA9IG9wdHMgPT4gY3JlYXRlR0xDb250ZXh0KG9wdHMpLFxuICAgIG9uSW5pdGlhbGl6ZSA9IG51bGwsXG4gICAgb25SZW5kZXIgPSBudWxsLFxuICAgIG9uRmluYWxpemUgPSBudWxsLFxuXG4gICAgZ2wgPSBudWxsLFxuICAgIHdpZHRoID0gbnVsbCxcbiAgICBoZWlnaHQgPSBudWxsLFxuICAgIGF1dG9SZXNpemVWaWV3cG9ydCA9IHRydWUsXG4gICAgYXV0b1Jlc2l6ZUNhbnZhcyA9IHRydWUsXG4gICAgYXV0b1Jlc2l6ZURyYXdpbmdCdWZmZXIgPSB0cnVlLFxuICAgIHVzZURldmljZVBpeGVsUmF0aW8gPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyRnJhbWUgPSB0aGlzLl9yZW5kZXJGcmFtZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgYXV0b1Jlc2l6ZVZpZXdwb3J0LFxuICAgICAgYXV0b1Jlc2l6ZUNhbnZhcyxcbiAgICAgIGF1dG9SZXNpemVEcmF3aW5nQnVmZmVyLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpb1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb25DcmVhdGVDb250ZXh0ID0gb25DcmVhdGVDb250ZXh0O1xuXG4gICAgdGhpcy5fb25Jbml0aWFsaXplID0gb25Jbml0aWFsaXplO1xuICAgIHRoaXMuX29uUmVuZGVyID0gb25SZW5kZXI7XG4gICAgdGhpcy5fb25GaW5hbGl6ZSA9IG9uRmluYWxpemU7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwYXJhbWV0ZXJzIChUT0RPIC0gc2hvdWxkIHRoZXNlIGJlIHNwZWNpZmllZCBpbiBgc3RhcnRgPylcbiAgdXBkYXRlKHtcbiAgICBhdXRvUmVzaXplRHJhd2luZ0J1ZmZlciA9IHRydWUsXG4gICAgYXV0b1Jlc2l6ZUNhbnZhcyA9IHRydWUsXG4gICAgYXV0b1Jlc2l6ZVZpZXdwb3J0ID0gdHJ1ZSxcbiAgICB1c2VEZXZpY2VQaXhlbFJhdGlvID0gdHJ1ZVxuICB9KSB7XG4gICAgdGhpcy5hdXRvUmVzaXplVmlld3BvcnQgPSBhdXRvUmVzaXplVmlld3BvcnQ7XG4gICAgdGhpcy5hdXRvUmVzaXplQ2FudmFzID0gYXV0b1Jlc2l6ZUNhbnZhcztcbiAgICB0aGlzLmF1dG9SZXNpemVEcmF3aW5nQnVmZmVyID0gYXV0b1Jlc2l6ZURyYXdpbmdCdWZmZXI7XG4gICAgdGhpcy51c2VEZXZpY2VQaXhlbFJhdGlvID0gdXNlRGV2aWNlUGl4ZWxSYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFN0YXJ0cyBhIHJlbmRlciBsb29wIGlmIG5vdCBhbHJlYWR5IHJ1bm5pbmdcbiAgLy8gQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBjb250YWlucyBmcmFtZSBzcGVjaWZpYyBpbmZvIChFLmcuIHRpY2ssIHdpZHRoLCBoZWlnaHQsIGV0YylcbiAgc3RhcnQoY29udGV4dFBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLl9hbmltYXRpb25GcmFtZUlkKSB7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHN0YXJ0IHByb21pc2UgYmVmb3JlIHJlbmRlcmluZyBmcmFtZVxuICAgICAgdGhpcy5fc3RhcnRQcm9taXNlID0gcGFnZUxvYWRQcm9taXNlXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY29udGV4dFxuICAgICAgICB0aGlzLmdsID0gdGhpcy5nbCB8fCBjb250ZXh0UGFyYW1zLmdsIHx8IHRoaXMuX29uQ3JlYXRlQ29udGV4dChjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgaWYgKCFpc1dlYkdMQ29udGV4dCh0aGlzLmdsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW5pbWF0aW9uTG9vcC5vbkNyZWF0ZUNvbnRleHQgLSBpbGxlZ2FsIGNvbnRleHQgcmV0dXJuZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbml0aWFsaXplQ29udGV4dCgpO1xuICAgICAgICAvLyBOb3RlOiBvbkludGlhbGl6ZSBjYW4gcmV0dXJuIGEgcHJvbWlzZSAoaW4gY2FzZSBpdCBuZWVkcyB0byBsb2FkIHJlc291cmNlcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uSW5pdGlhbGl6ZSh0aGlzLl9jb250ZXh0KSB8fCB7fTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoYXBwQ29udGV4dCA9IHt9KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZEFwcERhdGFUb0NvbnRleHQoYXBwQ29udGV4dCk7XG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCkge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFN0b3BzIGEgcmVuZGVyIGxvb3AgaWYgYWxyZWFkeSBydW5uaW5nLCBmaW5hbGl6aW5nXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQ29udGV4dCgpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVJZCk7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSZXNpemUgY2FudmFzIGluIFwiQ1NTIGNvb3JkaW5hdGVzXCIgKG1heSBiZSBkaWZmZXJlbnQgZnJvbSBkZXZpY2UgY29vcmRzKVxuICAvLyBOT1RFOiBObyBlZmZlY3Qgb24gaGVhZGxlc3MgY29udGV4dHNcbiAgLy8gQHBhcmFtIHtOdW1iZXJ9IHdpZHRoLCBoZWlnaHQgLSBuZXcgd2lkdGggYW5kIGhlaWdodCBvZiBjYW52YXMgaW4gQ1NTIGNvb3JkaW5hdGVzXG4gIHJlc2l6ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5fcmVzaXplQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBhcHAgY2FsbGJhY2tzXG4gIF9pbml0aWFsaXplQ29udGV4dCgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB7XG4gICAgICAgIGdsOiB0aGlzLmdsLFxuICAgICAgICBjYW52YXM6IHRoaXMuZ2wuY2FudmFzLFxuICAgICAgICBzdG9wOiB0aGlzLnN0b3AsXG4gICAgICAgIHRpY2s6IDAsXG4gICAgICAgIHRvY2s6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBhcHAgY2FsbGJhY2tzXG4gIF91cGRhdGVDb250ZXh0KCkge1xuICAgIC8vIENvbnRleHQgd2lkdGggYW5kIGhlaWdodCByZXByZXNlbnQgZHJhd2luZyBidWZmZXIgd2lkdGggYW5kIGhlaWdodFxuICAgIGNvbnN0IHtjYW52YXN9ID0gdGhpcy5fY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0LndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHRoaXMuX2NvbnRleHQuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB0aGlzLl9jb250ZXh0LmFzcGVjdCA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIH1cblxuICBfZmluYWxpemVDb250ZXh0KCkge1xuICB9XG5cbiAgLy8gQWRkIGFwcGxpY2F0aW9uJ3MgZGF0YSB0byB0aGUgYXBwIGNvbnRleHQgb2JqZWN0XG4gIF9hZGRBcHBEYXRhVG9Db250ZXh0KGFwcENvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIGFwcENvbnRleHQgPT09ICdvYmplY3QnICYmIGFwcENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBhcHBDb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogSGFuZGxlcyBhIHJlbmRlciBsb29wIGZyYW1lLSB1cGRhdGVzIGNvbnRleHQgYW5kIGNhbGxzIHRoZSBhcHBsaWNhdGlvblxuICAgKiBjYWxsYmFja1xuICAgKi9cbiAgX3JlbmRlckZyYW1lKCkge1xuICAgIGNvbnN0IHtjYW52YXN9ID0gdGhpcy5fY29udGV4dDtcblxuICAgIGlmICh0aGlzLl9vblNldHVwRnJhbWUpIHtcbiAgICAgIHRoaXMuX29uU2V0dXBGcmFtZSh0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQ2FudmFzRHJhd2luZ0J1ZmZlcihjYW52YXMpO1xuICAgICAgLy8gRGVmYXVsdCB2aWV3cG9ydCBzZXR1cFxuICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZVZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVDb250ZXh0KCk7XG4gICAgdGhpcy5fb25SZW5kZXIodGhpcy5fY29udGV4dCk7XG5cbiAgICAvLyBJbmNyZW1lbnQgdGlja1xuICAgIHRoaXMuX2NvbnRleHQudGljaysrO1xuXG4gICAgLy8gUmVxdWVzdCBhbm90aGVyIHJlbmRlciBmcmFtZSAobm93IClcbiAgICB0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lKTtcbiAgfVxuXG4gIC8vIFJlc2l6ZSBjYW52YXMgaW4gXCJDU1MgY29vcmRpbmF0ZXNcIiAobWF5IGJlIGRpZmZlcmVudCBmcm9tIGRldmljZSBjb29yZHMpXG4gIC8vIE5PVEU6IE5vIGVmZmVjdCBvbiBoZWFkbGVzcyBjb250ZXh0c1xuICAvLyBAcGFyYW0ge051bWJlcn0gd2lkdGgsIGhlaWdodCAtIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IG9mIGNhbnZhcyBpbiBDU1MgY29vcmRpbmF0ZXNcbiAgX3Jlc2l6ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge2NhbnZhc30gPSB0aGlzLl9jb250ZXh0O1xuICAgIC8vIGlmIChjYW52YXMpIHtcbiAgICAvLyAgIC8vIExvb2t1cCB0aGUgc2l6ZSB0aGUgYnJvd3NlciBpcyBkaXNwbGF5aW5nIHRoZSBjYW52YXMuXG4gICAgLy8gICB2YXIgZGlzcGxheVdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIC8vICAgdmFyIGRpc3BsYXlIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuXG4gICAgLy8gICAvLyBDaGVjayBpZiB0aGUgY2FudmFzIGlzIG5vdCB0aGUgc2FtZSBzaXplLlxuICAgIC8vICAgaWYgKGNhbnZhcy53aWR0aCAgIT09IGRpc3BsYXlXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkaXNwbGF5SGVpZ2h0KSB7XG4gICAgLy8gICAgIC8vIE1ha2UgdGhlIGNhbnZhcyB0aGUgc2FtZSBzaXplXG4gICAgLy8gICAgIGNhbnZhcy53aWR0aCAgPSBkaXNwbGF5V2lkdGg7XG4gICAgLy8gICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVzaXplRHJhd2luZ0J1ZmZlcikge1xuICAgICAgICBjb25zdCBjc3NUb0RldmljZVBpeGVscyA9IHRoaXMudXNlRGV2aWNlUGl4ZWxSYXRpbyA/XG4gICAgICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSA6IDE7XG5cbiAgICAgICAgLy8gTG9va3VwIHRoZSBzaXplIHRoZSBicm93c2VyIGlzIGRpc3BsYXlpbmcgdGhlIGNhbnZhcyBpbiBDU1MgcGl4ZWxzXG4gICAgICAgIC8vIGFuZCBjb21wdXRlIGEgc2l6ZSBuZWVkZWQgdG8gbWFrZSBvdXIgZHJhd2luZ2J1ZmZlciBtYXRjaCBpdCBpblxuICAgICAgICAvLyBkZXZpY2UgcGl4ZWxzLlxuICAgICAgICBjb25zdCBkaXNwbGF5V2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogY3NzVG9EZXZpY2VQaXhlbHMpO1xuICAgICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBjc3NUb0RldmljZVBpeGVscyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNhbnZhcyBpcyBub3QgdGhlIHNhbWUgc2l6ZS5cbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gZGlzcGxheVdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRpc3BsYXlIZWlnaHQpIHtcbiAgICAgICAgICAvLyBNYWtlIHRoZSBjYW52YXMgdGhlIHNhbWUgc2l6ZVxuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSZXNpemUgdGhlIHJlbmRlciBidWZmZXIgb2YgdGhlIGNhbnZhcyB0byBtYXRjaCBjYW52YXMgY2xpZW50IHNpemVcbiAgLy8gbXVsdGlwbHlpbmcgd2l0aCBkcHIgKE9wdGlvbmFsbHkgY2FuIGJlIHR1cm5lZCBvZmYpXG4gIC8vIGh0dHA6Ly93ZWJnbDJmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtcmVzaXppbmctdGhlLWNhbnZhcy5odG1sXG4gIF9yZXNpemVDYW52YXNEcmF3aW5nQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmF1dG9SZXNpemVEcmF3aW5nQnVmZmVyKSB7XG4gICAgICBjb25zdCB7Y2FudmFzfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICBjb25zdCBjc3NUb0RldmljZVBpeGVscyA9IHRoaXMudXNlRGV2aWNlUGl4ZWxSYXRpbyA/XG4gICAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEgOiAxO1xuXG4gICAgICAvLyBMb29rdXAgdGhlIHNpemUgdGhlIGJyb3dzZXIgaXMgZGlzcGxheWluZyB0aGUgY2FudmFzIGluIENTUyBwaXhlbHNcbiAgICAgIC8vIGFuZCBjb21wdXRlIGEgc2l6ZSBuZWVkZWQgdG8gbWFrZSBvdXIgZHJhd2luZ2J1ZmZlciBtYXRjaCBpdCBpblxuICAgICAgLy8gZGV2aWNlIHBpeGVscy5cbiAgICAgIGNvbnN0IG9sZFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBvbGRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjb25zdCBkaXNwbGF5V2lkdGggPSBNYXRoLmZsb29yKG9sZFdpZHRoICogY3NzVG9EZXZpY2VQaXhlbHMpO1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IE1hdGguZmxvb3Iob2xkSGVpZ2h0ICogY3NzVG9EZXZpY2VQaXhlbHMpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY2FudmFzIGlzIG5vdCB0aGUgc2FtZSBzaXplLlxuICAgICAgaWYgKG9sZFdpZHRoICE9PSBkaXNwbGF5V2lkdGggfHwgb2xkSGVpZ2h0ICE9PSBkaXNwbGF5SGVpZ2h0KSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIGNhbnZhcyB0aGUgc2FtZSBzaXplXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9sZFdpZHRoO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgY2FudmFzIGRyYXdpbmcgYnVmZmVyXG4gICAqIE5PVEU6IFRoZSBkcmF3aW5nIGJ1ZmZlciB3aWxsIGJlIHNjYWxlZCB0byB0aGUgdmlld3BvcnRcbiAgICogZm9yIGJlc3QgdmlzdWFsIHJlc3VsdHMsIHVzdWFsbHkgc2V0IHRvIGVpdGhlcjpcbiAgICogIGNhbnZhcyBDU1Mgd2lkdGggeCBjYW52YXMgQ1NTIGhlaWdodFxuICAgKiAgY2FudmFzIENTUyB3aWR0aCAqIGRldmljZVBpeGVsUmF0aW8geCBjYW52YXMgQ1NTIGhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9cbiAgICogVE9ETyAtIGFkZCBzZXBhcmF0ZSBjYWxsIGZvciBoZWFkbGVzcyBjb250ZXh0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBuZXcgd2lkdGggb2YgY2FudmFzIGluIENTUyBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gbmV3IGhlaWdodCBvZiBjYW52YXMgaW4gQ1NTIGNvb3JkaW5hdGVzXG4gICAqIEByZXR1cm4ge1JlbmRlcmVyfSAtIHJldHVybnMgc2VsZiBmb3IgY2hhaW5pbmdcbiAgICovXG4gIF9yZXNpemVEcmF3aW5nQnVmZmVyKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7Y2FudmFzfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5hdXRvUmVzaXplRHJhd2luZ0J1ZmZlciA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIl19

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickModels = pickModels;

var _webgl = __webpack_require__(20);

var _group = __webpack_require__(49);

var _group2 = _interopRequireDefault(_group);

var _assert = __webpack_require__(0);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ILLEGAL_ARG = 'Illegal argument to pick'; // TODO - this is the new picking for deck.gl
/* eslint-disable max-statements, no-try-catch */
/* global window */
function pickModels(gl, _ref) {
  var group = _ref.group,
      uniforms = _ref.uniforms,
      x = _ref.x,
      y = _ref.y,
      _ref$framebuffer = _ref.framebuffer,
      framebuffer = _ref$framebuffer === undefined ? null : _ref$framebuffer,
      _ref$pickingFBO = _ref.pickingFBO,
      pickingFBO = _ref$pickingFBO === undefined ? null : _ref$pickingFBO,
      _ref$pickingProgram = _ref.pickingProgram,
      pickingProgram = _ref$pickingProgram === undefined ? null : _ref$pickingProgram,
      _ref$pickingColors = _ref.pickingColors,
      pickingColors = _ref$pickingColors === undefined ? null : _ref$pickingColors;

  (0, _assert2.default)((0, _webgl.isWebGLContext)(gl), ILLEGAL_ARG);
  (0, _assert2.default)(group instanceof _group2.default, ILLEGAL_ARG);

  var dpr = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * dpr;
  var deviceY = gl.canvas.height - y * dpr;

  // Set up a frame buffer if needed
  // TODO - cache picking fbo (needs to be resized)?
  framebuffer = framebuffer || pickingFBO || new _webgl.Framebuffer(gl, {
    width: gl.canvas.width,
    height: gl.canvas.height
  });

  framebuffer.resize({ width: gl.canvas.width, height: gl.canvas.height });

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  return (0, _webgl.glContextWithState)(gl, {
    framebuffer: framebuffer,
    // We are only interested in one pixel, no need to render anything else
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {
    return group.traverseReverse(function (model) {
      if (model.isPickable()) {

        // Clear the frame buffer, render and sample
        gl.clear(_webgl.GL.COLOR_BUFFER_BIT | _webgl.GL.DEPTH_BUFFER_BIT);

        model.setUniforms({
          renderPickingBuffer: 1,
          enablePicking: true
        });

        model.render(uniforms);

        model.setUniforms({
          renderPickingBuffer: false,
          enablePicking: false
        });

        // Read color in the central pixel, to be mapped with picking colors
        var color = new Uint8Array(4);
        gl.readPixels(deviceX, deviceY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, color);

        var isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0 || color[3] !== 0;

        // Add the information to the stack
        if (isPicked) {
          return {
            model: model,
            color: color,
            x: x,
            y: y,
            deviceX: deviceX,
            deviceY: deviceY
          };
        }
      }
      return null;
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NjZW5lZ3JhcGgvcGljay5qcyJdLCJuYW1lcyI6WyJwaWNrTW9kZWxzIiwiSUxMRUdBTF9BUkciLCJnbCIsImdyb3VwIiwidW5pZm9ybXMiLCJ4IiwieSIsImZyYW1lYnVmZmVyIiwicGlja2luZ0ZCTyIsInBpY2tpbmdQcm9ncmFtIiwicGlja2luZ0NvbG9ycyIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsIndpZHRoIiwicmVzaXplIiwic2Npc3NvclRlc3QiLCJ3IiwiaCIsInRyYXZlcnNlUmV2ZXJzZSIsIm1vZGVsIiwiaXNQaWNrYWJsZSIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJzZXRVbmlmb3JtcyIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJlbmFibGVQaWNraW5nIiwicmVuZGVyIiwiY29sb3IiLCJVaW50OEFycmF5IiwicmVhZFBpeGVscyIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwiaXNQaWNrZWQiXSwibWFwcGluZ3MiOiI7Ozs7O1FBU2dCQSxVLEdBQUFBLFU7O0FBTmhCOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU1DLGNBQWMsMEJBQXBCLEMsQ0FQQTtBQUNBO0FBQ0E7QUFPTyxTQUFTRCxVQUFULENBQW9CRSxFQUFwQixRQVNKO0FBQUEsTUFSREMsS0FRQyxRQVJEQSxLQVFDO0FBQUEsTUFQREMsUUFPQyxRQVBEQSxRQU9DO0FBQUEsTUFOREMsQ0FNQyxRQU5EQSxDQU1DO0FBQUEsTUFMREMsQ0FLQyxRQUxEQSxDQUtDO0FBQUEsOEJBSkRDLFdBSUM7QUFBQSxNQUpEQSxXQUlDLG9DQUphLElBSWI7QUFBQSw2QkFIREMsVUFHQztBQUFBLE1BSERBLFVBR0MsbUNBSFksSUFHWjtBQUFBLGlDQUZEQyxjQUVDO0FBQUEsTUFGREEsY0FFQyx1Q0FGZ0IsSUFFaEI7QUFBQSxnQ0FEREMsYUFDQztBQUFBLE1BRERBLGFBQ0Msc0NBRGUsSUFDZjs7QUFDRCx3QkFBTywyQkFBZVIsRUFBZixDQUFQLEVBQTJCRCxXQUEzQjtBQUNBLHdCQUFPRSxnQ0FBUCxFQUErQkYsV0FBL0I7O0FBRUEsTUFBTVUsTUFBTSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxPQUFPQyxnQkFBdkMsR0FBMEQsQ0FBdEU7QUFDQSxNQUFNQyxVQUFVVCxJQUFJTSxHQUFwQjtBQUNBLE1BQU1JLFVBQVViLEdBQUdjLE1BQUgsQ0FBVUMsTUFBVixHQUFtQlgsSUFBSUssR0FBdkM7O0FBRUE7QUFDQTtBQUNBSixnQkFBY0EsZUFBZUMsVUFBZixJQUE2Qix1QkFBZ0JOLEVBQWhCLEVBQW9CO0FBQzdEZ0IsV0FBT2hCLEdBQUdjLE1BQUgsQ0FBVUUsS0FENEM7QUFFN0RELFlBQVFmLEdBQUdjLE1BQUgsQ0FBVUM7QUFGMkMsR0FBcEIsQ0FBM0M7O0FBS0FWLGNBQVlZLE1BQVosQ0FBbUIsRUFBQ0QsT0FBT2hCLEdBQUdjLE1BQUgsQ0FBVUUsS0FBbEIsRUFBeUJELFFBQVFmLEdBQUdjLE1BQUgsQ0FBVUMsTUFBM0MsRUFBbkI7O0FBRUE7QUFDQSxTQUFPLCtCQUFtQmYsRUFBbkIsRUFBdUI7QUFDNUJLLDRCQUQ0QjtBQUU1QjtBQUNBYSxpQkFBYSxFQUFDZixHQUFHUyxPQUFKLEVBQWFSLEdBQUdTLE9BQWhCLEVBQXlCTSxHQUFHLENBQTVCLEVBQStCQyxHQUFHLENBQWxDO0FBSGUsR0FBdkIsRUFJSixZQUFNO0FBQ1AsV0FBT25CLE1BQU1vQixlQUFOLENBQXNCLGlCQUFTO0FBQ3BDLFVBQUlDLE1BQU1DLFVBQU4sRUFBSixFQUF3Qjs7QUFFdEI7QUFDQXZCLFdBQUd3QixLQUFILENBQVMsVUFBR0MsZ0JBQUgsR0FBc0IsVUFBR0MsZ0JBQWxDOztBQUVBSixjQUFNSyxXQUFOLENBQWtCO0FBQ2hCQywrQkFBcUIsQ0FETDtBQUVoQkMseUJBQWU7QUFGQyxTQUFsQjs7QUFLQVAsY0FBTVEsTUFBTixDQUFhNUIsUUFBYjs7QUFFQW9CLGNBQU1LLFdBQU4sQ0FBa0I7QUFDaEJDLCtCQUFxQixLQURMO0FBRWhCQyx5QkFBZTtBQUZDLFNBQWxCOztBQUtBO0FBQ0EsWUFBTUUsUUFBUSxJQUFJQyxVQUFKLENBQWUsQ0FBZixDQUFkO0FBQ0FoQyxXQUFHaUMsVUFBSCxDQUNFckIsT0FERixFQUNXQyxPQURYLEVBQ29CLENBRHBCLEVBQ3VCLENBRHZCLEVBQzBCYixHQUFHa0MsSUFEN0IsRUFDbUNsQyxHQUFHbUMsYUFEdEMsRUFDcURKLEtBRHJEOztBQUlBLFlBQU1LLFdBQ0pMLE1BQU0sQ0FBTixNQUFhLENBQWIsSUFBa0JBLE1BQU0sQ0FBTixNQUFhLENBQS9CLElBQW9DQSxNQUFNLENBQU4sTUFBYSxDQUFqRCxJQUFzREEsTUFBTSxDQUFOLE1BQWEsQ0FEckU7O0FBR0E7QUFDQSxZQUFJSyxRQUFKLEVBQWM7QUFDWixpQkFBTztBQUNMZCx3QkFESztBQUVMUyx3QkFGSztBQUdMNUIsZ0JBSEs7QUFJTEMsZ0JBSks7QUFLTFEsNEJBTEs7QUFNTEM7QUFOSyxXQUFQO0FBUUQ7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNELEtBeENNLENBQVA7QUF5Q0QsR0E5Q00sQ0FBUDtBQStDRCIsImZpbGUiOiJwaWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyAtIHRoaXMgaXMgdGhlIG5ldyBwaWNraW5nIGZvciBkZWNrLmdsXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgbm8tdHJ5LWNhdGNoICovXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBnbENvbnRleHRXaXRoU3RhdGUsIEZyYW1lYnVmZmVyLCBpc1dlYkdMQ29udGV4dH0gZnJvbSAnLi4vLi4vd2ViZ2wnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vZ3JvdXAnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBJTExFR0FMX0FSRyA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIHBpY2snO1xuXG5leHBvcnQgZnVuY3Rpb24gcGlja01vZGVscyhnbCwge1xuICBncm91cCxcbiAgdW5pZm9ybXMsXG4gIHgsXG4gIHksXG4gIGZyYW1lYnVmZmVyID0gbnVsbCxcbiAgcGlja2luZ0ZCTyA9IG51bGwsXG4gIHBpY2tpbmdQcm9ncmFtID0gbnVsbCxcbiAgcGlja2luZ0NvbG9ycyA9IG51bGxcbn0pIHtcbiAgYXNzZXJ0KGlzV2ViR0xDb250ZXh0KGdsKSwgSUxMRUdBTF9BUkcpO1xuICBhc3NlcnQoZ3JvdXAgaW5zdGFuY2VvZiBHcm91cCwgSUxMRUdBTF9BUkcpO1xuXG4gIGNvbnN0IGRwciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBkZXZpY2VYID0geCAqIGRwcjtcbiAgY29uc3QgZGV2aWNlWSA9IGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogZHByO1xuXG4gIC8vIFNldCB1cCBhIGZyYW1lIGJ1ZmZlciBpZiBuZWVkZWRcbiAgLy8gVE9ETyAtIGNhY2hlIHBpY2tpbmcgZmJvIChuZWVkcyB0byBiZSByZXNpemVkKT9cbiAgZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlciB8fCBwaWNraW5nRkJPIHx8IG5ldyBGcmFtZWJ1ZmZlcihnbCwge1xuICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0XG4gIH0pO1xuXG4gIGZyYW1lYnVmZmVyLnJlc2l6ZSh7d2lkdGg6IGdsLmNhbnZhcy53aWR0aCwgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0fSk7XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHNjaXNzb3IgdGVzdCBhbmQgZmJvIGJpbmRpbmdzIGluIGNhc2Ugb2YgZXhjZXB0aW9uc1xuICByZXR1cm4gZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVidWZmZXIsXG4gICAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgICBzY2lzc29yVGVzdDoge3g6IGRldmljZVgsIHk6IGRldmljZVksIHc6IDEsIGg6IDF9XG4gIH0sICgpID0+IHtcbiAgICByZXR1cm4gZ3JvdXAudHJhdmVyc2VSZXZlcnNlKG1vZGVsID0+IHtcbiAgICAgIGlmIChtb2RlbC5pc1BpY2thYmxlKCkpIHtcblxuICAgICAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyLCByZW5kZXIgYW5kIHNhbXBsZVxuICAgICAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgbW9kZWwuc2V0VW5pZm9ybXMoe1xuICAgICAgICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IDEsXG4gICAgICAgICAgZW5hYmxlUGlja2luZzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuXG4gICAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHtcbiAgICAgICAgICByZW5kZXJQaWNraW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICBlbmFibGVQaWNraW5nOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKFxuICAgICAgICAgIGRldmljZVgsIGRldmljZVksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNvbG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaXNQaWNrZWQgPVxuICAgICAgICAgIGNvbG9yWzBdICE9PSAwIHx8IGNvbG9yWzFdICE9PSAwIHx8IGNvbG9yWzJdICE9PSAwIHx8IGNvbG9yWzNdICE9PSAwO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaW5mb3JtYXRpb24gdG8gdGhlIHN0YWNrXG4gICAgICAgIGlmIChpc1BpY2tlZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBkZXZpY2VYLFxuICAgICAgICAgICAgZGV2aWNlWVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9KTtcbn1cbiJdfQ==

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defaultVertex = __webpack_require__(223);

var _defaultVertex2 = _interopRequireDefault(_defaultVertex);

var _defaultFragment = __webpack_require__(221);

var _defaultFragment2 = _interopRequireDefault(_defaultFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default Shaders
var defaultUniforms = __webpack_require__(222);

exports.default = {
  vs: _defaultVertex2.default,
  fs: _defaultFragment2.default,
  defaultUniforms: defaultUniforms
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NoYWRlcmxpYi9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0VW5pZm9ybXMiLCJyZXF1aXJlIiwidnMiLCJmcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRkE7QUFHQSxJQUFNQSxrQkFBa0JDLFFBQVEsb0JBQVIsQ0FBeEI7O2tCQUVlO0FBQ2JDLDZCQURhO0FBRWJDLCtCQUZhO0FBR2JIO0FBSGEsQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgU2hhZGVyc1xuaW1wb3J0IHZzIGZyb20gJy4vZGVmYXVsdC12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9kZWZhdWx0LWZyYWdtZW50Lmdsc2wnO1xuY29uc3QgZGVmYXVsdFVuaWZvcm1zID0gcmVxdWlyZSgnLi9kZWZhdWx0LXVuaWZvcm1zJyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdnMsXG4gIGZzLFxuICBkZWZhdWx0VW5pZm9ybXNcbn07XG4iXX0=

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = fp64ify;
function fp64ify(a) {
  var hi = Math.fround(a);
  var lo = a - Math.fround(a);
  return new Float32Array([hi, lo]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvZnA2NC9tYXRoLWZwNjQuanMiXSwibmFtZXMiOlsiZnA2NGlmeSIsImEiLCJoaSIsIk1hdGgiLCJmcm91bmQiLCJsbyIsIkZsb2F0MzJBcnJheSJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTQSxPQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUN6QixNQUFNQyxLQUFLQyxLQUFLQyxNQUFMLENBQVlILENBQVosQ0FBWDtBQUNBLE1BQU1JLEtBQUtKLElBQUlFLEtBQUtDLE1BQUwsQ0FBWUgsQ0FBWixDQUFmO0FBQ0EsU0FBTyxJQUFJSyxZQUFKLENBQWlCLENBQUNKLEVBQUQsRUFBS0csRUFBTCxDQUFqQixDQUFQO0FBQ0QiLCJmaWxlIjoibWF0aC1mcDY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGZwNjRpZnkoYSkge1xuICBjb25zdCBoaSA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsbyA9IGEgLSBNYXRoLmZyb3VuZChhKTtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW2hpLCBsb10pO1xufVxuIl19

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__register_shaders__ = __webpack_require__(96);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__register_shaders__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__assemble_shaders__ = __webpack_require__(234);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__assemble_shaders__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_cache__ = __webpack_require__(235);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__shader_cache__["a"]; });



//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLXRvb2xzL2luZGV4LmpzIl0sIm5hbWVzIjpbInJlZ2lzdGVyU2hhZGVyTW9kdWxlcyIsImFzc2VtYmxlU2hhZGVycyIsImRlZmF1bHQiLCJTaGFkZXJDYWNoZSJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEscUJBQVIsUUFBb0Msb0JBQXBDO0FBQ0EsU0FBUUMsZUFBUixRQUE4QixvQkFBOUI7QUFDQSxTQUFRQyxXQUFXQyxXQUFuQixRQUFxQyxnQkFBckMiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge3JlZ2lzdGVyU2hhZGVyTW9kdWxlc30gZnJvbSAnLi9yZWdpc3Rlci1zaGFkZXJzJztcbmV4cG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuL2Fzc2VtYmxlLXNoYWRlcnMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNoYWRlckNhY2hlfSBmcm9tICcuL3NoYWRlci1jYWNoZSc7XG4iXX0=

/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = registerShaderModules;
/* harmony export (immutable) */ __webpack_exports__["b"] = getShaderModule;
/* harmony export (immutable) */ __webpack_exports__["c"] = getShaderDependencies;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);


var shaderModules = {};

/**
 * Registers an array of shader modules
 * @param {Object[]} shaderModuleList - Array of shader modules
 */
function registerShaderModules(shaderModuleList) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = shaderModuleList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var shaderModule = _step.value;

      __WEBPACK_IMPORTED_MODULE_0_assert___default()(shaderModule.name, 'shader module has no name');
      if (shaderModules[shaderModule.name]) {
        throw new Error('shader module ' + shaderModule.name + ' already registered');
      }
      shaderModules[shaderModule.name] = shaderModule;
      shaderModule.dependencies = shaderModule.dependencies || [];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function getShaderModule(moduleName) {
  var shaderModule = shaderModules[moduleName];
  if (!shaderModule) {
    // console.log(`${moduleName} not in registered modules:`, shaderModules);
    __WEBPACK_IMPORTED_MODULE_0_assert___default()(false, 'Unknown shader module ' + moduleName);
  }
  return shaderModule;
}

/**
 * Takes a list of shader module names and returns a new list of
 * shader module names that includes all dependencies, sorted so
 * that modules that are dependencies of other modules come first.
 *
 * If the shader glsl code from the returned modules is concatenated
 * in the reverse order, it is guaranteed that all functions be resolved and
 * that all function and variable definitions come before use.
 *
 * @param {String[]} moduleNames - Array of module names
 * @return {String[]} - Array of modules
 */
function getShaderDependencies(moduleNames) {
  var result = {};
  getDependencyGraph({
    moduleNames: moduleNames,
    level: 0,
    result: result
  });
  return Object.keys(result).sort(function (a, b) {
    return result[a] - result[b];
  });
}

// Adds another level of dependencies to the result map
function getDependencyGraph(_ref) {
  var moduleNames = _ref.moduleNames,
      level = _ref.level,
      result = _ref.result;

  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = moduleNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var moduleName = _step2.value;

      result[moduleName] = level;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = moduleNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _moduleName = _step3.value;

      var shaderModule = getShaderModule(_moduleName);

      getDependencyGraph({
        moduleNames: shaderModule.dependencies,
        level: level,
        result: result
      });
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLXRvb2xzL3JlZ2lzdGVyLXNoYWRlcnMuanMiXSwibmFtZXMiOlsiYXNzZXJ0Iiwic2hhZGVyTW9kdWxlcyIsInJlZ2lzdGVyU2hhZGVyTW9kdWxlcyIsInNoYWRlck1vZHVsZUxpc3QiLCJzaGFkZXJNb2R1bGUiLCJuYW1lIiwiRXJyb3IiLCJkZXBlbmRlbmNpZXMiLCJnZXRTaGFkZXJNb2R1bGUiLCJtb2R1bGVOYW1lIiwiZ2V0U2hhZGVyRGVwZW5kZW5jaWVzIiwibW9kdWxlTmFtZXMiLCJyZXN1bHQiLCJnZXREZXBlbmRlbmN5R3JhcGgiLCJsZXZlbCIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwiYSIsImIiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsSUFBTUMsZ0JBQWdCLEVBQXRCOztBQUVBOzs7O0FBSUEsT0FBTyxTQUFTQyxxQkFBVCxDQUErQkMsZ0JBQS9CLEVBQWlEO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ3RELHlCQUEyQkEsZ0JBQTNCLDhIQUE2QztBQUFBLFVBQWxDQyxZQUFrQzs7QUFDM0NKLGFBQU9JLGFBQWFDLElBQXBCLEVBQTBCLDJCQUExQjtBQUNBLFVBQUlKLGNBQWNHLGFBQWFDLElBQTNCLENBQUosRUFBc0M7QUFDcEMsY0FBTSxJQUFJQyxLQUFKLG9CQUEyQkYsYUFBYUMsSUFBeEMseUJBQU47QUFDRDtBQUNESixvQkFBY0csYUFBYUMsSUFBM0IsSUFBbUNELFlBQW5DO0FBQ0FBLG1CQUFhRyxZQUFiLEdBQTRCSCxhQUFhRyxZQUFiLElBQTZCLEVBQXpEO0FBQ0Q7QUFScUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVN2RDs7QUFFRCxPQUFPLFNBQVNDLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDO0FBQzFDLE1BQU1MLGVBQWVILGNBQWNRLFVBQWQsQ0FBckI7QUFDQSxNQUFJLENBQUNMLFlBQUwsRUFBbUI7QUFDakI7QUFDQUosV0FBTyxLQUFQLDZCQUF1Q1MsVUFBdkM7QUFDRDtBQUNELFNBQU9MLFlBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsT0FBTyxTQUFTTSxxQkFBVCxDQUErQkMsV0FBL0IsRUFBNEM7QUFDakQsTUFBTUMsU0FBUyxFQUFmO0FBQ0FDLHFCQUFtQjtBQUNqQkYsNEJBRGlCO0FBRWpCRyxXQUFPLENBRlU7QUFHakJGO0FBSGlCLEdBQW5CO0FBS0EsU0FBT0csT0FBT0MsSUFBUCxDQUFZSixNQUFaLEVBQW9CSyxJQUFwQixDQUF5QixVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxXQUFVUCxPQUFPTSxDQUFQLElBQVlOLE9BQU9PLENBQVAsQ0FBdEI7QUFBQSxHQUF6QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTTixrQkFBVCxPQUEwRDtBQUFBLE1BQTdCRixXQUE2QixRQUE3QkEsV0FBNkI7QUFBQSxNQUFoQkcsS0FBZ0IsUUFBaEJBLEtBQWdCO0FBQUEsTUFBVEYsTUFBUyxRQUFUQSxNQUFTOztBQUN4RCxNQUFJRSxTQUFTLENBQWIsRUFBZ0I7QUFDZCxVQUFNLElBQUlSLEtBQUosQ0FBVSwwQ0FBVixDQUFOO0FBQ0Q7QUFIdUQ7QUFBQTtBQUFBOztBQUFBO0FBSXhELDBCQUF5QkssV0FBekIsbUlBQXNDO0FBQUEsVUFBM0JGLFVBQTJCOztBQUNwQ0csYUFBT0gsVUFBUCxJQUFxQkssS0FBckI7QUFDRDtBQU51RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQVF4RCwwQkFBeUJILFdBQXpCLG1JQUFzQztBQUFBLFVBQTNCRixXQUEyQjs7QUFDcEMsVUFBTUwsZUFBZUksZ0JBQWdCQyxXQUFoQixDQUFyQjs7QUFFQUkseUJBQW1CO0FBQ2pCRixxQkFBYVAsYUFBYUcsWUFEVDtBQUVqQk8sb0JBRmlCO0FBR2pCRjtBQUhpQixPQUFuQjtBQUtEO0FBaEJ1RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWtCeEQsU0FBT0EsTUFBUDtBQUNEIiwiZmlsZSI6InJlZ2lzdGVyLXNoYWRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IHNoYWRlck1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYXJyYXkgb2Ygc2hhZGVyIG1vZHVsZXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IHNoYWRlck1vZHVsZUxpc3QgLSBBcnJheSBvZiBzaGFkZXIgbW9kdWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJTaGFkZXJNb2R1bGVzKHNoYWRlck1vZHVsZUxpc3QpIHtcbiAgZm9yIChjb25zdCBzaGFkZXJNb2R1bGUgb2Ygc2hhZGVyTW9kdWxlTGlzdCkge1xuICAgIGFzc2VydChzaGFkZXJNb2R1bGUubmFtZSwgJ3NoYWRlciBtb2R1bGUgaGFzIG5vIG5hbWUnKTtcbiAgICBpZiAoc2hhZGVyTW9kdWxlc1tzaGFkZXJNb2R1bGUubmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2hhZGVyIG1vZHVsZSAke3NoYWRlck1vZHVsZS5uYW1lfSBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICB9XG4gICAgc2hhZGVyTW9kdWxlc1tzaGFkZXJNb2R1bGUubmFtZV0gPSBzaGFkZXJNb2R1bGU7XG4gICAgc2hhZGVyTW9kdWxlLmRlcGVuZGVuY2llcyA9IHNoYWRlck1vZHVsZS5kZXBlbmRlbmNpZXMgfHwgW107XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYWRlck1vZHVsZShtb2R1bGVOYW1lKSB7XG4gIGNvbnN0IHNoYWRlck1vZHVsZSA9IHNoYWRlck1vZHVsZXNbbW9kdWxlTmFtZV07XG4gIGlmICghc2hhZGVyTW9kdWxlKSB7XG4gICAgLy8gY29uc29sZS5sb2coYCR7bW9kdWxlTmFtZX0gbm90IGluIHJlZ2lzdGVyZWQgbW9kdWxlczpgLCBzaGFkZXJNb2R1bGVzKTtcbiAgICBhc3NlcnQoZmFsc2UsIGBVbmtub3duIHNoYWRlciBtb2R1bGUgJHttb2R1bGVOYW1lfWApO1xuICB9XG4gIHJldHVybiBzaGFkZXJNb2R1bGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIHNoYWRlciBtb2R1bGUgbmFtZXMgYW5kIHJldHVybnMgYSBuZXcgbGlzdCBvZlxuICogc2hhZGVyIG1vZHVsZSBuYW1lcyB0aGF0IGluY2x1ZGVzIGFsbCBkZXBlbmRlbmNpZXMsIHNvcnRlZCBzb1xuICogdGhhdCBtb2R1bGVzIHRoYXQgYXJlIGRlcGVuZGVuY2llcyBvZiBvdGhlciBtb2R1bGVzIGNvbWUgZmlyc3QuXG4gKlxuICogSWYgdGhlIHNoYWRlciBnbHNsIGNvZGUgZnJvbSB0aGUgcmV0dXJuZWQgbW9kdWxlcyBpcyBjb25jYXRlbmF0ZWRcbiAqIGluIHRoZSByZXZlcnNlIG9yZGVyLCBpdCBpcyBndWFyYW50ZWVkIHRoYXQgYWxsIGZ1bmN0aW9ucyBiZSByZXNvbHZlZCBhbmRcbiAqIHRoYXQgYWxsIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZSBkZWZpbml0aW9ucyBjb21lIGJlZm9yZSB1c2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmdbXX0gbW9kdWxlTmFtZXMgLSBBcnJheSBvZiBtb2R1bGUgbmFtZXNcbiAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIEFycmF5IG9mIG1vZHVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYWRlckRlcGVuZGVuY2llcyhtb2R1bGVOYW1lcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZ2V0RGVwZW5kZW5jeUdyYXBoKHtcbiAgICBtb2R1bGVOYW1lcyxcbiAgICBsZXZlbDogMCxcbiAgICByZXN1bHRcbiAgfSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHQpLnNvcnQoKGEsIGIpID0+IHJlc3VsdFthXSAtIHJlc3VsdFtiXSk7XG59XG5cbi8vIEFkZHMgYW5vdGhlciBsZXZlbCBvZiBkZXBlbmRlbmNpZXMgdG8gdGhlIHJlc3VsdCBtYXBcbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lHcmFwaCh7bW9kdWxlTmFtZXMsIGxldmVsLCByZXN1bHR9KSB7XG4gIGlmIChsZXZlbCA+PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb3NzaWJsZSBsb29wIGluIHNoYWRlciBkZXBlbmRlbmN5IGdyYXBoJyk7XG4gIH1cbiAgZm9yIChjb25zdCBtb2R1bGVOYW1lIG9mIG1vZHVsZU5hbWVzKSB7XG4gICAgcmVzdWx0W21vZHVsZU5hbWVdID0gbGV2ZWw7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1vZHVsZU5hbWUgb2YgbW9kdWxlTmFtZXMpIHtcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSBnZXRTaGFkZXJNb2R1bGUobW9kdWxlTmFtZSk7XG5cbiAgICBnZXREZXBlbmRlbmN5R3JhcGgoe1xuICAgICAgbW9kdWxlTmFtZXM6IHNoYWRlck1vZHVsZS5kZXBlbmRlbmNpZXMsXG4gICAgICBsZXZlbCxcbiAgICAgIHJlc3VsdFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__truncated_cone_geometry__ = __webpack_require__(32);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var ConeGeometry = function (_TruncatedConeGeometr) {
  _inherits(ConeGeometry, _TruncatedConeGeometr);

  function ConeGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ConeGeometry);

    var _opts$radius = opts.radius,
        radius = _opts$radius === undefined ? 1 : _opts$radius,
        _opts$cap = opts.cap,
        cap = _opts$cap === undefined ? true : _opts$cap;
    return _possibleConstructorReturn(this, (ConeGeometry.__proto__ || Object.getPrototypeOf(ConeGeometry)).call(this, Object.assign({}, opts, {
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    })));
  }

  return ConeGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__truncated_cone_geometry__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ConeGeometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9jb25lLWdlb21ldHJ5LmpzIl0sIm5hbWVzIjpbIlRydW5jYXRlZENvbmVHZW9tZXRyeSIsIkNvbmVHZW9tZXRyeSIsIm9wdHMiLCJyYWRpdXMiLCJjYXAiLCJPYmplY3QiLCJhc3NpZ24iLCJ0b3BSYWRpdXMiLCJ0b3BDYXAiLCJCb29sZWFuIiwiYm90dG9tQ2FwIiwiYm90dG9tUmFkaXVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPQSxxQkFBUCxNQUFrQywyQkFBbEM7O0lBRXFCQyxZOzs7QUFDbkIsMEJBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLHVCQUNZQSxJQURaLENBQ2RDLE1BRGM7QUFBQSxRQUNkQSxNQURjLGdDQUNMLENBREs7QUFBQSxvQkFDWUQsSUFEWixDQUNGRSxHQURFO0FBQUEsUUFDRkEsR0FERSw2QkFDSSxJQURKO0FBQUEsdUhBRWZDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCSixJQUFsQixFQUF3QjtBQUM1QkssaUJBQVcsQ0FEaUI7QUFFNUJDLGNBQVFDLFFBQVFMLEdBQVIsQ0FGb0I7QUFHNUJNLGlCQUFXRCxRQUFRTCxHQUFSLENBSGlCO0FBSTVCTyxvQkFBY1I7QUFKYyxLQUF4QixDQUZlO0FBUXRCOzs7RUFUdUNILHFCOztlQUFyQkMsWSIsImZpbGUiOiJjb25lLWdlb21ldHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRydW5jYXRlZENvbmVHZW9tZXRyeSBmcm9tICcuL3RydW5jYXRlZC1jb25lLWdlb21ldHJ5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZUdlb21ldHJ5IGV4dGVuZHMgVHJ1bmNhdGVkQ29uZUdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge3JhZGl1cyA9IDEsIGNhcCA9IHRydWV9ID0gb3B0cztcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICB0b3BSYWRpdXM6IDAsXG4gICAgICB0b3BDYXA6IEJvb2xlYW4oY2FwKSxcbiAgICAgIGJvdHRvbUNhcDogQm9vbGVhbihjYXApLFxuICAgICAgYm90dG9tUmFkaXVzOiByYWRpdXNcbiAgICB9KSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var CubeGeometry = function (_Geometry) {
  _inherits(CubeGeometry, _Geometry);

  function CubeGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CubeGeometry);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["uid"])('cube-geometry') : _opts$id;
    return _possibleConstructorReturn(this, (CubeGeometry.__proto__ || Object.getPrototypeOf(CubeGeometry)).call(this, Object.assign({}, opts, { id: id, attributes: getCubeAttributes() })));
  }

  return CubeGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */]);

/* eslint-disable no-multi-spaces, indent */


/* harmony default export */ __webpack_exports__["a"] = (CubeGeometry);
var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);

var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);

var CUBE_NORMALS = new Float32Array([
// Front face
0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,

// Back face
0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,

// Top face
0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,

// Bottom face
0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,

// Right face
1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,

// Left face
-1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);

var CUBE_TEX_COORDS = new Float32Array([
// Front face
0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

// Back face
1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,

// Top face
0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0,

// Bottom face
1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,

// Right face
1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,

// Left face
0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]);
/* eslint-enable no-multi-spaces, indent */

function getCubeAttributes() {
  return {
    indices: new Uint16Array(CUBE_INDICES),
    positions: new Float32Array(CUBE_POSITIONS),
    normals: new Float32Array(CUBE_NORMALS),
    texCoords: new Float32Array(CUBE_TEX_COORDS)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9jdWJlLWdlb21ldHJ5LmpzIl0sIm5hbWVzIjpbIkdlb21ldHJ5IiwidWlkIiwiQ3ViZUdlb21ldHJ5Iiwib3B0cyIsImlkIiwiT2JqZWN0IiwiYXNzaWduIiwiYXR0cmlidXRlcyIsImdldEN1YmVBdHRyaWJ1dGVzIiwiQ1VCRV9JTkRJQ0VTIiwiVWludDE2QXJyYXkiLCJDVUJFX1BPU0lUSU9OUyIsIkZsb2F0MzJBcnJheSIsIkNVQkVfTk9STUFMUyIsIkNVQkVfVEVYX0NPT1JEUyIsImluZGljZXMiLCJwb3NpdGlvbnMiLCJub3JtYWxzIiwidGV4Q29vcmRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPQSxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixVQUFsQjs7SUFFcUJDLFk7OztBQUNuQiwwQkFBdUI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsbUJBQ2VBLElBRGYsQ0FDZEMsRUFEYztBQUFBLFFBQ2RBLEVBRGMsNEJBQ1RILElBQUksZUFBSixDQURTO0FBQUEsdUhBRWZJLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCSCxJQUFsQixFQUF3QixFQUFDQyxNQUFELEVBQUtHLFlBQVlDLG1CQUFqQixFQUF4QixDQUZlO0FBR3RCOzs7RUFKdUNSLFE7O0FBTzFDOzs7ZUFQcUJFLFk7QUFRckIsSUFBTU8sZUFBZSxJQUFJQyxXQUFKLENBQWdCLENBQ25DLENBRG1DLEVBQ2hDLENBRGdDLEVBQzdCLENBRDZCLEVBQzFCLENBRDBCLEVBQ3ZCLENBRHVCLEVBQ3BCLENBRG9CLEVBRW5DLENBRm1DLEVBRWhDLENBRmdDLEVBRTdCLENBRjZCLEVBRTFCLENBRjBCLEVBRXZCLENBRnVCLEVBRXBCLENBRm9CLEVBR25DLENBSG1DLEVBR2hDLENBSGdDLEVBRzdCLEVBSDZCLEVBR3pCLENBSHlCLEVBR3RCLEVBSHNCLEVBR2xCLEVBSGtCLEVBSW5DLEVBSm1DLEVBSS9C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QUFhdkM7QUFDQSxHQWR1QyxFQWNsQyxHQWRrQyxFQWV2QyxHQWZ1QyxFQWVsQyxHQWZrQyxFQWdCdkMsR0FoQnVDLEVBZ0JsQyxHQWhCa0MsRUFpQnZDLEdBakJ1QyxFQWlCbEMsR0FqQmtDOztBQW1CdkM7QUFDQSxHQXBCdUMsRUFvQmxDLEdBcEJrQyxFQXFCdkMsR0FyQnVDLEVBcUJsQyxHQXJCa0MsRUFzQnZDLEdBdEJ1QyxFQXNCbEMsR0F0QmtDLEVBdUJ2QyxHQXZCdUMsRUF1QmxDLEdBdkJrQzs7QUF5QnZDO0FBQ0EsR0ExQnVDLEVBMEJsQyxHQTFCa0MsRUEyQnZDLEdBM0J1QyxFQTJCbEMsR0EzQmtDLEVBNEJ2QyxHQTVCdUMsRUE0QmxDLEdBNUJrQyxFQTZCdkMsR0E3QnVDLEVBNkJsQyxHQTdCa0M7O0FBK0J2QztBQUNBLEdBaEN1QyxFQWdDbEMsR0FoQ2tDLEVBaUN2QyxHQWpDdUMsRUFpQ2xDLEdBakNrQyxFQWtDdkMsR0FsQ3VDLEVBa0NsQyxHQWxDa0MsRUFtQ3ZDLEdBbkN1QyxFQW1DbEMsR0FuQ2tDLENBQWpCLENBQXhCO0FBcUNBOztBQUVBLFNBQVNKLGlCQUFULEdBQTZCO0FBQzNCLFNBQU87QUFDTE8sYUFBUyxJQUFJTCxXQUFKLENBQWdCRCxZQUFoQixDQURKO0FBRUxPLGVBQVcsSUFBSUosWUFBSixDQUFpQkQsY0FBakIsQ0FGTjtBQUdMTSxhQUFTLElBQUlMLFlBQUosQ0FBaUJDLFlBQWpCLENBSEo7QUFJTEssZUFBVyxJQUFJTixZQUFKLENBQWlCRSxlQUFqQjtBQUpOLEdBQVA7QUFNRCIsImZpbGUiOiJjdWJlLWdlb21ldHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vZ2VvbWV0cnknO1xuaW1wb3J0IHt1aWR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ViZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCB7aWQgPSB1aWQoJ2N1YmUtZ2VvbWV0cnknKX0gPSBvcHRzO1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtpZCwgYXR0cmlidXRlczogZ2V0Q3ViZUF0dHJpYnV0ZXMoKX0pKTtcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMsIGluZGVudCAqL1xuY29uc3QgQ1VCRV9JTkRJQ0VTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgMCwgMSwgMiwgMCwgMiwgMyxcbiAgNCwgNSwgNiwgNCwgNiwgNyxcbiAgOCwgOSwgMTAsIDgsIDEwLCAxMSxcbiAgMTIsIDEzLCAxNCwgMTIsIDE0LCAxNSxcbiAgMTYsIDE3LCAxOCwgMTYsIDE4LCAxOSxcbiAgMjAsIDIxLCAyMiwgMjAsIDIyLCAyM1xuXSk7XG5cbmNvbnN0IENVQkVfUE9TSVRJT05TID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIC0xLCAtMSwgIDEsXG4gICAxLCAtMSwgIDEsXG4gICAxLCAgMSwgIDEsXG4gIC0xLCAgMSwgIDEsXG5cbiAgLTEsIC0xLCAtMSxcbiAgLTEsICAxLCAtMSxcbiAgIDEsICAxLCAtMSxcbiAgIDEsIC0xLCAtMSxcblxuICAtMSwgIDEsIC0xLFxuICAtMSwgIDEsICAxLFxuICAgMSwgIDEsICAxLFxuICAgMSwgIDEsIC0xLFxuXG4gIC0xLCAtMSwgLTEsXG4gICAxLCAtMSwgLTEsXG4gICAxLCAtMSwgIDEsXG4gIC0xLCAtMSwgIDEsXG5cbiAgIDEsIC0xLCAtMSxcbiAgIDEsICAxLCAtMSxcbiAgIDEsICAxLCAgMSxcbiAgIDEsIC0xLCAgMSxcblxuICAtMSwgLTEsIC0xLFxuICAtMSwgLTEsICAxLFxuICAtMSwgIDEsICAxLFxuICAtMSwgIDEsIC0xXG5dKTtcblxuY29uc3QgQ1VCRV9OT1JNQUxTID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIC8vIEZyb250IGZhY2VcbiAgMC4wLCAgMC4wLCAgMS4wLFxuICAwLjAsICAwLjAsICAxLjAsXG4gIDAuMCwgIDAuMCwgIDEuMCxcbiAgMC4wLCAgMC4wLCAgMS4wLFxuXG4gIC8vIEJhY2sgZmFjZVxuICAwLjAsICAwLjAsIC0xLjAsXG4gIDAuMCwgIDAuMCwgLTEuMCxcbiAgMC4wLCAgMC4wLCAtMS4wLFxuICAwLjAsICAwLjAsIC0xLjAsXG5cbiAgLy8gVG9wIGZhY2VcbiAgMC4wLCAgMS4wLCAgMC4wLFxuICAwLjAsICAxLjAsICAwLjAsXG4gIDAuMCwgIDEuMCwgIDAuMCxcbiAgMC4wLCAgMS4wLCAgMC4wLFxuXG4gIC8vIEJvdHRvbSBmYWNlXG4gIDAuMCwgLTEuMCwgIDAuMCxcbiAgMC4wLCAtMS4wLCAgMC4wLFxuICAwLjAsIC0xLjAsICAwLjAsXG4gIDAuMCwgLTEuMCwgIDAuMCxcblxuICAvLyBSaWdodCBmYWNlXG4gIDEuMCwgIDAuMCwgIDAuMCxcbiAgMS4wLCAgMC4wLCAgMC4wLFxuICAxLjAsICAwLjAsICAwLjAsXG4gIDEuMCwgIDAuMCwgIDAuMCxcblxuICAvLyBMZWZ0IGZhY2VcbiAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgLTEuMCwgIDAuMCwgIDAuMFxuXSk7XG5cbmNvbnN0IENVQkVfVEVYX0NPT1JEUyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAvLyBGcm9udCBmYWNlXG4gIDAuMCwgMC4wLFxuICAxLjAsIDAuMCxcbiAgMS4wLCAxLjAsXG4gIDAuMCwgMS4wLFxuXG4gIC8vIEJhY2sgZmFjZVxuICAxLjAsIDAuMCxcbiAgMS4wLCAxLjAsXG4gIDAuMCwgMS4wLFxuICAwLjAsIDAuMCxcblxuICAvLyBUb3AgZmFjZVxuICAwLjAsIDEuMCxcbiAgMC4wLCAwLjAsXG4gIDEuMCwgMC4wLFxuICAxLjAsIDEuMCxcblxuICAvLyBCb3R0b20gZmFjZVxuICAxLjAsIDEuMCxcbiAgMC4wLCAxLjAsXG4gIDAuMCwgMC4wLFxuICAxLjAsIDAuMCxcblxuICAvLyBSaWdodCBmYWNlXG4gIDEuMCwgMC4wLFxuICAxLjAsIDEuMCxcbiAgMC4wLCAxLjAsXG4gIDAuMCwgMC4wLFxuXG4gIC8vIExlZnQgZmFjZVxuICAwLjAsIDAuMCxcbiAgMS4wLCAwLjAsXG4gIDEuMCwgMS4wLFxuICAwLjAsIDEuMFxuXSk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLW11bHRpLXNwYWNlcywgaW5kZW50ICovXG5cbmZ1bmN0aW9uIGdldEN1YmVBdHRyaWJ1dGVzKCkge1xuICByZXR1cm4ge1xuICAgIGluZGljZXM6IG5ldyBVaW50MTZBcnJheShDVUJFX0lORElDRVMpLFxuICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShDVUJFX1BPU0lUSU9OUyksXG4gICAgbm9ybWFsczogbmV3IEZsb2F0MzJBcnJheShDVUJFX05PUk1BTFMpLFxuICAgIHRleENvb3JkczogbmV3IEZsb2F0MzJBcnJheShDVUJFX1RFWF9DT09SRFMpXG4gIH07XG59XG4iXX0=

/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__truncated_cone_geometry__ = __webpack_require__(32);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var CylinderGeometry = function (_TruncatedConeGeometr) {
  _inherits(CylinderGeometry, _TruncatedConeGeometr);

  function CylinderGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CylinderGeometry);

    var _opts$radius = opts.radius,
        radius = _opts$radius === undefined ? 1 : _opts$radius;
    return _possibleConstructorReturn(this, (CylinderGeometry.__proto__ || Object.getPrototypeOf(CylinderGeometry)).call(this, Object.assign({}, opts, {
      bottomRadius: radius,
      topRadius: radius
    })));
  }

  return CylinderGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__truncated_cone_geometry__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (CylinderGeometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9jeWxpbmRlci1nZW9tZXRyeS5qcyJdLCJuYW1lcyI6WyJUcnVuY2F0ZWRDb25lR2VvbWV0cnkiLCJDeWxpbmRlckdlb21ldHJ5Iiwib3B0cyIsInJhZGl1cyIsIk9iamVjdCIsImFzc2lnbiIsImJvdHRvbVJhZGl1cyIsInRvcFJhZGl1cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBT0EscUJBQVAsTUFBa0MsMkJBQWxDOztJQUVxQkMsZ0I7OztBQUNuQiw4QkFBdUI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsdUJBQ0FBLElBREEsQ0FDZEMsTUFEYztBQUFBLFFBQ2RBLE1BRGMsZ0NBQ0wsQ0FESztBQUFBLCtIQUVmQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkgsSUFBbEIsRUFBd0I7QUFDNUJJLG9CQUFjSCxNQURjO0FBRTVCSSxpQkFBV0o7QUFGaUIsS0FBeEIsQ0FGZTtBQU10Qjs7O0VBUDJDSCxxQjs7ZUFBekJDLGdCIiwiZmlsZSI6ImN5bGluZGVyLWdlb21ldHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRydW5jYXRlZENvbmVHZW9tZXRyeSBmcm9tICcuL3RydW5jYXRlZC1jb25lLWdlb21ldHJ5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3lsaW5kZXJHZW9tZXRyeSBleHRlbmRzIFRydW5jYXRlZENvbmVHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtyYWRpdXMgPSAxfSA9IG9wdHM7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgYm90dG9tUmFkaXVzOiByYWRpdXMsXG4gICAgICB0b3BSYWRpdXM6IHJhZGl1c1xuICAgIH0pKTtcbiAgfVxufVxuIl19

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__packages_math__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__packages_math___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__packages_math__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/* eslint-disable comma-spacing, max-statements, complexity */

var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

var IcoSphereGeometry = function (_Geometry) {
  _inherits(IcoSphereGeometry, _Geometry);

  function IcoSphereGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, IcoSphereGeometry);

    var _ref = {},
        _ref$iterations = _ref.iterations,
        iterations = _ref$iterations === undefined ? 0 : _ref$iterations;


    var PI = Math.PI;
    var PI2 = PI * 2;

    var positions = [].concat(ICO_POSITIONS);
    var indices = [].concat(ICO_INDICES);

    positions.push();
    indices.push();

    var getMiddlePoint = function () {
      var pointMemo = {};

      return function (i1, i2) {
        i1 *= 3;
        i2 *= 3;
        var mini = i1 < i2 ? i1 : i2;
        var maxi = i1 > i2 ? i1 : i2;
        var key = mini + '|' + maxi;

        if (key in pointMemo) {
          return pointMemo[key];
        }

        var x1 = positions[i1];
        var y1 = positions[i1 + 1];
        var z1 = positions[i1 + 2];
        var x2 = positions[i2];
        var y2 = positions[i2 + 1];
        var z2 = positions[i2 + 2];
        var xm = (x1 + x2) / 2;
        var ym = (y1 + y2) / 2;
        var zm = (z1 + z2) / 2;
        var len = Math.sqrt(xm * xm + ym * ym + zm * zm);

        xm /= len;
        ym /= len;
        zm /= len;

        positions.push(xm, ym, zm);

        return pointMemo[key] = positions.length / 3 - 1;
      };
    }();

    for (var i = 0; i < iterations; i++) {
      var indices2 = [];
      for (var j = 0; j < indices.length; j += 3) {
        var a = getMiddlePoint(indices[j + 0], indices[j + 1]);
        var b = getMiddlePoint(indices[j + 1], indices[j + 2]);
        var c = getMiddlePoint(indices[j + 2], indices[j + 0]);

        indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
      }
      indices = indices2;
    }

    // Calculate texCoords and normals
    var normals = new Array(indices.length * 3);
    var texCoords = new Array(indices.length * 2);

    var l = indices.length;
    for (var _i = l - 3; _i >= 0; _i -= 3) {
      var i1 = indices[_i + 0];
      var i2 = indices[_i + 1];
      var i3 = indices[_i + 2];
      var in1 = i1 * 3;
      var in2 = i2 * 3;
      var in3 = i3 * 3;
      var iu1 = i1 * 2;
      var iu2 = i2 * 2;
      var iu3 = i3 * 2;
      var x1 = positions[in1 + 0];
      var y1 = positions[in1 + 1];
      var z1 = positions[in1 + 2];
      var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
      var phi1 = Math.atan2(y1, x1) + PI;
      var v1 = theta1 / PI;
      var u1 = 1 - phi1 / PI2;
      var x2 = positions[in2 + 0];
      var y2 = positions[in2 + 1];
      var z2 = positions[in2 + 2];
      var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
      var phi2 = Math.atan2(y2, x2) + PI;
      var v2 = theta2 / PI;
      var u2 = 1 - phi2 / PI2;
      var x3 = positions[in3 + 0];
      var y3 = positions[in3 + 1];
      var z3 = positions[in3 + 2];
      var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
      var phi3 = Math.atan2(y3, x3) + PI;
      var v3 = theta3 / PI;
      var u3 = 1 - phi3 / PI2;
      var vec1 = [x3 - x2, y3 - y2, z3 - z2];
      var vec2 = [x1 - x2, y1 - y2, z1 - z2];
      var normal = __WEBPACK_IMPORTED_MODULE_1__packages_math__["Vector3"].cross(vec1, vec2).normalize();
      var newIndex = void 0;

      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {

        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v1;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;

        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v2;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;

        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v3;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
      }

      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;

      texCoords[iu1 + 0] = u1;
      texCoords[iu1 + 1] = v1;

      texCoords[iu2 + 0] = u2;
      texCoords[iu2 + 1] = v2;

      texCoords[iu3 + 0] = u3;
      texCoords[iu3 + 1] = v3;
    }

    return _possibleConstructorReturn(this, (IcoSphereGeometry.__proto__ || Object.getPrototypeOf(IcoSphereGeometry)).call(this, Object.assign({}, opts, {
      attributes: {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        texCoords: new Float32Array(texCoords),
        indices: new Uint16Array(indices)
      }
    })));
  }

  return IcoSphereGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (IcoSphereGeometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9pY28tc3BoZXJlLWdlb21ldHJ5LmpzIl0sIm5hbWVzIjpbIkdlb21ldHJ5IiwiVmVjdG9yMyIsIklDT19QT1NJVElPTlMiLCJJQ09fSU5ESUNFUyIsIkljb1NwaGVyZUdlb21ldHJ5Iiwib3B0cyIsIml0ZXJhdGlvbnMiLCJQSSIsIk1hdGgiLCJQSTIiLCJwb3NpdGlvbnMiLCJpbmRpY2VzIiwicHVzaCIsImdldE1pZGRsZVBvaW50IiwicG9pbnRNZW1vIiwiaTEiLCJpMiIsIm1pbmkiLCJtYXhpIiwia2V5IiwieDEiLCJ5MSIsInoxIiwieDIiLCJ5MiIsInoyIiwieG0iLCJ5bSIsInptIiwibGVuIiwic3FydCIsImxlbmd0aCIsImkiLCJpbmRpY2VzMiIsImoiLCJhIiwiYiIsImMiLCJub3JtYWxzIiwiQXJyYXkiLCJ0ZXhDb29yZHMiLCJsIiwiaTMiLCJpbjEiLCJpbjIiLCJpbjMiLCJpdTEiLCJpdTIiLCJpdTMiLCJ0aGV0YTEiLCJhY29zIiwicGhpMSIsImF0YW4yIiwidjEiLCJ1MSIsInRoZXRhMiIsInBoaTIiLCJ2MiIsInUyIiwieDMiLCJ5MyIsInozIiwidGhldGEzIiwicGhpMyIsInYzIiwidTMiLCJ2ZWMxIiwidmVjMiIsIm5vcm1hbCIsImNyb3NzIiwibm9ybWFsaXplIiwibmV3SW5kZXgiLCJ4IiwieSIsInoiLCJPYmplY3QiLCJhc3NpZ24iLCJhdHRyaWJ1dGVzIiwiRmxvYXQzMkFycmF5IiwiVWludDE2QXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLFFBQVAsTUFBcUIsWUFBckI7QUFDQSxTQUFRQyxPQUFSLFFBQXNCLGtCQUF0Qjs7QUFFQTs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUYsRUFBSSxDQUFKLEVBQU0sQ0FBTixFQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFrQixDQUFsQixFQUFvQixDQUFDLENBQXJCLEVBQXdCLENBQXhC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d0I7QUFDNUJ3RSxrQkFBWTtBQUNWbkUsbUJBQVcsSUFBSW9FLFlBQUosQ0FBaUJwRSxTQUFqQixDQUREO0FBRVY0QixpQkFBUyxJQUFJd0MsWUFBSixDQUFpQnhDLE9BQWpCLENBRkM7QUFHVkUsbUJBQVcsSUFBSXNDLFlBQUosQ0FBaUJ0QyxTQUFqQixDQUhEO0FBSVY3QixpQkFBUyxJQUFJb0UsV0FBSixDQUFnQnBFLE9BQWhCO0FBSkM7QUFEZ0IsS0FBeEIsQ0EzS2U7QUFtTHRCOzs7RUFwTDRDWCxROztlQUExQkksaUIiLCJmaWxlIjoiaWNvLXNwaGVyZS1nZW9tZXRyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHZW9tZXRyeSBmcm9tICcuL2dlb21ldHJ5JztcbmltcG9ydCB7VmVjdG9yM30gZnJvbSAnLi4vcGFja2FnZXMvbWF0aCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbmNvbnN0IElDT19QT1NJVElPTlMgPSBbLTEsMCwwLCAwLDEsMCwgMCwwLC0xLCAwLDAsMSwgMCwtMSwwLCAxLDAsMF07XG5jb25zdCBJQ09fSU5ESUNFUyA9IFszLDQsNSwzLDUsMSwzLDEsMCwzLDAsNCw0LDAsMiw0LDIsNSwyLDAsMSw1LDIsMV07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb1NwaGVyZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCB7aXRlcmF0aW9ucyA9IDB9ID0ge307XG5cbiAgICBjb25zdCBQSSA9IE1hdGguUEk7XG4gICAgY29uc3QgUEkyID0gUEkgKiAyO1xuXG4gICAgY29uc3QgcG9zaXRpb25zID0gWy4uLklDT19QT1NJVElPTlNdO1xuICAgIGxldCBpbmRpY2VzID0gWy4uLklDT19JTkRJQ0VTXTtcblxuICAgIHBvc2l0aW9ucy5wdXNoKCk7XG4gICAgaW5kaWNlcy5wdXNoKCk7XG5cbiAgICBjb25zdCBnZXRNaWRkbGVQb2ludCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBwb2ludE1lbW8gPSB7fTtcblxuICAgICAgcmV0dXJuIChpMSwgaTIpID0+IHtcbiAgICAgICAgaTEgKj0gMztcbiAgICAgICAgaTIgKj0gMztcbiAgICAgICAgY29uc3QgbWluaSA9IGkxIDwgaTIgPyBpMSA6IGkyO1xuICAgICAgICBjb25zdCBtYXhpID0gaTEgPiBpMiA/IGkxIDogaTI7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke21pbml9fCR7bWF4aX1gO1xuXG4gICAgICAgIGlmIChrZXkgaW4gcG9pbnRNZW1vKSB7XG4gICAgICAgICAgcmV0dXJuIHBvaW50TWVtb1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeDEgPSBwb3NpdGlvbnNbaTFdO1xuICAgICAgICBjb25zdCB5MSA9IHBvc2l0aW9uc1tpMSArIDFdO1xuICAgICAgICBjb25zdCB6MSA9IHBvc2l0aW9uc1tpMSArIDJdO1xuICAgICAgICBjb25zdCB4MiA9IHBvc2l0aW9uc1tpMl07XG4gICAgICAgIGNvbnN0IHkyID0gcG9zaXRpb25zW2kyICsgMV07XG4gICAgICAgIGNvbnN0IHoyID0gcG9zaXRpb25zW2kyICsgMl07XG4gICAgICAgIGxldCB4bSA9ICh4MSArIHgyKSAvIDI7XG4gICAgICAgIGxldCB5bSA9ICh5MSArIHkyKSAvIDI7XG4gICAgICAgIGxldCB6bSA9ICh6MSArIHoyKSAvIDI7XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh4bSAqIHhtICsgeW0gKiB5bSArIHptICogem0pO1xuXG4gICAgICAgIHhtIC89IGxlbjtcbiAgICAgICAgeW0gLz0gbGVuO1xuICAgICAgICB6bSAvPSBsZW47XG5cbiAgICAgICAgcG9zaXRpb25zLnB1c2goeG0sIHltLCB6bSk7XG5cbiAgICAgICAgcmV0dXJuIChwb2ludE1lbW9ba2V5XSA9IChwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDEpKTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2VzMiA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRpY2VzLmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgIGNvbnN0IGEgPSBnZXRNaWRkbGVQb2ludChpbmRpY2VzW2ogKyAwXSwgaW5kaWNlc1tqICsgMV0pO1xuICAgICAgICBjb25zdCBiID0gZ2V0TWlkZGxlUG9pbnQoaW5kaWNlc1tqICsgMV0sIGluZGljZXNbaiArIDJdKTtcbiAgICAgICAgY29uc3QgYyA9IGdldE1pZGRsZVBvaW50KGluZGljZXNbaiArIDJdLCBpbmRpY2VzW2ogKyAwXSk7XG5cbiAgICAgICAgaW5kaWNlczIucHVzaChcbiAgICAgICAgICBjLCBpbmRpY2VzW2ogKyAwXSwgYSxcbiAgICAgICAgICBhLCBpbmRpY2VzW2ogKyAxXSwgYixcbiAgICAgICAgICBiLCBpbmRpY2VzW2ogKyAyXSwgYyxcbiAgICAgICAgICBhLCBiLCBjKTtcbiAgICAgIH1cbiAgICAgIGluZGljZXMgPSBpbmRpY2VzMjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGV4Q29vcmRzIGFuZCBub3JtYWxzXG4gICAgY29uc3Qgbm9ybWFscyA9IG5ldyBBcnJheShpbmRpY2VzLmxlbmd0aCAqIDMpO1xuICAgIGNvbnN0IHRleENvb3JkcyA9IG5ldyBBcnJheShpbmRpY2VzLmxlbmd0aCAqIDIpO1xuXG4gICAgY29uc3QgbCA9IGluZGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsIC0gMzsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgIGNvbnN0IGkxID0gaW5kaWNlc1tpICsgMF07XG4gICAgICBjb25zdCBpMiA9IGluZGljZXNbaSArIDFdO1xuICAgICAgY29uc3QgaTMgPSBpbmRpY2VzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGluMSA9IGkxICogMztcbiAgICAgIGNvbnN0IGluMiA9IGkyICogMztcbiAgICAgIGNvbnN0IGluMyA9IGkzICogMztcbiAgICAgIGNvbnN0IGl1MSA9IGkxICogMjtcbiAgICAgIGNvbnN0IGl1MiA9IGkyICogMjtcbiAgICAgIGNvbnN0IGl1MyA9IGkzICogMjtcbiAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25zW2luMSArIDBdO1xuICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbnNbaW4xICsgMV07XG4gICAgICBjb25zdCB6MSA9IHBvc2l0aW9uc1tpbjEgKyAyXTtcbiAgICAgIGNvbnN0IHRoZXRhMSA9IE1hdGguYWNvcyh6MSAvIE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSArIHoxICogejEpKTtcbiAgICAgIGNvbnN0IHBoaTEgPSBNYXRoLmF0YW4yKHkxLCB4MSkgKyBQSTtcbiAgICAgIGNvbnN0IHYxID0gdGhldGExIC8gUEk7XG4gICAgICBjb25zdCB1MSA9IDEgLSBwaGkxIC8gUEkyO1xuICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbnNbaW4yICsgMF07XG4gICAgICBjb25zdCB5MiA9IHBvc2l0aW9uc1tpbjIgKyAxXTtcbiAgICAgIGNvbnN0IHoyID0gcG9zaXRpb25zW2luMiArIDJdO1xuICAgICAgY29uc3QgdGhldGEyID0gTWF0aC5hY29zKHoyIC8gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyICsgejIgKiB6MikpO1xuICAgICAgY29uc3QgcGhpMiA9IE1hdGguYXRhbjIoeTIsIHgyKSArIFBJO1xuICAgICAgY29uc3QgdjIgPSB0aGV0YTIgLyBQSTtcbiAgICAgIGNvbnN0IHUyID0gMSAtIHBoaTIgLyBQSTI7XG4gICAgICBjb25zdCB4MyA9IHBvc2l0aW9uc1tpbjMgKyAwXTtcbiAgICAgIGNvbnN0IHkzID0gcG9zaXRpb25zW2luMyArIDFdO1xuICAgICAgY29uc3QgejMgPSBwb3NpdGlvbnNbaW4zICsgMl07XG4gICAgICBjb25zdCB0aGV0YTMgPSBNYXRoLmFjb3MoejMgLyBNYXRoLnNxcnQoeDMgKiB4MyArIHkzICogeTMgKyB6MyAqIHozKSk7XG4gICAgICBjb25zdCBwaGkzID0gTWF0aC5hdGFuMih5MywgeDMpICsgUEk7XG4gICAgICBjb25zdCB2MyA9IHRoZXRhMyAvIFBJO1xuICAgICAgY29uc3QgdTMgPSAxIC0gcGhpMyAvIFBJMjtcbiAgICAgIGNvbnN0IHZlYzEgPSBbXG4gICAgICAgIHgzIC0geDIsXG4gICAgICAgIHkzIC0geTIsXG4gICAgICAgIHozIC0gejJcbiAgICAgIF07XG4gICAgICBjb25zdCB2ZWMyID0gW1xuICAgICAgICB4MSAtIHgyLFxuICAgICAgICB5MSAtIHkyLFxuICAgICAgICB6MSAtIHoyXG4gICAgICBdO1xuICAgICAgY29uc3Qgbm9ybWFsID0gVmVjdG9yMy5jcm9zcyh2ZWMxLCB2ZWMyKS5ub3JtYWxpemUoKTtcbiAgICAgIGxldCBuZXdJbmRleDtcblxuICAgICAgaWYgKCh1MSA9PT0gMCB8fCB1MiA9PT0gMCB8fCB1MyA9PT0gMCkgJiZcbiAgICAgICAgICAodTEgPT09IDAgfHwgdTEgPiAwLjUpICYmXG4gICAgICAgICAgICAodTIgPT09IDAgfHwgdTIgPiAwLjUpICYmXG4gICAgICAgICAgICAgICh1MyA9PT0gMCB8fCB1MyA+IDAuNSkpIHtcblxuICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICBwb3NpdGlvbnNbaW4xICsgMF0sXG4gICAgICAgICAgcG9zaXRpb25zW2luMSArIDFdLFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjEgKyAyXVxuICAgICAgICApO1xuICAgICAgICBuZXdJbmRleCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKG5ld0luZGV4KTtcbiAgICAgICAgdGV4Q29vcmRzW25ld0luZGV4ICogMiArIDBdID0gMTtcbiAgICAgICAgdGV4Q29vcmRzW25ld0luZGV4ICogMiArIDFdID0gdjE7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMF0gPSBub3JtYWwueDtcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAxXSA9IG5vcm1hbC55O1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDJdID0gbm9ybWFsLno7XG5cbiAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgcG9zaXRpb25zW2luMiArIDBdLFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjIgKyAxXSxcbiAgICAgICAgICBwb3NpdGlvbnNbaW4yICsgMl1cbiAgICAgICAgKTtcbiAgICAgICAgbmV3SW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7XG4gICAgICAgIGluZGljZXMucHVzaChuZXdJbmRleCk7XG4gICAgICAgIHRleENvb3Jkc1tuZXdJbmRleCAqIDIgKyAwXSA9IDE7XG4gICAgICAgIHRleENvb3Jkc1tuZXdJbmRleCAqIDIgKyAxXSA9IHYyO1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDBdID0gbm9ybWFsLng7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMV0gPSBub3JtYWwueTtcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAyXSA9IG5vcm1hbC56O1xuXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgIHBvc2l0aW9uc1tpbjMgKyAwXSxcbiAgICAgICAgICBwb3NpdGlvbnNbaW4zICsgMV0sXG4gICAgICAgICAgcG9zaXRpb25zW2luMyArIDJdXG4gICAgICAgICk7XG4gICAgICAgIG5ld0luZGV4ID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxO1xuICAgICAgICBpbmRpY2VzLnB1c2gobmV3SW5kZXgpO1xuICAgICAgICB0ZXhDb29yZHNbbmV3SW5kZXggKiAyICsgMF0gPSAxO1xuICAgICAgICB0ZXhDb29yZHNbbmV3SW5kZXggKiAyICsgMV0gPSB2MztcbiAgICAgICAgbm9ybWFsc1tuZXdJbmRleCAqIDMgKyAwXSA9IG5vcm1hbC54O1xuICAgICAgICBub3JtYWxzW25ld0luZGV4ICogMyArIDFdID0gbm9ybWFsLnk7XG4gICAgICAgIG5vcm1hbHNbbmV3SW5kZXggKiAzICsgMl0gPSBub3JtYWwuejtcbiAgICAgIH1cblxuICAgICAgbm9ybWFsc1tpbjEgKyAwXSA9IG5vcm1hbHNbaW4yICsgMF0gPSBub3JtYWxzW2luMyArIDBdID0gbm9ybWFsLng7XG4gICAgICBub3JtYWxzW2luMSArIDFdID0gbm9ybWFsc1tpbjIgKyAxXSA9IG5vcm1hbHNbaW4zICsgMV0gPSBub3JtYWwueTtcbiAgICAgIG5vcm1hbHNbaW4xICsgMl0gPSBub3JtYWxzW2luMiArIDJdID0gbm9ybWFsc1tpbjMgKyAyXSA9IG5vcm1hbC56O1xuXG4gICAgICB0ZXhDb29yZHNbaXUxICsgMF0gPSB1MTtcbiAgICAgIHRleENvb3Jkc1tpdTEgKyAxXSA9IHYxO1xuXG4gICAgICB0ZXhDb29yZHNbaXUyICsgMF0gPSB1MjtcbiAgICAgIHRleENvb3Jkc1tpdTIgKyAxXSA9IHYyO1xuXG4gICAgICB0ZXhDb29yZHNbaXUzICsgMF0gPSB1MztcbiAgICAgIHRleENvb3Jkc1tpdTMgKyAxXSA9IHYzO1xuICAgIH1cblxuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksXG4gICAgICAgIG5vcm1hbHM6IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFscyksXG4gICAgICAgIHRleENvb3JkczogbmV3IEZsb2F0MzJBcnJheSh0ZXhDb29yZHMpLFxuICAgICAgICBpbmRpY2VzOiBuZXcgVWludDE2QXJyYXkoaW5kaWNlcylcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var PlaneGeometry = function (_Geometry) {
  _inherits(PlaneGeometry, _Geometry);

  // Primitives inspired by TDL http://code.google.com/p/webglsamples/,
  // copyright 2011 Google Inc. new BSD License
  // (http://www.opensource.org/licenses/bsd-license.php).
  /* eslint-disable max-statements, complexity */
  /* eslint-disable complexity, max-statements */
  function PlaneGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PlaneGeometry);

    var _opts$type = opts.type,
        type = _opts$type === undefined ? 'x,y' : _opts$type,
        _opts$offset = opts.offset,
        offset = _opts$offset === undefined ? 0 : _opts$offset,
        _opts$flipCull = opts.flipCull,
        flipCull = _opts$flipCull === undefined ? false : _opts$flipCull,
        _opts$unpack = opts.unpack,
        unpack = _opts$unpack === undefined ? false : _opts$unpack,
        _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["uid"])('plane-geometry') : _opts$id;


    var coords = type.split(',');
    // width, height
    var c1len = opts[coords[0] + 'len'];
    var c2len = opts[coords[1] + 'len'];
    // subdivisionsWidth, subdivisionsDepth
    var subdivisions1 = opts['n' + coords[0]] || 1;
    var subdivisions2 = opts['n' + coords[1]] || 1;
    var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);

    var positions = new Float32Array(numVertices * 3);
    var normals = new Float32Array(numVertices * 3);
    var texCoords = new Float32Array(numVertices * 2);

    if (flipCull) {
      c1len = -c1len;
    }

    var i2 = 0;
    var i3 = 0;
    for (var z = 0; z <= subdivisions2; z++) {
      for (var x = 0; x <= subdivisions1; x++) {
        var u = x / subdivisions1;
        var v = z / subdivisions2;
        texCoords[i2 + 0] = flipCull ? 1 - u : u;
        texCoords[i2 + 1] = v;

        switch (type) {
          case 'x,y':
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = c2len * v - c2len * 0.5;
            positions[i3 + 2] = offset;

            normals[i3 + 0] = 0;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = flipCull ? 1 : -1;
            break;

          case 'x,z':
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = offset;
            positions[i3 + 2] = c2len * v - c2len * 0.5;

            normals[i3 + 0] = 0;
            normals[i3 + 1] = flipCull ? 1 : -1;
            normals[i3 + 2] = 0;
            break;

          case 'y,z':
            positions[i3 + 0] = offset;
            positions[i3 + 1] = c1len * u - c1len * 0.5;
            positions[i3 + 2] = c2len * v - c2len * 0.5;

            normals[i3 + 0] = flipCull ? 1 : -1;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = 0;
            break;

          default:
            break;
        }

        i2 += 2;
        i3 += 3;
      }
    }

    var numVertsAcross = subdivisions1 + 1;
    var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

    for (var _z = 0; _z < subdivisions2; _z++) {
      for (var _x2 = 0; _x2 < subdivisions1; _x2++) {
        var index = (_z * subdivisions1 + _x2) * 6;
        // Make triangle 1 of quad.
        indices[index + 0] = (_z + 0) * numVertsAcross + _x2;
        indices[index + 1] = (_z + 1) * numVertsAcross + _x2;
        indices[index + 2] = (_z + 0) * numVertsAcross + _x2 + 1;

        // Make triangle 2 of quad.
        indices[index + 3] = (_z + 1) * numVertsAcross + _x2;
        indices[index + 4] = (_z + 1) * numVertsAcross + _x2 + 1;
        indices[index + 5] = (_z + 0) * numVertsAcross + _x2 + 1;
      }
    }

    // Optionally, unpack indexed geometry
    if (unpack) {
      var positions2 = new Float32Array(indices.length * 3);
      var normals2 = new Float32Array(indices.length * 3);
      var texCoords2 = new Float32Array(indices.length * 2);

      for (var _x3 = 0; _x3 < indices.length; ++_x3) {
        var _index = indices[_x3];
        positions2[_x3 * 3 + 0] = positions[_index * 3 + 0];
        positions2[_x3 * 3 + 1] = positions[_index * 3 + 1];
        positions2[_x3 * 3 + 2] = positions[_index * 3 + 2];
        normals2[_x3 * 3 + 0] = normals[_index * 3 + 0];
        normals2[_x3 * 3 + 1] = normals[_index * 3 + 1];
        normals2[_x3 * 3 + 2] = normals[_index * 3 + 2];
        texCoords2[_x3 * 2 + 0] = texCoords[_index * 2 + 0];
        texCoords2[_x3 * 2 + 1] = texCoords[_index * 2 + 1];
      }

      positions = positions2;
      normals = normals2;
      texCoords = texCoords2;
      indices = undefined;
    }

    var attributes = {
      positions: positions,
      normals: normals,
      texCoords: texCoords
    };

    if (indices) {
      attributes.indices = indices;
    }

    return _possibleConstructorReturn(this, (PlaneGeometry.__proto__ || Object.getPrototypeOf(PlaneGeometry)).call(this, Object.assign({}, opts, { attributes: attributes, id: id })));
  }

  return PlaneGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (PlaneGeometry);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9wbGFuZS1nZW9tZXRyeS5qcyJdLCJuYW1lcyI6WyJHZW9tZXRyeSIsInVpZCIsIlBsYW5lR2VvbWV0cnkiLCJvcHRzIiwidHlwZSIsIm9mZnNldCIsImZsaXBDdWxsIiwidW5wYWNrIiwiaWQiLCJjb29yZHMiLCJzcGxpdCIsImMxbGVuIiwiYzJsZW4iLCJzdWJkaXZpc2lvbnMxIiwic3ViZGl2aXNpb25zMiIsIm51bVZlcnRpY2VzIiwicG9zaXRpb25zIiwiRmxvYXQzMkFycmF5Iiwibm9ybWFscyIsInRleENvb3JkcyIsImkyIiwiaTMiLCJ6IiwieCIsInUiLCJ2IiwibnVtVmVydHNBY3Jvc3MiLCJpbmRpY2VzIiwiVWludDE2QXJyYXkiLCJpbmRleCIsInBvc2l0aW9uczIiLCJsZW5ndGgiLCJub3JtYWxzMiIsInRleENvb3JkczIiLCJ1bmRlZmluZWQiLCJhdHRyaWJ1dGVzIiwiT2JqZWN0IiwiYXNzaWduIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPQSxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixVQUFsQjs7SUFFcUJDLGE7OztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLHFCQU9qQkEsSUFQaUIsQ0FFbkJDLElBRm1CO0FBQUEsUUFFbkJBLElBRm1CLDhCQUVaLEtBRlk7QUFBQSx1QkFPakJELElBUGlCLENBR25CRSxNQUhtQjtBQUFBLFFBR25CQSxNQUhtQixnQ0FHVixDQUhVO0FBQUEseUJBT2pCRixJQVBpQixDQUluQkcsUUFKbUI7QUFBQSxRQUluQkEsUUFKbUIsa0NBSVIsS0FKUTtBQUFBLHVCQU9qQkgsSUFQaUIsQ0FLbkJJLE1BTG1CO0FBQUEsUUFLbkJBLE1BTG1CLGdDQUtWLEtBTFU7QUFBQSxtQkFPakJKLElBUGlCLENBTW5CSyxFQU5tQjtBQUFBLFFBTW5CQSxFQU5tQiw0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O0FBQ0Q7O0FBRUQsUUFBTUMsYUFBYTtBQUNqQm5CLDBCQURpQjtBQUVqQkUsc0JBRmlCO0FBR2pCQztBQUhpQixLQUFuQjs7QUFNQSxRQUFJUSxPQUFKLEVBQWE7QUFDWFEsaUJBQVdSLE9BQVgsR0FBcUJBLE9BQXJCO0FBQ0Q7O0FBN0hvQix5SEErSGZTLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCbEMsSUFBbEIsRUFBd0IsRUFBQ2dDLHNCQUFELEVBQWEzQixNQUFiLEVBQXhCLENBL0hlO0FBZ0l0Qjs7O0VBdkl3Q1IsUTs7ZUFBdEJFLGEiLCJmaWxlIjoicGxhbmUtZ2VvbWV0cnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9nZW9tZXRyeSc7XG5pbXBvcnQge3VpZH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuXG4gIC8vIFByaW1pdGl2ZXMgaW5zcGlyZWQgYnkgVERMIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbHNhbXBsZXMvLFxuICAvLyBjb3B5cmlnaHQgMjAxMSBHb29nbGUgSW5jLiBuZXcgQlNEIExpY2Vuc2VcbiAgLy8gKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvYnNkLWxpY2Vuc2UucGhwKS5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSA9ICd4LHknLFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIGZsaXBDdWxsID0gZmFsc2UsXG4gICAgICB1bnBhY2sgPSBmYWxzZSxcbiAgICAgIGlkID0gdWlkKCdwbGFuZS1nZW9tZXRyeScpXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCBjb29yZHMgPSB0eXBlLnNwbGl0KCcsJyk7XG4gICAgLy8gd2lkdGgsIGhlaWdodFxuICAgIGxldCBjMWxlbiA9IG9wdHNbYCR7Y29vcmRzWzBdfWxlbmBdO1xuICAgIGNvbnN0IGMybGVuID0gb3B0c1tgJHtjb29yZHNbMV19bGVuYF07XG4gICAgLy8gc3ViZGl2aXNpb25zV2lkdGgsIHN1YmRpdmlzaW9uc0RlcHRoXG4gICAgY29uc3Qgc3ViZGl2aXNpb25zMSA9IG9wdHNbYG4ke2Nvb3Jkc1swXX1gXSB8fCAxO1xuICAgIGNvbnN0IHN1YmRpdmlzaW9uczIgPSBvcHRzW2BuJHtjb29yZHNbMV19YF0gfHwgMTtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IChzdWJkaXZpc2lvbnMxICsgMSkgKiAoc3ViZGl2aXNpb25zMiArIDEpO1xuXG4gICAgbGV0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVmVydGljZXMgKiAzKTtcbiAgICBsZXQgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVmVydGljZXMgKiAzKTtcbiAgICBsZXQgdGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0aWNlcyAqIDIpO1xuXG4gICAgaWYgKGZsaXBDdWxsKSB7XG4gICAgICBjMWxlbiA9IC1jMWxlbjtcbiAgICB9XG5cbiAgICBsZXQgaTIgPSAwO1xuICAgIGxldCBpMyA9IDA7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPD0gc3ViZGl2aXNpb25zMjsgeisrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBzdWJkaXZpc2lvbnMxOyB4KyspIHtcbiAgICAgICAgY29uc3QgdSA9IHggLyBzdWJkaXZpc2lvbnMxO1xuICAgICAgICBjb25zdCB2ID0geiAvIHN1YmRpdmlzaW9uczI7XG4gICAgICAgIHRleENvb3Jkc1tpMiArIDBdID0gZmxpcEN1bGwgPyAxIC0gdSA6IHU7XG4gICAgICAgIHRleENvb3Jkc1tpMiArIDFdID0gdjtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAneCx5JzpcbiAgICAgICAgICBwb3NpdGlvbnNbaTMgKyAwXSA9IGMxbGVuICogdSAtIGMxbGVuICogMC41O1xuICAgICAgICAgIHBvc2l0aW9uc1tpMyArIDFdID0gYzJsZW4gKiB2IC0gYzJsZW4gKiAwLjU7XG4gICAgICAgICAgcG9zaXRpb25zW2kzICsgMl0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICBub3JtYWxzW2kzICsgMF0gPSAwO1xuICAgICAgICAgIG5vcm1hbHNbaTMgKyAxXSA9IDA7XG4gICAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gZmxpcEN1bGwgPyAxIDogLTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAneCx6JzpcbiAgICAgICAgICBwb3NpdGlvbnNbaTMgKyAwXSA9IGMxbGVuICogdSAtIGMxbGVuICogMC41O1xuICAgICAgICAgIHBvc2l0aW9uc1tpMyArIDFdID0gb2Zmc2V0O1xuICAgICAgICAgIHBvc2l0aW9uc1tpMyArIDJdID0gYzJsZW4gKiB2IC0gYzJsZW4gKiAwLjU7XG5cbiAgICAgICAgICBub3JtYWxzW2kzICsgMF0gPSAwO1xuICAgICAgICAgIG5vcm1hbHNbaTMgKyAxXSA9IGZsaXBDdWxsID8gMSA6IC0xO1xuICAgICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAneSx6JzpcbiAgICAgICAgICBwb3NpdGlvbnNbaTMgKyAwXSA9IG9mZnNldDtcbiAgICAgICAgICBwb3NpdGlvbnNbaTMgKyAxXSA9IGMxbGVuICogdSAtIGMxbGVuICogMC41O1xuICAgICAgICAgIHBvc2l0aW9uc1tpMyArIDJdID0gYzJsZW4gKiB2IC0gYzJsZW4gKiAwLjU7XG5cbiAgICAgICAgICBub3JtYWxzW2kzICsgMF0gPSBmbGlwQ3VsbCA/IDEgOiAtMTtcbiAgICAgICAgICBub3JtYWxzW2kzICsgMV0gPSAwO1xuICAgICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGkyICs9IDI7XG4gICAgICAgIGkzICs9IDM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbnVtVmVydHNBY3Jvc3MgPSBzdWJkaXZpc2lvbnMxICsgMTtcbiAgICBsZXQgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShzdWJkaXZpc2lvbnMxICogc3ViZGl2aXNpb25zMiAqIDYpO1xuXG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBzdWJkaXZpc2lvbnMyOyB6KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViZGl2aXNpb25zMTsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHogKiBzdWJkaXZpc2lvbnMxICsgeCkgKiA2O1xuICAgICAgICAvLyBNYWtlIHRyaWFuZ2xlIDEgb2YgcXVhZC5cbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDBdID0gKHogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgeDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDFdID0gKHogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgeDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDJdID0gKHogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgeCArIDE7XG5cbiAgICAgICAgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG4gICAgICAgIGluZGljZXNbaW5kZXggKyAzXSA9ICh6ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIHg7XG4gICAgICAgIGluZGljZXNbaW5kZXggKyA0XSA9ICh6ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIHggKyAxO1xuICAgICAgICBpbmRpY2VzW2luZGV4ICsgNV0gPSAoeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyB4ICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5LCB1bnBhY2sgaW5kZXhlZCBnZW9tZXRyeVxuICAgIGlmICh1bnBhY2spIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uczIgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMubGVuZ3RoICogMyk7XG4gICAgICBjb25zdCBub3JtYWxzMiA9IG5ldyBGbG9hdDMyQXJyYXkoaW5kaWNlcy5sZW5ndGggKiAzKTtcbiAgICAgIGNvbnN0IHRleENvb3JkczIgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMubGVuZ3RoICogMik7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW5kaWNlcy5sZW5ndGg7ICsreCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGluZGljZXNbeF07XG4gICAgICAgIHBvc2l0aW9uczJbeCAqIDMgKyAwXSA9IHBvc2l0aW9uc1tpbmRleCAqIDMgKyAwXTtcbiAgICAgICAgcG9zaXRpb25zMlt4ICogMyArIDFdID0gcG9zaXRpb25zW2luZGV4ICogMyArIDFdO1xuICAgICAgICBwb3NpdGlvbnMyW3ggKiAzICsgMl0gPSBwb3NpdGlvbnNbaW5kZXggKiAzICsgMl07XG4gICAgICAgIG5vcm1hbHMyW3ggKiAzICsgMF0gPSBub3JtYWxzW2luZGV4ICogMyArIDBdO1xuICAgICAgICBub3JtYWxzMlt4ICogMyArIDFdID0gbm9ybWFsc1tpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgbm9ybWFsczJbeCAqIDMgKyAyXSA9IG5vcm1hbHNbaW5kZXggKiAzICsgMl07XG4gICAgICAgIHRleENvb3JkczJbeCAqIDIgKyAwXSA9IHRleENvb3Jkc1tpbmRleCAqIDIgKyAwXTtcbiAgICAgICAgdGV4Q29vcmRzMlt4ICogMiArIDFdID0gdGV4Q29vcmRzW2luZGV4ICogMiArIDFdO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMyO1xuICAgICAgbm9ybWFscyA9IG5vcm1hbHMyO1xuICAgICAgdGV4Q29vcmRzID0gdGV4Q29vcmRzMjtcbiAgICAgIGluZGljZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIHBvc2l0aW9ucyxcbiAgICAgIG5vcm1hbHMsXG4gICAgICB0ZXhDb29yZHNcbiAgICB9O1xuXG4gICAgaWYgKGluZGljZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge2F0dHJpYnV0ZXMsIGlkfSkpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var SphereGeometry = function (_Geometry) {
  _inherits(SphereGeometry, _Geometry);

  function SphereGeometry() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SphereGeometry);

    var _opts$nlat = opts.nlat,
        nlat = _opts$nlat === undefined ? 10 : _opts$nlat,
        _opts$nlong = opts.nlong,
        nlong = _opts$nlong === undefined ? 10 : _opts$nlong,
        _opts$radius = opts.radius,
        radius = _opts$radius === undefined ? 1 : _opts$radius,
        _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["uid"])('sphere-geometry') : _opts$id;
    return _possibleConstructorReturn(this, (SphereGeometry.__proto__ || Object.getPrototypeOf(SphereGeometry)).call(this, Object.assign({}, opts, { id: id, attributes: getSphereAttributes(nlat, nlong, radius) })));
  }

  return SphereGeometry;
}(__WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */]);

// Primitives inspired by TDL http://code.google.com/p/webglsamples/,
// copyright 2011 Google Inc. new BSD License
// (http://www.opensource.org/licenses/bsd-license.php).
/* eslint-disable max-statements, complexity */


/* harmony default export */ __webpack_exports__["a"] = (SphereGeometry);
function getSphereAttributes(nlat, nlong, radius) {
  var startLat = 0;
  var endLat = Math.PI;
  var latRange = endLat - startLat;
  var startLong = 0;
  var endLong = 2 * Math.PI;
  var longRange = endLong - startLong;
  var numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    var value = radius;
    radius = function radius(n1, n2, n3, u, v) {
      return value;
    };
  }

  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);
  var indices = new Uint16Array(nlat * nlong * 6);

  // Create positions, normals and texCoords
  for (var y = 0; y <= nlat; y++) {
    for (var x = 0; x <= nlong; x++) {

      var u = x / nlong;
      var v = y / nlat;

      var index = x + y * (nlong + 1);
      var i2 = index * 2;
      var i3 = index * 3;

      var theta = longRange * u;
      var phi = latRange * v;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;

      var r = radius(ux, uy, uz, u, v);

      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;

      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;

      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = v;
    }
  }

  // Create indices
  var numVertsAround = nlat + 1;
  for (var _x2 = 0; _x2 < nlat; _x2++) {
    for (var _y = 0; _y < nlong; _y++) {
      var _index = (_x2 * nlong + _y) * 6;

      indices[_index + 0] = _y * numVertsAround + _x2;
      indices[_index + 1] = _y * numVertsAround + _x2 + 1;
      indices[_index + 2] = (_y + 1) * numVertsAround + _x2;

      indices[_index + 3] = (_y + 1) * numVertsAround + _x2;
      indices[_index + 4] = _y * numVertsAround + _x2 + 1;
      indices[_index + 5] = (_y + 1) * numVertsAround + _x2 + 1;
    }
  }

  return {
    positions: positions,
    indices: indices,
    normals: normals,
    texCoords: texCoords
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9tZXRyeS9zcGhlcmUtZ2VvbWV0cnkuanMiXSwibmFtZXMiOlsiR2VvbWV0cnkiLCJ1aWQiLCJTcGhlcmVHZW9tZXRyeSIsIm9wdHMiLCJubGF0IiwibmxvbmciLCJyYWRpdXMiLCJpZCIsIk9iamVjdCIsImFzc2lnbiIsImF0dHJpYnV0ZXMiLCJnZXRTcGhlcmVBdHRyaWJ1dGVzIiwic3RhcnRMYXQiLCJlbmRMYXQiLCJNYXRoIiwiUEkiLCJsYXRSYW5nZSIsInN0YXJ0TG9uZyIsImVuZExvbmciLCJsb25nUmFuZ2UiLCJudW1WZXJ0aWNlcyIsInZhbHVlIiwibjEiLCJuMiIsIm4zIiwidSIsInYiLCJwb3NpdGlvbnMiLCJGbG9hdDMyQXJyYXkiLCJub3JtYWxzIiwidGV4Q29vcmRzIiwiaW5kaWNlcyIsIlVpbnQxNkFycmF5IiwieSIsIngiLCJpbmRleCIsImkyIiwiaTMiLCJ0aGV0YSIsInBoaSIsInNpblRoZXRhIiwic2luIiwiY29zVGhldGEiLCJjb3MiLCJzaW5QaGkiLCJjb3NQaGkiLCJ1eCIsInV5IiwidXoiLCJyIiwibnVtVmVydHNBcm91bmQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLFFBQVAsTUFBcUIsWUFBckI7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCOztJQUVxQkMsYzs7O0FBQ25CLDRCQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxxQkFNakJBLElBTmlCLENBRW5CQyxJQUZtQjtBQUFBLFFBRW5CQSxJQUZtQiw4QkFFWixFQUZZO0FBQUEsc0JBTWpCRCxJQU5pQixDQUduQkUsS0FIbUI7QUFBQSxRQUduQkEsS0FIbUIsK0JBR1gsRUFIVztBQUFBLHVCQU1qQkYsSUFOaUIsQ0FJbkJHLE1BSm1CO0FBQUEsUUFJbkJBLE1BSm1CLGdDQUlWLENBSlU7QUFBQSxtQkFNakJILElBTmlCLENBS25CSSxFQUxtQjtBQUFBLFFBS25CQSxFQUxtQiw0QkFLZE4sSUFBSSxp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Li9nZW9tZXRyeSc7XG5pbXBvcnQge3VpZH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbmxhdCA9IDEwLFxuICAgICAgbmxvbmcgPSAxMCxcbiAgICAgIHJhZGl1cyA9IDEsXG4gICAgICBpZCA9IHVpZCgnc3BoZXJlLWdlb21ldHJ5JylcbiAgICB9ID0gb3B0cztcblxuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtpZCwgYXR0cmlidXRlczogZ2V0U3BoZXJlQXR0cmlidXRlcyhubGF0LCBubG9uZywgcmFkaXVzKX0pKTtcbiAgfVxufVxuXG4vLyBQcmltaXRpdmVzIGluc3BpcmVkIGJ5IFRETCBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2xzYW1wbGVzLyxcbi8vIGNvcHlyaWdodCAyMDExIEdvb2dsZSBJbmMuIG5ldyBCU0QgTGljZW5zZVxuLy8gKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvYnNkLWxpY2Vuc2UucGhwKS5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5mdW5jdGlvbiBnZXRTcGhlcmVBdHRyaWJ1dGVzKG5sYXQsIG5sb25nLCByYWRpdXMpIHtcbiAgY29uc3Qgc3RhcnRMYXQgPSAwO1xuICBjb25zdCBlbmRMYXQgPSBNYXRoLlBJO1xuICBjb25zdCBsYXRSYW5nZSA9IGVuZExhdCAtIHN0YXJ0TGF0O1xuICBjb25zdCBzdGFydExvbmcgPSAwO1xuICBjb25zdCBlbmRMb25nID0gMiAqIE1hdGguUEk7XG4gIGNvbnN0IGxvbmdSYW5nZSA9IGVuZExvbmcgLSBzdGFydExvbmc7XG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKG5sYXQgKyAxKSAqIChubG9uZyArIDEpO1xuXG4gIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IHZhbHVlID0gcmFkaXVzO1xuICAgIHJhZGl1cyA9IChuMSwgbjIsIG4zLCB1LCB2KSA9PiB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVmVydGljZXMgKiAzKTtcbiAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVmVydGljZXMgKiAzKTtcbiAgY29uc3QgdGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0aWNlcyAqIDIpO1xuICBjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG5sYXQgKiBubG9uZyAqIDYpO1xuXG4gIC8vIENyZWF0ZSBwb3NpdGlvbnMsIG5vcm1hbHMgYW5kIHRleENvb3Jkc1xuICBmb3IgKGxldCB5ID0gMDsgeSA8PSBubGF0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBubG9uZzsgeCsrKSB7XG5cbiAgICAgIGNvbnN0IHUgPSB4IC8gbmxvbmc7XG4gICAgICBjb25zdCB2ID0geSAvIG5sYXQ7XG5cbiAgICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiAobmxvbmcgKyAxKTtcbiAgICAgIGNvbnN0IGkyID0gaW5kZXggKiAyO1xuICAgICAgY29uc3QgaTMgPSBpbmRleCAqIDM7XG5cbiAgICAgIGNvbnN0IHRoZXRhID0gbG9uZ1JhbmdlICogdTtcbiAgICAgIGNvbnN0IHBoaSA9IGxhdFJhbmdlICogdjtcbiAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgY29uc3QgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICAgIGNvbnN0IHV4ID0gY29zVGhldGEgKiBzaW5QaGk7XG4gICAgICBjb25zdCB1eSA9IGNvc1BoaTtcbiAgICAgIGNvbnN0IHV6ID0gc2luVGhldGEgKiBzaW5QaGk7XG5cbiAgICAgIGNvbnN0IHIgPSByYWRpdXModXgsIHV5LCB1eiwgdSwgdik7XG5cbiAgICAgIHBvc2l0aW9uc1tpMyArIDBdID0gciAqIHV4O1xuICAgICAgcG9zaXRpb25zW2kzICsgMV0gPSByICogdXk7XG4gICAgICBwb3NpdGlvbnNbaTMgKyAyXSA9IHIgKiB1ejtcblxuICAgICAgbm9ybWFsc1tpMyArIDBdID0gdXg7XG4gICAgICBub3JtYWxzW2kzICsgMV0gPSB1eTtcbiAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IHV6O1xuXG4gICAgICB0ZXhDb29yZHNbaTIgKyAwXSA9IHU7XG4gICAgICB0ZXhDb29yZHNbaTIgKyAxXSA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGljZXNcbiAgY29uc3QgbnVtVmVydHNBcm91bmQgPSBubGF0ICsgMTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBubGF0OyB4KyspIHtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG5sb25nOyB5KyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gKHggKiBubG9uZyArIHkpICogNjtcblxuICAgICAgaW5kaWNlc1tpbmRleCArIDBdID0geSAqIG51bVZlcnRzQXJvdW5kICsgeDtcbiAgICAgIGluZGljZXNbaW5kZXggKyAxXSA9IHkgKiBudW1WZXJ0c0Fyb3VuZCArIHggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleCArIDJdID0gKHkgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgeDtcblxuICAgICAgaW5kaWNlc1tpbmRleCArIDNdID0gKHkgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgeDtcbiAgICAgIGluZGljZXNbaW5kZXggKyA0XSA9IHkgKiBudW1WZXJ0c0Fyb3VuZCArIHggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleCArIDVdID0gKHkgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgeCArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbnMsXG4gICAgaW5kaWNlcyxcbiAgICBub3JtYWxzLFxuICAgIHRleENvb3Jkc1xuICB9O1xufVxuIl19

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFile = loadFile;
exports.loadImage = loadImage;

var _browserRequestFile = __webpack_require__(236);

function loadFile(opts) {
  return (0, _browserRequestFile.requestFile)(opts);
}

/* global Image */

/*
 * Loads images asynchronously
 * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'
 * returns a promise tracking the load
 */
function loadImage(url) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    crossOrigin: 'anonymous'
  };

  return new Promise(function (resolve, reject) {
    try {
      var image = new Image();
      image.onload = function () {
        return resolve(image);
      };
      image.onerror = function () {
        return reject(new Error('Could not load image ' + url + '.'));
      };
      image.crossOrigin = opts.crossOrigin;
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pby9icm93c2VyLWxvYWQuanMiXSwibmFtZXMiOlsibG9hZEZpbGUiLCJsb2FkSW1hZ2UiLCJvcHRzIiwidXJsIiwiY3Jvc3NPcmlnaW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJzcmMiLCJlcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFFZ0JBLFEsR0FBQUEsUTtRQVdBQyxTLEdBQUFBLFM7O0FBYmhCOztBQUVPLFNBQVNELFFBQVQsQ0FBa0JFLElBQWxCLEVBQXdCO0FBQzdCLFNBQU8scUNBQVlBLElBQVosQ0FBUDtBQUNEOztBQUVEOztBQUVBOzs7OztBQUtPLFNBQVNELFNBQVQsQ0FBbUJFLEdBQW5CLEVBRUo7QUFBQSxNQUY0QkQsSUFFNUIsdUVBRm1DO0FBQ3BDRSxpQkFBYTtBQUR1QixHQUVuQzs7QUFDRCxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdEMsUUFBSTtBQUNGLFVBQU1DLFFBQVEsSUFBSUMsS0FBSixFQUFkO0FBQ0FELFlBQU1FLE1BQU4sR0FBZTtBQUFBLGVBQU1KLFFBQVFFLEtBQVIsQ0FBTjtBQUFBLE9BQWY7QUFDQUEsWUFBTUcsT0FBTixHQUFnQjtBQUFBLGVBQU1KLE9BQU8sSUFBSUssS0FBSiwyQkFBa0NULEdBQWxDLE9BQVAsQ0FBTjtBQUFBLE9BQWhCO0FBQ0FLLFlBQU1KLFdBQU4sR0FBb0JGLEtBQUtFLFdBQXpCO0FBQ0FJLFlBQU1LLEdBQU4sR0FBWVYsR0FBWjtBQUNELEtBTkQsQ0FNRSxPQUFPVyxLQUFQLEVBQWM7QUFDZFAsYUFBT08sS0FBUDtBQUNEO0FBQ0YsR0FWTSxDQUFQO0FBV0QiLCJmaWxlIjoiYnJvd3Nlci1sb2FkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtyZXF1ZXN0RmlsZX0gZnJvbSAnLi9icm93c2VyLXJlcXVlc3QtZmlsZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmlsZShvcHRzKSB7XG4gIHJldHVybiByZXF1ZXN0RmlsZShvcHRzKTtcbn1cblxuLyogZ2xvYmFsIEltYWdlICovXG5cbi8qXG4gKiBMb2FkcyBpbWFnZXMgYXN5bmNocm9ub3VzbHlcbiAqIGltYWdlLmNyb3NzT3JpZ2luIGNhbiBiZSBzZXQgdmlhIG9wdHMuY3Jvc3NPcmlnaW4sIGRlZmF1bHQgdG8gJ2Fub255bW91cydcbiAqIHJldHVybnMgYSBwcm9taXNlIHRyYWNraW5nIHRoZSBsb2FkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2UodXJsLCBvcHRzID0ge1xuICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbn0pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1hZ2UpO1xuICAgICAgaW1hZ2Uub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIGltYWdlICR7dXJsfS5gKSk7XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IG9wdHMuY3Jvc3NPcmlnaW47XG4gICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mathArray = __webpack_require__(26);

var _mathArray2 = _interopRequireDefault(_mathArray);

var _common = __webpack_require__(17);

var _matrix = __webpack_require__(52);

var _matrix2 = _interopRequireDefault(_matrix);

var _quaternion = __webpack_require__(53);

var _quaternion2 = _interopRequireDefault(_quaternion);

var _vector = __webpack_require__(34);

var _vector2 = _interopRequireDefault(_vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Internal constants
var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
var ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }
  return value;
}

var Euler = function (_MathArray) {
  _inherits(Euler, _MathArray);

  _createClass(Euler, [{
    key: 'ELEMENTS',
    get: function get() {
      return 4;
    }
    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

    /*
     * Number|Number[], Number, Number, Number
     */

  }], [{
    key: 'rotationOrder',
    value: function rotationOrder(order) {
      return Euler.RotationOrders[order];
    }
  }, {
    key: 'ZYX',


    // Constants
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get: function get() {
      return 0;
    }
  }, {
    key: 'YXZ',
    get: function get() {
      return 1;
    }
  }, {
    key: 'XZY',
    get: function get() {
      return 2;
    }
  }, {
    key: 'ZXY',
    get: function get() {
      return 3;
    }
  }, {
    key: 'YZX',
    get: function get() {
      return 4;
    }
  }, {
    key: 'XYZ',
    get: function get() {
      return 5;
    }
  }, {
    key: 'RollPitchYaw',
    get: function get() {
      return 0;
    }
  }, {
    key: 'DefaultOrder',
    get: function get() {
      return Euler.ZYX;
    }
  }, {
    key: 'RotationOrders',
    get: function get() {
      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
    }
  }]);

  function Euler() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;

    _classCallCheck(this, Euler);

    var _this = _possibleConstructorReturn(this, (Euler.__proto__ || Object.getPrototypeOf(Euler)).call(this));

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      _this.fromVector3.apply(_this, arguments);
    } else {
      _this.set(x, y, z, order);
    }
    return _this;
  }

  // If copied array does contain fourth element, preserves currently set order


  _createClass(Euler, [{
    key: 'copy',
    value: function copy(array) {
      for (var i = 0; i < 3; ++i) {
        this[i] = array[i];
      }
      this[3] = Number.isFinite(array[3]) || this.order;
      this.check();
      return this;
    }

    // Sets the three angles, and optionally sets the rotation order
    // If order is not specified, preserves currently set order

  }, {
    key: 'set',
    value: function set() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments[3];

      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = Number.isFinite(order) ? order : this[3];
      this.check();
      return this;
    }
  }, {
    key: 'validate',
    value: function validate() {
      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
    }

    // Does not copy the orientation element

  }, {
    key: 'toArray',
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      return array;
    }

    // Copies the orientation element

  }, {
    key: 'toArray4',
    value: function toArray4() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      array[offset + 3] = this[3];
      return array;
    }
  }, {
    key: 'toVector3',
    value: function toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this[0], this[1], this[2]);
      }
      return new _vector2.default(this[0], this[1], this[2]);
    }

    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    // x, y, z angle notation (note: only corresponds to axis in XYZ orientation)

  }, {
    key: 'fromVector3',

    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

    // Constructors
    value: function fromVector3(v, order) {
      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
    }

    // TODO - with and without 4th element

  }, {
    key: 'fromArray',
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this[0] = array[0 + offset];
      this[1] = array[1 + offset];
      this[2] = array[2 + offset];
      if (array[3] !== undefined) {
        this[3] = array[3];
      }
      this.check();
      return this;
    }

    // Common ZYX rotation order

  }, {
    key: 'fromRollPitchYaw',
    value: function fromRollPitchYaw(roll, pitch, yaw) {
      return this.set(roll, pitch, yaw, Euler.ZYX);
    }
  }, {
    key: 'fromQuaternion',
    value: function fromQuaternion(q, order) {
      this._fromRotationMatrix(_matrix2.default.fromQuaternion(q), order);
      this.check();
      return this;
    }
  }, {
    key: 'fromRotationMatrix',
    value: function fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      this._fromRotationMatrix(m, order);
      this.check();
      return this;
    }

    // ACCESSORS

    // @return {Matrix4} a rotation matrix corresponding to rotations
    //   per the specified euler angles

  }, {
    key: 'getRotationMatrix',
    value: function getRotationMatrix() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _matrix2.default();

      this._getRotationMatrix(m);
      return m;
    }
  }, {
    key: 'getQuaternion',
    value: function getQuaternion() {
      var q = new _quaternion2.default();
      switch (this[4]) {
        case Euler.XYZ:
          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);
        case Euler.YXZ:
          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);
        case Euler.ZXY:
          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);
        case Euler.ZYX:
          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);
        case Euler.YZX:
          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);
        case Euler.XZY:
          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);
        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }
    }

    // INTERNAL METHODS

    // Concersion from Euler to rotation matrix and from matrix to Euler
    // Adapted from three.js under MIT license

    // // WARNING: this discards revolution information -bhouston
    // reorder(newOrder) {
    //   const q = new Quaternion().setFromEuler(this);
    //   return this.setFromQuaternion(q, newOrder);

    /* eslint-disable complexity, max-statements, one-var */

  }, {
    key: '_fromRotationMatrix',
    value: function _fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];

      order = order || this[3];

      switch (order) {
        case Euler.XYZ:
          this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));

          if (Math.abs(m13) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m33);
            this[2] = Math.atan2(-m12, m11);
          } else {
            this[0] = Math.atan2(m32, m22);
            this[2] = 0;
          }
          break;

        case Euler.YXZ:
          this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));

          if (Math.abs(m23) < ALMOST_ONE) {
            this[1] = Math.atan2(m13, m33);
            this[2] = Math.atan2(m21, m22);
          } else {
            this[1] = Math.atan2(-m31, m11);
            this[2] = 0;
          }
          break;

        case Euler.ZXY:
          this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));

          if (Math.abs(m32) < ALMOST_ONE) {
            this[1] = Math.atan2(-m31, m33);
            this[2] = Math.atan2(-m12, m22);
          } else {
            this[1] = 0;
            this[2] = Math.atan2(m21, m11);
          }
          break;

        case Euler.ZYX:
          this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));

          if (Math.abs(m31) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m33);
            this[2] = Math.atan2(m21, m11);
          } else {
            this[0] = 0;
            this[2] = Math.atan2(-m12, m22);
          }
          break;

        case Euler.YZX:
          this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));

          if (Math.abs(m21) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m22);
            this[1] = Math.atan2(-m31, m11);
          } else {
            this[0] = 0;
            this[1] = Math.atan2(m13, m33);
          }
          break;

        case Euler.XZY:
          this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));

          if (Math.abs(m12) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m22);
            this[1] = Math.atan2(m13, m11);
          } else {
            this[0] = Math.atan2(-m23, m33);
            this[1] = 0;
          }
          break;

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      this[3] = order;

      return this;
    }
  }, {
    key: '_getRotationMatrix',
    value: function _getRotationMatrix() {
      var te = new _matrix2.default();

      var x = this.x,
          y = this.y,
          z = this.z;
      var a = Math.cos(x);
      var c = Math.cos(y);
      var e = Math.cos(z);
      var b = Math.sin(x);
      var d = Math.sin(y);
      var f = Math.sin(z);

      switch (this[3]) {
        case Euler.XYZ:
          {
            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;

            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;

            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;

            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }

        case Euler.YXZ:
          {
            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;

            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;

            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;

            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }

        case Euler.ZXY:
          {
            var _ce = c * e,
                _cf = c * f,
                _de = d * e,
                _df = d * f;

            te[0] = _ce - _df * b;
            te[4] = -a * f;
            te[8] = _de + _cf * b;

            te[1] = _cf + _de * b;
            te[5] = a * e;
            te[9] = _df - _ce * b;

            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }

        case Euler.ZYX:
          {
            var _ae = a * e,
                _af = a * f,
                _be = b * e,
                _bf = b * f;

            te[0] = c * e;
            te[4] = _be * d - _af;
            te[8] = _ae * d + _bf;

            te[1] = c * f;
            te[5] = _bf * d + _ae;
            te[9] = _af * d - _be;

            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }

        case Euler.YZX:
          {
            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;

            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;

            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;

            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }

        case Euler.XZY:
          {
            var _ac = a * c,
                _ad = a * d,
                _bc = b * c,
                _bd = b * d;

            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;

            te[1] = _ac * f + _bd;
            te[5] = a * e;
            te[9] = _ad * f - _bc;

            te[2] = _bc * f - _ad;
            te[6] = b * e;
            te[10] = _bd * f + _ac;
            break;
          }

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      // last column
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;

      // bottom row
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;

      return this;
    }
    /* eslint-enable complexity, max-statements, one-var */

  }, {
    key: 'x',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'y',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'z',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }

    // alpha, beta, gamma angle notation

  }, {
    key: 'alpha',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'beta',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'gamma',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }

    // phi, theta, psi angle notation

  }, {
    key: 'phi',
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'theta',
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: 'psi',
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }

    // rotation order, in all three angle notations

  }, {
    key: 'order',
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = checkOrder(value);
    }
  }]);

  return Euler;
}(_mathArray2.default);

exports.default = Euler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy9ldWxlci5qcyJdLCJuYW1lcyI6WyJFUlJfVU5LTk9XTl9PUkRFUiIsIkFMTU9TVF9PTkUiLCJ2YWxpZGF0ZU9yZGVyIiwidmFsdWUiLCJjaGVja09yZGVyIiwiRXJyb3IiLCJFdWxlciIsIm9yZGVyIiwiUm90YXRpb25PcmRlcnMiLCJaWVgiLCJ4IiwieSIsInoiLCJEZWZhdWx0T3JkZXIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tVmVjdG9yMyIsInNldCIsImFycmF5IiwiaSIsIk51bWJlciIsImlzRmluaXRlIiwiY2hlY2siLCJvZmZzZXQiLCJvcHRpb25hbFJlc3VsdCIsInYiLCJ1bmRlZmluZWQiLCJyb2xsIiwicGl0Y2giLCJ5YXciLCJxIiwiX2Zyb21Sb3RhdGlvbk1hdHJpeCIsImZyb21RdWF0ZXJuaW9uIiwibSIsIl9nZXRSb3RhdGlvbk1hdHJpeCIsIlhZWiIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsIllYWiIsIlpYWSIsIllaWCIsIlhaWSIsInRlIiwiZWxlbWVudHMiLCJtMTEiLCJtMTIiLCJtMTMiLCJtMjEiLCJtMjIiLCJtMjMiLCJtMzEiLCJtMzIiLCJtMzMiLCJNYXRoIiwiYXNpbiIsImFicyIsImF0YW4yIiwiYSIsImNvcyIsImMiLCJlIiwiYiIsInNpbiIsImQiLCJmIiwiYWUiLCJhZiIsImJlIiwiYmYiLCJjZSIsImNmIiwiZGUiLCJkZiIsImFjIiwiYWQiLCJiYyIsImJkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTtBQUNBLElBQU1BLG9CQUFvQiwyQkFBMUI7QUFDQSxJQUFNQyxhQUFhLE9BQW5COztBQUVBLFNBQVNDLGFBQVQsQ0FBdUJDLEtBQXZCLEVBQThCO0FBQzVCLFNBQVFBLFNBQVMsQ0FBVCxJQUFjQSxRQUFRLENBQTlC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QWlCLEs7c0JBQzFCQSxLLEVBQU87QUFBRSxhQUFPLEtBQUssQ0FBTCxJQUFVLHlCQUFZQSxLQUFaLENBQWpCO0FBQXNDOzs7d0JBQ3hDO0FBQUUsYUFBTyxLQUFLLENBQUwsQ0FBUDtBQUFpQixLO3NCQUMzQkEsSyxFQUFRO0FBQUUsYUFBTyxLQUFLLENBQUwsSUFBVSx5QkFBWUEsS0FBWixDQUFqQjtBQUFzQzs7O3dCQUN4QztBQUFFLGFBQU8sS0FBSyxDQUFMLENBQVA7QUFBaUIsSztzQkFDMUJBLEssRUFBTztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7O0FBRXpEOzs7O3dCQUNpQjtBQUFFLGFBQU8sS0FBSyxDQUFMLENBQVA7QUFBaUIsSztzQkFDNUJBLEssRUFBUztBQUFFLGFBQU8sS0FBSyxDQUFMLElBQVUseUJBQVlBLEtBQVosQ0FBakI7QUFBc0M7Ozt3QkFDeEM7QUFBRSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQWlCLEs7c0JBQzFCQSxLLEVBQU87QUFBRSxhQUFPLEtBQUssQ0FBTCxJQUFVLHlCQUFZQSxLQUFaLENBQWpCO0FBQXNDOzs7d0JBQ3hDO0FBQUUsYUFBTyxLQUFLLENBQUwsQ0FBUDtBQUFpQixLO3NCQUM1QkEsSyxFQUFTO0FBQUUsYUFBTyxLQUFLLENBQUwsSUFBVSx5QkFBWUEsS0FBWixDQUFqQjtBQUFzQzs7QUFFekQ7Ozs7d0JBQ2lCO0FBQUUsYUFBTyxLQUFLLENBQUwsQ0FBUDtBQUFpQixLO3NCQUMxQkEsSyxFQUFPO0FBQUUsYUFBTyxLQUFLLENBQUwsSUFBVUMsV0FBV0QsS0FBWCxDQUFqQjtBQUFxQzs7Ozs7O2tCQWhIckNHLEsiLCJmaWxlIjoiZXVsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vbWF0aC1hcnJheSc7XG5pbXBvcnQge2NoZWNrTnVtYmVyLCBjbGFtcH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi9tYXRyaXg0JztcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4vcXVhdGVybmlvbic7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xuXG4vLyBJbnRlcm5hbCBjb25zdGFudHNcbmNvbnN0IEVSUl9VTktOT1dOX09SREVSID0gJ1Vua25vd24gRXVsZXIgYW5nbGUgb3JkZXInO1xuY29uc3QgQUxNT1NUX09ORSA9IDAuOTk5OTk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3JkZXIodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgNik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3JkZXIodmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgMCAmJiB2YWx1ZSA+PSA2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9VTktOT1dOX09SREVSKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV1bGVyIGV4dGVuZHMgTWF0aEFycmF5IHtcblxuICAvLyBDb25zdGFudHNcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzLCBicmFjZS1zdHlsZSwgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICBzdGF0aWMgZ2V0IFpZWCgpIHsgcmV0dXJuIDA7IH1cbiAgc3RhdGljIGdldCBZWFooKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyBnZXQgWFpZKCkgeyByZXR1cm4gMjsgfVxuICBzdGF0aWMgZ2V0IFpYWSgpIHsgcmV0dXJuIDM7IH1cbiAgc3RhdGljIGdldCBZWlgoKSB7IHJldHVybiA0OyB9XG4gIHN0YXRpYyBnZXQgWFlaKCkgeyByZXR1cm4gNTsgfVxuICBzdGF0aWMgZ2V0IFJvbGxQaXRjaFlhdygpIHsgcmV0dXJuIDA7IH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRPcmRlcigpIHsgcmV0dXJuIEV1bGVyLlpZWDsgfVxuICBzdGF0aWMgZ2V0IFJvdGF0aW9uT3JkZXJzKCkge1xuICAgIHJldHVybiBbJ1pZWCcsICdZWFonLCAnWFpZJywgJ1pYWScsICdZWlgnLCAnWFlaJ107XG4gIH1cbiAgc3RhdGljIHJvdGF0aW9uT3JkZXIob3JkZXIpIHsgcmV0dXJuIEV1bGVyLlJvdGF0aW9uT3JkZXJzW29yZGVyXTsgfVxuXG4gIGdldCBFTEVNRU5UUygpIHsgcmV0dXJuIDQ7IH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1tdWx0aS1zcGFjZXMsIGJyYWNlLXN0eWxlLCBuby1yZXR1cm4tYXNzaWduICovXG5cbiAgLypcbiAgICogTnVtYmVyfE51bWJlcltdLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCBvcmRlciA9IEV1bGVyLkRlZmF1bHRPcmRlcikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgdGhpcy5mcm9tVmVjdG9yMyguLi5hcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldCh4LCB5LCB6LCBvcmRlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgY29waWVkIGFycmF5IGRvZXMgY29udGFpbiBmb3VydGggZWxlbWVudCwgcHJlc2VydmVzIGN1cnJlbnRseSBzZXQgb3JkZXJcbiAgY29weShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHRoaXNbM10gPSBOdW1iZXIuaXNGaW5pdGUoYXJyYXlbM10pIHx8IHRoaXMub3JkZXI7XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gU2V0cyB0aGUgdGhyZWUgYW5nbGVzLCBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSByb3RhdGlvbiBvcmRlclxuICAvLyBJZiBvcmRlciBpcyBub3Qgc3BlY2lmaWVkLCBwcmVzZXJ2ZXMgY3VycmVudGx5IHNldCBvcmRlclxuICBzZXQoeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIpIHtcbiAgICB0aGlzWzBdID0geDtcbiAgICB0aGlzWzFdID0geTtcbiAgICB0aGlzWzJdID0gejtcbiAgICB0aGlzWzNdID0gTnVtYmVyLmlzRmluaXRlKG9yZGVyKSA/IG9yZGVyIDogdGhpc1szXTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPcmRlcih0aGlzWzNdKSAmJlxuICAgICAgTnVtYmVyLmlzRmluaXRlKHRoaXNbMF0pICYmXG4gICAgICBOdW1iZXIuaXNGaW5pdGUodGhpc1sxXSkgJiZcbiAgICAgIE51bWJlci5pc0Zpbml0ZSh0aGlzWzJdKTtcbiAgfVxuXG4gIC8vIERvZXMgbm90IGNvcHkgdGhlIG9yaWVudGF0aW9uIGVsZW1lbnRcbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXNbMF07XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzWzFdO1xuICAgIGFycmF5W29mZnNldCArIDJdID0gdGhpc1syXTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvLyBDb3BpZXMgdGhlIG9yaWVudGF0aW9uIGVsZW1lbnRcbiAgdG9BcnJheTQoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGFycmF5W29mZnNldF0gPSB0aGlzWzBdO1xuICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpc1sxXTtcbiAgICBhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXNbMl07XG4gICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzWzNdO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHRvVmVjdG9yMyhvcHRpb25hbFJlc3VsdCkge1xuICAgIGlmIChvcHRpb25hbFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCh0aGlzWzBdLCB0aGlzWzFdLCB0aGlzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzLCBicmFjZS1zdHlsZSwgbm8tcmV0dXJuLWFzc2lnbiAqL1xuICAvLyB4LCB5LCB6IGFuZ2xlIG5vdGF0aW9uIChub3RlOiBvbmx5IGNvcnJlc3BvbmRzIHRvIGF4aXMgaW4gWFlaIG9yaWVudGF0aW9uKVxuICBnZXQgeCgpICAgICAgeyByZXR1cm4gdGhpc1swXTsgfVxuICBzZXQgeCh2YWx1ZSkgeyByZXR1cm4gdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeSgpICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgeSh2YWx1ZSkgeyByZXR1cm4gdGhpc1sxXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuICBnZXQgeigpICAgICAgeyByZXR1cm4gdGhpc1syXTsgfVxuICBzZXQgeih2YWx1ZSkgeyByZXR1cm4gdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuXG4gIC8vIGFscGhhLCBiZXRhLCBnYW1tYSBhbmdsZSBub3RhdGlvblxuICBnZXQgYWxwaGEoKSAgICAgIHsgcmV0dXJuIHRoaXNbMF07IH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7IHJldHVybiB0aGlzWzBdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCBiZXRhKCkgICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgYmV0YSh2YWx1ZSkgIHsgcmV0dXJuIHRoaXNbMV0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IGdhbW1hKCkgICAgICB7IHJldHVybiB0aGlzWzJdOyB9XG4gIHNldCBnYW1tYSh2YWx1ZSkgeyByZXR1cm4gdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuXG4gIC8vIHBoaSwgdGhldGEsIHBzaSBhbmdsZSBub3RhdGlvblxuICBnZXQgcGhpKCkgICAgICAgIHsgcmV0dXJuIHRoaXNbMF07IH1cbiAgc2V0IHBoaSh2YWx1ZSkgICB7IHJldHVybiB0aGlzWzBdID0gY2hlY2tOdW1iZXIodmFsdWUpOyB9XG4gIGdldCB0aGV0YSgpICAgICAgeyByZXR1cm4gdGhpc1sxXTsgfVxuICBzZXQgdGhldGEodmFsdWUpIHsgcmV0dXJuIHRoaXNbMV0gPSBjaGVja051bWJlcih2YWx1ZSk7IH1cbiAgZ2V0IHBzaSgpICAgICAgICB7IHJldHVybiB0aGlzWzJdOyB9XG4gIHNldCBwc2kodmFsdWUpICAgeyByZXR1cm4gdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTsgfVxuXG4gIC8vIHJvdGF0aW9uIG9yZGVyLCBpbiBhbGwgdGhyZWUgYW5nbGUgbm90YXRpb25zXG4gIGdldCBvcmRlcigpICAgICAgeyByZXR1cm4gdGhpc1szXTsgfVxuICBzZXQgb3JkZXIodmFsdWUpIHsgcmV0dXJuIHRoaXNbM10gPSBjaGVja09yZGVyKHZhbHVlKTsgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMsIGJyYWNlLXN0eWxlLCBuby1yZXR1cm4tYXNzaWduICovXG5cbiAgLy8gQ29uc3RydWN0b3JzXG4gIGZyb21WZWN0b3IzKHYsIG9yZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHZbMF0sIHZbMV0sIHZbMl0sIE51bWJlci5pc0Zpbml0ZShvcmRlcikgPyBvcmRlciA6IHRoaXNbM10pO1xuICB9XG5cbiAgLy8gVE9ETyAtIHdpdGggYW5kIHdpdGhvdXQgNHRoIGVsZW1lbnRcbiAgZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgdGhpc1swXSA9IGFycmF5WzAgKyBvZmZzZXRdO1xuICAgIHRoaXNbMV0gPSBhcnJheVsxICsgb2Zmc2V0XTtcbiAgICB0aGlzWzJdID0gYXJyYXlbMiArIG9mZnNldF07XG4gICAgaWYgKGFycmF5WzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICB9XG4gICAgdGhpcy5jaGVjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ29tbW9uIFpZWCByb3RhdGlvbiBvcmRlclxuICBmcm9tUm9sbFBpdGNoWWF3KHJvbGwsIHBpdGNoLCB5YXcpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQocm9sbCwgcGl0Y2gsIHlhdywgRXVsZXIuWllYKTtcbiAgfVxuXG4gIGZyb21RdWF0ZXJuaW9uKHEsIG9yZGVyKSB7XG4gICAgdGhpcy5fZnJvbVJvdGF0aW9uTWF0cml4KE1hdHJpeDQuZnJvbVF1YXRlcm5pb24ocSksIG9yZGVyKTtcbiAgICB0aGlzLmNoZWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIgPSBFdWxlci5EZWZhdWx0T3JkZXIpIHtcbiAgICB0aGlzLl9mcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIpO1xuICAgIHRoaXMuY2hlY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFDQ0VTU09SU1xuXG4gIC8vIEByZXR1cm4ge01hdHJpeDR9IGEgcm90YXRpb24gbWF0cml4IGNvcnJlc3BvbmRpbmcgdG8gcm90YXRpb25zXG4gIC8vICAgcGVyIHRoZSBzcGVjaWZpZWQgZXVsZXIgYW5nbGVzXG4gIGdldFJvdGF0aW9uTWF0cml4KG0gPSBuZXcgTWF0cml4NCgpKSB7XG4gICAgdGhpcy5fZ2V0Um90YXRpb25NYXRyaXgobSk7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBnZXRRdWF0ZXJuaW9uKCkge1xuICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHN3aXRjaCAodGhpc1s0XSkge1xuICAgIGNhc2UgRXVsZXIuWFlaOlxuICAgICAgcmV0dXJuIHEucm90YXRlWCh0aGlzWzBdKS5yb3RhdGVZKHRoaXNbMV0pLnJvdGF0ZVoodGhpc1syXSk7XG4gICAgY2FzZSBFdWxlci5ZWFo6XG4gICAgICByZXR1cm4gcS5yb3RhdGVZKHRoaXNbMF0pLnJvdGF0ZVgodGhpc1sxXSkucm90YXRlWih0aGlzWzJdKTtcbiAgICBjYXNlIEV1bGVyLlpYWTpcbiAgICAgIHJldHVybiBxLnJvdGF0ZVoodGhpc1swXSkucm90YXRlWCh0aGlzWzFdKS5yb3RhdGVZKHRoaXNbMl0pO1xuICAgIGNhc2UgRXVsZXIuWllYOlxuICAgICAgcmV0dXJuIHEucm90YXRlWih0aGlzWzBdKS5yb3RhdGVZKHRoaXNbMV0pLnJvdGF0ZVgodGhpc1syXSk7XG4gICAgY2FzZSBFdWxlci5ZWlg6XG4gICAgICByZXR1cm4gcS5yb3RhdGVZKHRoaXNbMF0pLnJvdGF0ZVoodGhpc1sxXSkucm90YXRlWCh0aGlzWzJdKTtcbiAgICBjYXNlIEV1bGVyLlhaWTpcbiAgICAgIHJldHVybiBxLnJvdGF0ZVgodGhpc1swXSkucm90YXRlWih0aGlzWzFdKS5yb3RhdGVZKHRoaXNbMl0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX1VOS05PV05fT1JERVIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICAvLyBDb25jZXJzaW9uIGZyb20gRXVsZXIgdG8gcm90YXRpb24gbWF0cml4IGFuZCBmcm9tIG1hdHJpeCB0byBFdWxlclxuICAvLyBBZGFwdGVkIGZyb20gdGhyZWUuanMgdW5kZXIgTUlUIGxpY2Vuc2VcblxuICAvLyAvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG4gIC8vIHJlb3JkZXIobmV3T3JkZXIpIHtcbiAgLy8gICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIodGhpcyk7XG4gIC8vICAgcmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24ocSwgbmV3T3JkZXIpO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzLCBvbmUtdmFyICovXG4gIF9mcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIgPSBFdWxlci5EZWZhdWx0T3JkZXIpIHtcbiAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgIGNvbnN0IG0xMSA9IHRlWzBdLCBtMTIgPSB0ZVs0XSwgbTEzID0gdGVbOF07XG4gICAgY29uc3QgbTIxID0gdGVbMV0sIG0yMiA9IHRlWzVdLCBtMjMgPSB0ZVs5XTtcbiAgICBjb25zdCBtMzEgPSB0ZVsyXSwgbTMyID0gdGVbNl0sIG0zMyA9IHRlWzEwXTtcblxuICAgIG9yZGVyID0gb3JkZXIgfHwgdGhpc1szXTtcblxuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIEV1bGVyLlhZWjpcbiAgICAgIHRoaXNbMV0gPSBNYXRoLmFzaW4oY2xhbXAobTEzLCAtMSwgMSkpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobTEzKSA8IEFMTU9TVF9PTkUpIHtcbiAgICAgICAgdGhpc1swXSA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgdGhpc1syXSA9IE1hdGguYXRhbjIoLW0xMiwgbTExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbMF0gPSBNYXRoLmF0YW4yKG0zMiwgbTIyKTtcbiAgICAgICAgdGhpc1syXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRXVsZXIuWVhaOlxuICAgICAgdGhpc1swXSA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobTIzKSA8IEFMTU9TVF9PTkUpIHtcbiAgICAgICAgdGhpc1sxXSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICB0aGlzWzJdID0gTWF0aC5hdGFuMihtMjEsIG0yMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzWzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgICB0aGlzWzJdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFdWxlci5aWFk6XG4gICAgICB0aGlzWzBdID0gTWF0aC5hc2luKGNsYW1wKG0zMiwgLTEsIDEpKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG0zMikgPCBBTE1PU1RfT05FKSB7XG4gICAgICAgIHRoaXNbMV0gPSBNYXRoLmF0YW4yKC1tMzEsIG0zMyk7XG4gICAgICAgIHRoaXNbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzWzFdID0gMDtcbiAgICAgICAgdGhpc1syXSA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEV1bGVyLlpZWDpcbiAgICAgIHRoaXNbMV0gPSBNYXRoLmFzaW4oLWNsYW1wKG0zMSwgLTEsIDEpKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG0zMSkgPCBBTE1PU1RfT05FKSB7XG4gICAgICAgIHRoaXNbMF0gPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcbiAgICAgICAgdGhpc1syXSA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1swXSA9IDA7XG4gICAgICAgIHRoaXNbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRXVsZXIuWVpYOlxuICAgICAgdGhpc1syXSA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMjEpIDwgQUxNT1NUX09ORSkge1xuICAgICAgICB0aGlzWzBdID0gTWF0aC5hdGFuMigtbTIzLCBtMjIpO1xuICAgICAgICB0aGlzWzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1swXSA9IDA7XG4gICAgICAgIHRoaXNbMV0gPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFdWxlci5YWlk6XG4gICAgICB0aGlzWzJdID0gTWF0aC5hc2luKC1jbGFtcChtMTIsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMTIpIDwgQUxNT1NUX09ORSkge1xuICAgICAgICB0aGlzWzBdID0gTWF0aC5hdGFuMihtMzIsIG0yMik7XG4gICAgICAgIHRoaXNbMV0gPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgIHRoaXNbMV0gPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9VTktOT1dOX09SREVSKTtcbiAgICB9XG5cbiAgICB0aGlzWzNdID0gb3JkZXI7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9nZXRSb3RhdGlvbk1hdHJpeCgpIHtcbiAgICBjb25zdCB0ZSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgIGNvbnN0IGEgPSBNYXRoLmNvcyh4KTtcbiAgICBjb25zdCBjID0gTWF0aC5jb3MoeSk7XG4gICAgY29uc3QgZSA9IE1hdGguY29zKHopO1xuICAgIGNvbnN0IGIgPSBNYXRoLnNpbih4KTtcbiAgICBjb25zdCBkID0gTWF0aC5zaW4oeSk7XG4gICAgY29uc3QgZiA9IE1hdGguc2luKHopO1xuXG4gICAgc3dpdGNoICh0aGlzWzNdKSB7XG4gICAgY2FzZSBFdWxlci5YWVo6IHtcbiAgICAgIGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cbiAgICAgIHRlWzBdID0gYyAqIGU7XG4gICAgICB0ZVs0XSA9IC1jICogZjtcbiAgICAgIHRlWzhdID0gZDtcblxuICAgICAgdGVbMV0gPSBhZiArIGJlICogZDtcbiAgICAgIHRlWzVdID0gYWUgLSBiZiAqIGQ7XG4gICAgICB0ZVs5XSA9IC1iICogYztcblxuICAgICAgdGVbMl0gPSBiZiAtIGFlICogZDtcbiAgICAgIHRlWzZdID0gYmUgKyBhZiAqIGQ7XG4gICAgICB0ZVsxMF0gPSBhICogYztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgRXVsZXIuWVhaOiB7XG4gICAgICBjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG4gICAgICB0ZVswXSA9IGNlICsgZGYgKiBiO1xuICAgICAgdGVbNF0gPSBkZSAqIGIgLSBjZjtcbiAgICAgIHRlWzhdID0gYSAqIGQ7XG5cbiAgICAgIHRlWzFdID0gYSAqIGY7XG4gICAgICB0ZVs1XSA9IGEgKiBlO1xuICAgICAgdGVbOV0gPSAtYjtcblxuICAgICAgdGVbMl0gPSBjZiAqIGIgLSBkZTtcbiAgICAgIHRlWzZdID0gZGYgKyBjZSAqIGI7XG4gICAgICB0ZVsxMF0gPSBhICogYztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgRXVsZXIuWlhZOiB7XG4gICAgICBjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG4gICAgICB0ZVswXSA9IGNlIC0gZGYgKiBiO1xuICAgICAgdGVbNF0gPSAtYSAqIGY7XG4gICAgICB0ZVs4XSA9IGRlICsgY2YgKiBiO1xuXG4gICAgICB0ZVsxXSA9IGNmICsgZGUgKiBiO1xuICAgICAgdGVbNV0gPSBhICogZTtcbiAgICAgIHRlWzldID0gZGYgLSBjZSAqIGI7XG5cbiAgICAgIHRlWzJdID0gLWEgKiBkO1xuICAgICAgdGVbNl0gPSBiO1xuICAgICAgdGVbMTBdID0gYSAqIGM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEV1bGVyLlpZWDoge1xuICAgICAgY29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgICAgdGVbMF0gPSBjICogZTtcbiAgICAgIHRlWzRdID0gYmUgKiBkIC0gYWY7XG4gICAgICB0ZVs4XSA9IGFlICogZCArIGJmO1xuXG4gICAgICB0ZVsxXSA9IGMgKiBmO1xuICAgICAgdGVbNV0gPSBiZiAqIGQgKyBhZTtcbiAgICAgIHRlWzldID0gYWYgKiBkIC0gYmU7XG5cbiAgICAgIHRlWzJdID0gLWQ7XG4gICAgICB0ZVs2XSA9IGIgKiBjO1xuICAgICAgdGVbMTBdID0gYSAqIGM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEV1bGVyLllaWDoge1xuICAgICAgY29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgICAgdGVbMF0gPSBjICogZTtcbiAgICAgIHRlWzRdID0gYmQgLSBhYyAqIGY7XG4gICAgICB0ZVs4XSA9IGJjICogZiArIGFkO1xuXG4gICAgICB0ZVsxXSA9IGY7XG4gICAgICB0ZVs1XSA9IGEgKiBlO1xuICAgICAgdGVbOV0gPSAtYiAqIGU7XG5cbiAgICAgIHRlWzJdID0gLWQgKiBlO1xuICAgICAgdGVbNl0gPSBhZCAqIGYgKyBiYztcbiAgICAgIHRlWzEwXSA9IGFjIC0gYmQgKiBmO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBFdWxlci5YWlk6IHtcbiAgICAgIGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cbiAgICAgIHRlWzBdID0gYyAqIGU7XG4gICAgICB0ZVs0XSA9IC1mO1xuICAgICAgdGVbOF0gPSBkICogZTtcblxuICAgICAgdGVbMV0gPSBhYyAqIGYgKyBiZDtcbiAgICAgIHRlWzVdID0gYSAqIGU7XG4gICAgICB0ZVs5XSA9IGFkICogZiAtIGJjO1xuXG4gICAgICB0ZVsyXSA9IGJjICogZiAtIGFkO1xuICAgICAgdGVbNl0gPSBiICogZTtcbiAgICAgIHRlWzEwXSA9IGJkICogZiArIGFjO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfVU5LTk9XTl9PUkRFUik7XG4gICAgfVxuXG4gICAgLy8gbGFzdCBjb2x1bW5cbiAgICB0ZVszXSA9IDA7XG4gICAgdGVbN10gPSAwO1xuICAgIHRlWzExXSA9IDA7XG5cbiAgICAvLyBib3R0b20gcm93XG4gICAgdGVbMTJdID0gMDtcbiAgICB0ZVsxM10gPSAwO1xuICAgIHRlWzE0XSA9IDA7XG4gICAgdGVbMTVdID0gMTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMsIG9uZS12YXIgKi9cbn1cbiJdfQ==

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global, document */
module.exports = {
  window: typeof window !== 'undefined' ? window : global,
  global: typeof global !== 'undefined' ? global : window,
  document: typeof document !== 'undefined' ? document : {}
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9nbG9iYWxzLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJkb2N1bWVudCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQUEsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxVQUFRLE9BQU9BLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDQyxNQURsQztBQUVmQSxVQUFRLE9BQU9BLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDRCxNQUZsQztBQUdmRSxZQUFVLE9BQU9BLFFBQVAsS0FBb0IsV0FBcEIsR0FBa0NBLFFBQWxDLEdBQTZDO0FBSHhDLENBQWpCIiwiZmlsZSI6Imdsb2JhbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93LCBnbG9iYWwsIGRvY3VtZW50ICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9XG59O1xuIl19
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getGLTypeFromTypedArray;
/* harmony export (immutable) */ __webpack_exports__["b"] = getTypedArrayFromGLType;
// GL Constants
var GL_BYTE = 0x1400;
var GL_UNSIGNED_BYTE = 0x1401;
var GL_SHORT = 0x1402;
var GL_UNSIGNED_SHORT = 0x1403;
var GL_INT = 0x1404;
var GL_UNSIGNED_INT = 0x1405;
var GL_FLOAT = 0x1406;
var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;

var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';

// Converts TYPED ARRAYS to corresponding GL constant
// Used to auto deduce gl parameter types
function getGLTypeFromTypedArray(arrayOrType) {
  // If typed array, look up constructor
  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return GL_FLOAT;
    case Uint16Array:
      return GL_UNSIGNED_SHORT;
    case Uint32Array:
      return GL_UNSIGNED_INT;
    case Uint8Array:
      return GL_UNSIGNED_BYTE;
    case Uint8ClampedArray:
      return GL_UNSIGNED_BYTE;
    case Int8Array:
      return GL_BYTE;
    case Int16Array:
      return GL_SHORT;
    case Int32Array:
      return GL_INT;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}

// Converts GL constant to corresponding TYPED ARRAY
// Used to auto deduce gl parameter types

/* eslint-disable complexity */
function getTypedArrayFromGLType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case GL_FLOAT:
      return Float32Array;
    case GL_UNSIGNED_SHORT:
    case GL_UNSIGNED_SHORT_5_6_5:
    case GL_UNSIGNED_SHORT_4_4_4_4:
    case GL_UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case GL_UNSIGNED_INT:
      return Uint32Array;
    case GL_UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case GL_BYTE:
      return Int8Array;
    case GL_SHORT:
      return Int16Array;
    case GL_INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
/* eslint-enable complexity */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy90eXBlZC1hcnJheS11dGlscy5qcyJdLCJuYW1lcyI6WyJHTF9CWVRFIiwiR0xfVU5TSUdORURfQllURSIsIkdMX1NIT1JUIiwiR0xfVU5TSUdORURfU0hPUlQiLCJHTF9JTlQiLCJHTF9VTlNJR05FRF9JTlQiLCJHTF9GTE9BVCIsIkdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQiLCJHTF9VTlNJR05FRF9TSE9SVF81XzVfNV8xIiwiR0xfVU5TSUdORURfU0hPUlRfNV82XzUiLCJFUlJfVFlQRV9ERURVQ1RJT04iLCJnZXRHTFR5cGVGcm9tVHlwZWRBcnJheSIsImFycmF5T3JUeXBlIiwidHlwZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVWludDhBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJFcnJvciIsImdldFR5cGVkQXJyYXlGcm9tR0xUeXBlIiwiZ2xUeXBlIiwiY2xhbXBlZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFNQSxVQUFVLE1BQWhCO0FBQ0EsSUFBTUMsbUJBQW1CLE1BQXpCO0FBQ0EsSUFBTUMsV0FBVyxNQUFqQjtBQUNBLElBQU1DLG9CQUFvQixNQUExQjtBQUNBLElBQU1DLFNBQVMsTUFBZjtBQUNBLElBQU1DLGtCQUFrQixNQUF4QjtBQUNBLElBQU1DLFdBQVcsTUFBakI7QUFDQSxJQUFNQyw0QkFBNEIsTUFBbEM7QUFDQSxJQUFNQyw0QkFBNEIsTUFBbEM7QUFDQSxJQUFNQywwQkFBMEIsTUFBaEM7O0FBRUEsSUFBTUMscUJBQXFCLCtDQUEzQjs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxTQUFTQyx1QkFBVCxDQUFpQ0MsV0FBakMsRUFBOEM7QUFDbkQ7QUFDQSxNQUFNQyxPQUFPQyxZQUFZQyxNQUFaLENBQW1CSCxXQUFuQixJQUFrQ0EsWUFBWUksV0FBOUMsR0FBNERKLFdBQXpFO0FBQ0EsVUFBUUMsSUFBUjtBQUNBLFNBQUtJLFlBQUw7QUFBbUIsYUFBT1gsUUFBUDtBQUNuQixTQUFLWSxXQUFMO0FBQWtCLGFBQU9mLGlCQUFQO0FBQ2xCLFNBQUtnQixXQUFMO0FBQWtCLGFBQU9kLGVBQVA7QUFDbEIsU0FBS2UsVUFBTDtBQUFpQixhQUFPbkIsZ0JBQVA7QUFDakIsU0FBS29CLGlCQUFMO0FBQXdCLGFBQU9wQixnQkFBUDtBQUN4QixTQUFLcUIsU0FBTDtBQUFnQixhQUFPdEIsT0FBUDtBQUNoQixTQUFLdUIsVUFBTDtBQUFpQixhQUFPckIsUUFBUDtBQUNqQixTQUFLc0IsVUFBTDtBQUFpQixhQUFPcEIsTUFBUDtBQUNqQjtBQUNFLFlBQU0sSUFBSXFCLEtBQUosQ0FBVWYsa0JBQVYsQ0FBTjtBQVZGO0FBWUQ7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLE9BQU8sU0FBU2dCLHVCQUFULENBQWlDQyxNQUFqQyxFQUFnRTtBQUFBLGlGQUFKLEVBQUk7QUFBQSwwQkFBdEJDLE9BQXNCO0FBQUEsTUFBdEJBLE9BQXNCLGdDQUFaLElBQVk7O0FBQ3JFO0FBQ0EsVUFBUUQsTUFBUjtBQUNBLFNBQUtyQixRQUFMO0FBQ0UsYUFBT1csWUFBUDtBQUNGLFNBQUtkLGlCQUFMO0FBQ0EsU0FBS00sdUJBQUw7QUFDQSxTQUFLRix5QkFBTDtBQUNBLFNBQUtDLHlCQUFMO0FBQ0UsYUFBT1UsV0FBUDtBQUNGLFNBQUtiLGVBQUw7QUFDRSxhQUFPYyxXQUFQO0FBQ0YsU0FBS2xCLGdCQUFMO0FBQ0UsYUFBTzJCLFVBQVVQLGlCQUFWLEdBQThCRCxVQUFyQztBQUNGLFNBQUtwQixPQUFMO0FBQ0UsYUFBT3NCLFNBQVA7QUFDRixTQUFLcEIsUUFBTDtBQUNFLGFBQU9xQixVQUFQO0FBQ0YsU0FBS25CLE1BQUw7QUFDRSxhQUFPb0IsVUFBUDtBQUNGO0FBQ0UsWUFBTSxJQUFJQyxLQUFKLENBQVUsb0RBQVYsQ0FBTjtBQW5CRjtBQXFCRDtBQUNEIiwiZmlsZSI6InR5cGVkLWFycmF5LXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gR0wgQ29uc3RhbnRzXG5jb25zdCBHTF9CWVRFID0gMHgxNDAwO1xuY29uc3QgR0xfVU5TSUdORURfQllURSA9IDB4MTQwMTtcbmNvbnN0IEdMX1NIT1JUID0gMHgxNDAyO1xuY29uc3QgR0xfVU5TSUdORURfU0hPUlQgPSAweDE0MDM7XG5jb25zdCBHTF9JTlQgPSAweDE0MDQ7XG5jb25zdCBHTF9VTlNJR05FRF9JTlQgPSAweDE0MDU7XG5jb25zdCBHTF9GTE9BVCA9IDB4MTQwNjtcbmNvbnN0IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XG5jb25zdCBHTF9VTlNJR05FRF9TSE9SVF81XzVfNV8xID0gMHg4MDM0O1xuY29uc3QgR0xfVU5TSUdORURfU0hPUlRfNV82XzUgPSAweDgzNjM7XG5cbmNvbnN0IEVSUl9UWVBFX0RFRFVDVElPTiA9ICdGYWlsZWQgdG8gZGVkdWNlIEdMIGNvbnN0YW50IGZyb20gdHlwZWQgYXJyYXknO1xuXG4vLyBDb252ZXJ0cyBUWVBFRCBBUlJBWVMgdG8gY29ycmVzcG9uZGluZyBHTCBjb25zdGFudFxuLy8gVXNlZCB0byBhdXRvIGRlZHVjZSBnbCBwYXJhbWV0ZXIgdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRHTFR5cGVGcm9tVHlwZWRBcnJheShhcnJheU9yVHlwZSkge1xuICAvLyBJZiB0eXBlZCBhcnJheSwgbG9vayB1cCBjb25zdHJ1Y3RvclxuICBjb25zdCB0eXBlID0gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmF5T3JUeXBlKSA/IGFycmF5T3JUeXBlLmNvbnN0cnVjdG9yIDogYXJyYXlPclR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlIEZsb2F0MzJBcnJheTogcmV0dXJuIEdMX0ZMT0FUO1xuICBjYXNlIFVpbnQxNkFycmF5OiByZXR1cm4gR0xfVU5TSUdORURfU0hPUlQ7XG4gIGNhc2UgVWludDMyQXJyYXk6IHJldHVybiBHTF9VTlNJR05FRF9JTlQ7XG4gIGNhc2UgVWludDhBcnJheTogcmV0dXJuIEdMX1VOU0lHTkVEX0JZVEU7XG4gIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6IHJldHVybiBHTF9VTlNJR05FRF9CWVRFO1xuICBjYXNlIEludDhBcnJheTogcmV0dXJuIEdMX0JZVEU7XG4gIGNhc2UgSW50MTZBcnJheTogcmV0dXJuIEdMX1NIT1JUO1xuICBjYXNlIEludDMyQXJyYXk6IHJldHVybiBHTF9JTlQ7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9UWVBFX0RFRFVDVElPTik7XG4gIH1cbn1cblxuLy8gQ29udmVydHMgR0wgY29uc3RhbnQgdG8gY29ycmVzcG9uZGluZyBUWVBFRCBBUlJBWVxuLy8gVXNlZCB0byBhdXRvIGRlZHVjZSBnbCBwYXJhbWV0ZXIgdHlwZXNcblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVkQXJyYXlGcm9tR0xUeXBlKGdsVHlwZSwge2NsYW1wZWQgPSB0cnVlfSA9IHt9KSB7XG4gIC8vIFNvcnRlZCBpbiBzb21lIG9yZGVyIG9mIGxpa2VsaWhvb2QgdG8gcmVkdWNlIGFtb3VudCBvZiBjb21wYXJpc29uc1xuICBzd2l0Y2ggKGdsVHlwZSkge1xuICBjYXNlIEdMX0ZMT0FUOlxuICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gIGNhc2UgR0xfVU5TSUdORURfU0hPUlQ6XG4gIGNhc2UgR0xfVU5TSUdORURfU0hPUlRfNV82XzU6XG4gIGNhc2UgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNDpcbiAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVF81XzVfNV8xOlxuICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgY2FzZSBHTF9VTlNJR05FRF9JTlQ6XG4gICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICBjYXNlIEdMX1VOU0lHTkVEX0JZVEU6XG4gICAgcmV0dXJuIGNsYW1wZWQgPyBVaW50OENsYW1wZWRBcnJheSA6IFVpbnQ4QXJyYXk7XG4gIGNhc2UgR0xfQllURTpcbiAgICByZXR1cm4gSW50OEFycmF5O1xuICBjYXNlIEdMX1NIT1JUOlxuICAgIHJldHVybiBJbnQxNkFycmF5O1xuICBjYXNlIEdMX0lOVDpcbiAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWR1Y2UgdHlwZWQgYXJyYXkgdHlwZSBmcm9tIEdMIGNvbnN0YW50Jyk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuIl19

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return webGLTypesAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return WebGLRenderingContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return WebGLProgram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return WebGLShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return WebGLBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return WebGLFramebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return WebGLRenderbuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return WebGLTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return WebGLUniformLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return WebGLActiveInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return WebGLShaderPrecisionFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return WebGL2RenderingContext; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(33);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// WEBGL BUILT-IN TYPES
// 1) Exports all WebGL constants as {GL}
// 2) Enables app to "import" WebGL types
//    - Importing these types makes them known to eslint etc.
//    - Provides dummy types for WebGL2 when not available to streamline
//      library code.
//    - Exports types from headless gl when running under Node.js



var DummyType = function DummyType() {
  _classCallCheck(this, DummyType);
};

var _ref = __WEBPACK_IMPORTED_MODULE_0__init__["default"].globals.headlessTypes || __WEBPACK_IMPORTED_MODULE_0__init__["global"],
    _ref$WebGLRenderingCo = _ref.WebGLRenderingContext,
    WebGLRenderingContext = _ref$WebGLRenderingCo === undefined ? DummyType : _ref$WebGLRenderingCo,
    _ref$WebGLProgram = _ref.WebGLProgram,
    WebGLProgram = _ref$WebGLProgram === undefined ? DummyType : _ref$WebGLProgram,
    _ref$WebGLShader = _ref.WebGLShader,
    WebGLShader = _ref$WebGLShader === undefined ? DummyType : _ref$WebGLShader,
    _ref$WebGLBuffer = _ref.WebGLBuffer,
    WebGLBuffer = _ref$WebGLBuffer === undefined ? DummyType : _ref$WebGLBuffer,
    _ref$WebGLFramebuffer = _ref.WebGLFramebuffer,
    WebGLFramebuffer = _ref$WebGLFramebuffer === undefined ? DummyType : _ref$WebGLFramebuffer,
    _ref$WebGLRenderbuffe = _ref.WebGLRenderbuffer,
    WebGLRenderbuffer = _ref$WebGLRenderbuffe === undefined ? DummyType : _ref$WebGLRenderbuffe,
    _ref$WebGLTexture = _ref.WebGLTexture,
    WebGLTexture = _ref$WebGLTexture === undefined ? DummyType : _ref$WebGLTexture,
    _ref$WebGLUniformLoca = _ref.WebGLUniformLocation,
    WebGLUniformLocation = _ref$WebGLUniformLoca === undefined ? DummyType : _ref$WebGLUniformLoca,
    _ref$WebGLActiveInfo = _ref.WebGLActiveInfo,
    WebGLActiveInfo = _ref$WebGLActiveInfo === undefined ? DummyType : _ref$WebGLActiveInfo,
    _ref$WebGLShaderPreci = _ref.WebGLShaderPrecisionFormat,
    WebGLShaderPrecisionFormat = _ref$WebGLShaderPreci === undefined ? DummyType : _ref$WebGLShaderPreci;

var webGLTypesAvailable = WebGLRenderingContext !== DummyType && WebGLProgram !== DummyType && WebGLShader !== DummyType && WebGLBuffer !== DummyType && WebGLFramebuffer !== DummyType && WebGLRenderbuffer !== DummyType && WebGLTexture !== DummyType && WebGLUniformLocation !== DummyType && WebGLActiveInfo !== DummyType && WebGLShaderPrecisionFormat !== DummyType;

// Ensures that WebGL2RenderingContext is defined in non-WebGL2 environments
// so that apps can test their gl contexts with instanceof
// E.g. if (gl instanceof WebGL2RenderingContext) { }
function getWebGL2RenderingContext() {
  var WebGL2RenderingContextNotSupported = function WebGL2RenderingContextNotSupported() {
    _classCallCheck(this, WebGL2RenderingContextNotSupported);
  };

  return __WEBPACK_IMPORTED_MODULE_0__init__["global"].WebGL2RenderingContext || WebGL2RenderingContextNotSupported;
}

// Ensure that Image is defined under Node.js
function getImage() {
  var ImageNotSupported = function ImageNotSupported() {
    _classCallCheck(this, ImageNotSupported);
  };

  return __WEBPACK_IMPORTED_MODULE_0__init__["global"].Image || ImageNotSupported;
}

var WebGL2RenderingContext = getWebGL2RenderingContext();
var Image = getImage();

// Export the standard WebGL types

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy93ZWJnbC9hcGkvd2ViZ2wtdHlwZXMuanMiXSwibmFtZXMiOlsibHVtYSIsImdsb2JhbCIsIkR1bW15VHlwZSIsImdsb2JhbHMiLCJoZWFkbGVzc1R5cGVzIiwiV2ViR0xSZW5kZXJpbmdDb250ZXh0IiwiV2ViR0xQcm9ncmFtIiwiV2ViR0xTaGFkZXIiLCJXZWJHTEJ1ZmZlciIsIldlYkdMRnJhbWVidWZmZXIiLCJXZWJHTFJlbmRlcmJ1ZmZlciIsIldlYkdMVGV4dHVyZSIsIldlYkdMVW5pZm9ybUxvY2F0aW9uIiwiV2ViR0xBY3RpdmVJbmZvIiwiV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQiLCJ3ZWJHTFR5cGVzQXZhaWxhYmxlIiwiZ2V0V2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsIldlYkdMMlJlbmRlcmluZ0NvbnRleHROb3RTdXBwb3J0ZWQiLCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0IiwiZ2V0SW1hZ2UiLCJJbWFnZU5vdFN1cHBvcnRlZCIsIkltYWdlIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLElBQVAsSUFBY0MsTUFBZCxRQUEyQixZQUEzQjs7SUFFTUMsUzs7OztXQWFGRixLQUFLRyxPQUFMLENBQWFDLGFBQWIsSUFBOEJILE07aUNBVmhDSSxxQjtJQUFBQSxxQix5Q0FBd0JILFM7NkJBQ3hCSSxZO0lBQUFBLFkscUNBQWVKLFM7NEJBQ2ZLLFc7SUFBQUEsVyxvQ0FBY0wsUzs0QkFDZE0sVztJQUFBQSxXLG9DQUFjTixTO2lDQUNkTyxnQjtJQUFBQSxnQix5Q0FBbUJQLFM7aUNBQ25CUSxpQjtJQUFBQSxpQix5Q0FBb0JSLFM7NkJBQ3BCUyxZO0lBQUFBLFkscUNBQWVULFM7aUNBQ2ZVLG9CO0lBQUFBLG9CLHlDQUF1QlYsUztnQ0FDdkJXLGU7SUFBQUEsZSx3Q0FBa0JYLFM7aUNBQ2xCWSwwQjtJQUFBQSwwQix5Q0FBNkJaLFM7O0FBRy9CLE9BQU8sSUFBTWEsc0JBQ1hWLDBCQUEwQkgsU0FBMUIsSUFDQUksaUJBQWlCSixTQURqQixJQUVBSyxnQkFBZ0JMLFNBRmhCLElBR0FNLGdCQUFnQk4sU0FIaEIsSUFJQU8scUJBQXFCUCxTQUpyQixJQUtBUSxzQkFBc0JSLFNBTHRCLElBTUFTLGlCQUFpQlQsU0FOakIsSUFPQVUseUJBQXlCVixTQVB6QixJQVFBVyxvQkFBb0JYLFNBUnBCLElBU0FZLCtCQUErQlosU0FWMUI7O0FBWVA7QUFDQTtBQUNBO0FBQ0EsU0FBU2MseUJBQVQsR0FBcUM7QUFBQSxNQUM3QkMsa0NBRDZCO0FBQUE7QUFBQTs7QUFFbkMsU0FBT2hCLE9BQU9pQixzQkFBUCxJQUFpQ0Qsa0NBQXhDO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTRSxRQUFULEdBQW9CO0FBQUEsTUFDWkMsaUJBRFk7QUFBQTtBQUFBOztBQUVsQixTQUFPbkIsT0FBT29CLEtBQVAsSUFBZ0JELGlCQUF2QjtBQUNEOztBQUVELElBQU1GLHlCQUF5QkYsMkJBQS9CO0FBQ0EsSUFBTUssUUFBUUYsVUFBZDs7QUFFQTtBQUNBLFNBQ0VFLEtBREYsRUFHRWhCLHFCQUhGLEVBSUVDLFlBSkYsRUFLRUMsV0FMRixFQU1FQyxXQU5GLEVBT0VDLGdCQVBGLEVBUUVDLGlCQVJGLEVBU0VDLFlBVEYsRUFVRUMsb0JBVkYsRUFXRUMsZUFYRixFQVlFQywwQkFaRixFQWNFSSxzQkFkRiIsImZpbGUiOiJ3ZWJnbC10eXBlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdFQkdMIEJVSUxULUlOIFRZUEVTXG4vLyAxKSBFeHBvcnRzIGFsbCBXZWJHTCBjb25zdGFudHMgYXMge0dMfVxuLy8gMikgRW5hYmxlcyBhcHAgdG8gXCJpbXBvcnRcIiBXZWJHTCB0eXBlc1xuLy8gICAgLSBJbXBvcnRpbmcgdGhlc2UgdHlwZXMgbWFrZXMgdGhlbSBrbm93biB0byBlc2xpbnQgZXRjLlxuLy8gICAgLSBQcm92aWRlcyBkdW1teSB0eXBlcyBmb3IgV2ViR0wyIHdoZW4gbm90IGF2YWlsYWJsZSB0byBzdHJlYW1saW5lXG4vLyAgICAgIGxpYnJhcnkgY29kZS5cbi8vICAgIC0gRXhwb3J0cyB0eXBlcyBmcm9tIGhlYWRsZXNzIGdsIHdoZW4gcnVubmluZyB1bmRlciBOb2RlLmpzXG5cbmltcG9ydCBsdW1hLCB7Z2xvYmFsfSBmcm9tICcuLi8uLi9pbml0JztcblxuY2xhc3MgRHVtbXlUeXBlIHt9XG5cbmNvbnN0IHtcbiAgV2ViR0xSZW5kZXJpbmdDb250ZXh0ID0gRHVtbXlUeXBlLFxuICBXZWJHTFByb2dyYW0gPSBEdW1teVR5cGUsXG4gIFdlYkdMU2hhZGVyID0gRHVtbXlUeXBlLFxuICBXZWJHTEJ1ZmZlciA9IER1bW15VHlwZSxcbiAgV2ViR0xGcmFtZWJ1ZmZlciA9IER1bW15VHlwZSxcbiAgV2ViR0xSZW5kZXJidWZmZXIgPSBEdW1teVR5cGUsXG4gIFdlYkdMVGV4dHVyZSA9IER1bW15VHlwZSxcbiAgV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBEdW1teVR5cGUsXG4gIFdlYkdMQWN0aXZlSW5mbyA9IER1bW15VHlwZSxcbiAgV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBEdW1teVR5cGVcbn0gPSBsdW1hLmdsb2JhbHMuaGVhZGxlc3NUeXBlcyB8fCBnbG9iYWw7XG5cbmV4cG9ydCBjb25zdCB3ZWJHTFR5cGVzQXZhaWxhYmxlID1cbiAgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSBEdW1teVR5cGUgJiZcbiAgV2ViR0xQcm9ncmFtICE9PSBEdW1teVR5cGUgJiZcbiAgV2ViR0xTaGFkZXIgIT09IER1bW15VHlwZSAmJlxuICBXZWJHTEJ1ZmZlciAhPT0gRHVtbXlUeXBlICYmXG4gIFdlYkdMRnJhbWVidWZmZXIgIT09IER1bW15VHlwZSAmJlxuICBXZWJHTFJlbmRlcmJ1ZmZlciAhPT0gRHVtbXlUeXBlICYmXG4gIFdlYkdMVGV4dHVyZSAhPT0gRHVtbXlUeXBlICYmXG4gIFdlYkdMVW5pZm9ybUxvY2F0aW9uICE9PSBEdW1teVR5cGUgJiZcbiAgV2ViR0xBY3RpdmVJbmZvICE9PSBEdW1teVR5cGUgJiZcbiAgV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQgIT09IER1bW15VHlwZTtcblxuLy8gRW5zdXJlcyB0aGF0IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgaXMgZGVmaW5lZCBpbiBub24tV2ViR0wyIGVudmlyb25tZW50c1xuLy8gc28gdGhhdCBhcHBzIGNhbiB0ZXN0IHRoZWlyIGdsIGNvbnRleHRzIHdpdGggaW5zdGFuY2VvZlxuLy8gRS5nLiBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7IH1cbmZ1bmN0aW9uIGdldFdlYkdMMlJlbmRlcmluZ0NvbnRleHQoKSB7XG4gIGNsYXNzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHROb3RTdXBwb3J0ZWQge31cbiAgcmV0dXJuIGdsb2JhbC5XZWJHTDJSZW5kZXJpbmdDb250ZXh0IHx8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHROb3RTdXBwb3J0ZWQ7XG59XG5cbi8vIEVuc3VyZSB0aGF0IEltYWdlIGlzIGRlZmluZWQgdW5kZXIgTm9kZS5qc1xuZnVuY3Rpb24gZ2V0SW1hZ2UoKSB7XG4gIGNsYXNzIEltYWdlTm90U3VwcG9ydGVkIHt9XG4gIHJldHVybiBnbG9iYWwuSW1hZ2UgfHwgSW1hZ2VOb3RTdXBwb3J0ZWQ7XG59XG5cbmNvbnN0IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBnZXRXZWJHTDJSZW5kZXJpbmdDb250ZXh0KCk7XG5jb25zdCBJbWFnZSA9IGdldEltYWdlKCk7XG5cbi8vIEV4cG9ydCB0aGUgc3RhbmRhcmQgV2ViR0wgdHlwZXNcbmV4cG9ydCB7XG4gIEltYWdlLFxuXG4gIFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgV2ViR0xQcm9ncmFtLFxuICBXZWJHTFNoYWRlcixcbiAgV2ViR0xCdWZmZXIsXG4gIFdlYkdMRnJhbWVidWZmZXIsXG4gIFdlYkdMUmVuZGVyYnVmZmVyLFxuICBXZWJHTFRleHR1cmUsXG4gIFdlYkdMVW5pZm9ybUxvY2F0aW9uLFxuICBXZWJHTEFjdGl2ZUluZm8sXG4gIFdlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0LFxuXG4gIFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbn07XG4iXX0=

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = makeDebugContext;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webgl_debug__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webgl_debug___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_webgl_debug__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__debug_parameters__ = __webpack_require__(110);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Khronos Debug support module




// Uses webgl-debug
function makeDebugContext(gl) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__debug_parameters__["a" /* installParameterDefinitions */])();
  var debugGL = __WEBPACK_IMPORTED_MODULE_0_webgl_debug___default.a.makeDebugContext(gl, throwOnError, validateArgsAndLog);

  var WebGLDebugContext = function WebGLDebugContext() {
    _classCallCheck(this, WebGLDebugContext);
  };

  Object.assign(WebGLDebugContext.prototype, debugGL);
  debugGL.debug = true;
  return debugGL;
}

// DEBUG TRACING

function getFunctionString(functionName, functionArgs) {
  var args = __WEBPACK_IMPORTED_MODULE_0_webgl_debug___default.a.glFunctionArgsToString(functionName, functionArgs);
  args = '' + args.slice(0, 100) + (args.length > 100 ? '...' : '');
  return 'gl.' + functionName + '(' + args + ')';
}

function throwOnError(err, functionName, args) {
  var errorMessage = __WEBPACK_IMPORTED_MODULE_0_webgl_debug___default.a.glEnumToString(err);
  var functionArgs = __WEBPACK_IMPORTED_MODULE_0_webgl_debug___default.a.glFunctionArgsToString(functionName, args);
  throw new Error(errorMessage + ' was caused by call to: ' + ('gl.' + functionName + '(' + functionArgs + ')'));
}

// Don't generate function string until it is needed
function validateArgsAndLog(functionName, functionArgs) {
  var functionString = void 0;
  if (__WEBPACK_IMPORTED_MODULE_1__utils__["log"].priority >= 4) {
    functionString = getFunctionString(functionName, functionArgs);
    __WEBPACK_IMPORTED_MODULE_1__utils__["log"].info(4, '' + functionString);
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = functionArgs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var arg = _step.value;

      if (arg === undefined) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        throw new Error('Undefined argument: ' + functionString);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (__WEBPACK_IMPORTED_MODULE_1__utils__["log"].break) {
    functionString = functionString || getFunctionString(functionName, functionArgs);
    var isBreakpoint = __WEBPACK_IMPORTED_MODULE_1__utils__["log"].break && __WEBPACK_IMPORTED_MODULE_1__utils__["log"].break.every(function (breakString) {
      return functionString.indexOf(breakString) !== -1;
    });

    /* eslint-disable no-debugger */
    if (isBreakpoint) {
      debugger;
    }
    /* eslint-enable no-debugger */
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9jb250ZXh0LWRlYnVnLmpzIl0sIm5hbWVzIjpbIldlYkdMRGVidWciLCJsb2ciLCJpbnN0YWxsUGFyYW1ldGVyRGVmaW5pdGlvbnMiLCJtYWtlRGVidWdDb250ZXh0IiwiZ2wiLCJkZWJ1Z0dMIiwidGhyb3dPbkVycm9yIiwidmFsaWRhdGVBcmdzQW5kTG9nIiwiV2ViR0xEZWJ1Z0NvbnRleHQiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJkZWJ1ZyIsImdldEZ1bmN0aW9uU3RyaW5nIiwiZnVuY3Rpb25OYW1lIiwiZnVuY3Rpb25BcmdzIiwiYXJncyIsImdsRnVuY3Rpb25BcmdzVG9TdHJpbmciLCJzbGljZSIsImxlbmd0aCIsImVyciIsImVycm9yTWVzc2FnZSIsImdsRW51bVRvU3RyaW5nIiwiRXJyb3IiLCJmdW5jdGlvblN0cmluZyIsInByaW9yaXR5IiwiaW5mbyIsImFyZyIsInVuZGVmaW5lZCIsImJyZWFrIiwiaXNCcmVha3BvaW50IiwiZXZlcnkiLCJpbmRleE9mIiwiYnJlYWtTdHJpbmciXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQSxPQUFPQSxVQUFQLE1BQXVCLGFBQXZCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixVQUFsQjtBQUNBLFNBQVFDLDJCQUFSLFFBQTBDLG9CQUExQzs7QUFFQTtBQUNBLE9BQU8sU0FBU0MsZ0JBQVQsQ0FBMEJDLEVBQTFCLEVBQThCO0FBQ25DRjtBQUNBLE1BQU1HLFVBQVVMLFdBQVdHLGdCQUFYLENBQTRCQyxFQUE1QixFQUFnQ0UsWUFBaEMsRUFBOENDLGtCQUE5QyxDQUFoQjs7QUFGbUMsTUFHN0JDLGlCQUg2QjtBQUFBO0FBQUE7O0FBSW5DQyxTQUFPQyxNQUFQLENBQWNGLGtCQUFrQkcsU0FBaEMsRUFBMkNOLE9BQTNDO0FBQ0FBLFVBQVFPLEtBQVIsR0FBZ0IsSUFBaEI7QUFDQSxTQUFPUCxPQUFQO0FBQ0Q7O0FBRUQ7O0FBRUEsU0FBU1EsaUJBQVQsQ0FBMkJDLFlBQTNCLEVBQXlDQyxZQUF6QyxFQUF1RDtBQUNyRCxNQUFJQyxPQUFPaEIsV0FBV2lCLHNCQUFYLENBQWtDSCxZQUFsQyxFQUFnREMsWUFBaEQsQ0FBWDtBQUNBQyxjQUFVQSxLQUFLRSxLQUFMLENBQVcsQ0FBWCxFQUFjLEdBQWQsQ0FBVixJQUErQkYsS0FBS0csTUFBTCxHQUFjLEdBQWQsR0FBb0IsS0FBcEIsR0FBNEIsRUFBM0Q7QUFDQSxpQkFBYUwsWUFBYixTQUE2QkUsSUFBN0I7QUFDRDs7QUFFRCxTQUFTVixZQUFULENBQXNCYyxHQUF0QixFQUEyQk4sWUFBM0IsRUFBeUNFLElBQXpDLEVBQStDO0FBQzdDLE1BQU1LLGVBQWVyQixXQUFXc0IsY0FBWCxDQUEwQkYsR0FBMUIsQ0FBckI7QUFDQSxNQUFNTCxlQUFlZixXQUFXaUIsc0JBQVgsQ0FBa0NILFlBQWxDLEVBQWdERSxJQUFoRCxDQUFyQjtBQUNBLFFBQU0sSUFBSU8sS0FBSixDQUFhRixZQUFILHlDQUNSUCxZQURRLFNBQ1FDLFlBRFIsT0FBVixDQUFOO0FBRUQ7O0FBRUQ7QUFDQSxTQUFTUixrQkFBVCxDQUE0Qk8sWUFBNUIsRUFBMENDLFlBQTFDLEVBQXdEO0FBQ3RELE1BQUlTLHVCQUFKO0FBQ0EsTUFBSXZCLElBQUl3QixRQUFKLElBQWdCLENBQXBCLEVBQXVCO0FBQ3JCRCxxQkFBaUJYLGtCQUFrQkMsWUFBbEIsRUFBZ0NDLFlBQWhDLENBQWpCO0FBQ0FkLFFBQUl5QixJQUFKLENBQVMsQ0FBVCxPQUFlRixjQUFmO0FBQ0Q7O0FBTHFEO0FBQUE7QUFBQTs7QUFBQTtBQU90RCx5QkFBa0JULFlBQWxCLDhIQUFnQztBQUFBLFVBQXJCWSxHQUFxQjs7QUFDOUIsVUFBSUEsUUFBUUMsU0FBWixFQUF1QjtBQUNyQkoseUJBQWlCQSxrQkFDZlgsa0JBQWtCQyxZQUFsQixFQUFnQ0MsWUFBaEMsQ0FERjtBQUVBLGNBQU0sSUFBSVEsS0FBSiwwQkFBaUNDLGNBQWpDLENBQU47QUFDRDtBQUNGO0FBYnFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBZXRELE1BQUl2QixJQUFJNEIsS0FBUixFQUFlO0FBQ2JMLHFCQUFpQkEsa0JBQ2ZYLGtCQUFrQkMsWUFBbEIsRUFBZ0NDLFlBQWhDLENBREY7QUFFQSxRQUFNZSxlQUFlN0IsSUFBSTRCLEtBQUosSUFBYTVCLElBQUk0QixLQUFKLENBQVVFLEtBQVYsQ0FDaEM7QUFBQSxhQUFlUCxlQUFlUSxPQUFmLENBQXVCQyxXQUF2QixNQUF3QyxDQUFDLENBQXhEO0FBQUEsS0FEZ0MsQ0FBbEM7O0FBSUE7QUFDQSxRQUFJSCxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0Q7QUFDRDtBQUNEO0FBQ0YiLCJmaWxlIjoiY29udGV4dC1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEtocm9ub3MgRGVidWcgc3VwcG9ydCBtb2R1bGVcbmltcG9ydCBXZWJHTERlYnVnIGZyb20gJ3dlYmdsLWRlYnVnJztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge2luc3RhbGxQYXJhbWV0ZXJEZWZpbml0aW9uc30gZnJvbSAnLi9kZWJ1Zy1wYXJhbWV0ZXJzJztcblxuLy8gVXNlcyB3ZWJnbC1kZWJ1Z1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VEZWJ1Z0NvbnRleHQoZ2wpIHtcbiAgaW5zdGFsbFBhcmFtZXRlckRlZmluaXRpb25zKCk7XG4gIGNvbnN0IGRlYnVnR0wgPSBXZWJHTERlYnVnLm1ha2VEZWJ1Z0NvbnRleHQoZ2wsIHRocm93T25FcnJvciwgdmFsaWRhdGVBcmdzQW5kTG9nKTtcbiAgY2xhc3MgV2ViR0xEZWJ1Z0NvbnRleHQge31cbiAgT2JqZWN0LmFzc2lnbihXZWJHTERlYnVnQ29udGV4dC5wcm90b3R5cGUsIGRlYnVnR0wpO1xuICBkZWJ1Z0dMLmRlYnVnID0gdHJ1ZTtcbiAgcmV0dXJuIGRlYnVnR0w7XG59XG5cbi8vIERFQlVHIFRSQUNJTkdcblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25TdHJpbmcoZnVuY3Rpb25OYW1lLCBmdW5jdGlvbkFyZ3MpIHtcbiAgbGV0IGFyZ3MgPSBXZWJHTERlYnVnLmdsRnVuY3Rpb25BcmdzVG9TdHJpbmcoZnVuY3Rpb25OYW1lLCBmdW5jdGlvbkFyZ3MpO1xuICBhcmdzID0gYCR7YXJncy5zbGljZSgwLCAxMDApfSR7YXJncy5sZW5ndGggPiAxMDAgPyAnLi4uJyA6ICcnfWA7XG4gIHJldHVybiBgZ2wuJHtmdW5jdGlvbk5hbWV9KCR7YXJnc30pYDtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkVycm9yKGVyciwgZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IFdlYkdMRGVidWcuZ2xFbnVtVG9TdHJpbmcoZXJyKTtcbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gV2ViR0xEZWJ1Zy5nbEZ1bmN0aW9uQXJnc1RvU3RyaW5nKGZ1bmN0aW9uTmFtZSwgYXJncyk7XG4gIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2V9IHdhcyBjYXVzZWQgYnkgY2FsbCB0bzogYCArXG4gICAgYGdsLiR7ZnVuY3Rpb25OYW1lfSgke2Z1bmN0aW9uQXJnc30pYCk7XG59XG5cbi8vIERvbid0IGdlbmVyYXRlIGZ1bmN0aW9uIHN0cmluZyB1bnRpbCBpdCBpcyBuZWVkZWRcbmZ1bmN0aW9uIHZhbGlkYXRlQXJnc0FuZExvZyhmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uQXJncykge1xuICBsZXQgZnVuY3Rpb25TdHJpbmc7XG4gIGlmIChsb2cucHJpb3JpdHkgPj0gNCkge1xuICAgIGZ1bmN0aW9uU3RyaW5nID0gZ2V0RnVuY3Rpb25TdHJpbmcoZnVuY3Rpb25OYW1lLCBmdW5jdGlvbkFyZ3MpO1xuICAgIGxvZy5pbmZvKDQsIGAke2Z1bmN0aW9uU3RyaW5nfWApO1xuICB9XG5cbiAgZm9yIChjb25zdCBhcmcgb2YgZnVuY3Rpb25BcmdzKSB7XG4gICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdW5jdGlvblN0cmluZyA9IGZ1bmN0aW9uU3RyaW5nIHx8XG4gICAgICAgIGdldEZ1bmN0aW9uU3RyaW5nKGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25BcmdzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGFyZ3VtZW50OiAke2Z1bmN0aW9uU3RyaW5nfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb2cuYnJlYWspIHtcbiAgICBmdW5jdGlvblN0cmluZyA9IGZ1bmN0aW9uU3RyaW5nIHx8XG4gICAgICBnZXRGdW5jdGlvblN0cmluZyhmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uQXJncyk7XG4gICAgY29uc3QgaXNCcmVha3BvaW50ID0gbG9nLmJyZWFrICYmIGxvZy5icmVhay5ldmVyeShcbiAgICAgIGJyZWFrU3RyaW5nID0+IGZ1bmN0aW9uU3RyaW5nLmluZGV4T2YoYnJlYWtTdHJpbmcpICE9PSAtMVxuICAgICk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgIGlmIChpc0JyZWFrcG9pbnQpIHtcbiAgICAgIGRlYnVnZ2VyO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWRlYnVnZ2VyICovXG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ES300 */
/* unused harmony export getGLContextInfo */
/* unused harmony export getContextLimits */
/* harmony export (immutable) */ __webpack_exports__["a"] = getContextCaps;
/* unused harmony export getContextInfo */
/* unused harmony export TEST_LIMITS */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _WEBGL_LIMITS;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-inline-comments, max-len */




var WEBGL_LIMITS = (_WEBGL_LIMITS = {}, _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ALIASED_LINE_WIDTH_RANGE, { webgl1: new Float32Array([1, 1]) }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ALIASED_POINT_SIZE_RANGE, { webgl1: new Float32Array([1, 1]) }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TEXTURE_SIZE, { webgl1: 64, webgl2: 2048 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_CUBE_MAP_TEXTURE_SIZE, { webgl1: 16 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TEXTURE_IMAGE_UNITS, { webgl1: 8 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_COMBINED_TEXTURE_IMAGE_UNITS, { webgl1: 8 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_TEXTURE_IMAGE_UNITS, { webgl1: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_RENDERBUFFER_SIZE, { webgl1: 1 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VARYING_VECTORS, { webgl1: 8 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_ATTRIBS, { webgl1: 8 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_UNIFORM_VECTORS, { webgl1: 128 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_FRAGMENT_UNIFORM_VECTORS, { webgl1: 16 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VIEWPORT_DIMS, { webgl1: new Int32Array([0, 0]) }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TEXTURE_MAX_ANISOTROPY_EXT, {
  webgl1: 1.0,
  extension: 'EXT_texture_filter_anisotropic'
}), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_3D_TEXTURE_SIZE, { webgl1: 0, webgl2: 256 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_ARRAY_TEXTURE_LAYERS, { webgl1: 0, webgl2: 256 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_CLIENT_WAIT_TIMEOUT_WEBGL, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_COLOR_ATTACHMENTS, { webgl1: 0, webgl2: 4 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_COMBINED_UNIFORM_BLOCKS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_DRAW_BUFFERS, { webgl1: 0, webgl2: 4 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_ELEMENT_INDEX, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_ELEMENTS_INDICES, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_ELEMENTS_VERTICES, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_FRAGMENT_INPUT_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_FRAGMENT_UNIFORM_BLOCKS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_FRAGMENT_UNIFORM_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_PROGRAM_TEXEL_OFFSET, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_SAMPLES, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_SERVER_WAIT_TIMEOUT, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TEXTURE_LOD_BIAS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_UNIFORM_BLOCK_SIZE, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_UNIFORM_BUFFER_BINDINGS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VARYING_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_OUTPUT_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_UNIFORM_BLOCKS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MAX_VERTEX_UNIFORM_COMPONENTS, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].MIN_PROGRAM_TEXEL_OFFSET, { webgl1: 0, webgl2: 0 }), _defineProperty(_WEBGL_LIMITS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNIFORM_BUFFER_OFFSET_ALIGNMENT, { webgl1: 0, webgl2: 0 }), _WEBGL_LIMITS);

var ES300 = 'ES300';
var WEBGL1 = 'WEBGL1';

var WEBGL_CAPS = {

  // DEBUG CAPABILITIS

  DEBUG_RENDERER_INFO: {
    webgl1: 'WEBGL_debug_renderer_info',
    webgl2: WEBGL1
  },
  DEBUG_SHADERS: {
    webgl1: 'WEBGL_debug_shaders',
    webgl2: WEBGL1
  },
  LOSE_CONTEXT: {
    webgl1: 'WEBGL_lose_context',
    webgl2: WEBGL1
  },
  DISJOINT_TIMER_QUERY: {
    webgl1: 'EXT_disjoint_timer_query',
    webgl2: 'EXT_disjoint_timer_query_webgl2'
  },

  // MAJOR FEATURE/OBJECT SUPPORT

  INSTANCED_ARRAYS: {
    webgl1: 'ANGLE_instanced_arrays',
    webgl2: true
  },
  VERTEX_ARRAY_OBJECT: {
    webgl1: 'OES_vertex_array_object',
    webgl2: true
  },

  ELEMENT_INDEX_UINT: {
    webgl1: 'OES_element_index_uint',
    webgl2: true
  },
  BLEND_MINMAX: {
    webgl1: 'EXT_blend_minmax',
    webgl2: true
  },
  SRGB: {
    webgl1: 'EXT_sRGB',
    webgl2: true
  },
  DEPTH_TEXTURE: {
    webgl1: 'WEBGL_depth_texture',
    webgl2: true
  },
  TEXTURE_FILTER_ANISOTROPIC: {
    webgl1: 'EXT_texture_filter_anisotropic',
    webgl2: WEBGL1
  },
  TEXTURE_FLOAT: {
    webgl1: 'OES_texture_float',
    webgl2: true
  },
  TEXTURE_FLOAT_LINEAR: {
    webgl1: 'OES_texture_float_linear',
    webgl2: WEBGL1
  },
  TEXTURE_HALF_FLOAT: {
    webgl1: 'OES_texture_half_float',
    webgl2: true
  },
  TEXTURE_HALF_FLOAT_LINEAR: {
    webgl1: 'OES_texture_half_float_linear',
    webgl2: true
  },
  // WebGL1 only supports one color buffer format (RBG32F is deprecated)
  COLOR_BUFFER_FLOAT_RGBA32F: {
    webgl1: 'WEBGL_color_buffer_float',
    webgl2: 'EXT_color_buffer_float'
  },
  // WebGL2 supports multiple color buffer formats
  COLOR_BUFFER_FLOAT: {
    webgl1: false,
    webgl2: 'EXT_color_buffer_float'
  },
  COLOR_BUFFER_HALF_FLOAT: {
    webgl1: false,
    webgl2: 'EXT_color_buffer_half_float'
  },

  // GLSL extensions

  FRAG_DEPTH: {
    webgl1: 'EXT_frag_depth',
    webgl2: ES300
  },
  SHADER_TEXTURE_LOD: {
    webgl1: 'EXT_shader_texture_lod',
    webgl2: ES300
  },
  STANDARD_DERIVATIVES: {
    webgl1: 'OES_standard_derivatives',
    webgl2: ES300
  },
  DRAW_BUFFERS: {
    webgl1: 'WEBGL_draw_buffers',
    webgl2: ES300
  },

  // COMPRESSED TEXTURES

  COMPRESSED_TEXTURE_S3TC: {
    webgl1: 'WEBGL_compressed_texture_s3tc',
    webgl2: WEBGL1
  },
  COMPRESSED_TEXTURE_ATC: {
    webgl1: 'WEBGL_compressed_texture_atc',
    webgl2: WEBGL1
  },
  COMPRESSED_TEXTURE_ETC: {
    webgl1: 'WEBGL_compressed_texture_etc',
    webgl2: WEBGL1
  },
  COMPRESSED_TEXTURE_ETC1: {
    webgl1: 'WEBGL_compressed_texture_etc1',
    webgl2: WEBGL1
  },
  COMPRESSED_TEXTURE_PVRTC: {
    webgl1: 'WEBGL_compressed_texture_pvrtc',
    webgl2: WEBGL1
  }
};

function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.info) {
    var _gl$luma$info;

    var info = gl.getExtension('WEBGL_debug_renderer_info');
    gl.luma.info = (_gl$luma$info = {}, _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VENDOR, gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VENDOR)), _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERER, gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERER)), _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_VENDOR_WEBGL, gl.getParameter(info ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_VENDOR_WEBGL : __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VENDOR)), _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_RENDERER_WEBGL, gl.getParameter(info ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_RENDERER_WEBGL : __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERER)), _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VERSION, gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VERSION)), _defineProperty(_gl$luma$info, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SHADING_LANGUAGE_VERSION, gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SHADING_LANGUAGE_VERSION)), _gl$luma$info);
  }

  return gl.luma.info;
}

function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};

    var isWebgl2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl);

    // WEBGL limits
    for (var parameter in WEBGL_LIMITS) {
      var limit = WEBGL_LIMITS[parameter];

      var webgl1MinLimit = limit.webgl1;
      var webgl2MinLimit = 'webgl2' in limit ? limit.webgl2 : limit.webgl1;
      var minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;

      // Check if we can query for this limit
      var limitNotAvailable = 'webgl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);

      var value = limitNotAvailable ? minLimit : gl.getParameter(parameter);

      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}

function getContextCaps(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.caps) {
    var webglVersion = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl) ? 'webgl2' : 'webgl1';
    gl.luma.caps = {};
    for (var cap in WEBGL_CAPS) {
      gl.luma.caps[cap] = getCap({ gl: gl, cap: cap, webglVersion: webglVersion });
    }
  }
  return gl.luma.caps;
}

function getCap(_ref) {
  var gl = _ref.gl,
      cap = _ref.cap,
      webglVersion = _ref.webglVersion;


  // Get extension name, and replace if webgl2 uses the webgl1 extension
  var extensionName = WEBGL_CAPS[cap][webglVersion];
  if (extensionName === WEBGL1) {
    extensionName = WEBGL_CAPS[cap].webgl1;
  }

  var value = extensionName;
  // Check if the value is dependent on checking an extension
  if (typeof extensionName === 'string' && extensionName !== ES300) {
    value = Boolean(gl.getExtension(extensionName));
  }
  __WEBPACK_IMPORTED_MODULE_2_assert___default()(value === false || value === true || value === ES300);
  return value;
}

function getContextInfo(gl) {
  var info = getGLContextInfo(gl);
  var limits = getContextLimits(gl);
  return {
    // basic information
    vendor: info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_VENDOR_WEBGL] || info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VENDOR],
    renderer: info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNMASKED_RENDERER_WEBGL] || info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERER],
    version: info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VERSION],
    shadingLanguageVersion: info[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SHADING_LANGUAGE_VERSION],
    // info, caps and limits
    info: info,
    caps: getContextCaps(gl),
    limits: limits,
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  };
}

var TEST_LIMITS = {
  WEBGL_LIMITS: WEBGL_LIMITS,
  WEBGL_CAPS: WEBGL_CAPS
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9jb250ZXh0LWxpbWl0cy5qcyJdLCJuYW1lcyI6WyJHTCIsImlzV2ViR0wyQ29udGV4dCIsImFzc2VydCIsIldFQkdMX0xJTUlUUyIsIkFMSUFTRURfTElORV9XSURUSF9SQU5HRSIsIndlYmdsMSIsIkZsb2F0MzJBcnJheSIsIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRSIsIk1BWF9URVhUVVJFX1NJWkUiLCJ3ZWJnbDIiLCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9SRU5ERVJCVUZGRVJfU0laRSIsIk1BWF9WQVJZSU5HX1ZFQ1RPUlMiLCJNQVhfVkVSVEVYX0FUVFJJQlMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyIsIk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMiLCJNQVhfVklFV1BPUlRfRElNUyIsIkludDMyQXJyYXkiLCJNQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJleHRlbnNpb24iLCJNQVhfM0RfVEVYVFVSRV9TSVpFIiwiTUFYX0FSUkFZX1RFWFRVUkVfTEFZRVJTIiwiTUFYX0NMSUVOVF9XQUlUX1RJTUVPVVRfV0VCR0wiLCJNQVhfQ09MT1JfQVRUQUNITUVOVFMiLCJNQVhfQ09NQklORURfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTIiwiTUFYX0NPTUJJTkVEX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFMiLCJNQVhfRFJBV19CVUZGRVJTIiwiTUFYX0VMRU1FTlRfSU5ERVgiLCJNQVhfRUxFTUVOVFNfSU5ESUNFUyIsIk1BWF9FTEVNRU5UU19WRVJUSUNFUyIsIk1BWF9GUkFHTUVOVF9JTlBVVF9DT01QT05FTlRTIiwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UUyIsIk1BWF9QUk9HUkFNX1RFWEVMX09GRlNFVCIsIk1BWF9TQU1QTEVTIiwiTUFYX1NFUlZFUl9XQUlUX1RJTUVPVVQiLCJNQVhfVEVYVFVSRV9MT0RfQklBUyIsIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfSU5URVJMRUFWRURfQ09NUE9ORU5UUyIsIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfU0VQQVJBVEVfQVRUUklCUyIsIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfU0VQQVJBVEVfQ09NUE9ORU5UUyIsIk1BWF9VTklGT1JNX0JMT0NLX1NJWkUiLCJNQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1MiLCJNQVhfVkFSWUlOR19DT01QT05FTlRTIiwiTUFYX1ZFUlRFWF9PVVRQVVRfQ09NUE9ORU5UUyIsIk1BWF9WRVJURVhfVU5JRk9STV9CTE9DS1MiLCJNQVhfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UUyIsIk1JTl9QUk9HUkFNX1RFWEVMX09GRlNFVCIsIlVOSUZPUk1fQlVGRkVSX09GRlNFVF9BTElHTk1FTlQiLCJFUzMwMCIsIldFQkdMMSIsIldFQkdMX0NBUFMiLCJERUJVR19SRU5ERVJFUl9JTkZPIiwiREVCVUdfU0hBREVSUyIsIkxPU0VfQ09OVEVYVCIsIkRJU0pPSU5UX1RJTUVSX1FVRVJZIiwiSU5TVEFOQ0VEX0FSUkFZUyIsIlZFUlRFWF9BUlJBWV9PQkpFQ1QiLCJFTEVNRU5UX0lOREVYX1VJTlQiLCJCTEVORF9NSU5NQVgiLCJTUkdCIiwiREVQVEhfVEVYVFVSRSIsIlRFWFRVUkVfRklMVEVSX0FOSVNPVFJPUElDIiwiVEVYVFVSRV9GTE9BVCIsIlRFWFRVUkVfRkxPQVRfTElORUFSIiwiVEVYVFVSRV9IQUxGX0ZMT0FUIiwiVEVYVFVSRV9IQUxGX0ZMT0FUX0xJTkVBUiIsIkNPTE9SX0JVRkZFUl9GTE9BVF9SR0JBMzJGIiwiQ09MT1JfQlVGRkVSX0ZMT0FUIiwiQ09MT1JfQlVGRkVSX0hBTEZfRkxPQVQiLCJGUkFHX0RFUFRIIiwiU0hBREVSX1RFWFRVUkVfTE9EIiwiU1RBTkRBUkRfREVSSVZBVElWRVMiLCJEUkFXX0JVRkZFUlMiLCJDT01QUkVTU0VEX1RFWFRVUkVfUzNUQyIsIkNPTVBSRVNTRURfVEVYVFVSRV9BVEMiLCJDT01QUkVTU0VEX1RFWFRVUkVfRVRDIiwiQ09NUFJFU1NFRF9URVhUVVJFX0VUQzEiLCJDT01QUkVTU0VEX1RFWFRVUkVfUFZSVEMiLCJnZXRHTENvbnRleHRJbmZvIiwiZ2wiLCJsdW1hIiwiaW5mbyIsImdldEV4dGVuc2lvbiIsIlZFTkRPUiIsImdldFBhcmFtZXRlciIsIlJFTkRFUkVSIiwiVU5NQVNLRURfVkVORE9SX1dFQkdMIiwiVU5NQVNLRURfUkVOREVSRVJfV0VCR0wiLCJWRVJTSU9OIiwiU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OIiwiZ2V0Q29udGV4dExpbWl0cyIsImxpbWl0cyIsIndlYmdsMU1pbkxpbWl0cyIsIndlYmdsMk1pbkxpbWl0cyIsImlzV2ViZ2wyIiwicGFyYW1ldGVyIiwibGltaXQiLCJ3ZWJnbDFNaW5MaW1pdCIsIndlYmdsMk1pbkxpbWl0IiwibWluTGltaXQiLCJsaW1pdE5vdEF2YWlsYWJsZSIsInZhbHVlIiwiZ2V0Q29udGV4dENhcHMiLCJjYXBzIiwid2ViZ2xWZXJzaW9uIiwiY2FwIiwiZ2V0Q2FwIiwiZXh0ZW5zaW9uTmFtZSIsIkJvb2xlYW4iLCJnZXRDb250ZXh0SW5mbyIsInZlbmRvciIsInJlbmRlcmVyIiwidmVyc2lvbiIsInNoYWRpbmdMYW5ndWFnZVZlcnNpb24iLCJURVNUX0xJTUlUUyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsT0FBT0EsRUFBUCxNQUFlLGdCQUFmO0FBQ0EsU0FBUUMsZUFBUixRQUE4QixXQUE5QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsSUFBTUMsbUVBQ0hILEdBQUdJLHdCQURBLEVBQzJCLEVBQUNDLFFBQVEsSUFBSUMsWUFBSixDQUFpQixDQUFDLENBQUQsRUFB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LE1BQVIsQ0FGckM7QUFHTDRCLGNBQVU5QixLQUFLckYsR0FBRzJGLHVCQUFSLEtBQW9DTixLQUFLckYsR0FBR3lGLFFBQVIsQ0FIekM7QUFJTDJCLGFBQVMvQixLQUFLckYsR0FBRzRGLE9BQVIsQ0FKSjtBQUtMeUIsNEJBQXdCaEMsS0FBS3JGLEdBQUc2Rix3QkFBUixDQUxuQjtBQU1MO0FBQ0FSLGNBUEs7QUFRTHNCLFVBQU1ELGVBQWV2QixFQUFmLENBUkQ7QUFTTFksa0JBVEs7QUFVTEMscUJBQWlCYixHQUFHQyxJQUFILENBQVFZLGVBVnBCO0FBV0xDLHFCQUFpQmQsR0FBR0MsSUFBSCxDQUFRYTtBQVhwQixHQUFQO0FBYUQ7O0FBRUQsT0FBTyxJQUFNcUIsY0FBYztBQUN6Qm5ILDRCQUR5QjtBQUV6Qm1EO0FBRnlCLENBQXBCIiwiZmlsZSI6ImNvbnRleHQtbGltaXRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8taW5saW5lLWNvbW1lbnRzLCBtYXgtbGVuICovXG5pbXBvcnQgR0wgZnJvbSAnLi9nbC1jb25zdGFudHMnO1xuaW1wb3J0IHtpc1dlYkdMMkNvbnRleHR9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IFdFQkdMX0xJTUlUUyA9IHtcbiAgW0dMLkFMSUFTRURfTElORV9XSURUSF9SQU5HRV06IHt3ZWJnbDE6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKX0sXG4gIFtHTC5BTElBU0VEX1BPSU5UX1NJWkVfUkFOR0VdOiB7d2ViZ2wxOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSl9LFxuICBbR0wuTUFYX1RFWFRVUkVfU0laRV06IHt3ZWJnbDE6IDY0LCB3ZWJnbDI6IDIwNDh9LCAvLyBHTGludFxuICBbR0wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRV06IHt3ZWJnbDE6IDE2fSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTXToge3dlYmdsMTogOH0sIC8vIEdMaW50XG4gIFtHTC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUU106IHt3ZWJnbDE6IDh9LCAvLyBHTGludFxuICBbR0wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTXToge3dlYmdsMTogMH0sIC8vIEdMaW50XG4gIFtHTC5NQVhfUkVOREVSQlVGRkVSX1NJWkVdOiB7d2ViZ2wxOiAxfSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9WQVJZSU5HX1ZFQ1RPUlNdOiB7d2ViZ2wxOiA4fSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9WRVJURVhfQVRUUklCU106IHt3ZWJnbDE6IDh9LCAvLyBHTGludFxuICBbR0wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlNdOiB7d2ViZ2wxOiAxMjh9LCAvLyBHTGludFxuICBbR0wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SU106IHt3ZWJnbDE6IDE2fSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9WSUVXUE9SVF9ESU1TXToge3dlYmdsMTogbmV3IEludDMyQXJyYXkoWzAsIDBdKX0sXG5cbiAgLy8gRXh0ZW5zaW9uc1xuICBbR0wuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUXToge1xuICAgIHdlYmdsMTogMS4wLFxuICAgIGV4dGVuc2lvbjogJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYydcbiAgfSxcblxuICAvLyBXZWJHTDIgTGltaXRzXG4gIFtHTC5NQVhfM0RfVEVYVFVSRV9TSVpFXToge3dlYmdsMTogMCwgd2ViZ2wyOiAyNTZ9LCAvLyAgR0xpbnRcbiAgW0dMLk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMjU2fSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9DTElFTlRfV0FJVF9USU1FT1VUX1dFQkdMXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gIEdMaW50NjRcbiAgW0dMLk1BWF9DT0xPUl9BVFRBQ0hNRU5UU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogNH0sIC8vICBHTGludFxuICBbR0wuTUFYX0NPTUJJTkVEX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vIEdMaW50NjRcbiAgW0dMLk1BWF9DT01CSU5FRF9VTklGT1JNX0JMT0NLU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFNdOiB7d2ViZ2wxOiAwLCB3ZWJnbDI6IDB9LCAvLyBHTGludDY0XG4gIFtHTC5NQVhfRFJBV19CVUZGRVJTXToge3dlYmdsMTogMCwgd2ViZ2wyOiA0fSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9FTEVNRU5UX0lOREVYXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gIEdMaW50NjRcbiAgW0dMLk1BWF9FTEVNRU5UU19JTkRJQ0VTXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9FTEVNRU5UU19WRVJUSUNFU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFNdOiB7d2ViZ2wxOiAwLCB3ZWJnbDI6IDB9LCAvLyAgR0xpbnRcbiAgW0dMLk1BWF9GUkFHTUVOVF9VTklGT1JNX0JMT0NLU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX1BST0dSQU1fVEVYRUxfT0ZGU0VUXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9TQU1QTEVTXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gIEdMaW50XG4gIFtHTC5NQVhfU0VSVkVSX1dBSVRfVElNRU9VVF06IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludDY0XG4gIFtHTC5NQVhfVEVYVFVSRV9MT0RfQklBU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vIEdMZmxvYXRcbiAgW0dMLk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfSU5URVJMRUFWRURfQ09NUE9ORU5UU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gIEdMaW50XG4gIFtHTC5NQVhfVFJBTlNGT1JNX0ZFRURCQUNLX1NFUEFSQVRFX0NPTVBPTkVOVFNdOiB7d2ViZ2wxOiAwLCB3ZWJnbDI6IDB9LCAvLyBHTGludFxuICBbR0wuTUFYX1VOSUZPUk1fQkxPQ0tfU0laRV06IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vIEdMaW50NjRcbiAgW0dMLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vICBHTGludFxuICBbR0wuTUFYX1ZBUllJTkdfQ09NUE9ORU5UU106IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0sIC8vIEdMaW50XG4gIFtHTC5NQVhfVkVSVEVYX09VVFBVVF9DT01QT05FTlRTXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gR0xpbnRcbiAgW0dMLk1BWF9WRVJURVhfVU5JRk9STV9CTE9DS1NdOiB7d2ViZ2wxOiAwLCB3ZWJnbDI6IDB9LCAvLyAgR0xpbnRcbiAgW0dMLk1BWF9WRVJURVhfVU5JRk9STV9DT01QT05FTlRTXToge3dlYmdsMTogMCwgd2ViZ2wyOiAwfSwgLy8gIEdMaW50XG4gIFtHTC5NSU5fUFJPR1JBTV9URVhFTF9PRkZTRVRdOiB7d2ViZ2wxOiAwLCB3ZWJnbDI6IDB9LCAvLyBHTGludFxuICBbR0wuVU5JRk9STV9CVUZGRVJfT0ZGU0VUX0FMSUdOTUVOVF06IHt3ZWJnbDE6IDAsIHdlYmdsMjogMH0gLy8gR0xpbnRcbn07XG5cbmV4cG9ydCBjb25zdCBFUzMwMCA9ICdFUzMwMCc7XG5jb25zdCBXRUJHTDEgPSAnV0VCR0wxJztcblxuY29uc3QgV0VCR0xfQ0FQUyA9IHtcblxuICAvLyBERUJVRyBDQVBBQklMSVRJU1xuXG4gIERFQlVHX1JFTkRFUkVSX0lORk86IHtcbiAgICB3ZWJnbDE6ICdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyxcbiAgICB3ZWJnbDI6IFdFQkdMMVxuICB9LFxuICBERUJVR19TSEFERVJTOiB7XG4gICAgd2ViZ2wxOiAnV0VCR0xfZGVidWdfc2hhZGVycycsXG4gICAgd2ViZ2wyOiBXRUJHTDFcbiAgfSxcbiAgTE9TRV9DT05URVhUOiB7XG4gICAgd2ViZ2wxOiAnV0VCR0xfbG9zZV9jb250ZXh0JyxcbiAgICB3ZWJnbDI6IFdFQkdMMVxuICB9LFxuICBESVNKT0lOVF9USU1FUl9RVUVSWToge1xuICAgIHdlYmdsMTogJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScsXG4gICAgd2ViZ2wyOiAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMidcbiAgfSxcblxuICAvLyBNQUpPUiBGRUFUVVJFL09CSkVDVCBTVVBQT1JUXG5cbiAgSU5TVEFOQ0VEX0FSUkFZUzoge1xuICAgIHdlYmdsMTogJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICBWRVJURVhfQVJSQVlfT0JKRUNUOiB7XG4gICAgd2ViZ2wxOiAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuXG4gIEVMRU1FTlRfSU5ERVhfVUlOVDoge1xuICAgIHdlYmdsMTogJ09FU19lbGVtZW50X2luZGV4X3VpbnQnLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICBCTEVORF9NSU5NQVg6IHtcbiAgICB3ZWJnbDE6ICdFWFRfYmxlbmRfbWlubWF4JyxcbiAgICB3ZWJnbDI6IHRydWVcbiAgfSxcbiAgU1JHQjoge1xuICAgIHdlYmdsMTogJ0VYVF9zUkdCJyxcbiAgICB3ZWJnbDI6IHRydWVcbiAgfSxcbiAgREVQVEhfVEVYVFVSRToge1xuICAgIHdlYmdsMTogJ1dFQkdMX2RlcHRoX3RleHR1cmUnLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICBURVhUVVJFX0ZJTFRFUl9BTklTT1RST1BJQzoge1xuICAgIHdlYmdsMTogJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycsXG4gICAgd2ViZ2wyOiBXRUJHTDFcbiAgfSxcbiAgVEVYVFVSRV9GTE9BVDoge1xuICAgIHdlYmdsMTogJ09FU190ZXh0dXJlX2Zsb2F0JyxcbiAgICB3ZWJnbDI6IHRydWVcbiAgfSxcbiAgVEVYVFVSRV9GTE9BVF9MSU5FQVI6IHtcbiAgICB3ZWJnbDE6ICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInLFxuICAgIHdlYmdsMjogV0VCR0wxXG4gIH0sXG4gIFRFWFRVUkVfSEFMRl9GTE9BVDoge1xuICAgIHdlYmdsMTogJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICBURVhUVVJFX0hBTEZfRkxPQVRfTElORUFSOiB7XG4gICAgd2ViZ2wxOiAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICAvLyBXZWJHTDEgb25seSBzdXBwb3J0cyBvbmUgY29sb3IgYnVmZmVyIGZvcm1hdCAoUkJHMzJGIGlzIGRlcHJlY2F0ZWQpXG4gIENPTE9SX0JVRkZFUl9GTE9BVF9SR0JBMzJGOiB7XG4gICAgd2ViZ2wxOiAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyxcbiAgICB3ZWJnbDI6ICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0J1xuICB9LFxuICAvLyBXZWJHTDIgc3VwcG9ydHMgbXVsdGlwbGUgY29sb3IgYnVmZmVyIGZvcm1hdHNcbiAgQ09MT1JfQlVGRkVSX0ZMT0FUOiB7XG4gICAgd2ViZ2wxOiBmYWxzZSxcbiAgICB3ZWJnbDI6ICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0J1xuICB9LFxuICBDT0xPUl9CVUZGRVJfSEFMRl9GTE9BVDoge1xuICAgIHdlYmdsMTogZmFsc2UsXG4gICAgd2ViZ2wyOiAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0J1xuICB9LFxuXG4gIC8vIEdMU0wgZXh0ZW5zaW9uc1xuXG4gIEZSQUdfREVQVEg6IHtcbiAgICB3ZWJnbDE6ICdFWFRfZnJhZ19kZXB0aCcsXG4gICAgd2ViZ2wyOiBFUzMwMFxuICB9LFxuICBTSEFERVJfVEVYVFVSRV9MT0Q6IHtcbiAgICB3ZWJnbDE6ICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyxcbiAgICB3ZWJnbDI6IEVTMzAwXG4gIH0sXG4gIFNUQU5EQVJEX0RFUklWQVRJVkVTOiB7XG4gICAgd2ViZ2wxOiAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyxcbiAgICB3ZWJnbDI6IEVTMzAwXG4gIH0sXG4gIERSQVdfQlVGRkVSUzoge1xuICAgIHdlYmdsMTogJ1dFQkdMX2RyYXdfYnVmZmVycycsXG4gICAgd2ViZ2wyOiBFUzMwMFxuICB9LFxuXG4gIC8vIENPTVBSRVNTRUQgVEVYVFVSRVNcblxuICBDT01QUkVTU0VEX1RFWFRVUkVfUzNUQzoge1xuICAgIHdlYmdsMTogJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyxcbiAgICB3ZWJnbDI6IFdFQkdMMVxuICB9LFxuICBDT01QUkVTU0VEX1RFWFRVUkVfQVRDOiB7XG4gICAgd2ViZ2wxOiAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0YycsXG4gICAgd2ViZ2wyOiBXRUJHTDFcbiAgfSxcbiAgQ09NUFJFU1NFRF9URVhUVVJFX0VUQzoge1xuICAgIHdlYmdsMTogJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnLFxuICAgIHdlYmdsMjogV0VCR0wxXG4gIH0sXG4gIENPTVBSRVNTRURfVEVYVFVSRV9FVEMxOiB7XG4gICAgd2ViZ2wxOiAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLFxuICAgIHdlYmdsMjogV0VCR0wxXG4gIH0sXG4gIENPTVBSRVNTRURfVEVYVFVSRV9QVlJUQzoge1xuICAgIHdlYmdsMTogJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycsXG4gICAgd2ViZ2wyOiBXRUJHTDFcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdMQ29udGV4dEluZm8oZ2wpIHtcbiAgZ2wubHVtYSA9IGdsLmx1bWEgfHwge307XG5cbiAgaWYgKCFnbC5sdW1hLmluZm8pIHtcbiAgICBjb25zdCBpbmZvID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gICAgZ2wubHVtYS5pbmZvID0ge1xuICAgICAgW0dMLlZFTkRPUl06IGdsLmdldFBhcmFtZXRlcihHTC5WRU5ET1IpLFxuICAgICAgW0dMLlJFTkRFUkVSXTogZ2wuZ2V0UGFyYW1ldGVyKEdMLlJFTkRFUkVSKSxcbiAgICAgIFtHTC5VTk1BU0tFRF9WRU5ET1JfV0VCR0xdOlxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoaW5mbyA/IEdMLlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCA6IEdMLlZFTkRPUiksXG4gICAgICBbR0wuVU5NQVNLRURfUkVOREVSRVJfV0VCR0xdOlxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoaW5mbyA/IEdMLlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMIDogR0wuUkVOREVSRVIpLFxuICAgICAgW0dMLlZFUlNJT05dOiBnbC5nZXRQYXJhbWV0ZXIoR0wuVkVSU0lPTiksXG4gICAgICBbR0wuU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OXTogZ2wuZ2V0UGFyYW1ldGVyKEdMLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGdsLmx1bWEuaW5mbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRMaW1pdHMoZ2wpIHtcbiAgZ2wubHVtYSA9IGdsLmx1bWEgfHwge307XG5cbiAgaWYgKCFnbC5sdW1hLmxpbWl0cykge1xuICAgIGdsLmx1bWEubGltaXRzID0ge307XG4gICAgZ2wubHVtYS53ZWJnbDFNaW5MaW1pdHMgPSB7fTtcbiAgICBnbC5sdW1hLndlYmdsMk1pbkxpbWl0cyA9IHt9O1xuXG4gICAgY29uc3QgaXNXZWJnbDIgPSBpc1dlYkdMMkNvbnRleHQoZ2wpO1xuXG4gICAgLy8gV0VCR0wgbGltaXRzXG4gICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgaW4gV0VCR0xfTElNSVRTKSB7XG4gICAgICBjb25zdCBsaW1pdCA9IFdFQkdMX0xJTUlUU1twYXJhbWV0ZXJdO1xuXG4gICAgICBjb25zdCB3ZWJnbDFNaW5MaW1pdCA9IGxpbWl0LndlYmdsMTtcbiAgICAgIGNvbnN0IHdlYmdsMk1pbkxpbWl0ID0gJ3dlYmdsMicgaW4gbGltaXQgPyBsaW1pdC53ZWJnbDIgOiBsaW1pdC53ZWJnbDE7XG4gICAgICBjb25zdCBtaW5MaW1pdCA9IGlzV2ViZ2wyID8gd2ViZ2wyTWluTGltaXQgOiB3ZWJnbDFNaW5MaW1pdDtcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHF1ZXJ5IGZvciB0aGlzIGxpbWl0XG4gICAgICBjb25zdCBsaW1pdE5vdEF2YWlsYWJsZSA9XG4gICAgICAgICgnd2ViZ2wyJyBpbiBsaW1pdCAmJiAhaXNXZWJnbDIpIHx8XG4gICAgICAgICgnZXh0ZW5zaW9uJyBpbiBsaW1pdCAmJiAhZ2wuZ2V0RXh0ZW5zaW9uKGxpbWl0LmV4dGVuc2lvbikpO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IGxpbWl0Tm90QXZhaWxhYmxlID8gbWluTGltaXQgOiBnbC5nZXRQYXJhbWV0ZXIocGFyYW1ldGVyKTtcblxuICAgICAgZ2wubHVtYS5saW1pdHNbcGFyYW1ldGVyXSA9IHZhbHVlO1xuICAgICAgZ2wubHVtYS53ZWJnbDFNaW5MaW1pdHNbcGFyYW1ldGVyXSA9IHdlYmdsMU1pbkxpbWl0O1xuICAgICAgZ2wubHVtYS53ZWJnbDJNaW5MaW1pdHNbcGFyYW1ldGVyXSA9IHdlYmdsMk1pbkxpbWl0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnbC5sdW1hLmxpbWl0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRDYXBzKGdsKSB7XG4gIGdsLmx1bWEgPSBnbC5sdW1hIHx8IHt9O1xuXG4gIGlmICghZ2wubHVtYS5jYXBzKSB7XG4gICAgY29uc3Qgd2ViZ2xWZXJzaW9uID0gaXNXZWJHTDJDb250ZXh0KGdsKSA/ICd3ZWJnbDInIDogJ3dlYmdsMSc7XG4gICAgZ2wubHVtYS5jYXBzID0ge307XG4gICAgZm9yIChjb25zdCBjYXAgaW4gV0VCR0xfQ0FQUykge1xuICAgICAgZ2wubHVtYS5jYXBzW2NhcF0gPSBnZXRDYXAoe2dsLCBjYXAsIHdlYmdsVmVyc2lvbn0pO1xuICAgIH1cblxuICB9XG4gIHJldHVybiBnbC5sdW1hLmNhcHM7XG59XG5cbmZ1bmN0aW9uIGdldENhcCh7Z2wsIGNhcCwgd2ViZ2xWZXJzaW9ufSkge1xuXG4gIC8vIEdldCBleHRlbnNpb24gbmFtZSwgYW5kIHJlcGxhY2UgaWYgd2ViZ2wyIHVzZXMgdGhlIHdlYmdsMSBleHRlbnNpb25cbiAgbGV0IGV4dGVuc2lvbk5hbWUgPSBXRUJHTF9DQVBTW2NhcF1bd2ViZ2xWZXJzaW9uXTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IFdFQkdMMSkge1xuICAgIGV4dGVuc2lvbk5hbWUgPSBXRUJHTF9DQVBTW2NhcF0ud2ViZ2wxO1xuICB9XG5cbiAgbGV0IHZhbHVlID0gZXh0ZW5zaW9uTmFtZTtcbiAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGRlcGVuZGVudCBvbiBjaGVja2luZyBhbiBleHRlbnNpb25cbiAgaWYgKHR5cGVvZiBleHRlbnNpb25OYW1lID09PSAnc3RyaW5nJyAmJiBleHRlbnNpb25OYW1lICE9PSBFUzMwMCkge1xuICAgIHZhbHVlID0gQm9vbGVhbihnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSkpO1xuICB9XG4gIGFzc2VydCh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IEVTMzAwKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dEluZm8oZ2wpIHtcbiAgY29uc3QgaW5mbyA9IGdldEdMQ29udGV4dEluZm8oZ2wpO1xuICBjb25zdCBsaW1pdHMgPSBnZXRDb250ZXh0TGltaXRzKGdsKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBiYXNpYyBpbmZvcm1hdGlvblxuICAgIHZlbmRvcjogaW5mb1tHTC5VTk1BU0tFRF9WRU5ET1JfV0VCR0xdIHx8IGluZm9bR0wuVkVORE9SXSxcbiAgICByZW5kZXJlcjogaW5mb1tHTC5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTF0gfHwgaW5mb1tHTC5SRU5ERVJFUl0sXG4gICAgdmVyc2lvbjogaW5mb1tHTC5WRVJTSU9OXSxcbiAgICBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBpbmZvW0dMLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTl0sXG4gICAgLy8gaW5mbywgY2FwcyBhbmQgbGltaXRzXG4gICAgaW5mbyxcbiAgICBjYXBzOiBnZXRDb250ZXh0Q2FwcyhnbCksXG4gICAgbGltaXRzLFxuICAgIHdlYmdsMU1pbkxpbWl0czogZ2wubHVtYS53ZWJnbDFNaW5MaW1pdHMsXG4gICAgd2ViZ2wyTWluTGltaXRzOiBnbC5sdW1hLndlYmdsMk1pbkxpbWl0c1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgVEVTVF9MSU1JVFMgPSB7XG4gIFdFQkdMX0xJTUlUUyxcbiAgV0VCR0xfQ0FQU1xufTtcbiJdfQ==

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = installParameterDefinitions;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__buffer__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__fence_sync__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__framebuffer__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__program__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renderbuffer__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sampler__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__texture__ = __webpack_require__(21);
var _BUFFER_PARAMETERS, _FRAMEBUFFER_STATUS, _PROGRAM_PARAMETERS, _RENDERBUFFER_PARAMET, _SAMPLER_PARAMETERS, _TEXTURE_PARAMETERS;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Parameter support.
// Installs definitions that enable querying an object for all its parameters
// with resource.getParameters(). This is mainly useful during debugging.
// Note: Kept separate to avoid bundling in production applications








// import Shader from './shader';


var BUFFER_PARAMETERS = (_BUFFER_PARAMETERS = {}, _defineProperty(_BUFFER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BUFFER_SIZE, { webgl1: 0 }), _defineProperty(_BUFFER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BUFFER_USAGE, { webgl1: 0 }), _BUFFER_PARAMETERS);

var FENCE_SYNC_PARAMETERS = [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].OBJECT_TYPE, // GLenum, type of sync object (always GL.SYNC_FENCE).
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SYNC_STATUS, // GLenum, status of sync object (GL.SIGNALED/GL.UNSIGNALED)
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SYNC_CONDITION, // GLenum. object condition (always GL.SYNC_GPU_COMMANDS_COMPLETE).
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SYNC_FLAGS // GLenum, flags sync object was created with (always 0)
];

var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, // WebGLRenderbuffer or WebGLTexture
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, // GL.RENDERBUFFER, GL.TEXTURE, GL.NONE
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, // GL.TEXTURE_CUBE_MAP_POSITIVE_X, etc.
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, // GLint
// EXT_sRGB or WebGL2
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, // GL.LINEAR, GL.SRBG
// WebGL2
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_RED_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, // GLint
__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
// GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.
];

var FRAMEBUFFER_STATUS = (_FRAMEBUFFER_STATUS = {}, _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_COMPLETE, 'Success. Framebuffer is correctly set up'), _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_INCOMPLETE_ATTACHMENT, 'Attachment types are mismatched or not all attachment points are attachment complete.'), _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, 'There is no attachment.'), _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_INCOMPLETE_DIMENSIONS, 'Attachments do not have the same size.'), _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_UNSUPPORTED, 'Attachment format not supported or depth and stencil attachments are not same renderbuffer.'), _defineProperty(_FRAMEBUFFER_STATUS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRAMEBUFFER_INCOMPLETE_MULTISAMPLE, 'SAMPLES differs among attached renderbuffers, or non-zero SAMPLES are mixed with textures.'), _FRAMEBUFFER_STATUS);

var PROGRAM_PARAMETERS = (_PROGRAM_PARAMETERS = {}, _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DELETE_STATUS, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINK_STATUS, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VALIDATE_STATUS, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ATTACHED_SHADERS, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ACTIVE_ATTRIBUTES, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ACTIVE_UNIFORMS, { webgl1: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRANSFORM_FEEDBACK_BUFFER_MODE, { webgl2: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRANSFORM_FEEDBACK_VARYINGS, { webgl2: 0 }), _defineProperty(_PROGRAM_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ACTIVE_UNIFORM_BLOCKS, { webgl2: 0 }), _PROGRAM_PARAMETERS);

//  parameters
var RENDERBUFFER_PARAMETERS = (_RENDERBUFFER_PARAMET = {}, _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_WIDTH, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_HEIGHT, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_INTERNAL_FORMAT, { type: 'GLenum', webgl1: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RGBA4 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_GREEN_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_BLUE_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_RED_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_ALPHA_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_DEPTH_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_STENCIL_SIZE, { webgl1: 0 }), _defineProperty(_RENDERBUFFER_PARAMET, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].RENDERBUFFER_SAMPLES, { webgl2: 1 }), _RENDERBUFFER_PARAMET);

var SAMPLER_PARAMETERS = (_SAMPLER_PARAMETERS = {}, _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAG_FILTER, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MIN_FILTER, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_S, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_T, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_R, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_BASE_LEVEL, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_LEVEL, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_COMPARE_FUNC, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_COMPARE_MODE, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MIN_LOD, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_LOD, { webgl2: true }), _defineProperty(_SAMPLER_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_ANISOTROPY_EXT, { webgl2: 'EXT_texture_filter_anisotropic' }), _SAMPLER_PARAMETERS);

// const SHADER_PARAMETERS = [
//   GL.DELETE_STATUS, // GLboolean - whether shader is flagged for deletion.
//   GL.COMPILE_STATUS, // GLboolean - was last shader compilation successful.
//   GL.SHADER_TYPE // GLenum - GL.VERTEX_SHADER or GL.FRAGMENT_SHADER.
// ];

var TEXTURE_PARAMETERS = (_TEXTURE_PARAMETERS = {}, _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAG_FILTER, { type: 'GLenum', webgl1: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINEAR }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MIN_FILTER, { type: 'GLenum', webgl1: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].NEAREST_MIPMAP_LINEAR }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_S, { type: 'GLenum', webgl1: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].REPEAT }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_T, { type: 'GLenum', webgl1: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].REPEAT }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WRAP_R, { type: 'GLenum', webgl2: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].REPEAT }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_BASE_LEVEL, { webgl2: 0 }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_LEVEL, { webgl2: 1000 }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_COMPARE_FUNC, { type: 'GLenum', webgl2: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LEQUAL }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_COMPARE_MODE, { type: 'GLenum', webgl2: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].NONE }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MIN_LOD, { webgl2: -1000 }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_LOD, { webgl2: 1000 }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_MAX_ANISOTROPY_EXT, { webgl1: 1.0, extension: 'EXT_texture_filter_anisotropic' }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_WIDTH, { webgl1: 0 }), _defineProperty(_TEXTURE_PARAMETERS, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TEXTURE_HEIGHT, { webgl1: 0 }), _TEXTURE_PARAMETERS);

function installParameterDefinitions() {
  __WEBPACK_IMPORTED_MODULE_1__buffer__["a" /* default */].PARAMETERS = BUFFER_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_2__fence_sync__["a" /* default */].PARAMETERS = FENCE_SYNC_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_3__framebuffer__["a" /* default */].ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_3__framebuffer__["a" /* default */].STATUS = FRAMEBUFFER_STATUS;
  __WEBPACK_IMPORTED_MODULE_4__program__["a" /* default */].PARAMETERS = PROGRAM_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_5__renderbuffer__["a" /* default */].PARAMETERS = RENDERBUFFER_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_6__sampler__["a" /* default */].PARAMETERS = SAMPLER_PARAMETERS;
  // Shader.PARAMETERS = SHADER_PARAMETERS;
  __WEBPACK_IMPORTED_MODULE_7__texture__["a" /* default */].PARAMETERS = TEXTURE_PARAMETERS;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9kZWJ1Zy1wYXJhbWV0ZXJzLmpzIl0sIm5hbWVzIjpbIkdMIiwiQnVmZmVyIiwiRmVuY2VTeW5jIiwiRnJhbWVidWZmZXIiLCJQcm9ncmFtIiwiUmVuZGVyYnVmZmVyIiwiU2FtcGxlciIsIlRleHR1cmUiLCJCVUZGRVJfUEFSQU1FVEVSUyIsIkJVRkZFUl9TSVpFIiwid2ViZ2wxIiwiQlVGRkVSX1VTQUdFIiwiRkVOQ0VfU1lOQ19QQVJBTUVURVJTIiwiT0JKRUNUX1RZUEUiLCJTWU5DX1NUQVRVUyIsIlNZTkNfQ09ORElUSU9OIiwiU1lOQ19GTEFHUyIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUEFSQU1FVEVSUyIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0UiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUwiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTE9SX0VOQ09ESU5HIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9SRURfU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfR1JFRU5fU0laRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9BTFBIQV9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9ERVBUSF9TSVpFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFIiwiRlJBTUVCVUZGRVJfU1RBVFVTIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NVUxUSVNBTVBMRSIsIlBST0dSQU1fUEFSQU1FVEVSUyIsIkRFTEVURV9TVEFUVVMiLCJMSU5LX1NUQVRVUyIsIlZBTElEQVRFX1NUQVRVUyIsIkFUVEFDSEVEX1NIQURFUlMiLCJBQ1RJVkVfQVRUUklCVVRFUyIsIkFDVElWRV9VTklGT1JNUyIsIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfTU9ERSIsIndlYmdsMiIsIlRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyIsIkFDVElWRV9VTklGT1JNX0JMT0NLUyIsIlJFTkRFUkJVRkZFUl9QQVJBTUVURVJTIiwiUkVOREVSQlVGRkVSX1dJRFRIIiwiUkVOREVSQlVGRkVSX0hFSUdIVCIsIlJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQiLCJ0eXBlIiwiUkdCQTQiLCJSRU5ERVJCVUZGRVJfR1JFRU5fU0laRSIsIlJFTkRFUkJVRkZFUl9CTFVFX1NJWkUiLCJSRU5ERVJCVUZGRVJfUkVEX1NJWkUiLCJSRU5ERVJCVUZGRVJfQUxQSEFfU0laRSIsIlJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFIiwiUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRSIsIlJFTkRFUkJVRkZFUl9TQU1QTEVTIiwiU0FNUExFUl9QQVJBTUVURVJTIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJURVhUVVJFX1dSQVBfVCIsIlRFWFRVUkVfV1JBUF9SIiwiVEVYVFVSRV9CQVNFX0xFVkVMIiwiVEVYVFVSRV9NQVhfTEVWRUwiLCJURVhUVVJFX0NPTVBBUkVfRlVOQyIsIlRFWFRVUkVfQ09NUEFSRV9NT0RFIiwiVEVYVFVSRV9NSU5fTE9EIiwiVEVYVFVSRV9NQVhfTE9EIiwiVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJURVhUVVJFX1BBUkFNRVRFUlMiLCJMSU5FQVIiLCJORUFSRVNUX01JUE1BUF9MSU5FQVIiLCJSRVBFQVQiLCJMRVFVQUwiLCJOT05FIiwiZXh0ZW5zaW9uIiwiVEVYVFVSRV9XSURUSCIsIlRFWFRVUkVfSEVJR0hUIiwiaW5zdGFsbFBhcmFtZXRlckRlZmluaXRpb25zIiwiUEFSQU1FVEVSUyIsIkFUVEFDSE1FTlRfUEFSQU1FVEVSUyIsIlNUQVRVUyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEVBQVAsTUFBZSxnQkFBZjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsVUFBbkI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLGNBQXRCO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QixlQUF4QjtBQUNBLE9BQU9DLE9BQVAsTUFBb0IsV0FBcEI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLGdCQUF6QjtBQUNBLE9BQU9DLE9BQVAsTUFBb0IsV0FBcEI7QUFDQTtBQUNBLE9BQU9DLE9BQVAsTUFBb0IsV0FBcEI7O0FBRUEsSUFBTUMsa0ZBQ0hSLEdBQUdTLFdBREEsRUFDYyxFQUFDQyxRQUFRLENBQVQsRUFEZCx1Q0FFSFYsR0FBR1csWUFGQSxFQUVlLEVBQUNELFFBQVEsQ0FBVCxFQUZmLHNCQUFOOztBQUtBLElBQU1FLHdCQUF3QixDQUM1QlosR0FBR2EsV0FEeUIsRUFDWjtBQUNoQmIsR0FBR2MsV0FGeUIsRUFFWjtBQUNoQmQsR0FBR2UsY0FIeUIsRUFHVDtBQUNuQmYsR0FBR2dCLFVBSnlCLENBSWQ7QUFKYyxDQUE5Qjs7QUFPQSxJQUFNQyxvQ0FBb0MsQ0FDeENqQixHQUFHa0Isa0NBRHFDLEVBQ0Q7QUFDdkNsQixHQUFHbUIsa0NBRnFDLEVBRUQ7QUFDdkNuQixHQUFHb0IsNENBSHFDLEVBR1M7QUFDakRwQixHQUFHcUIsb0NBSnFDLEVBSUM7QUFDekM7QUFDQXJCLEdBQUdzQixxQ0FOcUMsRUFNRTtBQUMxQztBQUNB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aUJQLFFBQVE5QyxHQUFHZ0YsSUFBNUIsRUFadkIsd0NBYUhoRixHQUFHd0UsZUFiQSxFQWFrQixFQUFDMUIsUUFBUSxDQUFDLElBQVYsRUFibEIsd0NBY0g5QyxHQUFHeUUsZUFkQSxFQWNrQixFQUFDM0IsUUFBUSxJQUFULEVBZGxCLHdDQWlCSDlDLEdBQUcwRSwwQkFqQkEsRUFpQjZCLEVBQUNoRSxRQUFRLEdBQVQsRUFBY3VFLFdBQVcsZ0NBQXpCLEVBakI3Qix3Q0FvQkhqRixHQUFHa0YsYUFwQkEsRUFvQmdCLEVBQUN4RSxRQUFRLENBQVQsRUFwQmhCLHdDQXFCSFYsR0FBR21GLGNBckJBLEVBcUJpQixFQUFDekUsUUFBUSxDQUFULEVBckJqQix1QkFBTjs7QUF3QkEsT0FBTyxTQUFTMEUsMkJBQVQsR0FBdUM7QUFDNUNuRixTQUFPb0YsVUFBUCxHQUFvQjdFLGlCQUFwQjtBQUNBTixZQUFVbUYsVUFBVixHQUF1QnpFLHFCQUF2QjtBQUNBVCxjQUFZbUYscUJBQVosR0FBb0NyRSxpQ0FBcEM7QUFDQWQsY0FBWW9GLE1BQVosR0FBcUJ4RCxrQkFBckI7QUFDQTNCLFVBQVFpRixVQUFSLEdBQXFCL0Msa0JBQXJCO0FBQ0FqQyxlQUFhZ0YsVUFBYixHQUEwQnBDLHVCQUExQjtBQUNBM0MsVUFBUStFLFVBQVIsR0FBcUJ2QixrQkFBckI7QUFDQTtBQUNBdkQsVUFBUThFLFVBQVIsR0FBcUJWLGtCQUFyQjtBQUNEIiwiZmlsZSI6ImRlYnVnLXBhcmFtZXRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYXJhbWV0ZXIgc3VwcG9ydC5cbi8vIEluc3RhbGxzIGRlZmluaXRpb25zIHRoYXQgZW5hYmxlIHF1ZXJ5aW5nIGFuIG9iamVjdCBmb3IgYWxsIGl0cyBwYXJhbWV0ZXJzXG4vLyB3aXRoIHJlc291cmNlLmdldFBhcmFtZXRlcnMoKS4gVGhpcyBpcyBtYWlubHkgdXNlZnVsIGR1cmluZyBkZWJ1Z2dpbmcuXG4vLyBOb3RlOiBLZXB0IHNlcGFyYXRlIHRvIGF2b2lkIGJ1bmRsaW5nIGluIHByb2R1Y3Rpb24gYXBwbGljYXRpb25zXG5cbmltcG9ydCBHTCBmcm9tICcuL2dsLWNvbnN0YW50cyc7XG5pbXBvcnQgQnVmZmVyIGZyb20gJy4vYnVmZmVyJztcbmltcG9ydCBGZW5jZVN5bmMgZnJvbSAnLi9mZW5jZS1zeW5jJztcbmltcG9ydCBGcmFtZWJ1ZmZlciBmcm9tICcuL2ZyYW1lYnVmZmVyJztcbmltcG9ydCBQcm9ncmFtIGZyb20gJy4vcHJvZ3JhbSc7XG5pbXBvcnQgUmVuZGVyYnVmZmVyIGZyb20gJy4vcmVuZGVyYnVmZmVyJztcbmltcG9ydCBTYW1wbGVyIGZyb20gJy4vc2FtcGxlcic7XG4vLyBpbXBvcnQgU2hhZGVyIGZyb20gJy4vc2hhZGVyJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5cbmNvbnN0IEJVRkZFUl9QQVJBTUVURVJTID0ge1xuICBbR0wuQlVGRkVSX1NJWkVdOiB7d2ViZ2wxOiAwfSwgLy8gR0xpbnQgaW5kaWNhdGluZyB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxuICBbR0wuQlVGRkVSX1VTQUdFXToge3dlYmdsMTogMH0gLy8gR0xlbnVtIGluZGljYXRpbmcgdGhlIHVzYWdlIHBhdHRlcm4gb2YgdGhlIGJ1ZmZlci5cbn07XG5cbmNvbnN0IEZFTkNFX1NZTkNfUEFSQU1FVEVSUyA9IFtcbiAgR0wuT0JKRUNUX1RZUEUsIC8vIEdMZW51bSwgdHlwZSBvZiBzeW5jIG9iamVjdCAoYWx3YXlzIEdMLlNZTkNfRkVOQ0UpLlxuICBHTC5TWU5DX1NUQVRVUywgLy8gR0xlbnVtLCBzdGF0dXMgb2Ygc3luYyBvYmplY3QgKEdMLlNJR05BTEVEL0dMLlVOU0lHTkFMRUQpXG4gIEdMLlNZTkNfQ09ORElUSU9OLCAvLyBHTGVudW0uIG9iamVjdCBjb25kaXRpb24gKGFsd2F5cyBHTC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSkuXG4gIEdMLlNZTkNfRkxBR1MgLy8gR0xlbnVtLCBmbGFncyBzeW5jIG9iamVjdCB3YXMgY3JlYXRlZCB3aXRoIChhbHdheXMgMClcbl07XG5cbmNvbnN0IEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUEFSQU1FVEVSUyA9IFtcbiAgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSwgLy8gV2ViR0xSZW5kZXJidWZmZXIgb3IgV2ViR0xUZXh0dXJlXG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUsIC8vIEdMLlJFTkRFUkJVRkZFUiwgR0wuVEVYVFVSRSwgR0wuTk9ORVxuICBHTC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRSwgLy8gR0wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBldGMuXG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCwgLy8gR0xpbnRcbiAgLy8gRVhUX3NSR0Igb3IgV2ViR0wyXG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkcsIC8vIEdMLkxJTkVBUiwgR0wuU1JCR1xuICAvLyBXZWJHTDJcbiAgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xBWUVSLCAvLyBHTGludFxuICBHTC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1JFRF9TSVpFLCAvLyBHTGludFxuICBHTC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0dSRUVOX1NJWkUsIC8vIEdMaW50XG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFLCAvLyBHTGludFxuICBHTC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0FMUEhBX1NJWkUsIC8vIEdMaW50XG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfREVQVEhfU0laRSwgLy8gR0xpbnRcbiAgR0wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkUsIC8vIEdMaW50XG4gIEdMLkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09NUE9ORU5UX1RZUEVcbiAgLy8gR0wuRkxPQVQsIEdMLklOVCwgR0wuVU5TSUdORURfSU5ULCBHTC5TSUdORURfTk9STUFMSVpFRCwgT1IgR0wuVU5TSUdORURfTk9STUFMSVpFRC5cbl07XG5cbmNvbnN0IEZSQU1FQlVGRkVSX1NUQVRVUyA9IHtcbiAgW0dMLkZSQU1FQlVGRkVSX0NPTVBMRVRFXTpcbiAgICAnU3VjY2Vzcy4gRnJhbWVidWZmZXIgaXMgY29ycmVjdGx5IHNldCB1cCcsXG4gIFtHTC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdOlxuICAgICdBdHRhY2htZW50IHR5cGVzIGFyZSBtaXNtYXRjaGVkIG9yIG5vdCBhbGwgYXR0YWNobWVudCBwb2ludHMgYXJlIGF0dGFjaG1lbnQgY29tcGxldGUuJyxcbiAgW0dMLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXTpcbiAgICAnVGhlcmUgaXMgbm8gYXR0YWNobWVudC4nLFxuICBbR0wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXTpcbiAgICAnQXR0YWNobWVudHMgZG8gbm90IGhhdmUgdGhlIHNhbWUgc2l6ZS4nLFxuICBbR0wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURURdOlxuICAgICdBdHRhY2htZW50IGZvcm1hdCBub3Qgc3VwcG9ydGVkIG9yIGRlcHRoIGFuZCBzdGVuY2lsIGF0dGFjaG1lbnRzIGFyZSBub3Qgc2FtZSByZW5kZXJidWZmZXIuJyxcbiAgLy8gV2hlbiB1c2luZyBhIFdlYkdMIDIgY29udGV4dCwgdGhlIGZvbGxvd2luZyB2YWx1ZXMgY2FuIGJlIHJldHVybmVkXG4gIFtHTC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFXTpcbiAgICAnU0FNUExFUyBkaWZmZXJzIGFtb25nIGF0dGFjaGVkIHJlbmRlcmJ1ZmZlcnMsIG9yIG5vbi16ZXJvIFNBTVBMRVMgYXJlIG1peGVkIHdpdGggdGV4dHVyZXMuJ1xufTtcblxuY29uc3QgUFJPR1JBTV9QQVJBTUVURVJTID0ge1xuICBbR0wuREVMRVRFX1NUQVRVU106IHt3ZWJnbDE6IDB9LCAvLyBHTGJvb2xlYW5cbiAgW0dMLkxJTktfU1RBVFVTXToge3dlYmdsMTogMH0sIC8vIEdMYm9vbGVhblxuICBbR0wuVkFMSURBVEVfU1RBVFVTXToge3dlYmdsMTogMH0sIC8vIEdMYm9vbGVhblxuICBbR0wuQVRUQUNIRURfU0hBREVSU106IHt3ZWJnbDE6IDB9LCAvLyBHTGludFxuICBbR0wuQUNUSVZFX0FUVFJJQlVURVNdOiB7d2ViZ2wxOiAwfSwgLy8gR0xpbnRcbiAgW0dMLkFDVElWRV9VTklGT1JNU106IHt3ZWJnbDE6IDB9LCAvLyBHTGludFxuICBbR0wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9NT0RFXToge3dlYmdsMjogMH0sIC8vIFNFUEFSQVRFX0FUVFJJQlMvSU5URVJMRUFWRURfQVRUUklCU1xuICBbR0wuVFJBTlNGT1JNX0ZFRURCQUNLX1ZBUllJTkdTXToge3dlYmdsMjogMH0sIC8vIEdMaW50XG4gIFtHTC5BQ1RJVkVfVU5JRk9STV9CTE9DS1NdOiB7d2ViZ2wyOiAwfSAvLyBHTGludFxufTtcblxuLy8gIHBhcmFtZXRlcnNcbmNvbnN0IFJFTkRFUkJVRkZFUl9QQVJBTUVURVJTID0ge1xuICAvLyBXZWJHTDEgcGFyYW1ldGVyc1xuICBbR0wuUkVOREVSQlVGRkVSX1dJRFRIXToge3dlYmdsMTogMH0sIC8vIHtHTGludH0gLSBoZWlnaHQgb2YgdGhlIGltYWdlIG9mIHJlbmRlcmJ1ZmZlci5cbiAgW0dMLlJFTkRFUkJVRkZFUl9IRUlHSFRdOiB7d2ViZ2wxOiAwfSwgLy8ge0dMaW50fSAtIGhlaWdodCBvZiB0aGUgaW1hZ2Ugb2YgcmVuZGVyYnVmZmVyLlxuXG4gIC8vIEludGVybmFsIGZvcm1hdCBvZiB0aGUgY3VycmVudGx5IGJvdW5kIHJlbmRlcmJ1ZmZlci5cbiAgLy8gVGhlIGRlZmF1bHQgaXMgR0wuUkdCQTQuIFBvc3NpYmxlIHJldHVybiB2YWx1ZXM6XG4gIC8vIEdMLlJHQkE0OiA0IHJlZCBiaXRzLCA0IGdyZWVuIGJpdHMsIDQgYmx1ZSBiaXRzIDQgYWxwaGEgYml0cy5cbiAgLy8gR0wuUkdCNTY1OiA1IHJlZCBiaXRzLCA2IGdyZWVuIGJpdHMsIDUgYmx1ZSBiaXRzLlxuICAvLyBHTC5SR0I1X0ExOiA1IHJlZCBiaXRzLCA1IGdyZWVuIGJpdHMsIDUgYmx1ZSBiaXRzLCAxIGFscGhhIGJpdC5cbiAgLy8gR0wuREVQVEhfQ09NUE9ORU5UMTY6IDE2IGRlcHRoIGJpdHMuXG4gIC8vIEdMLlNURU5DSUxfSU5ERVg4OiA4IHN0ZW5jaWwgYml0cy5cbiAgW0dMLlJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVRdOiB7dHlwZTogJ0dMZW51bScsIHdlYmdsMTogR0wuUkdCQTR9LFxuXG4gIFtHTC5SRU5ERVJCVUZGRVJfR1JFRU5fU0laRV06IHt3ZWJnbDE6IDB9LCAvLyB7R0xpbnR9IC0gcmVzb2x1dGlvbiAoYml0cykgb2YgZ3JlZW4gY29sb3JcbiAgW0dMLlJFTkRFUkJVRkZFUl9CTFVFX1NJWkVdOiB7d2ViZ2wxOiAwfSwgLy8ge0dMaW50fSAtIHJlc29sdXRpb24gKGJpdHMpIG9mIGJsdWUgY29sb3JcbiAgW0dMLlJFTkRFUkJVRkZFUl9SRURfU0laRV06IHt3ZWJnbDE6IDB9LCAvLyB7R0xpbnR9IC0gcmVzb2x1dGlvbiAoYml0cykgb2YgcmVkIGNvbG9yXG4gIFtHTC5SRU5ERVJCVUZGRVJfQUxQSEFfU0laRV06IHt3ZWJnbDE6IDB9LCAvLyB7R0xpbnR9IC0gcmVzb2x1dGlvbiAoYml0cykgb2YgYWxwaGEgY29tcG9uZW50XG4gIFtHTC5SRU5ERVJCVUZGRVJfREVQVEhfU0laRV06IHt3ZWJnbDE6IDB9LCAvLyB7R0xpbnR9IC0gcmVzb2x1dGlvbiAoYml0cykgb2YgZGVwdGggY29tcG9uZW50XG4gIFtHTC5SRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFXToge3dlYmdsMTogMH0sIC8vIHtHTGludH0gLSByZXNvbHV0aW9uIChiaXRzKSBvZiBzdGVuY2lsIGNvbXBvbmVudFxuXG4gIC8vIFdoZW4gdXNpbmcgYSBXZWJHTCAyIGNvbnRleHQsIHRoZSBmb2xsb3dpbmcgdmFsdWUgaXMgYXZhaWxhYmxlXG4gIFtHTC5SRU5ERVJCVUZGRVJfU0FNUExFU106IHt3ZWJnbDI6IDF9XG59O1xuXG5jb25zdCBTQU1QTEVSX1BBUkFNRVRFUlMgPSB7XG4gIFtHTC5URVhUVVJFX01BR19GSUxURVJdOiB7d2ViZ2wyOiB0cnVlfSwgLy8gdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlclxuICBbR0wuVEVYVFVSRV9NSU5fRklMVEVSXToge3dlYmdsMjogdHJ1ZX0sIC8vIHRleHR1cmUgbWluaWZpY2F0aW9uIGZpbHRlclxuICBbR0wuVEVYVFVSRV9XUkFQX1NdOiB7d2ViZ2wyOiB0cnVlfSwgLy8gdGV4dHVyZSB3cmFwcGluZyBmdW5jdGlvbiBmb3IgdGV4dHVyZSBjb29yZGluYXRlIHNcbiAgW0dMLlRFWFRVUkVfV1JBUF9UXToge3dlYmdsMjogdHJ1ZX0sIC8vIHRleHR1cmUgd3JhcHBpbmcgZnVuY3Rpb24gZm9yIHRleHR1cmUgY29vcmRpbmF0ZSB0XG4gIFtHTC5URVhUVVJFX1dSQVBfUl06IHt3ZWJnbDI6IHRydWV9LCAvLyB0ZXh0dXJlIHdyYXBwaW5nIGZ1bmN0aW9uIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGUgclxuICBbR0wuVEVYVFVSRV9CQVNFX0xFVkVMXToge3dlYmdsMjogdHJ1ZX0sIC8vIFRleHR1cmUgbWlwbWFwIGxldmVsXG4gIFtHTC5URVhUVVJFX01BWF9MRVZFTF06IHt3ZWJnbDI6IHRydWV9LCAvLyBNYXhpbXVtIHRleHR1cmUgbWlwbWFwIGFycmF5IGxldmVsXG4gIFtHTC5URVhUVVJFX0NPTVBBUkVfRlVOQ106IHt3ZWJnbDI6IHRydWV9LCAvLyB0ZXh0dXJlIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgW0dMLlRFWFRVUkVfQ09NUEFSRV9NT0RFXToge3dlYmdsMjogdHJ1ZX0sIC8vIHRleHR1cmUgY29tcGFyaXNvbiBtb2RlXG4gIFtHTC5URVhUVVJFX01JTl9MT0RdOiB7d2ViZ2wyOiB0cnVlfSwgLy8gbWluaW11bSBsZXZlbC1vZi1kZXRhaWwgdmFsdWVcbiAgW0dMLlRFWFRVUkVfTUFYX0xPRF06IHt3ZWJnbDI6IHRydWV9LCAvLyBtYXhpbXVtIGxldmVsLW9mLWRldGFpbCB2YWx1ZVxuXG4gIFtHTC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVF06IHt3ZWJnbDI6ICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnfVxufTtcblxuLy8gY29uc3QgU0hBREVSX1BBUkFNRVRFUlMgPSBbXG4vLyAgIEdMLkRFTEVURV9TVEFUVVMsIC8vIEdMYm9vbGVhbiAtIHdoZXRoZXIgc2hhZGVyIGlzIGZsYWdnZWQgZm9yIGRlbGV0aW9uLlxuLy8gICBHTC5DT01QSUxFX1NUQVRVUywgLy8gR0xib29sZWFuIC0gd2FzIGxhc3Qgc2hhZGVyIGNvbXBpbGF0aW9uIHN1Y2Nlc3NmdWwuXG4vLyAgIEdMLlNIQURFUl9UWVBFIC8vIEdMZW51bSAtIEdMLlZFUlRFWF9TSEFERVIgb3IgR0wuRlJBR01FTlRfU0hBREVSLlxuLy8gXTtcblxuY29uc3QgVEVYVFVSRV9QQVJBTUVURVJTID0ge1xuICAvLyBXRUJHTDFcbiAgW0dMLlRFWFRVUkVfTUFHX0ZJTFRFUl06IHt0eXBlOiAnR0xlbnVtJywgd2ViZ2wxOiBHTC5MSU5FQVJ9LCAvLyB0ZXh0dXJlIG1hZ25pZmljYXRpb24gZmlsdGVyXG4gIFtHTC5URVhUVVJFX01JTl9GSUxURVJdOiB7dHlwZTogJ0dMZW51bScsIHdlYmdsMTogR0wuTkVBUkVTVF9NSVBNQVBfTElORUFSfSwgLy8gbWluaWZpY2F0aW9uIGZpbHQuXG4gIFtHTC5URVhUVVJFX1dSQVBfU106IHt0eXBlOiAnR0xlbnVtJywgd2ViZ2wxOiBHTC5SRVBFQVR9LCAvLyB0ZXh0dXJlIHdyYXBwaW5nIGZvciBjb29yZGluYXRlIHNcbiAgW0dMLlRFWFRVUkVfV1JBUF9UXToge3R5cGU6ICdHTGVudW0nLCB3ZWJnbDE6IEdMLlJFUEVBVH0sIC8vIHRleHR1cmUgd3JhcHBpbmcgZm9yIHRleHR1cmUgdFxuXG4gIC8vIFdFQkdMMlxuICBbR0wuVEVYVFVSRV9XUkFQX1JdOiB7dHlwZTogJ0dMZW51bScsIHdlYmdsMjogR0wuUkVQRUFUfSwgLy8gdGV4dHVyZSB3cmFwcGluZyBmb3IgdGV4dHVyZSByXG4gIFtHTC5URVhUVVJFX0JBU0VfTEVWRUxdOiB7d2ViZ2wyOiAwfSwgLy8gVGV4dHVyZSBtaXBtYXAgbGV2ZWxcbiAgW0dMLlRFWFRVUkVfTUFYX0xFVkVMXToge3dlYmdsMjogMTAwMH0sIC8vIE1heGltdW0gdGV4dHVyZSBtaXBtYXAgYXJyYXkgbGV2ZWxcbiAgW0dMLlRFWFRVUkVfQ09NUEFSRV9GVU5DXToge3R5cGU6ICdHTGVudW0nLCB3ZWJnbDI6IEdMLkxFUVVBTH0sIC8vIHRleHR1cmUgY29tcGFyaXNvbiBmdW5jdGlvblxuICBbR0wuVEVYVFVSRV9DT01QQVJFX01PREVdOiB7dHlwZTogJ0dMZW51bScsIHdlYmdsMjogR0wuTk9ORX0sIC8vIHRleHR1cmUgY29tcGFyaXNvbiBtb2RlXG4gIFtHTC5URVhUVVJFX01JTl9MT0RdOiB7d2ViZ2wyOiAtMTAwMH0sIC8vIG1pbmltdW0gbGV2ZWwtb2YtZGV0YWlsIHZhbHVlXG4gIFtHTC5URVhUVVJFX01BWF9MT0RdOiB7d2ViZ2wyOiAxMDAwfSwgLy8gbWF4aW11bSBsZXZlbC1vZi1kZXRhaWwgdmFsdWVcblxuICAvLyBXZWJHTCBFeHRlbnNpb25zXG4gIFtHTC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVF06IHt3ZWJnbDE6IDEuMCwgZXh0ZW5zaW9uOiAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJ30sXG5cbiAgLy8gRW11bGF0ZWQgcGFyYW1ldGVycyAtIFRoZXNlIE9wZW5HTCBwYXJhbWV0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IE9wZW5HTCBFU1xuICBbR0wuVEVYVFVSRV9XSURUSF06IHt3ZWJnbDE6IDB9LFxuICBbR0wuVEVYVFVSRV9IRUlHSFRdOiB7d2ViZ2wxOiAwfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxQYXJhbWV0ZXJEZWZpbml0aW9ucygpIHtcbiAgQnVmZmVyLlBBUkFNRVRFUlMgPSBCVUZGRVJfUEFSQU1FVEVSUztcbiAgRmVuY2VTeW5jLlBBUkFNRVRFUlMgPSBGRU5DRV9TWU5DX1BBUkFNRVRFUlM7XG4gIEZyYW1lYnVmZmVyLkFUVEFDSE1FTlRfUEFSQU1FVEVSUyA9IEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfUEFSQU1FVEVSUztcbiAgRnJhbWVidWZmZXIuU1RBVFVTID0gRlJBTUVCVUZGRVJfU1RBVFVTO1xuICBQcm9ncmFtLlBBUkFNRVRFUlMgPSBQUk9HUkFNX1BBUkFNRVRFUlM7XG4gIFJlbmRlcmJ1ZmZlci5QQVJBTUVURVJTID0gUkVOREVSQlVGRkVSX1BBUkFNRVRFUlM7XG4gIFNhbXBsZXIuUEFSQU1FVEVSUyA9IFNBTVBMRVJfUEFSQU1FVEVSUztcbiAgLy8gU2hhZGVyLlBBUkFNRVRFUlMgPSBTSEFERVJfUEFSQU1FVEVSUztcbiAgVGV4dHVyZS5QQVJBTUVURVJTID0gVEVYVFVSRV9QQVJBTUVURVJTO1xufVxuIl19

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = draw;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
/* eslint-disable */
// TODO - generic draw call
// One of the good things about GL is that there are so many ways to draw things





// A good thing about webGL is that there are so many ways to draw things,
// e.g. depending on whether data is indexed and/or isInstanced.
// This function unifies those into a single call with simple parameters
// that have sane defaults.
function draw(gl, _ref) {
  var _ref$drawMode = _ref.drawMode,
      drawMode = _ref$drawMode === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TRIANGLES : _ref$drawMode,
      vertexCount = _ref.vertexCount,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? 0 : _ref$offset,
      _ref$isIndexed = _ref.isIndexed,
      isIndexed = _ref$isIndexed === undefined ? false : _ref$isIndexed,
      _ref$indexType = _ref.indexType,
      indexType = _ref$indexType === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_SHORT : _ref$indexType,
      _ref$isInstanced = _ref.isInstanced,
      isInstanced = _ref$isInstanced === undefined ? false : _ref$isInstanced,
      _ref$instanceCount = _ref.instanceCount,
      instanceCount = _ref$instanceCount === undefined ? 0 : _ref$instanceCount;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);

  var extension = gl.getExtension('ANGLE_instanced_arrays');

  // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension
  if (isInstanced && isIndexed) {
    extension.drawElementsInstancedANGLE(drawMode, vertexCount, indexType, offset, instanceCount);
  } else if (isInstanced) {
    extension.drawArraysInstancedANGLE(drawMode, offset, vertexCount, instanceCount);
  } else if (isIndexed) {
    gl.drawElements(drawMode, vertexCount, indexType, offset);
  } else {
    gl.drawArrays(drawMode, offset, vertexCount);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9kcmF3LmpzIl0sIm5hbWVzIjpbIkdMIiwiZ2xHZXQiLCJhc3NlcnRXZWJHTENvbnRleHQiLCJhc3NlcnRXZWJHTDJDb250ZXh0IiwiZ2xDb250ZXh0V2l0aFN0YXRlIiwiYXNzZXJ0IiwiZHJhdyIsImdsIiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhDb3VudCIsIm9mZnNldCIsImlzSW5kZXhlZCIsImluZGV4VHlwZSIsIlVOU0lHTkVEX1NIT1JUIiwiaXNJbnN0YW5jZWQiLCJpbnN0YW5jZUNvdW50IiwiZXh0ZW5zaW9uIiwiZ2V0RXh0ZW5zaW9uIiwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUiLCJkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUiLCJkcmF3RWxlbWVudHMiLCJkcmF3QXJyYXlzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxPQUFPQSxFQUFQLElBQVlDLEtBQVosUUFBd0IsT0FBeEI7QUFDQSxTQUFRQyxrQkFBUixFQUE0QkMsbUJBQTVCLFFBQXNELFdBQXREO0FBQ0EsU0FBUUMsa0JBQVIsUUFBaUMsV0FBakM7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxTQUFTQyxJQUFULENBQWNDLEVBQWQsUUFRSjtBQUFBLDJCQVBEQyxRQU9DO0FBQUEsTUFQREEsUUFPQyxpQ0FQVVIsR0FBR1MsU0FPYjtBQUFBLE1BTkRDLFdBTUMsUUFOREEsV0FNQztBQUFBLHlCQUxEQyxNQUtDO0FBQUEsTUFMREEsTUFLQywrQkFMUSxDQUtSO0FBQUEsNEJBSkRDLFNBSUM7QUFBQSxNQUpEQSxTQUlDLGtDQUpXLEtBSVg7QUFBQSw0QkFIREMsU0FHQztBQUFBLE1BSERBLFNBR0Msa0NBSFdiLEdBQUdjLGNBR2Q7QUFBQSw4QkFGREMsV0FFQztBQUFBLE1BRkRBLFdBRUMsb0NBRmEsS0FFYjtBQUFBLGdDQUREQyxhQUNDO0FBQUEsTUFEREEsYUFDQyxzQ0FEZSxDQUNmOztBQUNEZCxxQkFBbUJLLEVBQW5COztBQUVBLE1BQU1VLFlBQVlWLEdBQUdXLFlBQUgsQ0FBZ0Isd0JBQWhCLENBQWxCOztBQUVBO0FBQ0EsTUFBSUgsZUFBZUgsU0FBbkIsRUFBOEI7QUFDNUJLLGNBQVVFLDBCQUFWLENBQ0VYLFFBREYsRUFDWUUsV0FEWixFQUN5QkcsU0FEekIsRUFDb0NGLE1BRHBDLEVBQzRDSyxhQUQ1QztBQUdELEdBSkQsTUFJTyxJQUFJRCxXQUFKLEVBQWlCO0FBQ3RCRSxjQUFVRyx3QkFBVixDQUNFWixRQURGLEVBQ1lHLE1BRFosRUFDb0JELFdBRHBCLEVBQ2lDTSxhQURqQztBQUdELEdBSk0sTUFJQSxJQUFJSixTQUFKLEVBQWU7QUFDcEJMLE9BQUdjLFlBQUgsQ0FBZ0JiLFFBQWhCLEVBQTBCRSxXQUExQixFQUF1Q0csU0FBdkMsRUFBa0RGLE1BQWxEO0FBQ0QsR0FGTSxNQUVBO0FBQ0xKLE9BQUdlLFVBQUgsQ0FBY2QsUUFBZCxFQUF3QkcsTUFBeEIsRUFBZ0NELFdBQWhDO0FBQ0Q7QUFDRiIsImZpbGUiOiJkcmF3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIFRPRE8gLSBnZW5lcmljIGRyYXcgY2FsbFxuLy8gT25lIG9mIHRoZSBnb29kIHRoaW5ncyBhYm91dCBHTCBpcyB0aGF0IHRoZXJlIGFyZSBzbyBtYW55IHdheXMgdG8gZHJhdyB0aGluZ3NcbmltcG9ydCBHTCwge2dsR2V0fSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2Fzc2VydFdlYkdMQ29udGV4dCwgYXNzZXJ0V2ViR0wyQ29udGV4dH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7Z2xDb250ZXh0V2l0aFN0YXRlfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBBIGdvb2QgdGhpbmcgYWJvdXQgd2ViR0wgaXMgdGhhdCB0aGVyZSBhcmUgc28gbWFueSB3YXlzIHRvIGRyYXcgdGhpbmdzLFxuLy8gZS5nLiBkZXBlbmRpbmcgb24gd2hldGhlciBkYXRhIGlzIGluZGV4ZWQgYW5kL29yIGlzSW5zdGFuY2VkLlxuLy8gVGhpcyBmdW5jdGlvbiB1bmlmaWVzIHRob3NlIGludG8gYSBzaW5nbGUgY2FsbCB3aXRoIHNpbXBsZSBwYXJhbWV0ZXJzXG4vLyB0aGF0IGhhdmUgc2FuZSBkZWZhdWx0cy5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KGdsLCB7XG4gIGRyYXdNb2RlID0gR0wuVFJJQU5HTEVTLFxuICB2ZXJ0ZXhDb3VudCxcbiAgb2Zmc2V0ID0gMCxcbiAgaXNJbmRleGVkID0gZmFsc2UsXG4gIGluZGV4VHlwZSA9IEdMLlVOU0lHTkVEX1NIT1JULFxuICBpc0luc3RhbmNlZCA9IGZhbHNlLFxuICBpbnN0YW5jZUNvdW50ID0gMFxufSkge1xuICBhc3NlcnRXZWJHTENvbnRleHQoZ2wpO1xuXG4gIGNvbnN0IGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXG4gIC8vIFRPRE8gLSBVc2UgcG9seWZpbGxlZCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IGluc3RlYWQgb2YgQU5HTEUgZXh0ZW5zaW9uXG4gIGlmIChpc0luc3RhbmNlZCAmJiBpc0luZGV4ZWQpIHtcbiAgICBleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoXG4gICAgICBkcmF3TW9kZSwgdmVydGV4Q291bnQsIGluZGV4VHlwZSwgb2Zmc2V0LCBpbnN0YW5jZUNvdW50XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc0luc3RhbmNlZCkge1xuICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoXG4gICAgICBkcmF3TW9kZSwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VDb3VudFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNJbmRleGVkKSB7XG4gICAgZ2wuZHJhd0VsZW1lbnRzKGRyYXdNb2RlLCB2ZXJ0ZXhDb3VudCwgaW5kZXhUeXBlLCBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGdsLmRyYXdBcnJheXMoZHJhd01vZGUsIG9mZnNldCwgdmVydGV4Q291bnQpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers_query_manager__ = __webpack_require__(58);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var FenceSync = function (_Resource) {
  _inherits(FenceSync, _Resource);

  /*
   * @class
   * @param {WebGL2RenderingContext} gl
   */
  function FenceSync(gl, opts) {
    _classCallCheck(this, FenceSync);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);

    // query manager needs a promise field
    var _this = _possibleConstructorReturn(this, (FenceSync.__proto__ || Object.getPrototypeOf(FenceSync)).call(this, gl, opts));

    _this.promise = null;
    Object.seal(_this);
    return _this;
  }

  /**
   * The method is a no-op in the absence of the possibility of
   * synchronizing between multiple GL contexts.
   * Prevent commands from being added to GPU command queue.
   * Note: commands can still be buffered in driver.
   *
   * @param {GLbitfield} flags
   * @param {GLint64} timeout
   * @return {Sync} status
   */


  _createClass(FenceSync, [{
    key: 'wait',
    value: function wait() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$flags = _ref.flags,
          flags = _ref$flags === undefined ? 0 : _ref$flags,
          _ref$timeout = _ref.timeout,
          timeout = _ref$timeout === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIMEOUT_IGNORED : _ref$timeout;

      this.gl.waitSync(this.handle, flags, timeout);
      return this;
    }

    /**
     * Block all CPU operations until fence is signalled
     * @param {GLbitfield} flags
     * @param {GLint64} timeout
     * @return {GLenum} result
     */

  }, {
    key: 'clientWait',
    value: function clientWait(_ref2) {
      var _ref2$flags = _ref2.flags,
          flags = _ref2$flags === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SYNC_FLUSH_COMMANDS_BIT : _ref2$flags,
          timeout = _ref2.timeout;

      var result = this.gl.clientWaitSync(this.handle, flags, timeout);
      // TODO - map to boolean?
      switch (result) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].ALREADY_SIGNALED:
          // Indicates that sync object was signaled when this method was called.
          break;
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIMEOUT_EXPIRED:
          // Indicates that timeout time passed, sync object did not become signaled
          break;
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].CONDITION_SATISFIED:
          // Indicates that sync object was signaled before timeout expired.
          break;
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].WAIT_FAILED:
          // Indicates that an error occurred during execution.
          break;
        default:
      }
      return result;
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      __WEBPACK_IMPORTED_MODULE_3__helpers_query_manager__["a" /* default */].cancelQuery(this);
    }
  }, {
    key: 'isSignaled',
    value: function isSignaled() {
      return this.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SYNC_STATUS) === __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SIGNALED;
    }

    // TODO - Query manager needs these?

  }, {
    key: 'isResultAvailable',
    value: function isResultAvailable() {
      return this.isSignaled();
    }
  }, {
    key: 'getResult',
    value: function getResult() {
      return this.isSignaled();
    }
  }, {
    key: 'getParameter',
    value: function getParameter(pname) {
      return this.gl.getSyncParameter(this.handle, pname);
    }

    // PRIVATE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.fenceSync(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].SYNC_GPU_COMMANDS_COMPLETE, 0);
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      __WEBPACK_IMPORTED_MODULE_3__helpers_query_manager__["a" /* default */].deleteQuery(this);
      this.gl.deleteSync(this.handle);
    }
  }]);

  return FenceSync;
}(__WEBPACK_IMPORTED_MODULE_2__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (FenceSync);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9mZW5jZS1zeW5jLmpzIl0sIm5hbWVzIjpbIkdMIiwiYXNzZXJ0V2ViR0wyQ29udGV4dCIsIlJlc291cmNlIiwicXVlcnlNYW5hZ2VyIiwiRmVuY2VTeW5jIiwiZ2wiLCJvcHRzIiwicHJvbWlzZSIsIk9iamVjdCIsInNlYWwiLCJmbGFncyIsInRpbWVvdXQiLCJUSU1FT1VUX0lHTk9SRUQiLCJ3YWl0U3luYyIsImhhbmRsZSIsIlNZTkNfRkxVU0hfQ09NTUFORFNfQklUIiwicmVzdWx0IiwiY2xpZW50V2FpdFN5bmMiLCJBTFJFQURZX1NJR05BTEVEIiwiVElNRU9VVF9FWFBJUkVEIiwiQ09ORElUSU9OX1NBVElTRklFRCIsIldBSVRfRkFJTEVEIiwiY2FuY2VsUXVlcnkiLCJnZXRQYXJhbWV0ZXIiLCJTWU5DX1NUQVRVUyIsIlNJR05BTEVEIiwiaXNTaWduYWxlZCIsInBuYW1lIiwiZ2V0U3luY1BhcmFtZXRlciIsImZlbmNlU3luYyIsIlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFIiwiZGVsZXRlUXVlcnkiLCJkZWxldGVTeW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE9BQU9BLEVBQVAsTUFBZSxPQUFmO0FBQ0EsU0FBUUMsbUJBQVIsUUFBa0MsV0FBbEM7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5Qix5QkFBekI7O0lBRXFCQyxTOzs7QUFDbkI7Ozs7QUFJQSxxQkFBWUMsRUFBWixFQUFnQkMsSUFBaEIsRUFBc0I7QUFBQTs7QUFDcEJMLHdCQUFvQkksRUFBcEI7O0FBRUE7QUFIb0Isc0hBRWRBLEVBRmMsRUFFVkMsSUFGVTs7QUFJcEIsVUFBS0MsT0FBTCxHQUFlLElBQWY7QUFDQUMsV0FBT0MsSUFBUDtBQUxvQjtBQU1yQjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7MkJBVXFEO0FBQUEscUZBQUosRUFBSTtBQUFBLDRCQUEvQ0MsS0FBK0M7QUFBQSxVQUEvQ0EsS0FBK0MsOEJBQXZDLENBQXVDO0FBQUEsOEJBQXBDQyxPQUFvQztBQUFBLFVBQXBDQSxPQUFvQyxnQ0FBMUJYLEdBQUdZLGVBQXVCOztBQUNuRCxXQUFLUCxFQUFMLENBQVFRLFFBQVIsQ0FBaUIsS0FBS0MsTUFBdEIsRUFBOEJKLEtBQTlCLEVBQXFDQyxPQUFyQztBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7c0NBTTBEO0FBQUEsOEJBQTlDRCxLQUE4QztBQUFBLFVBQTlDQSxLQUE4QywrQkFBdENWLEdBQUdlLHVCQUFtQztBQUFBLFVBQVZKLE9BQVUsU0FBVkEsT0FBVTs7QUFDeEQsVUFBTUssU0FBUyxLQUFLWCxFQUFMLENBQVFZLGNBQVIsQ0FBdUIsS0FBS0gsTUFBNUIsRUFBb0NKLEtBQXBDLEVBQTJDQyxPQUEzQyxDQUFmO0FBQ0E7QUFDQSxjQUFRSyxNQUFSO0FBQ0EsYUFBS2hCLEdBQUdrQixnQkFBUjtBQUNFO0FBQ0E7QUFDRixhQUFLbEIsR0FBR21CLGVBQVI7QUFDRTtBQUNBO0FBQ0YsYUFBS25CLEdBQUdvQixtQkFBUjtBQUNFO0FBQ0E7QUFDRixhQUFLcEIsR0FBR3FCLFdBQVI7QUFDRTtBQUNBO0FBQ0Y7QUFiQTtBQWVBLGFBQU9MLE1BQVA7QUFDRDs7OzZCQUVRO0FBQ1BiLG1CQUFhbUIsV0FBYixDQUF5QixJQUF6QjtBQUNEOzs7aUNBRVk7QUFDWCxhQUFPLEtBQUtDLFlBQUwsQ0FBa0J2QixHQUFHd0IsV0FBckIsTUFBc0N4QixHQUFHeUIsUUFBaEQ7QUFDRDs7QUFFRDs7Ozt3Q0FDb0I7QUFDbEIsYUFBTyxLQUFLQyxVQUFMLEVBQVA7QUFDRDs7O2dDQUVXO0FBQ1YsYUFBTyxLQUFLQSxVQUFMLEVBQVA7QUFDRDs7O2lDQUVZQyxLLEVBQU87QUFDbEIsYUFBTyxLQUFLdEIsRUFBTCxDQUFRdUIsZ0JBQVIsQ0FBeUIsS0FBS2QsTUFBOUIsRUFBc0NhLEtBQXRDLENBQVA7QUFDRDs7QUFFRDs7OztvQ0FFZ0I7QUFDZCxhQUFPLEtBQUt0QixFQUFMLENBQVF3QixTQUFSLENBQWtCN0IsR0FBRzhCLDBCQUFyQixFQUFpRCxDQUFqRCxDQUFQO0FBQ0Q7OztvQ0FFZTtBQUNkM0IsbUJBQWE0QixXQUFiLENBQXlCLElBQXpCO0FBQ0EsV0FBSzFCLEVBQUwsQ0FBUTJCLFVBQVIsQ0FBbUIsS0FBS2xCLE1BQXhCO0FBQ0Q7Ozs7RUFyRm9DWixROztlQUFsQkUsUyIsImZpbGUiOiJmZW5jZS1zeW5jLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdMIGZyb20gJy4vYXBpJztcbmltcG9ydCB7YXNzZXJ0V2ViR0wyQ29udGV4dH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCBxdWVyeU1hbmFnZXIgZnJvbSAnLi9oZWxwZXJzL3F1ZXJ5LW1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZW5jZVN5bmMgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnbCwgb3B0cykge1xuICAgIGFzc2VydFdlYkdMMkNvbnRleHQoZ2wpO1xuICAgIHN1cGVyKGdsLCBvcHRzKTtcbiAgICAvLyBxdWVyeSBtYW5hZ2VyIG5lZWRzIGEgcHJvbWlzZSBmaWVsZFxuICAgIHRoaXMucHJvbWlzZSA9IG51bGw7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCBpcyBhIG5vLW9wIGluIHRoZSBhYnNlbmNlIG9mIHRoZSBwb3NzaWJpbGl0eSBvZlxuICAgKiBzeW5jaHJvbml6aW5nIGJldHdlZW4gbXVsdGlwbGUgR0wgY29udGV4dHMuXG4gICAqIFByZXZlbnQgY29tbWFuZHMgZnJvbSBiZWluZyBhZGRlZCB0byBHUFUgY29tbWFuZCBxdWV1ZS5cbiAgICogTm90ZTogY29tbWFuZHMgY2FuIHN0aWxsIGJlIGJ1ZmZlcmVkIGluIGRyaXZlci5cbiAgICpcbiAgICogQHBhcmFtIHtHTGJpdGZpZWxkfSBmbGFnc1xuICAgKiBAcGFyYW0ge0dMaW50NjR9IHRpbWVvdXRcbiAgICogQHJldHVybiB7U3luY30gc3RhdHVzXG4gICAqL1xuICB3YWl0KHtmbGFncyA9IDAsIHRpbWVvdXQgPSBHTC5USU1FT1VUX0lHTk9SRUR9ID0ge30pIHtcbiAgICB0aGlzLmdsLndhaXRTeW5jKHRoaXMuaGFuZGxlLCBmbGFncywgdGltZW91dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQmxvY2sgYWxsIENQVSBvcGVyYXRpb25zIHVudGlsIGZlbmNlIGlzIHNpZ25hbGxlZFxuICAgKiBAcGFyYW0ge0dMYml0ZmllbGR9IGZsYWdzXG4gICAqIEBwYXJhbSB7R0xpbnQ2NH0gdGltZW91dFxuICAgKiBAcmV0dXJuIHtHTGVudW19IHJlc3VsdFxuICAgKi9cbiAgY2xpZW50V2FpdCh7ZmxhZ3MgPSBHTC5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwgdGltZW91dH0pIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdsLmNsaWVudFdhaXRTeW5jKHRoaXMuaGFuZGxlLCBmbGFncywgdGltZW91dCk7XG4gICAgLy8gVE9ETyAtIG1hcCB0byBib29sZWFuP1xuICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgY2FzZSBHTC5BTFJFQURZX1NJR05BTEVEOlxuICAgICAgLy8gSW5kaWNhdGVzIHRoYXQgc3luYyBvYmplY3Qgd2FzIHNpZ25hbGVkIHdoZW4gdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgR0wuVElNRU9VVF9FWFBJUkVEOlxuICAgICAgLy8gSW5kaWNhdGVzIHRoYXQgdGltZW91dCB0aW1lIHBhc3NlZCwgc3luYyBvYmplY3QgZGlkIG5vdCBiZWNvbWUgc2lnbmFsZWRcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgR0wuQ09ORElUSU9OX1NBVElTRklFRDpcbiAgICAgIC8vIEluZGljYXRlcyB0aGF0IHN5bmMgb2JqZWN0IHdhcyBzaWduYWxlZCBiZWZvcmUgdGltZW91dCBleHBpcmVkLlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBHTC5XQUlUX0ZBSUxFRDpcbiAgICAgIC8vIEluZGljYXRlcyB0aGF0IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHF1ZXJ5TWFuYWdlci5jYW5jZWxRdWVyeSh0aGlzKTtcbiAgfVxuXG4gIGlzU2lnbmFsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFyYW1ldGVyKEdMLlNZTkNfU1RBVFVTKSA9PT0gR0wuU0lHTkFMRUQ7XG4gIH1cblxuICAvLyBUT0RPIC0gUXVlcnkgbWFuYWdlciBuZWVkcyB0aGVzZT9cbiAgaXNSZXN1bHRBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaWduYWxlZCgpO1xuICB9XG5cbiAgZ2V0UmVzdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmlzU2lnbmFsZWQoKTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcihwbmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdsLmdldFN5bmNQYXJhbWV0ZXIodGhpcy5oYW5kbGUsIHBuYW1lKTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIF9jcmVhdGVIYW5kbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZmVuY2VTeW5jKEdMLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLCAwKTtcbiAgfVxuXG4gIF9kZWxldGVIYW5kbGUoKSB7XG4gICAgcXVlcnlNYW5hZ2VyLmRlbGV0ZVF1ZXJ5KHRoaXMpO1xuICAgIHRoaXMuZ2wuZGVsZXRlU3luYyh0aGlzLmhhbmRsZSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clear;
/* harmony export (immutable) */ __webpack_exports__["b"] = readPixels;
/* unused harmony export readPixelsToBuffer */
/* unused harmony export blitFramebuffer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* eslint-disable */
// TODO - generic draw call
// One of the good things about GL is that there are so many ways to draw things





var ERR_ARGUMENTS = 'clear called without arguments';

/**
 * Optionally clears depth, color and stencil buffers
 * @param {WebGLRenderingContext} gl - context
 * @param {Object} options
 */
function clear(gl) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      color = _ref.color,
      depth = _ref.depth,
      stencil = _ref.stencil;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["g" /* glContextWithState */])(gl, { color: color, depth: depth, stencil: stencil }, function () {
    var clearFlags = (color ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COLOR_BUFFER_BIT : 0) | (depth ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COLOR_BUFFER_BIT : 0) | (stencil ? gl.DEPTH_BUFFER_BIT : 0);
    __WEBPACK_IMPORTED_MODULE_2_assert___default()(clearFlags, ERR_ARGUMENTS);
    gl.clear(clearFlags);
  });
}

/**
 * Read pixels from a target
 *
 * Will read from the currently bound framebuffer, or the currently bound
 *  drawing buffer - if context has been created with
 *  preserveDrawingBuffers
 *
 * @param {WebGLRenderingContext} gl
 * @param {Object} opts
 * @param {Number} opts.x - leftmost coord to be read
 * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)
 * @param {Number} opts.width=1 - width of area to be read
 * @param {Number} opts.height=1 - height of area to be read
 * @param {Number} opts.sourceHeight= - target height, implies top left coords
 * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array
 * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA
 *
 * @return {ArrayView} - types array, either passed in or autoallocated
 */
function readPixels(gl, _ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      _ref2$width = _ref2.width,
      width = _ref2$width === undefined ? 1 : _ref2$width,
      _ref2$height = _ref2.height,
      height = _ref2$height === undefined ? 1 : _ref2$height,
      data = _ref2.data,
      _ref2$dataOffset = _ref2.dataOffset,
      dataOffset = _ref2$dataOffset === undefined ? 0 : _ref2$dataOffset,
      _ref2$type = _ref2.type,
      type = _ref2$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref2$type,
      sourceHeight = _ref2.sourceHeight,
      _ref2$format = _ref2.format,
      format = _ref2$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref2$format;

  // Read color in the central pixel, to be mapped with picking colors
  data = data || new Uint8Array(4 * width * height);
  // If source height is specified, a top left coordinate system is used
  y = sourceHeight ? sourceHeight - y : y;
  if (dataOffset) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);
    gl.readPixels(x, y, width, height, format, type, data, dataOffset);
  } else {
    gl.readPixels(x, y, width, height, format, type, data);
  }
  return data;
}

/**
 * Read pixels directly into webgl buffer
 * NOTE: WebGL2 only
 *
 * @param {WebGLRenderingContext} gl
 * @param {Object} options
 * @return {WebGLBuffer} the passed in buffer
 */
function readPixelsToBuffer(gl, _ref3) {
  var x = _ref3.x,
      y = _ref3.y,
      _ref3$width = _ref3.width,
      width = _ref3$width === undefined ? 1 : _ref3$width,
      _ref3$height = _ref3.height,
      height = _ref3$height === undefined ? 1 : _ref3$height,
      buffer = _ref3.buffer,
      _ref3$dataOffset = _ref3.dataOffset,
      dataOffset = _ref3$dataOffset === undefined ? 0 : _ref3$dataOffset,
      _ref3$type = _ref3.type,
      type = _ref3$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref3$type,
      sourceHeight = _ref3.sourceHeight,
      _ref3$format = _ref3.format,
      format = _ref3$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref3$format;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);

  // If source height is specified, a top left coordinate system is used
  y = sourceHeight ? sourceHeight - y : y;

  gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_PACK_BUFFER, buffer.handle);

  gl.readPixels(x, y, width, height, format, type, dataOffset);

  gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_PACK_BUFFER, null);

  return buffer;
}

/*
* @param {} opt.filter
 */
function blitFramebuffer(gl, _ref4) {
  var _ref4$source = _slicedToArray(_ref4.source, 4),
      sourceX = _ref4$source[0],
      sourceY = _ref4$source[1],
      sourceWidth = _ref4$source[2],
      sourceHeight = _ref4$source[3],
      _ref4$dest = _slicedToArray(_ref4.dest, 4),
      destX = _ref4$dest[0],
      destY = _ref4$dest[1],
      destWidth = _ref4$dest[2],
      destHeight = _ref4$dest[3],
      _ref4$mask = _ref4.mask,
      mask = _ref4$mask === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].DEPTH_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].STENCIL_BUFFER_BIT : _ref4$mask,
      _ref4$filter = _ref4.filter,
      filter = _ref4$filter === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].LINEAR : _ref4$filter;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9mdW5jdGlvbnMuanMiXSwibmFtZXMiOlsiR0wiLCJnbEdldCIsImFzc2VydFdlYkdMQ29udGV4dCIsImFzc2VydFdlYkdMMkNvbnRleHQiLCJnbENvbnRleHRXaXRoU3RhdGUiLCJhc3NlcnQiLCJFUlJfQVJHVU1FTlRTIiwiY2xlYXIiLCJnbCIsImNvbG9yIiwiZGVwdGgiLCJzdGVuY2lsIiwiY2xlYXJGbGFncyIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwicmVhZFBpeGVscyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJkYXRhIiwiZGF0YU9mZnNldCIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwic291cmNlSGVpZ2h0IiwiZm9ybWF0IiwiUkdCQSIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzVG9CdWZmZXIiLCJidWZmZXIiLCJiaW5kQnVmZmVyIiwiUElYRUxfUEFDS19CVUZGRVIiLCJoYW5kbGUiLCJibGl0RnJhbWVidWZmZXIiLCJzb3VyY2UiLCJzb3VyY2VYIiwic291cmNlWSIsInNvdXJjZVdpZHRoIiwiZGVzdCIsImRlc3RYIiwiZGVzdFkiLCJkZXN0V2lkdGgiLCJkZXN0SGVpZ2h0IiwibWFzayIsIlNURU5DSUxfQlVGRkVSX0JJVCIsImZpbHRlciIsIkxJTkVBUiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxPQUFPQSxFQUFQLElBQVlDLEtBQVosUUFBd0IsT0FBeEI7QUFDQSxTQUFRQyxrQkFBUixFQUE0QkMsbUJBQTVCLFFBQXNELFdBQXREO0FBQ0EsU0FBUUMsa0JBQVIsUUFBaUMsV0FBakM7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGdCQUFnQixnQ0FBdEI7O0FBRUE7Ozs7O0FBS0EsT0FBTyxTQUFTQyxLQUFULENBQWVDLEVBQWYsRUFJQztBQUFBLGlGQUFKLEVBQUk7QUFBQSxNQUhOQyxLQUdNLFFBSE5BLEtBR007QUFBQSxN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OztBQUVBYixLQUFHc0IsVUFBSCxDQUFjOUIsR0FBRytCLGlCQUFqQixFQUFvQyxJQUFwQzs7QUFFQSxTQUFPRixNQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLE9BQU8sU0FBU0ksZUFBVCxDQUF5QnpCLEVBQXpCLFNBS0o7QUFBQSwwQ0FKRDBCLE1BSUM7QUFBQSxNQUpRQyxPQUlSO0FBQUEsTUFKaUJDLE9BSWpCO0FBQUEsTUFKMEJDLFdBSTFCO0FBQUEsTUFKdUNiLFlBSXZDO0FBQUEsd0NBSERjLElBR0M7QUFBQSxNQUhNQyxLQUdOO0FBQUEsTUFIYUMsS0FHYjtBQUFBLE1BSG9CQyxTQUdwQjtBQUFBLE1BSCtCQyxVQUcvQjtBQUFBLHlCQUZEQyxJQUVDO0FBQUEsTUFGREEsSUFFQyw4QkFGTTNDLEdBQUdhLGdCQUFILEdBQXNCYixHQUFHYyxnQkFBekIsR0FBNENkLEdBQUc0QyxrQkFFckQ7QUFBQSwyQkFEREMsTUFDQztBQUFBLE1BRERBLE1BQ0MsZ0NBRFE3QyxHQUFHOEMsTUFDWDtBQUNGIiwiZmlsZSI6ImZ1bmN0aW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBUT0RPIC0gZ2VuZXJpYyBkcmF3IGNhbGxcbi8vIE9uZSBvZiB0aGUgZ29vZCB0aGluZ3MgYWJvdXQgR0wgaXMgdGhhdCB0aGVyZSBhcmUgc28gbWFueSB3YXlzIHRvIGRyYXcgdGhpbmdzXG5pbXBvcnQgR0wsIHtnbEdldH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthc3NlcnRXZWJHTENvbnRleHQsIGFzc2VydFdlYkdMMkNvbnRleHR9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQge2dsQ29udGV4dFdpdGhTdGF0ZX0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgRVJSX0FSR1VNRU5UUyA9ICdjbGVhciBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMnO1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgY2xlYXJzIGRlcHRoLCBjb2xvciBhbmQgc3RlbmNpbCBidWZmZXJzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoZ2wsIHtcbiAgY29sb3IsXG4gIGRlcHRoLFxuICBzdGVuY2lsXG59ID0ge30pIHtcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7Y29sb3IsIGRlcHRoLCBzdGVuY2lsfSwgKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFyRmxhZ3MgPVxuICAgICAgKGNvbG9yID8gR0wuQ09MT1JfQlVGRkVSX0JJVCA6IDApIHxcbiAgICAgIChkZXB0aCA/IEdMLkNPTE9SX0JVRkZFUl9CSVQgOiAwKSB8XG4gICAgICAoc3RlbmNpbCA/IGdsLkRFUFRIX0JVRkZFUl9CSVQgOiAwKTtcbiAgICBhc3NlcnQoY2xlYXJGbGFncywgRVJSX0FSR1VNRU5UUyk7XG4gICAgZ2wuY2xlYXIoY2xlYXJGbGFncyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlYWQgcGl4ZWxzIGZyb20gYSB0YXJnZXRcbiAqXG4gKiBXaWxsIHJlYWQgZnJvbSB0aGUgY3VycmVudGx5IGJvdW5kIGZyYW1lYnVmZmVyLCBvciB0aGUgY3VycmVudGx5IGJvdW5kXG4gKiAgZHJhd2luZyBidWZmZXIgLSBpZiBjb250ZXh0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aFxuICogIHByZXNlcnZlRHJhd2luZ0J1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0cy54IC0gbGVmdG1vc3QgY29vcmQgdG8gYmUgcmVhZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMueSAtIGJvdHRvbW1vc3QgKG9yIHRvcG1vc3QgaWYgc291cmNlSGVpZ2h0IHN1cHBsaWVkKVxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMud2lkdGg9MSAtIHdpZHRoIG9mIGFyZWEgdG8gYmUgcmVhZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMuaGVpZ2h0PTEgLSBoZWlnaHQgb2YgYXJlYSB0byBiZSByZWFkXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0cy5zb3VyY2VIZWlnaHQ9IC0gdGFyZ2V0IGhlaWdodCwgaW1wbGllcyB0b3AgbGVmdCBjb29yZHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLmRhdGFPZmZzZXQ9MCAtIFdlYkdMMiBvbmx5IC0gb2Zmc2V0IGludG8gZGF0YSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMuZm9ybWF0PUdMLlJCR0EgLSBDYW4gYmUgc2V0IHRvIEdMLlJHQiBvciBHTC5BTFBIQVxuICpcbiAqIEByZXR1cm4ge0FycmF5Vmlld30gLSB0eXBlcyBhcnJheSwgZWl0aGVyIHBhc3NlZCBpbiBvciBhdXRvYWxsb2NhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkUGl4ZWxzKGdsLCB7XG4gIHgsXG4gIHksXG4gIHdpZHRoID0gMSxcbiAgaGVpZ2h0ID0gMSxcbiAgZGF0YSxcbiAgZGF0YU9mZnNldCA9IDAsXG4gIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFLFxuICBzb3VyY2VIZWlnaHQsXG4gIGZvcm1hdCA9IEdMLlJHQkFcbn0pIHtcbiAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgZGF0YSA9IGRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgLy8gSWYgc291cmNlIGhlaWdodCBpcyBzcGVjaWZpZWQsIGEgdG9wIGxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgdXNlZFxuICB5ID0gc291cmNlSGVpZ2h0ID8gc291cmNlSGVpZ2h0IC0geSA6IHk7XG4gIGlmIChkYXRhT2Zmc2V0KSB7XG4gICAgYXNzZXJ0V2ViR0wyQ29udGV4dChnbCk7XG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIGRhdGEsIGRhdGFPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWFkIHBpeGVscyBkaXJlY3RseSBpbnRvIHdlYmdsIGJ1ZmZlclxuICogTk9URTogV2ViR0wyIG9ubHlcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtXZWJHTEJ1ZmZlcn0gdGhlIHBhc3NlZCBpbiBidWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRQaXhlbHNUb0J1ZmZlcihnbCwge1xuICB4LFxuICB5LFxuICB3aWR0aCA9IDEsXG4gIGhlaWdodCA9IDEsXG4gIGJ1ZmZlcixcbiAgZGF0YU9mZnNldCA9IDAsXG4gIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFLFxuICBzb3VyY2VIZWlnaHQsXG4gIGZvcm1hdCA9IEdMLlJHQkFcbn0pIHtcbiAgYXNzZXJ0V2ViR0wyQ29udGV4dChnbCk7XG5cbiAgLy8gSWYgc291cmNlIGhlaWdodCBpcyBzcGVjaWZpZWQsIGEgdG9wIGxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgdXNlZFxuICB5ID0gc291cmNlSGVpZ2h0ID8gc291cmNlSGVpZ2h0IC0geSA6IHk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihHTC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyLmhhbmRsZSk7XG5cbiAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIGRhdGFPZmZzZXQpO1xuXG4gIGdsLmJpbmRCdWZmZXIoR0wuUElYRUxfUEFDS19CVUZGRVIsIG51bGwpO1xuXG4gIHJldHVybiBidWZmZXI7XG59XG5cbi8qXG4qIEBwYXJhbSB7fSBvcHQuZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibGl0RnJhbWVidWZmZXIoZ2wsIHtcbiAgc291cmNlOiBbc291cmNlWCwgc291cmNlWSwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodF0sXG4gIGRlc3Q6IFtkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodF0sXG4gIG1hc2sgPSBHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCB8IEdMLlNURU5DSUxfQlVGRkVSX0JJVCxcbiAgZmlsdGVyID0gR0wuTElORUFSXG59KSB7XG59XG4iXX0=

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resource__ = __webpack_require__(13);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-inline-comments */




var Sampler = function (_Resource) {
  _inherits(Sampler, _Resource);

  _createClass(Sampler, null, [{
    key: 'isSupported',
    value: function isSupported(gl) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl);
    }
  }, {
    key: 'isHandle',
    value: function isHandle(handle) {
      return this.gl.isSampler(this.handle);
    }
  }]);

  function Sampler(gl, opts) {
    _classCallCheck(this, Sampler);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);

    var _this = _possibleConstructorReturn(this, (Sampler.__proto__ || Object.getPrototypeOf(Sampler)).call(this, gl, opts));

    Object.seal(_this);
    return _this;
  }

  /**
   * Bind to the same texture unit as a texture to control sampling for that texture
   * @param {GLuint} unit - texture unit index
   * @return {Sampler} - returns self to enable chaining
   */


  _createClass(Sampler, [{
    key: 'bind',
    value: function bind(unit) {
      this.gl.bindSampler(unit, this.handle);
      return this;
    }

    /**
     * Bind to the same texture unit as a texture to control sampling for that texture
     * @param {GLuint} unit - texture unit index
     * @return {Sampler} - returns self to enable chaining
     */

  }, {
    key: 'unbind',
    value: function unbind(unit) {
      this.gl.bindSampler(unit, null);
      return this;
    }

    // RESOURCE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createSampler();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteSampler(this.handle);
    }
  }, {
    key: '_getParameter',
    value: function _getParameter(pname) {
      this.gl.bindSampler(this.target, this.handle);
      var value = this.gl.getSamplerParameter(this.target, pname);
      this.gl.bindSampler(this.target, null);
      return value;
    }
  }, {
    key: '_setParameter',
    value: function _setParameter(pname, param) {
      this.gl.bindSampler(this.target, this.handle);
      // Apparently there are some conversion integer/float rules that made
      // the WebGL committe expose two parameter setting functions in JavaScript.
      // For now, pick the float version for parameters specified as GLfloat.
      switch (pname) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MIN_LOD:
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_MAX_LOD:
          this.gl.samplerParameterf(this.handle, pname, param);
          break;
        default:
          this.gl.samplerParameteri(this.handle, pname, param);
          break;
      }
      this.gl.bindSampler(this.target, null);
      return this;
    }
  }]);

  return Sampler;
}(__WEBPACK_IMPORTED_MODULE_2__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Sampler);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9zYW1wbGVyLmpzIl0sIm5hbWVzIjpbIkdMIiwiaXNXZWJHTDJDb250ZXh0IiwiYXNzZXJ0V2ViR0wyQ29udGV4dCIsIlJlc291cmNlIiwiU2FtcGxlciIsImdsIiwiaGFuZGxlIiwiaXNTYW1wbGVyIiwib3B0cyIsIk9iamVjdCIsInNlYWwiLCJ1bml0IiwiYmluZFNhbXBsZXIiLCJjcmVhdGVTYW1wbGVyIiwiZGVsZXRlU2FtcGxlciIsInBuYW1lIiwidGFyZ2V0IiwidmFsdWUiLCJnZXRTYW1wbGVyUGFyYW1ldGVyIiwicGFyYW0iLCJURVhUVVJFX01JTl9MT0QiLCJURVhUVVJFX01BWF9MT0QiLCJzYW1wbGVyUGFyYW1ldGVyZiIsInNhbXBsZXJQYXJhbWV0ZXJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsT0FBT0EsRUFBUCxNQUFlLE9BQWY7QUFDQSxTQUFRQyxlQUFSLEVBQXlCQyxtQkFBekIsUUFBbUQsV0FBbkQ7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCOztJQUVxQkMsTzs7Ozs7Z0NBRUFDLEUsRUFBSTtBQUNyQixhQUFPSixnQkFBZ0JJLEVBQWhCLENBQVA7QUFDRDs7OzZCQUVlQyxNLEVBQVE7QUFDdEIsYUFBTyxLQUFLRCxFQUFMLENBQVFFLFNBQVIsQ0FBa0IsS0FBS0QsTUFBdkIsQ0FBUDtBQUNEOzs7QUFFRCxtQkFBWUQsRUFBWixFQUFnQkcsSUFBaEIsRUFBc0I7QUFBQTs7QUFDcEJOLHdCQUFvQkcsRUFBcEI7O0FBRG9CLGtIQUVkQSxFQUZjLEVBRVZHLElBRlU7O0FBR3BCQyxXQUFPQyxJQUFQO0FBSG9CO0FBSXJCOztBQUVEOzs7Ozs7Ozs7eUJBS0tDLEksRUFBTTtBQUNULFdBQUtOLEVBQUwsQ0FBUU8sV0FBUixDQUFvQkQsSUFBcEIsRUFBMEIsS0FBS0wsTUFBL0I7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS09LLEksRUFBTTtBQUNYLFdBQUtOLEVBQUwsQ0FBUU8sV0FBUixDQUFvQkQsSUFBcEIsRUFBMEIsSUFBMUI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7OztvQ0FFZ0I7QUFDZCxhQUFPLEtBQUtOLEVBQUwsQ0FBUVEsYUFBUixFQUFQO0FBQ0Q7OztvQ0FFZTtBQUNkLFdBQUtSLEVBQUwsQ0FBUVMsYUFBUixDQUFzQixLQUFLUixNQUEzQjtBQUNEOzs7a0NBRWFTLEssRUFBTztBQUNuQixXQUFLVixFQUFMLENBQVFPLFdBQVIsQ0FBb0IsS0FBS0ksTUFBekIsRUFBaUMsS0FBS1YsTUFBdEM7QUFDQSxVQUFNVyxRQUFRLEtBQUtaLEVBQUwsQ0FBUWEsbUJBQVIsQ0FBNEIsS0FBS0YsTUFBakMsRUFBeUNELEtBQXpDLENBQWQ7QUFDQSxXQUFLVixFQUFMLENBQVFPLFdBQVIsQ0FBb0IsS0FBS0ksTUFBekIsRUFBaUMsSUFBakM7QUFDQSxhQUFPQyxLQUFQO0FBQ0Q7OztrQ0FFYUYsSyxFQUFPSSxLLEVBQU87QUFDMUIsV0FBS2QsRUFBTCxDQUFRTyxXQUFSLENBQW9CLEtBQUtJLE1BQXpCLEVBQWlDLEtBQUtWLE1BQXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBUVMsS0FBUjtBQUNBLGFBQUtmLEdBQUdvQixlQUFSO0FBQ0EsYUFBS3BCLEdBQUdxQixlQUFSO0FBQ0UsZUFBS2hCLEVBQUwsQ0FBUWlCLGlCQUFSLENBQTBCLEtBQUtoQixNQUEvQixFQUF1Q1MsS0FBdkMsRUFBOENJLEtBQTlDO0FBQ0E7QUFDRjtBQUNFLGVBQUtkLEVBQUwsQ0FBUWtCLGlCQUFSLENBQTBCLEtBQUtqQixNQUEvQixFQUF1Q1MsS0FBdkMsRUFBOENJLEtBQTlDO0FBQ0E7QUFQRjtBQVNBLFdBQUtkLEVBQUwsQ0FBUU8sV0FBUixDQUFvQixLQUFLSSxNQUF6QixFQUFpQyxJQUFqQztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7O0VBckVrQ2IsUTs7ZUFBaEJDLE8iLCJmaWxlIjoic2FtcGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWlubGluZS1jb21tZW50cyAqL1xuaW1wb3J0IEdMIGZyb20gJy4vYXBpJztcbmltcG9ydCB7aXNXZWJHTDJDb250ZXh0LCBhc3NlcnRXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcmVzb3VyY2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTYW1wbGVyIGV4dGVuZHMgUmVzb3VyY2Uge1xuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZChnbCkge1xuICAgIHJldHVybiBpc1dlYkdMMkNvbnRleHQoZ2wpO1xuICB9XG5cbiAgc3RhdGljIGlzSGFuZGxlKGhhbmRsZSkge1xuICAgIHJldHVybiB0aGlzLmdsLmlzU2FtcGxlcih0aGlzLmhhbmRsZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihnbCwgb3B0cykge1xuICAgIGFzc2VydFdlYkdMMkNvbnRleHQoZ2wpO1xuICAgIHN1cGVyKGdsLCBvcHRzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIHRvIHRoZSBzYW1lIHRleHR1cmUgdW5pdCBhcyBhIHRleHR1cmUgdG8gY29udHJvbCBzYW1wbGluZyBmb3IgdGhhdCB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7R0x1aW50fSB1bml0IC0gdGV4dHVyZSB1bml0IGluZGV4XG4gICAqIEByZXR1cm4ge1NhbXBsZXJ9IC0gcmV0dXJucyBzZWxmIHRvIGVuYWJsZSBjaGFpbmluZ1xuICAgKi9cbiAgYmluZCh1bml0KSB7XG4gICAgdGhpcy5nbC5iaW5kU2FtcGxlcih1bml0LCB0aGlzLmhhbmRsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQmluZCB0byB0aGUgc2FtZSB0ZXh0dXJlIHVuaXQgYXMgYSB0ZXh0dXJlIHRvIGNvbnRyb2wgc2FtcGxpbmcgZm9yIHRoYXQgdGV4dHVyZVxuICAgKiBAcGFyYW0ge0dMdWludH0gdW5pdCAtIHRleHR1cmUgdW5pdCBpbmRleFxuICAgKiBAcmV0dXJuIHtTYW1wbGVyfSAtIHJldHVybnMgc2VsZiB0byBlbmFibGUgY2hhaW5pbmdcbiAgICovXG4gIHVuYmluZCh1bml0KSB7XG4gICAgdGhpcy5nbC5iaW5kU2FtcGxlcih1bml0LCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJFU09VUkNFIE1FVEhPRFNcblxuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZVNhbXBsZXIoKTtcbiAgfVxuXG4gIF9kZWxldGVIYW5kbGUoKSB7XG4gICAgdGhpcy5nbC5kZWxldGVTYW1wbGVyKHRoaXMuaGFuZGxlKTtcbiAgfVxuXG4gIF9nZXRQYXJhbWV0ZXIocG5hbWUpIHtcbiAgICB0aGlzLmdsLmJpbmRTYW1wbGVyKHRoaXMudGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdsLmdldFNhbXBsZXJQYXJhbWV0ZXIodGhpcy50YXJnZXQsIHBuYW1lKTtcbiAgICB0aGlzLmdsLmJpbmRTYW1wbGVyKHRoaXMudGFyZ2V0LCBudWxsKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBfc2V0UGFyYW1ldGVyKHBuYW1lLCBwYXJhbSkge1xuICAgIHRoaXMuZ2wuYmluZFNhbXBsZXIodGhpcy50YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAvLyBBcHBhcmVudGx5IHRoZXJlIGFyZSBzb21lIGNvbnZlcnNpb24gaW50ZWdlci9mbG9hdCBydWxlcyB0aGF0IG1hZGVcbiAgICAvLyB0aGUgV2ViR0wgY29tbWl0dGUgZXhwb3NlIHR3byBwYXJhbWV0ZXIgc2V0dGluZyBmdW5jdGlvbnMgaW4gSmF2YVNjcmlwdC5cbiAgICAvLyBGb3Igbm93LCBwaWNrIHRoZSBmbG9hdCB2ZXJzaW9uIGZvciBwYXJhbWV0ZXJzIHNwZWNpZmllZCBhcyBHTGZsb2F0LlxuICAgIHN3aXRjaCAocG5hbWUpIHtcbiAgICBjYXNlIEdMLlRFWFRVUkVfTUlOX0xPRDpcbiAgICBjYXNlIEdMLlRFWFRVUkVfTUFYX0xPRDpcbiAgICAgIHRoaXMuZ2wuc2FtcGxlclBhcmFtZXRlcmYodGhpcy5oYW5kbGUsIHBuYW1lLCBwYXJhbSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5nbC5zYW1wbGVyUGFyYW1ldGVyaSh0aGlzLmhhbmRsZSwgcG5hbWUsIHBhcmFtKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmdsLmJpbmRTYW1wbGVyKHRoaXMudGFyZ2V0LCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG4iXX0=

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__texture__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



// import {withParameters} from './context';


var FACES = [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_POSITIVE_X, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_POSITIVE_Y, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_POSITIVE_Z, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_NEGATIVE_X, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_NEGATIVE_Y, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_NEGATIVE_Z];

var TextureCube = function (_Texture) {
  _inherits(TextureCube, _Texture);

  function TextureCube(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TextureCube);

    var _this = _possibleConstructorReturn(this, (TextureCube.__proto__ || Object.getPrototypeOf(TextureCube)).call(this, gl, Object.assign({}, opts, { target: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP })));

    _this.initialize(opts);
    Object.seal(_this);
    return _this;
  }

  /* eslint-disable max-len, max-statements */


  _createClass(TextureCube, [{
    key: 'initialize',
    value: function initialize() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$format = opts.format,
          format = _opts$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].RGBA : _opts$format,
          _opts$mipmaps = opts.mipmaps,
          mipmaps = _opts$mipmaps === undefined ? false : _opts$mipmaps;
      var _opts$width = opts.width,
          width = _opts$width === undefined ? 1 : _opts$width,
          _opts$height = opts.height,
          height = _opts$height === undefined ? 1 : _opts$height,
          _opts$type = opts.type,
          type = _opts$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].UNSIGNED_BYTE : _opts$type,
          dataFormat = opts.dataFormat;

      // Deduce width and height based on one of the faces

      var _deduceParameters = this._deduceParameters({ format: format, type: type, dataFormat: dataFormat });

      type = _deduceParameters.type;
      dataFormat = _deduceParameters.dataFormat;

      // Enforce cube
      var _deduceImageSize = this._deduceImageSize({
        data: opts[__WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP_POSITIVE_X], width: width, height: height
      });

      width = _deduceImageSize.width;
      height = _deduceImageSize.height;
      __WEBPACK_IMPORTED_MODULE_2_assert___default()(width === height);

      // Temporarily apply any pixel store settings and build textures
      // withParameters(this.gl, opts, () => {
      //   for (const face of CUBE_MAP_FACES) {
      //     this.setImageData({
      //       target: face,
      //       data: opts[face],
      //       width, height, format, type, dataFormat, border, mipmaps
      //     });
      //   }
      // });

      this.setCubeMapImageData(opts);

      // Called here so that GL.
      // TODO - should genMipmap() be called on the cubemap or on the faces?
      if (mipmaps) {
        this.generateMipmap(opts);
      }

      // Store opts for accessors
      this.opts = opts;
    }
  }, {
    key: 'subImage',
    value: function subImage(_ref) {
      var face = _ref.face,
          data = _ref.data,
          _ref$x = _ref.x,
          x = _ref$x === undefined ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === undefined ? 0 : _ref$y,
          _ref$mipmapLevel = _ref.mipmapLevel,
          mipmapLevel = _ref$mipmapLevel === undefined ? 0 : _ref$mipmapLevel;

      return this._subImage({ target: face, data: data, x: x, y: y, mipmapLevel: mipmapLevel });
    }

    /* eslint-disable max-statements, max-len */

  }, {
    key: 'setCubeMapImageData',
    value: function setCubeMapImageData(_ref2) {
      var width = _ref2.width,
          height = _ref2.height,
          pixels = _ref2.pixels,
          data = _ref2.data,
          _ref2$border = _ref2.border,
          border = _ref2$border === undefined ? 0 : _ref2$border,
          _ref2$format = _ref2.format,
          format = _ref2$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].RGBA : _ref2$format,
          _ref2$type = _ref2.type,
          type = _ref2$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].UNSIGNED_BYTE : _ref2$type,
          _ref2$generateMipmap = _ref2.generateMipmap,
          generateMipmap = _ref2$generateMipmap === undefined ? false : _ref2$generateMipmap;
      var gl = this.gl;

      pixels = pixels || data;
      this.bind();
      if (this.width || this.height) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = FACES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var face = _step.value;

            gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = FACES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _face = _step2.value;

            gl.texImage2D(_face, 0, format, format, type, pixels[_face]);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }, {
    key: 'bind',
    value: function bind() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          index = _ref3.index;

      if (index !== undefined) {
        this.gl.activeTexture(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE0 + index);
      }
      this.gl.bindTexture(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP, this.handle);
      return index;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      this.gl.bindTexture(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["b" /* GL */].TEXTURE_CUBE_MAP, null);
      return this;
    }
  }]);

  return TextureCube;
}(__WEBPACK_IMPORTED_MODULE_1__texture__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (TextureCube);


TextureCube.FACES = FACES;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90ZXh0dXJlLWN1YmUuanMiXSwibmFtZXMiOlsiR0wiLCJUZXh0dXJlIiwiYXNzZXJ0IiwiRkFDRVMiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1oiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1oiLCJUZXh0dXJlQ3ViZSIsImdsIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsIlRFWFRVUkVfQ1VCRV9NQVAiLCJpbml0aWFsaXplIiwic2VhbCIsImZvcm1hdCIsIlJHQkEiLCJtaXBtYXBzIiwid2lkdGgiLCJoZWlnaHQiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImRhdGFGb3JtYXQiLCJfZGVkdWNlUGFyYW1ldGVycyIsIl9kZWR1Y2VJbWFnZVNpemUiLCJkYXRhIiwic2V0Q3ViZU1hcEltYWdlRGF0YSIsImdlbmVyYXRlTWlwbWFwIiwiZmFjZSIsIngiLCJ5IiwibWlwbWFwTGV2ZWwiLCJfc3ViSW1hZ2UiLCJwaXhlbHMiLCJib3JkZXIiLCJiaW5kIiwidGV4SW1hZ2UyRCIsImluZGV4IiwidW5kZWZpbmVkIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwiYmluZFRleHR1cmUiLCJoYW5kbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsU0FBUUEsRUFBUixRQUFpQixnQkFBakI7QUFDQSxPQUFPQyxPQUFQLE1BQW9CLFdBQXBCO0FBQ0E7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLFFBQVEsQ0FDWkgsR0FBR0ksMkJBRFMsRUFFWkosR0FBR0ssMkJBRlMsRUFHWkwsR0FBR00sMkJBSFMsRUFJWk4sR0FBR08sMkJBSlMsRUFLWlAsR0FBR1EsMkJB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LENBQW9CN0MsR0FBR2dCLGdCQUF2QixFQUF5QyxLQUFLOEIsTUFBOUM7QUFDQSxhQUFPTCxLQUFQO0FBQ0Q7Ozs2QkFFUTtBQUNQLFdBQUs5QixFQUFMLENBQVFrQyxXQUFSLENBQW9CN0MsR0FBR2dCLGdCQUF2QixFQUF5QyxJQUF6QztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7O0VBN0ZzQ2YsTzs7ZUFBcEJTLFc7OztBQWdHckJBLFlBQVlQLEtBQVosR0FBb0JBLEtBQXBCIiwiZmlsZSI6InRleHR1cmUtY3ViZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7R0x9IGZyb20gJy4vZ2wtY29uc3RhbnRzJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG4vLyBpbXBvcnQge3dpdGhQYXJhbWV0ZXJzfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBGQUNFUyA9IFtcbiAgR0wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxuICBHTC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksXG4gIEdMLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWixcbiAgR0wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxuICBHTC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksXG4gIEdMLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZUN1YmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgY29uc3RydWN0b3IoZ2wsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKGdsLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7dGFyZ2V0OiBHTC5URVhUVVJFX0NVQkVfTUFQfSkpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHRzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIG1heC1zdGF0ZW1lbnRzICovXG4gIGluaXRpYWxpemUob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9ybWF0ID0gR0wuUkdCQSxcbiAgICAgIG1pcG1hcHMgPSBmYWxzZVxuICAgIH0gPSBvcHRzO1xuXG4gICAgbGV0IHtcbiAgICAgIHdpZHRoID0gMSxcbiAgICAgIGhlaWdodCA9IDEsXG4gICAgICB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICAgIGRhdGFGb3JtYXRcbiAgICB9ID0gb3B0cztcblxuICAgIC8vIERlZHVjZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIG9uZSBvZiB0aGUgZmFjZXNcbiAgICAoe3R5cGUsIGRhdGFGb3JtYXR9ID0gdGhpcy5fZGVkdWNlUGFyYW1ldGVycyh7Zm9ybWF0LCB0eXBlLCBkYXRhRm9ybWF0fSkpO1xuICAgICh7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9kZWR1Y2VJbWFnZVNpemUoe1xuICAgICAgZGF0YTogb3B0c1tHTC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1hdLCB3aWR0aCwgaGVpZ2h0XG4gICAgfSkpO1xuXG4gICAgLy8gRW5mb3JjZSBjdWJlXG4gICAgYXNzZXJ0KHdpZHRoID09PSBoZWlnaHQpO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkgYXBwbHkgYW55IHBpeGVsIHN0b3JlIHNldHRpbmdzIGFuZCBidWlsZCB0ZXh0dXJlc1xuICAgIC8vIHdpdGhQYXJhbWV0ZXJzKHRoaXMuZ2wsIG9wdHMsICgpID0+IHtcbiAgICAvLyAgIGZvciAoY29uc3QgZmFjZSBvZiBDVUJFX01BUF9GQUNFUykge1xuICAgIC8vICAgICB0aGlzLnNldEltYWdlRGF0YSh7XG4gICAgLy8gICAgICAgdGFyZ2V0OiBmYWNlLFxuICAgIC8vICAgICAgIGRhdGE6IG9wdHNbZmFjZV0sXG4gICAgLy8gICAgICAgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhRm9ybWF0LCBib3JkZXIsIG1pcG1hcHNcbiAgICAvLyAgICAgfSk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG5cbiAgICB0aGlzLnNldEN1YmVNYXBJbWFnZURhdGEob3B0cyk7XG5cbiAgICAvLyBDYWxsZWQgaGVyZSBzbyB0aGF0IEdMLlxuICAgIC8vIFRPRE8gLSBzaG91bGQgZ2VuTWlwbWFwKCkgYmUgY2FsbGVkIG9uIHRoZSBjdWJlbWFwIG9yIG9uIHRoZSBmYWNlcz9cbiAgICBpZiAobWlwbWFwcykge1xuICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcChvcHRzKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBvcHRzIGZvciBhY2Nlc3NvcnNcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICB9XG5cbiAgc3ViSW1hZ2Uoe2ZhY2UsIGRhdGEsIHggPSAwLCB5ID0gMCwgbWlwbWFwTGV2ZWwgPSAwfSkge1xuICAgIHJldHVybiB0aGlzLl9zdWJJbWFnZSh7dGFyZ2V0OiBmYWNlLCBkYXRhLCB4LCB5LCBtaXBtYXBMZXZlbH0pO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIG1heC1sZW4gKi9cbiAgc2V0Q3ViZU1hcEltYWdlRGF0YSh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBpeGVscyxcbiAgICBkYXRhLFxuICAgIGJvcmRlciA9IDAsXG4gICAgZm9ybWF0ID0gR0wuUkdCQSxcbiAgICB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICBnZW5lcmF0ZU1pcG1hcCA9IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBwaXhlbHMgPSBwaXhlbHMgfHwgZGF0YTtcbiAgICB0aGlzLmJpbmQoKTtcbiAgICBpZiAodGhpcy53aWR0aCB8fCB0aGlzLmhlaWdodCkge1xuICAgICAgZm9yIChjb25zdCBmYWNlIG9mIEZBQ0VTKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZmFjZSwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgcGl4ZWxzW2ZhY2VdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBmYWNlIG9mIEZBQ0VTKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZmFjZSwgMCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBpeGVsc1tmYWNlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmluZCh7aW5kZXh9ID0ge30pIHtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKEdMLlRFWFRVUkUwICsgaW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKEdMLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICB1bmJpbmQoKSB7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZShHTC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5UZXh0dXJlQ3ViZS5GQUNFUyA9IEZBQ0VTO1xuIl19

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// WebGL2 VertexArray Objects Helper




/* eslint-disable camelcase */
var OES_vertex_array_object = 'OES_vertex_array_object';

var ERR_NOT_SUPPORTED = 'VertexArrayObject: WebGL2 or OES_vertex_array_object required';

var VertexArrayObject = function (_Resource) {
  _inherits(VertexArrayObject, _Resource);

  _createClass(VertexArrayObject, null, [{
    key: 'isSupported',
    value: function isSupported(gl) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(gl) || gl.getExtension(OES_vertex_array_object);
    }
  }, {
    key: 'isHandle',
    value: function isHandle(gl, vertexArray) {
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(gl)) {
        return gl.isVertexArray(vertexArray);
      }
      var ext = gl.getExtension(OES_vertex_array_object);
      if (ext) {
        return ext.isVertexArrayOES(vertexArray);
      }
      return false;
    }

    // Create a VertexArrayObject

  }]);

  function VertexArrayObject(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, VertexArrayObject);

    __WEBPACK_IMPORTED_MODULE_2_assert___default()(VertexArrayObject.isSupported(gl), ERR_NOT_SUPPORTED);

    var _this = _possibleConstructorReturn(this, (VertexArrayObject.__proto__ || Object.getPrototypeOf(VertexArrayObject)).call(this, gl, opts));

    Object.seal(_this);
    return _this;
  }

  _createClass(VertexArrayObject, [{
    key: 'bind',
    value: function bind() {
      this._bindVertexArray(this.gl, this.handle);
      return this;
    }
  }, {
    key: 'unbind',
    value: function unbind() {
      this._bindVertexArray(this.gl, null);
      return this;
    }

    // RESOURCE IMPLEMENTATION

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(this.gl)) {
        return this.gl.createVertexArray();
      }
      var ext = this.gl.getExtension(OES_vertex_array_object);
      if (ext) {
        return ext.createVertexArrayOES();
      }
      return null;
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle(handle) {
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(this.gl)) {
        this.gl.deleteVertexArray(handle);
        return;
      }
      var ext = this.gl.getExtension(OES_vertex_array_object);
      if (ext) {
        ext.deleteVertexArrayOES(handle);
      }
    }

    // WebGL2 does not have any methods for querying vertex array objects

    // PRIVATE METHODS

  }, {
    key: '_bindVertexArray',
    value: function _bindVertexArray(gl, vertexArray) {
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(gl)) {
        gl.bindVertexArray(vertexArray);
      }
      var ext = gl.getExtension(OES_vertex_array_object);
      if (ext) {
        ext.bindVertexArrayOES(vertexArray);
      }
    }
  }]);

  return VertexArrayObject;
}(__WEBPACK_IMPORTED_MODULE_1__resource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (VertexArrayObject);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC92ZXJ0ZXgtYXJyYXktb2JqZWN0LmpzIl0sIm5hbWVzIjpbImlzV2ViR0wyQ29udGV4dCIsIlJlc291cmNlIiwiYXNzZXJ0IiwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3QiLCJFUlJfTk9UX1NVUFBPUlRFRCIsIlZlcnRleEFycmF5T2JqZWN0IiwiZ2wiLCJnZXRFeHRlbnNpb24iLCJ2ZXJ0ZXhBcnJheSIsImlzVmVydGV4QXJyYXkiLCJleHQiLCJpc1ZlcnRleEFycmF5T0VTIiwib3B0cyIsImlzU3VwcG9ydGVkIiwiT2JqZWN0Iiwic2VhbCIsIl9iaW5kVmVydGV4QXJyYXkiLCJoYW5kbGUiLCJjcmVhdGVWZXJ0ZXhBcnJheSIsImNyZWF0ZVZlcnRleEFycmF5T0VTIiwiZGVsZXRlVmVydGV4QXJyYXkiLCJkZWxldGVWZXJ0ZXhBcnJheU9FUyIsImJpbmRWZXJ0ZXhBcnJheSIsImJpbmRWZXJ0ZXhBcnJheU9FUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLFNBQVFBLGVBQVIsUUFBOEIsV0FBOUI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLFlBQXJCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTtBQUNBLElBQU1DLDBCQUEwQix5QkFBaEM7O0FBRUEsSUFBTUMsb0JBQW9CLCtEQUExQjs7SUFFcUJDLGlCOzs7OztnQ0FFQUMsRSxFQUFJO0FBQ3JCLGFBQU9OLGdCQUFnQk0sRUFBaEIsS0FBdUJBLEdBQUdDLFlBQUgsQ0FBZ0JKLHVCQUFoQixDQUE5QjtBQUNEOzs7NkJBRWVHLEUsRUFBSUUsVyxFQUFhO0FBQy9CLFVBQUlSLGdCQUFnQk0sRUFBaEIsQ0FBSixFQUF5QjtBQUN2QixlQUFPQSxHQUFHRyxhQUFILENBQWlCRCxXQUFqQixDQUFQO0FBQ0Q7QUFDRCxVQUFNRSxNQUFNSixHQUFHQyxZQUFILENBQWdCSix1QkFBaEIsQ0FBWjtBQUNBLFVBQUlPLEdBQUosRUFBUztBQUNQLGVBQU9BLElBQUlDLGdCQUFKLENBQXFCSCxXQUFyQixDQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7OztBQUNBLDZCQUFZRixFQUFaLEVBQTJCO0FBQUEsUUFBWE0sSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUN6QlYsV0FBT0csa0JBQWtCUSxXQUFsQixDQUE4QlAsRUFBOUIsQ0FBUCxFQUEwQ0YsaUJBQTFDOztBQUR5QixzSUFFbkJFLEVBRm1CLEVBRWZNLElBRmU7O0FBR3pCRSxXQUFPQyxJQUFQO0FBSHlCO0FBSTFCOzs7OzJCQUVNO0FBQ0wsV0FBS0MsZ0JBQUwsQ0FBc0IsS0FBS1YsRUFBM0IsRUFBK0IsS0FBS1csTUFBcEM7QUFDQSxhQUFPLElBQVA7QUFDRDs7OzZCQUVRO0FBQ1AsV0FBS0QsZ0JBQUwsQ0FBc0IsS0FBS1YsRUFBM0IsRUFBK0IsSUFBL0I7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7OztvQ0FFZ0I7QUFDZCxVQUFJTixnQkFBZ0IsS0FBS00sRUFBckIsQ0FBSixFQUE4QjtBQUM1QixlQUFPLEtBQUtBLEVBQUwsQ0FBUVksaUJBQVIsRUFBUDtBQUNEO0FBQ0QsVUFBTVIsTUFBTSxLQUFLSixFQUFMLENBQVFDLFlBQVIsQ0FBcUJKLHVCQUFyQixDQUFaO0FBQ0EsVUFBSU8sR0FBSixFQUFTO0FBQ1AsZUFBT0EsSUFBSVMsb0JBQUosRUFBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7OztrQ0FFYUYsTSxFQUFRO0FBQ3BCLFVBQUlqQixnQkFBZ0IsS0FBS00sRUFBckIsQ0FBSixFQUE4QjtBQUM1QixhQUFLQSxFQUFMLENBQVFjLGlCQUFSLENBQTBCSCxNQUExQjtBQUNBO0FBQ0Q7QUFDRCxVQUFNUCxNQUFNLEtBQUtKLEVBQUwsQ0FBUUMsWUFBUixDQUFxQkosdUJBQXJCLENBQVo7QUFDQSxVQUFJTyxHQUFKLEVBQVM7QUFDUEEsWUFBSVcsb0JBQUosQ0FBeUJKLE1BQXpCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7OztxQ0FFaUJYLEUsRUFBSUUsVyxFQUFhO0FBQ2hDLFVBQUlSLGdCQUFnQk0sRUFBaEIsQ0FBSixFQUF5QjtBQUN2QkEsV0FBR2dCLGVBQUgsQ0FBbUJkLFdBQW5CO0FBQ0Q7QUFDRCxVQUFNRSxNQUFNSixHQUFHQyxZQUFILENBQWdCSix1QkFBaEIsQ0FBWjtBQUNBLFVBQUlPLEdBQUosRUFBUztBQUNQQSxZQUFJYSxrQkFBSixDQUF1QmYsV0FBdkI7QUFDRDtBQUNGOzs7O0VBdEU0Q1AsUTs7ZUFBMUJJLGlCIiwiZmlsZSI6InZlcnRleC1hcnJheS1vYmplY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZWJHTDIgVmVydGV4QXJyYXkgT2JqZWN0cyBIZWxwZXJcbmltcG9ydCB7aXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcmVzb3VyY2UnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmNvbnN0IE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0ID0gJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JztcblxuY29uc3QgRVJSX05PVF9TVVBQT1JURUQgPSAnVmVydGV4QXJyYXlPYmplY3Q6IFdlYkdMMiBvciBPRVNfdmVydGV4X2FycmF5X29iamVjdCByZXF1aXJlZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleEFycmF5T2JqZWN0IGV4dGVuZHMgUmVzb3VyY2Uge1xuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZChnbCkge1xuICAgIHJldHVybiBpc1dlYkdMMkNvbnRleHQoZ2wpIHx8IGdsLmdldEV4dGVuc2lvbihPRVNfdmVydGV4X2FycmF5X29iamVjdCk7XG4gIH1cblxuICBzdGF0aWMgaXNIYW5kbGUoZ2wsIHZlcnRleEFycmF5KSB7XG4gICAgaWYgKGlzV2ViR0wyQ29udGV4dChnbCkpIHtcbiAgICAgIHJldHVybiBnbC5pc1ZlcnRleEFycmF5KHZlcnRleEFycmF5KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0KTtcbiAgICBpZiAoZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmlzVmVydGV4QXJyYXlPRVModmVydGV4QXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBWZXJ0ZXhBcnJheU9iamVjdFxuICBjb25zdHJ1Y3RvcihnbCwgb3B0cyA9IHt9KSB7XG4gICAgYXNzZXJ0KFZlcnRleEFycmF5T2JqZWN0LmlzU3VwcG9ydGVkKGdsKSwgRVJSX05PVF9TVVBQT1JURUQpO1xuICAgIHN1cGVyKGdsLCBvcHRzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgdGhpcy5fYmluZFZlcnRleEFycmF5KHRoaXMuZ2wsIHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVuYmluZCgpIHtcbiAgICB0aGlzLl9iaW5kVmVydGV4QXJyYXkodGhpcy5nbCwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSRVNPVVJDRSBJTVBMRU1FTlRBVElPTlxuXG4gIF9jcmVhdGVIYW5kbGUoKSB7XG4gICAgaWYgKGlzV2ViR0wyQ29udGV4dCh0aGlzLmdsKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oT0VTX3ZlcnRleF9hcnJheV9vYmplY3QpO1xuICAgIGlmIChleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfZGVsZXRlSGFuZGxlKGhhbmRsZSkge1xuICAgIGlmIChpc1dlYkdMMkNvbnRleHQodGhpcy5nbCkpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlVmVydGV4QXJyYXkoaGFuZGxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oT0VTX3ZlcnRleF9hcnJheV9vYmplY3QpO1xuICAgIGlmIChleHQpIHtcbiAgICAgIGV4dC5kZWxldGVWZXJ0ZXhBcnJheU9FUyhoYW5kbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlYkdMMiBkb2VzIG5vdCBoYXZlIGFueSBtZXRob2RzIGZvciBxdWVyeWluZyB2ZXJ0ZXggYXJyYXkgb2JqZWN0c1xuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIF9iaW5kVmVydGV4QXJyYXkoZ2wsIHZlcnRleEFycmF5KSB7XG4gICAgaWYgKGlzV2ViR0wyQ29udGV4dChnbCkpIHtcbiAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2ZXJ0ZXhBcnJheSk7XG4gICAgfVxuICAgIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihPRVNfdmVydGV4X2FycmF5X29iamVjdCk7XG4gICAgaWYgKGV4dCkge1xuICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2ZXJ0ZXhBcnJheSk7XG4gICAgfVxuICB9XG59XG4iXX0=

/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["getMaxAttributes"] = getMaxAttributes;
/* harmony export (immutable) */ __webpack_exports__["hasDivisor"] = hasDivisor;
/* harmony export (immutable) */ __webpack_exports__["isEnabled"] = isEnabled;
/* harmony export (immutable) */ __webpack_exports__["getBuffer"] = getBuffer;
/* harmony export (immutable) */ __webpack_exports__["getGeneric"] = getGeneric;
/* harmony export (immutable) */ __webpack_exports__["getSize"] = getSize;
/* harmony export (immutable) */ __webpack_exports__["getType"] = getType;
/* harmony export (immutable) */ __webpack_exports__["isNormalized"] = isNormalized;
/* harmony export (immutable) */ __webpack_exports__["isInteger"] = isInteger;
/* harmony export (immutable) */ __webpack_exports__["getStride"] = getStride;
/* harmony export (immutable) */ __webpack_exports__["getOffset"] = getOffset;
/* harmony export (immutable) */ __webpack_exports__["enable"] = enable;
/* harmony export (immutable) */ __webpack_exports__["disable"] = disable;
/* harmony export (immutable) */ __webpack_exports__["setDivisor"] = setDivisor;
/* harmony export (immutable) */ __webpack_exports__["getDivisor"] = getDivisor;
/* harmony export (immutable) */ __webpack_exports__["setBuffer"] = setBuffer;
/* harmony export (immutable) */ __webpack_exports__["setGeneric"] = setGeneric;
/* harmony export (immutable) */ __webpack_exports__["setGenericValues"] = setGenericValues;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assert__);
/* eslint-disable dot-notation*/





/**
 * Methods for manipulating the vertex attributes array, which is where
 * vertex data is staged for shader execution.
 *
 * Vertex attributes are stored in "arrays" with indices from 0 and up.
 * During shader execution, these indices (or 'locations') are matched to
 * the indices assigned to shader attributes during WebGLProgram linking.
 *
 * Note: The global state contains an implicit vertex attribute array which
 * the methods in this class manipulate by default. It is also possible to
 * create and bind a VertexArrayObject to manage multiple arrays.
 *
 * Each vertex attribute has these properties:
 * - Can be enabled or disabled (Only enable attrs actually used by a program)
 * - Has an instance `divisor` (usually 1 or 0 to enable/disable instancing)
 * - Have a size (1-4 values per vertex)
 * - Has a value or values that is accessible in shaders
 *
 * Attribute values are either
 * - Generic: a constant value for all vertices/instances, or
 * - Bound to a WebGLBuffer with unique values for each vertex/instance
 *
 * When binding to a WebGLBuffer it is necessary to specify the layout of
 * data in the buffer:
 * - size (1-4 values per vertex)
 * - data type (e.g. gl.FLOAT)
 * - stride, offset, and integer normalization policy can also be specified
 *
 * Note: All methods in this class take a `location` index to specify which
 * vertex attribute in the array they are operating on.
 *
 * Note: Attribute 0 can sometimes be treated specially by the driver,
 * to be safe we avoid disabling it.
 *
 * Note: WebGL2
 * - Improves support for integer attributes, both generic and buffered.
 * - Setting instance "divisors" no longer require using a WebGL extension.
 *
 */

function glGetLumaInfo(gl) {
  if (!gl.luma) {
    gl.luma = { extensions: {} };
  }
  if (gl.luma.extensions['ANGLE_instanced_arrays'] === undefined) {
    gl.luma.extensions['ANGLE_instanced_arrays'] = gl.getExtension('ANGLE_instanced_arrays');
  }
  return gl.luma;
}

// ACCESSORS

/**
 * The max number of attributes in the vertex attribute array is an
 * implementation defined limit, but never smaller than 8
 * @param {WebGLRenderingContext} gl - webgl context
 * @returns {GLuint} - (max) number of attributes in the vertex attribute array
 */
function getMaxAttributes(gl) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);
  return gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
}

/**
 * Is instance divisor availble (checks for WebGL2 or ANGLE extension)
 * @param {WebGLRenderingContext} gl - webgl context
 * @returns {Boolean} - is divisor available?
 */
function hasDivisor(gl) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);
  return Boolean(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl) || gl.getExtension(gl, 'ANGLE_instanced_arrays'));
}

/**
 * Returns true if the vertex attribute is enabled at this index.
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {Boolean} - enabled status
 */
function isEnabled(gl, location) {
  return Boolean(get(gl, location, gl.VERTEX_ATTRIB_ARRAY_ENABLED));
}

/**
 * Returns the currently bound buffer
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {WebGLBuffer} Returns the currently bound buffer
 */
function getBuffer(gl, location) {
  return get(gl, location, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
}

/**
 * Get values for generic vertex attributes
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {Float32Array} (with 4 elements) representing the current value
 * of the vertex attribute at the given index.
 */
function getGeneric(gl, location) {
  return get(gl, gl.CURRENT_VERTEX_ATTRIB);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLint} the size of an element of the vertex array.
function getSize(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_SIZE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLenum} representing the array type.
function getType(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_TYPE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
// @returns {GLboolean} true if fixed-point data types are normalized
// for the vertex attribute array at the given index.
function isNormalized(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);
}

/**
 * check if an integer data type in the vertex attribute at index
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - index of the vertex attribute.
 * @returns {GLboolean} - true if an integer data type is in the
 * vertex attribute array at the given index.
 */
function isInteger(gl, location) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);
  return get(location, gl.VERTEX_ATTRIB_ARRAY_INTEGER);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {GLint} number of bytes between successive elements in the array.
 * 0 means that the elements are sequential.
 */
function getStride(gl, location) {
  return get(location, gl.VERTEX_ATTRIB_ARRAY_STRIDE);
}

/**
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} pname - enum specifying which offset to return
 * @returns {GLuint} the address of a specified vertex attribute.
 */
function getOffset(gl, location) {
  var pname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : gl.VERTEX_ATTRIB_ARRAY_POINTER;

  return gl.getVertexAttribOffset(location, pname);
}

/**
 * @private
 * Generic getter for information about a vertex attribute at a given position
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - index of the vertex attribute.
 * @param {GLenum} pname - specifies the information to query.
 * @returns {*} - requested vertex attribute information (specified by pname)
 */
function get(gl, location, pname) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);
  return gl.getVertexAttrib(location, pname);
}

// MODIFIERS

/**
 * Enable the attribute
 * Note: By default all attributes are disabled. Only attributes
 * used by a program's shaders should be enabled.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
function enable(gl, location) {
  gl.enableVertexAttribArray(location);
}

/**
 * Disable the attribute
 * Note: Only attributes used by a program's shaders should be enabled.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 */
function disable(gl, location) {
  // Don't disable location 0
  if (location > 0) {
    gl.disableVertexAttribArray(location);
  }
}

/**
 * Set the frequency divisor used for instanced rendering.
 * Note: Usually simply set to 1 or 0 to enable/disable instanced rendering
 * for a specific attribute.
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
function setDivisor(gl, location, divisor) {
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl)) {
    gl.vertexAttribDivisor(location, divisor);
    return;
  }
  var ext = glGetLumaInfo(gl).extensions['ANGLE_instanced_arrays'];
  if (ext) {
    ext.vertexAttribDivisorANGLE(location, divisor);
    return;
  }
  // Accept divisor 0 even if instancing is not supported (0 = no instancing)
  if (divisor !== 0) {
    throw new Error('WebGL instanced rendering not supported');
  }
}

/**
 * Returns the frequency divisor used for instanced rendering.
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @returns {GLuint} divisor
 */
function getDivisor(gl, location) {
  __WEBPACK_IMPORTED_MODULE_3_assert___default()(location > 0);
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl)) {
    var divisor = get(location, gl.VERTEX_ATTRIB_ARRAY_DIVISOR);
    return divisor;
  }
  var ext = glGetLumaInfo(gl).extensions['ANGLE_instanced_arrays'];
  if (ext) {
    var _divisor = get(location, ext.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
    return _divisor;
  }
  // if instancing is not available, return 0 meaning divisor has not been set
  return 0;
}

/**
 * Set a location in vertex attributes array to a buffer, specifying
 * its data layout and integer to float conversion and normalization flags
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {WebGLBuffer|Buffer} buffer - WebGL buffer to set as value
 * @param {GLuint} target=gl.ARRAY_BUFFER - which target to bind to
 * @param {Object} layout= Optional data layout, defaults to buffer's layout
 * @param {GLuint} layout.size - number of values per element (1-4)
 * @param {GLuint} layout.type - type of values (e.g. gl.FLOAT)
 * @param {GLbool} layout.normalized=false - normalize integers to [-1,1], [0,1]
 * @param {GLuint} layout.integer=false - WebGL2 only, disable int-to-float conv
 * @param {GLuint} layout.stride=0 - supports strided arrays
 * @param {GLuint} layout.offset=0 - supports strided arrays
 */
function setBuffer() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      gl = _ref.gl,
      location = _ref.location,
      buffer = _ref.buffer,
      target = _ref.target,
      layout = _ref.layout;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);

  // Copy main data characteristics from buffer
  target = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["d" /* glGet */])(target !== undefined ? target : buffer.target);
  layout = layout !== undefined ? layout : buffer.layout;
  __WEBPACK_IMPORTED_MODULE_3_assert___default()(target, 'setBuffer needs target');
  __WEBPACK_IMPORTED_MODULE_3_assert___default()(layout, 'setBuffer called on uninitialized buffer');

  // a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target
  buffer.bind({ target: gl.ARRAY_BUFFER });

  // Attach bound ARRAY_BUFFER with specified buffer format to location
  if (!layout.integer) {
    gl.vertexAttribPointer(location, layout.size, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["d" /* glGet */])(layout.type), layout.normalized, layout.stride, layout.offset);
  } else {
    // specifies *integer* data formats and locations of vertex attributes
    // For glVertexAttribIPointer, Values are always left as integer values.
    // Only accepts the integer types gl.BYTE, gl.UNSIGNED_BYTE,
    // gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);
    gl.vertexAttribIPointer(location, layout.size, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__api__["d" /* glGet */])(layout.type), layout.stride, layout.offset);
  }

  buffer.unbind({ target: gl.ARRAY_BUFFER });
}

/*
 * Specify values for generic vertex attributes
 * Generic vertex attributes are constant for all vertices
 * Up to 4 values depending on attribute size
 *
 * @param {WebGLRenderingContext} gl - webgl context
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
function setGeneric(_ref2) {
  var gl = _ref2.gl,
      location = _ref2.location,
      array = _ref2.array;

  __WEBPACK_IMPORTED_MODULE_2__utils__["log"].warn(0, 'VertexAttributes.setGeneric is not well tested');
  // throw new Error('vertex attribute size must be between 1 and 4');

  if (array instanceof Float32Array) {
    gl.vertexAttrib4fv(location, array);
  } else if (array instanceof Int32Array) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);
    gl.vertexAttribI4iv(location, array);
  } else if (array instanceof Uint32Array) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);
    gl.vertexAttribI4uiv(location, array);
  }
}

/*
 * Specify values for generic vertex attributes
 * Generic vertex attributes are constant for all vertices
 * Up to 4 values depending on attribute size
 *
 * @param {GLuint} location - ordinal number of the attribute
 * @param {GLuint} divisor - instances that pass between updates of attribute
 */
/* eslint-disable max-params */
function setGenericValues(gl, location, v0, v1, v2, v3) {
  __WEBPACK_IMPORTED_MODULE_2__utils__["log"].warn(0, 'VertexAttributes.setGenericValues is not well tested');
  switch (arguments.length - 1) {
    case 1:
      gl.vertexAttrib1f(location, v0);break;
    case 2:
      gl.vertexAttrib2f(location, v0, v1);break;
    case 3:
      gl.vertexAttrib3f(location, v0, v1, v2);break;
    case 4:
      gl.vertexAttrib4f(location, v0, v1, v2, v3);break;
    default:
      throw new Error('vertex attribute size must be between 1 and 4');
  }

  // assert(gl instanceof WebGL2RenderingContext, 'WebGL2 required');
  // Looks like these will check how many arguments were supplied?
  // gl.vertexAttribI4i(location, v0, v1, v2, v3);
  // gl.vertexAttribI4ui(location, v0, v1, v2, v3);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC92ZXJ0ZXgtYXR0cmlidXRlcy5qcyJdLCJuYW1lcyI6WyJnbEdldCIsImFzc2VydFdlYkdMQ29udGV4dCIsImFzc2VydFdlYkdMMkNvbnRleHQiLCJpc1dlYkdMMkNvbnRleHQiLCJsb2ciLCJhc3NlcnQiLCJnbEdldEx1bWFJbmZvIiwiZ2wiLCJsdW1hIiwiZXh0ZW5zaW9ucyIsInVuZGVmaW5lZCIsImdldEV4dGVuc2lvbiIsImdldE1heEF0dHJpYnV0ZXMiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVkVSVEVYX0FUVFJJQlMiLCJoYXNEaXZpc29yIiwiQm9vbGVhbiIsImlzRW5hYmxlZCIsImxvY2F0aW9uIiwiZ2V0IiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEIiwiZ2V0QnVmZmVyIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORyIsImdldEdlbmVyaWMiLCJDVVJSRU5UX1ZFUlRFWF9BVFRSSUIiLCJnZXRTaXplIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFIiwiZ2V0VHlwZSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRSIsImlzTm9ybWFsaXplZCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCIsImlzSW50ZWdlciIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfSU5URUdFUiIsImdldFN0cmlkZSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFIiwiZ2V0T2Zmc2V0IiwicG5hbWUiLCJWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVIiLCJnZXRWZXJ0ZXhBdHRyaWJPZmZzZXQiLCJnZXRWZXJ0ZXhBdHRyaWIiLCJlbmFibGUiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsImRpc2FibGUiLCJkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkiLCJzZXREaXZpc29yIiwiZGl2aXNvciIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJleHQiLCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUiLCJFcnJvciIsImdldERpdmlzb3IiLCJWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1IiLCJWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JfQU5HTEUiLCJzZXRCdWZmZXIiLCJidWZmZXIiLCJ0YXJnZXQiLCJsYXlvdXQiLCJiaW5kIiwiQVJSQVlfQlVGRkVSIiwiaW50ZWdlciIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJzaXplIiwidHlwZSIsIm5vcm1hbGl6ZWQiLCJzdHJpZGUiLCJvZmZzZXQiLCJ2ZXJ0ZXhBdHRyaWJJUG9pbnRlciIsInVuYmluZCIsInNldEdlbmVyaWMiLCJhcnJheSIsIndhcm4iLCJGbG9hdDMyQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWI0ZnYiLCJJbnQzMkFycmF5IiwidmVydGV4QXR0cmliSTRpdiIsIlVpbnQzMkFycmF5IiwidmVydGV4QXR0cmliSTR1aXYiLCJzZXRHZW5lcmljVmFsdWVzIiwidjAiLCJ2MSIsInYyIiwidjMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ2ZXJ0ZXhBdHRyaWIxZiIsInZlcnRleEF0dHJpYjJmIiwidmVydGV4QXR0cmliM2YiLCJ2ZXJ0ZXhBdHRyaWI0ZiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxTQUFRQSxLQUFSLFFBQW9CLE9BQXBCO0FBQ0EsU0FBUUMsa0JBQVIsRUFBNEJDLG1CQUE1QixFQUFpREMsZUFBakQsUUFBdUUsV0FBdkU7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdDQSxTQUFTQyxhQUFULENBQXVCQyxFQUF2QixFQUEyQjtBQUN6QixNQUFJLENBQUNBLEdBQUdDLElBQVIsRUFBYztBQUNaRCxPQUFHQyxJQUFILEdBQVUsRUFBQ0MsWUFBWSxFQUFiLEVBQVY7QUFDRDtBQUNELE1BQUlGLEdBQUdDLElBQUgsQ0FBUUMsVUFBUixDQUFtQix3QkFBbkIsTUFBaURDLFNBQXJELEVBQWdFO0FBQzlESCxP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QVF4RSxTQUFHK0UsY0FBSCxDQUFrQnBFLFFBQWxCLEVBQTRCNEQsRUFBNUIsRUFBZ0NDLEVBQWhDLEVBQW9DQyxFQUFwQyxFQUF5QztBQUNqRCxTQUFLLENBQUw7QUFBUXpFLFNBQUdnRixjQUFILENBQWtCckUsUUFBbEIsRUFBNEI0RCxFQUE1QixFQUFnQ0MsRUFBaEMsRUFBb0NDLEVBQXBDLEVBQXdDQyxFQUF4QyxFQUE2QztBQUNyRDtBQUNFLFlBQU0sSUFBSWhDLEtBQUosQ0FBVSwrQ0FBVixDQUFOO0FBTkY7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDRCIsImZpbGUiOiJ2ZXJ0ZXgtYXR0cmlidXRlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiovXG5pbXBvcnQge2dsR2V0fSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2Fzc2VydFdlYkdMQ29udGV4dCwgYXNzZXJ0V2ViR0wyQ29udGV4dCwgaXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLyoqXG4gKiBNZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgdGhlIHZlcnRleCBhdHRyaWJ1dGVzIGFycmF5LCB3aGljaCBpcyB3aGVyZVxuICogdmVydGV4IGRhdGEgaXMgc3RhZ2VkIGZvciBzaGFkZXIgZXhlY3V0aW9uLlxuICpcbiAqIFZlcnRleCBhdHRyaWJ1dGVzIGFyZSBzdG9yZWQgaW4gXCJhcnJheXNcIiB3aXRoIGluZGljZXMgZnJvbSAwIGFuZCB1cC5cbiAqIER1cmluZyBzaGFkZXIgZXhlY3V0aW9uLCB0aGVzZSBpbmRpY2VzIChvciAnbG9jYXRpb25zJykgYXJlIG1hdGNoZWQgdG9cbiAqIHRoZSBpbmRpY2VzIGFzc2lnbmVkIHRvIHNoYWRlciBhdHRyaWJ1dGVzIGR1cmluZyBXZWJHTFByb2dyYW0gbGlua2luZy5cbiAqXG4gKiBOb3RlOiBUaGUgZ2xvYmFsIHN0YXRlIGNvbnRhaW5zIGFuIGltcGxpY2l0IHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgd2hpY2hcbiAqIHRoZSBtZXRob2RzIGluIHRoaXMgY2xhc3MgbWFuaXB1bGF0ZSBieSBkZWZhdWx0LiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvXG4gKiBjcmVhdGUgYW5kIGJpbmQgYSBWZXJ0ZXhBcnJheU9iamVjdCB0byBtYW5hZ2UgbXVsdGlwbGUgYXJyYXlzLlxuICpcbiAqIEVhY2ggdmVydGV4IGF0dHJpYnV0ZSBoYXMgdGhlc2UgcHJvcGVydGllczpcbiAqIC0gQ2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgKE9ubHkgZW5hYmxlIGF0dHJzIGFjdHVhbGx5IHVzZWQgYnkgYSBwcm9ncmFtKVxuICogLSBIYXMgYW4gaW5zdGFuY2UgYGRpdmlzb3JgICh1c3VhbGx5IDEgb3IgMCB0byBlbmFibGUvZGlzYWJsZSBpbnN0YW5jaW5nKVxuICogLSBIYXZlIGEgc2l6ZSAoMS00IHZhbHVlcyBwZXIgdmVydGV4KVxuICogLSBIYXMgYSB2YWx1ZSBvciB2YWx1ZXMgdGhhdCBpcyBhY2Nlc3NpYmxlIGluIHNoYWRlcnNcbiAqXG4gKiBBdHRyaWJ1dGUgdmFsdWVzIGFyZSBlaXRoZXJcbiAqIC0gR2VuZXJpYzogYSBjb25zdGFudCB2YWx1ZSBmb3IgYWxsIHZlcnRpY2VzL2luc3RhbmNlcywgb3JcbiAqIC0gQm91bmQgdG8gYSBXZWJHTEJ1ZmZlciB3aXRoIHVuaXF1ZSB2YWx1ZXMgZm9yIGVhY2ggdmVydGV4L2luc3RhbmNlXG4gKlxuICogV2hlbiBiaW5kaW5nIHRvIGEgV2ViR0xCdWZmZXIgaXQgaXMgbmVjZXNzYXJ5IHRvIHNwZWNpZnkgdGhlIGxheW91dCBvZlxuICogZGF0YSBpbiB0aGUgYnVmZmVyOlxuICogLSBzaXplICgxLTQgdmFsdWVzIHBlciB2ZXJ0ZXgpXG4gKiAtIGRhdGEgdHlwZSAoZS5nLiBnbC5GTE9BVClcbiAqIC0gc3RyaWRlLCBvZmZzZXQsIGFuZCBpbnRlZ2VyIG5vcm1hbGl6YXRpb24gcG9saWN5IGNhbiBhbHNvIGJlIHNwZWNpZmllZFxuICpcbiAqIE5vdGU6IEFsbCBtZXRob2RzIGluIHRoaXMgY2xhc3MgdGFrZSBhIGBsb2NhdGlvbmAgaW5kZXggdG8gc3BlY2lmeSB3aGljaFxuICogdmVydGV4IGF0dHJpYnV0ZSBpbiB0aGUgYXJyYXkgdGhleSBhcmUgb3BlcmF0aW5nIG9uLlxuICpcbiAqIE5vdGU6IEF0dHJpYnV0ZSAwIGNhbiBzb21ldGltZXMgYmUgdHJlYXRlZCBzcGVjaWFsbHkgYnkgdGhlIGRyaXZlcixcbiAqIHRvIGJlIHNhZmUgd2UgYXZvaWQgZGlzYWJsaW5nIGl0LlxuICpcbiAqIE5vdGU6IFdlYkdMMlxuICogLSBJbXByb3ZlcyBzdXBwb3J0IGZvciBpbnRlZ2VyIGF0dHJpYnV0ZXMsIGJvdGggZ2VuZXJpYyBhbmQgYnVmZmVyZWQuXG4gKiAtIFNldHRpbmcgaW5zdGFuY2UgXCJkaXZpc29yc1wiIG5vIGxvbmdlciByZXF1aXJlIHVzaW5nIGEgV2ViR0wgZXh0ZW5zaW9uLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBnbEdldEx1bWFJbmZvKGdsKSB7XG4gIGlmICghZ2wubHVtYSkge1xuICAgIGdsLmx1bWEgPSB7ZXh0ZW5zaW9uczoge319O1xuICB9XG4gIGlmIChnbC5sdW1hLmV4dGVuc2lvbnNbJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wubHVtYS5leHRlbnNpb25zWydBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJ10gPVxuICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gIH1cbiAgcmV0dXJuIGdsLmx1bWE7XG59XG5cbi8vIEFDQ0VTU09SU1xuXG4vKipcbiAqIFRoZSBtYXggbnVtYmVyIG9mIGF0dHJpYnV0ZXMgaW4gdGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgaXMgYW5cbiAqIGltcGxlbWVudGF0aW9uIGRlZmluZWQgbGltaXQsIGJ1dCBuZXZlciBzbWFsbGVyIHRoYW4gOFxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHJldHVybnMge0dMdWludH0gLSAobWF4KSBudW1iZXIgb2YgYXR0cmlidXRlcyBpbiB0aGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4QXR0cmlidXRlcyhnbCkge1xuICBhc3NlcnRXZWJHTENvbnRleHQoZ2wpO1xuICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG59XG5cbi8qKlxuICogSXMgaW5zdGFuY2UgZGl2aXNvciBhdmFpbGJsZSAoY2hlY2tzIGZvciBXZWJHTDIgb3IgQU5HTEUgZXh0ZW5zaW9uKVxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHJldHVybnMge0Jvb2xlYW59IC0gaXMgZGl2aXNvciBhdmFpbGFibGU/XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNEaXZpc29yKGdsKSB7XG4gIGFzc2VydFdlYkdMQ29udGV4dChnbCk7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIGlzV2ViR0wyQ29udGV4dChnbCkgfHxcbiAgICBnbC5nZXRFeHRlbnNpb24oZ2wsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZlcnRleCBhdHRyaWJ1dGUgaXMgZW5hYmxlZCBhdCB0aGlzIGluZGV4LlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Jvb2xlYW59IC0gZW5hYmxlZCBzdGF0dXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW5hYmxlZChnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4oZ2V0KGdsLCBsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGJvdW5kIGJ1ZmZlclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMge1dlYkdMQnVmZmVyfSBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYm91bmQgYnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQoZ2wsIGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HKTtcbn1cblxuLyoqXG4gKiBHZXQgdmFsdWVzIGZvciBnZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSAod2l0aCA0IGVsZW1lbnRzKSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgdmFsdWVcbiAqIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlbmVyaWMoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQoZ2wsIGdsLkNVUlJFTlRfVkVSVEVYX0FUVFJJQik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG4vLyBAcmV0dXJucyB7R0xpbnR9IHRoZSBzaXplIG9mIGFuIGVsZW1lbnQgb2YgdGhlIHZlcnRleCBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZ2V0KGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX1NJWkUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuLy8gQHJldHVybnMge0dMZW51bX0gcmVwcmVzZW50aW5nIHRoZSBhcnJheSB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBnZXQobG9jYXRpb24sIGdsLlZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG4vLyBAcmV0dXJucyB7R0xib29sZWFufSB0cnVlIGlmIGZpeGVkLXBvaW50IGRhdGEgdHlwZXMgYXJlIG5vcm1hbGl6ZWRcbi8vIGZvciB0aGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5leHBvcnQgZnVuY3Rpb24gaXNOb3JtYWxpemVkKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZ2V0KGxvY2F0aW9uLCBnbC5WRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQpO1xufVxuXG4vKipcbiAqIGNoZWNrIGlmIGFuIGludGVnZXIgZGF0YSB0eXBlIGluIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIGF0IGluZGV4XG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBpbmRleCBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtHTGJvb2xlYW59IC0gdHJ1ZSBpZiBhbiBpbnRlZ2VyIGRhdGEgdHlwZSBpcyBpbiB0aGVcbiAqIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgYXQgdGhlIGdpdmVuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKGdsLCBsb2NhdGlvbikge1xuICBhc3NlcnRXZWJHTDJDb250ZXh0KGdsKTtcbiAgcmV0dXJuIGdldChsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9JTlRFR0VSKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7R0xpbnR9IG51bWJlciBvZiBieXRlcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICogMCBtZWFucyB0aGF0IHRoZSBlbGVtZW50cyBhcmUgc2VxdWVudGlhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZShnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGdldChsb2NhdGlvbiwgZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7R0x1aW50fSBwbmFtZSAtIGVudW0gc3BlY2lmeWluZyB3aGljaCBvZmZzZXQgdG8gcmV0dXJuXG4gKiBAcmV0dXJucyB7R0x1aW50fSB0aGUgYWRkcmVzcyBvZiBhIHNwZWNpZmllZCB2ZXJ0ZXggYXR0cmlidXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2Zmc2V0KFxuICBnbCwgbG9jYXRpb24sIHBuYW1lID0gZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSXG4pIHtcbiAgcmV0dXJuIGdsLmdldFZlcnRleEF0dHJpYk9mZnNldChsb2NhdGlvbiwgcG5hbWUpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBHZW5lcmljIGdldHRlciBmb3IgaW5mb3JtYXRpb24gYWJvdXQgYSB2ZXJ0ZXggYXR0cmlidXRlIGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIGluZGV4IG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxuICogQHBhcmFtIHtHTGVudW19IHBuYW1lIC0gc3BlY2lmaWVzIHRoZSBpbmZvcm1hdGlvbiB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSAtIHJlcXVlc3RlZCB2ZXJ0ZXggYXR0cmlidXRlIGluZm9ybWF0aW9uIChzcGVjaWZpZWQgYnkgcG5hbWUpXG4gKi9cbmZ1bmN0aW9uIGdldChnbCwgbG9jYXRpb24sIHBuYW1lKSB7XG4gIGFzc2VydFdlYkdMQ29udGV4dChnbCk7XG4gIHJldHVybiBnbC5nZXRWZXJ0ZXhBdHRyaWIobG9jYXRpb24sIHBuYW1lKTtcbn1cblxuLy8gTU9ESUZJRVJTXG5cbi8qKlxuICogRW5hYmxlIHRoZSBhdHRyaWJ1dGVcbiAqIE5vdGU6IEJ5IGRlZmF1bHQgYWxsIGF0dHJpYnV0ZXMgYXJlIGRpc2FibGVkLiBPbmx5IGF0dHJpYnV0ZXNcbiAqIHVzZWQgYnkgYSBwcm9ncmFtJ3Mgc2hhZGVycyBzaG91bGQgYmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGUoZ2wsIGxvY2F0aW9uKSB7XG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlIHRoZSBhdHRyaWJ1dGVcbiAqIE5vdGU6IE9ubHkgYXR0cmlidXRlcyB1c2VkIGJ5IGEgcHJvZ3JhbSdzIHNoYWRlcnMgc2hvdWxkIGJlIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZShnbCwgbG9jYXRpb24pIHtcbiAgLy8gRG9uJ3QgZGlzYWJsZSBsb2NhdGlvbiAwXG4gIGlmIChsb2NhdGlvbiA+IDApIHtcbiAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHRoZSBmcmVxdWVuY3kgZGl2aXNvciB1c2VkIGZvciBpbnN0YW5jZWQgcmVuZGVyaW5nLlxuICogTm90ZTogVXN1YWxseSBzaW1wbHkgc2V0IHRvIDEgb3IgMCB0byBlbmFibGUvZGlzYWJsZSBpbnN0YW5jZWQgcmVuZGVyaW5nXG4gKiBmb3IgYSBzcGVjaWZpYyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gd2ViZ2wgY29udGV4dFxuICogQHBhcmFtIHtHTHVpbnR9IGxvY2F0aW9uIC0gb3JkaW5hbCBudW1iZXIgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtHTHVpbnR9IGRpdmlzb3IgLSBpbnN0YW5jZXMgdGhhdCBwYXNzIGJldHdlZW4gdXBkYXRlcyBvZiBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERpdmlzb3IoZ2wsIGxvY2F0aW9uLCBkaXZpc29yKSB7XG4gIGlmIChpc1dlYkdMMkNvbnRleHQoZ2wpKSB7XG4gICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgZGl2aXNvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGV4dCA9IGdsR2V0THVtYUluZm8oZ2wpLmV4dGVuc2lvbnNbJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnXTtcbiAgaWYgKGV4dCkge1xuICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUobG9jYXRpb24sIGRpdmlzb3IpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBBY2NlcHQgZGl2aXNvciAwIGV2ZW4gaWYgaW5zdGFuY2luZyBpcyBub3Qgc3VwcG9ydGVkICgwID0gbm8gaW5zdGFuY2luZylcbiAgaWYgKGRpdmlzb3IgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGluc3RhbmNlZCByZW5kZXJpbmcgbm90IHN1cHBvcnRlZCcpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnJlcXVlbmN5IGRpdmlzb3IgdXNlZCBmb3IgaW5zdGFuY2VkIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHdlYmdsIGNvbnRleHRcbiAqIEBwYXJhbSB7R0x1aW50fSBsb2NhdGlvbiAtIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtHTHVpbnR9IGRpdmlzb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpdmlzb3IoZ2wsIGxvY2F0aW9uKSB7XG4gIGFzc2VydChsb2NhdGlvbiA+IDApO1xuICBpZiAoaXNXZWJHTDJDb250ZXh0KGdsKSkge1xuICAgIGNvbnN0IGRpdmlzb3IgPSBnZXQobG9jYXRpb24sIGdsLlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUik7XG4gICAgcmV0dXJuIGRpdmlzb3I7XG4gIH1cbiAgY29uc3QgZXh0ID0gZ2xHZXRMdW1hSW5mbyhnbCkuZXh0ZW5zaW9uc1snQU5HTEVfaW5zdGFuY2VkX2FycmF5cyddO1xuICBpZiAoZXh0KSB7XG4gICAgY29uc3QgZGl2aXNvciA9IGdldChsb2NhdGlvbiwgZXh0LlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRSk7XG4gICAgcmV0dXJuIGRpdmlzb3I7XG4gIH1cbiAgLy8gaWYgaW5zdGFuY2luZyBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm4gMCBtZWFuaW5nIGRpdmlzb3IgaGFzIG5vdCBiZWVuIHNldFxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBTZXQgYSBsb2NhdGlvbiBpbiB2ZXJ0ZXggYXR0cmlidXRlcyBhcnJheSB0byBhIGJ1ZmZlciwgc3BlY2lmeWluZ1xuICogaXRzIGRhdGEgbGF5b3V0IGFuZCBpbnRlZ2VyIHRvIGZsb2F0IGNvbnZlcnNpb24gYW5kIG5vcm1hbGl6YXRpb24gZmxhZ3NcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge1dlYkdMQnVmZmVyfEJ1ZmZlcn0gYnVmZmVyIC0gV2ViR0wgYnVmZmVyIHRvIHNldCBhcyB2YWx1ZVxuICogQHBhcmFtIHtHTHVpbnR9IHRhcmdldD1nbC5BUlJBWV9CVUZGRVIgLSB3aGljaCB0YXJnZXQgdG8gYmluZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IGxheW91dD0gT3B0aW9uYWwgZGF0YSBsYXlvdXQsIGRlZmF1bHRzIHRvIGJ1ZmZlcidzIGxheW91dFxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5zaXplIC0gbnVtYmVyIG9mIHZhbHVlcyBwZXIgZWxlbWVudCAoMS00KVxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC50eXBlIC0gdHlwZSBvZiB2YWx1ZXMgKGUuZy4gZ2wuRkxPQVQpXG4gKiBAcGFyYW0ge0dMYm9vbH0gbGF5b3V0Lm5vcm1hbGl6ZWQ9ZmFsc2UgLSBub3JtYWxpemUgaW50ZWdlcnMgdG8gWy0xLDFdLCBbMCwxXVxuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5pbnRlZ2VyPWZhbHNlIC0gV2ViR0wyIG9ubHksIGRpc2FibGUgaW50LXRvLWZsb2F0IGNvbnZcbiAqIEBwYXJhbSB7R0x1aW50fSBsYXlvdXQuc3RyaWRlPTAgLSBzdXBwb3J0cyBzdHJpZGVkIGFycmF5c1xuICogQHBhcmFtIHtHTHVpbnR9IGxheW91dC5vZmZzZXQ9MCAtIHN1cHBvcnRzIHN0cmlkZWQgYXJyYXlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCdWZmZXIoe1xuICBnbCxcbiAgbG9jYXRpb24sXG4gIGJ1ZmZlcixcbiAgdGFyZ2V0LFxuICBsYXlvdXRcbn0gPSB7fSkge1xuICBhc3NlcnRXZWJHTENvbnRleHQoZ2wpO1xuXG4gIC8vIENvcHkgbWFpbiBkYXRhIGNoYXJhY3RlcmlzdGljcyBmcm9tIGJ1ZmZlclxuICB0YXJnZXQgPSBnbEdldCh0YXJnZXQgIT09IHVuZGVmaW5lZCA/IHRhcmdldCA6IGJ1ZmZlci50YXJnZXQpO1xuICBsYXlvdXQgPSBsYXlvdXQgIT09IHVuZGVmaW5lZCA/IGxheW91dCA6IGJ1ZmZlci5sYXlvdXQ7XG4gIGFzc2VydCh0YXJnZXQsICdzZXRCdWZmZXIgbmVlZHMgdGFyZ2V0Jyk7XG4gIGFzc2VydChsYXlvdXQsICdzZXRCdWZmZXIgY2FsbGVkIG9uIHVuaW5pdGlhbGl6ZWQgYnVmZmVyJyk7XG5cbiAgLy8gYSBub24temVybyBuYW1lZCBidWZmZXIgb2JqZWN0IG11c3QgYmUgYm91bmQgdG8gdGhlIEdMX0FSUkFZX0JVRkZFUiB0YXJnZXRcbiAgYnVmZmVyLmJpbmQoe3RhcmdldDogZ2wuQVJSQVlfQlVGRkVSfSk7XG5cbiAgLy8gQXR0YWNoIGJvdW5kIEFSUkFZX0JVRkZFUiB3aXRoIHNwZWNpZmllZCBidWZmZXIgZm9ybWF0IHRvIGxvY2F0aW9uXG4gIGlmICghbGF5b3V0LmludGVnZXIpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBsYXlvdXQuc2l6ZSxcbiAgICAgIGdsR2V0KGxheW91dC50eXBlKSxcbiAgICAgIGxheW91dC5ub3JtYWxpemVkLFxuICAgICAgbGF5b3V0LnN0cmlkZSxcbiAgICAgIGxheW91dC5vZmZzZXRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIHNwZWNpZmllcyAqaW50ZWdlciogZGF0YSBmb3JtYXRzIGFuZCBsb2NhdGlvbnMgb2YgdmVydGV4IGF0dHJpYnV0ZXNcbiAgICAvLyBGb3IgZ2xWZXJ0ZXhBdHRyaWJJUG9pbnRlciwgVmFsdWVzIGFyZSBhbHdheXMgbGVmdCBhcyBpbnRlZ2VyIHZhbHVlcy5cbiAgICAvLyBPbmx5IGFjY2VwdHMgdGhlIGludGVnZXIgdHlwZXMgZ2wuQllURSwgZ2wuVU5TSUdORURfQllURSxcbiAgICAvLyBnbC5TSE9SVCwgZ2wuVU5TSUdORURfU0hPUlQsIGdsLklOVCwgZ2wuVU5TSUdORURfSU5UXG4gICAgYXNzZXJ0V2ViR0wyQ29udGV4dChnbCk7XG4gICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGxheW91dC5zaXplLFxuICAgICAgZ2xHZXQobGF5b3V0LnR5cGUpLFxuICAgICAgbGF5b3V0LnN0cmlkZSxcbiAgICAgIGxheW91dC5vZmZzZXRcbiAgICApO1xuICB9XG5cbiAgYnVmZmVyLnVuYmluZCh7dGFyZ2V0OiBnbC5BUlJBWV9CVUZGRVJ9KTtcbn1cblxuLypcbiAqIFNwZWNpZnkgdmFsdWVzIGZvciBnZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzXG4gKiBHZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzIGFyZSBjb25zdGFudCBmb3IgYWxsIHZlcnRpY2VzXG4gKiBVcCB0byA0IHZhbHVlcyBkZXBlbmRpbmcgb24gYXR0cmlidXRlIHNpemVcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSB3ZWJnbCBjb250ZXh0XG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0dMdWludH0gZGl2aXNvciAtIGluc3RhbmNlcyB0aGF0IHBhc3MgYmV0d2VlbiB1cGRhdGVzIG9mIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0R2VuZXJpYyh7Z2wsIGxvY2F0aW9uLCBhcnJheX0pIHtcbiAgbG9nLndhcm4oMCwgJ1ZlcnRleEF0dHJpYnV0ZXMuc2V0R2VuZXJpYyBpcyBub3Qgd2VsbCB0ZXN0ZWQnKTtcbiAgLy8gdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggYXR0cmlidXRlIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDQnKTtcblxuICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYobG9jYXRpb24sIGFycmF5KTtcbiAgfSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICBhc3NlcnRXZWJHTDJDb250ZXh0KGdsKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJJNGl2KGxvY2F0aW9uLCBhcnJheSk7XG4gIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgIGFzc2VydFdlYkdMMkNvbnRleHQoZ2wpO1xuICAgIGdsLnZlcnRleEF0dHJpYkk0dWl2KGxvY2F0aW9uLCBhcnJheSk7XG4gIH1cbn1cblxuLypcbiAqIFNwZWNpZnkgdmFsdWVzIGZvciBnZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzXG4gKiBHZW5lcmljIHZlcnRleCBhdHRyaWJ1dGVzIGFyZSBjb25zdGFudCBmb3IgYWxsIHZlcnRpY2VzXG4gKiBVcCB0byA0IHZhbHVlcyBkZXBlbmRpbmcgb24gYXR0cmlidXRlIHNpemVcbiAqXG4gKiBAcGFyYW0ge0dMdWludH0gbG9jYXRpb24gLSBvcmRpbmFsIG51bWJlciBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0dMdWludH0gZGl2aXNvciAtIGluc3RhbmNlcyB0aGF0IHBhc3MgYmV0d2VlbiB1cGRhdGVzIG9mIGF0dHJpYnV0ZVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtcGFyYW1zICovXG5leHBvcnQgZnVuY3Rpb24gc2V0R2VuZXJpY1ZhbHVlcyhnbCwgbG9jYXRpb24sIHYwLCB2MSwgdjIsIHYzKSB7XG4gIGxvZy53YXJuKDAsICdWZXJ0ZXhBdHRyaWJ1dGVzLnNldEdlbmVyaWNWYWx1ZXMgaXMgbm90IHdlbGwgdGVzdGVkJyk7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCAtIDEpIHtcbiAgY2FzZSAxOiBnbC52ZXJ0ZXhBdHRyaWIxZihsb2NhdGlvbiwgdjApOyBicmVhaztcbiAgY2FzZSAyOiBnbC52ZXJ0ZXhBdHRyaWIyZihsb2NhdGlvbiwgdjAsIHYxKTsgYnJlYWs7XG4gIGNhc2UgMzogZ2wudmVydGV4QXR0cmliM2YobG9jYXRpb24sIHYwLCB2MSwgdjIpOyBicmVhaztcbiAgY2FzZSA0OiBnbC52ZXJ0ZXhBdHRyaWI0Zihsb2NhdGlvbiwgdjAsIHYxLCB2MiwgdjMpOyBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRleCBhdHRyaWJ1dGUgc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNCcpO1xuICB9XG5cbiAgLy8gYXNzZXJ0KGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgJ1dlYkdMMiByZXF1aXJlZCcpO1xuICAvLyBMb29rcyBsaWtlIHRoZXNlIHdpbGwgY2hlY2sgaG93IG1hbnkgYXJndW1lbnRzIHdlcmUgc3VwcGxpZWQ/XG4gIC8vIGdsLnZlcnRleEF0dHJpYkk0aShsb2NhdGlvbiwgdjAsIHYxLCB2MiwgdjMpO1xuICAvLyBnbC52ZXJ0ZXhBdHRyaWJJNHVpKGxvY2F0aW9uLCB2MCwgdjEsIHYyLCB2Myk7XG59XG4iXX0=

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(30);
var invariant = __webpack_require__(14);
var warning = __webpack_require__(11);

var ReactPropTypesSecret = __webpack_require__(63);
var checkPropTypes = __webpack_require__(261);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(118)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(263)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var ReactCurrentOwner = __webpack_require__(38);
var ReactComponentTreeHook = __webpack_require__(65);
var ReactElement = __webpack_require__(22);

var checkReactTypeSpec = __webpack_require__(274);

var canDefineProperty = __webpack_require__(39);
var getIteratorFn = __webpack_require__(123);
var warning = __webpack_require__(11);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(266);


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "experimental", function() { return experimental; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_utils__ = __webpack_require__(8);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return __WEBPACK_IMPORTED_MODULE_0__shader_utils__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib__ = __webpack_require__(1);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CompositeLayer", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LayerManager", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeManager", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "COORDINATE_SYSTEM", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__["e"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_viewports_viewport__ = __webpack_require__(25);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Viewport", function() { return __WEBPACK_IMPORTED_MODULE_2__lib_viewports_viewport__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_viewports_perspective_viewport__ = __webpack_require__(78);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveViewport", function() { return __WEBPACK_IMPORTED_MODULE_3__lib_viewports_perspective_viewport__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_viewports_orthographic_viewport__ = __webpack_require__(77);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicViewport", function() { return __WEBPACK_IMPORTED_MODULE_4__lib_viewports_orthographic_viewport__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_viewports_web_mercator_viewport__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebMercatorViewport", function() { return __WEBPACK_IMPORTED_MODULE_5__lib_viewports_web_mercator_viewport__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__layers_core_arc_layer_arc_layer__ = __webpack_require__(139);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ArcLayer", function() { return __WEBPACK_IMPORTED_MODULE_6__layers_core_arc_layer_arc_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__layers_core_icon_layer_icon_layer__ = __webpack_require__(155);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "IconLayer", function() { return __WEBPACK_IMPORTED_MODULE_7__layers_core_icon_layer_icon_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__layers_core_line_layer_line_layer__ = __webpack_require__(159);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineLayer", function() { return __WEBPACK_IMPORTED_MODULE_8__layers_core_line_layer_line_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__layers_core_point_cloud_layer_point_cloud_layer__ = __webpack_require__(166);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudLayer", function() { return __WEBPACK_IMPORTED_MODULE_9__layers_core_point_cloud_layer_point_cloud_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__layers_core_scatterplot_layer_scatterplot_layer__ = __webpack_require__(72);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ScatterplotLayer", function() { return __WEBPACK_IMPORTED_MODULE_10__layers_core_scatterplot_layer_scatterplot_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__layers_core_screen_grid_layer_screen_grid_layer__ = __webpack_require__(173);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenGridLayer", function() { return __WEBPACK_IMPORTED_MODULE_11__layers_core_screen_grid_layer_screen_grid_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__layers_core_grid_layer_grid_layer__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GridLayer", function() { return __WEBPACK_IMPORTED_MODULE_12__layers_core_grid_layer_grid_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__layers_core_grid_cell_layer_grid_cell_layer__ = __webpack_require__(70);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GridCellLayer", function() { return __WEBPACK_IMPORTED_MODULE_13__layers_core_grid_cell_layer_grid_cell_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__layers_core_hexagon_layer_hexagon_layer__ = __webpack_require__(151);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HexagonLayer", function() { return __WEBPACK_IMPORTED_MODULE_14__layers_core_hexagon_layer_hexagon_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__layers_core_hexagon_cell_layer_hexagon_cell_layer__ = __webpack_require__(71);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HexagonCellLayer", function() { return __WEBPACK_IMPORTED_MODULE_15__layers_core_hexagon_cell_layer_hexagon_cell_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__layers_core_path_layer_path_layer__ = __webpack_require__(41);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PathLayer", function() { return __WEBPACK_IMPORTED_MODULE_16__layers_core_path_layer_path_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__layers_core_polygon_layer_polygon_layer__ = __webpack_require__(167);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonLayer", function() { return __WEBPACK_IMPORTED_MODULE_17__layers_core_polygon_layer_polygon_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__layers_core_geojson_layer_geojson_layer__ = __webpack_require__(140);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJsonLayer", function() { return __WEBPACK_IMPORTED_MODULE_18__layers_core_geojson_layer_geojson_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__ = __webpack_require__(74);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ChoroplethLayer", function() { return __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__ = __webpack_require__(179);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ChoroplethLayer64", function() { return __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__ = __webpack_require__(184);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudedChoroplethLayer64", function() { return __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__react_deckgl__ = __webpack_require__(81);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DeckGL", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__lib_utils_get__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__lib_utils_count__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__experimental_lib__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__experimental_effects_reflection_effect__ = __webpack_require__(69);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/* eslint-disable max-len */

// Utilities


// Lib


// Viewports





// Core Layers

















// Deprecated Layers




// React exports



// Experimental Features (May change in minor version bumps, use at your own risk)





var experimental = {
  get: __WEBPACK_IMPORTED_MODULE_23__lib_utils_get__["a" /* get */],
  count: __WEBPACK_IMPORTED_MODULE_24__lib_utils_count__["a" /* count */],
  EffectManager: __WEBPACK_IMPORTED_MODULE_25__experimental_lib__["a" /* EffectManager */],
  Effect: __WEBPACK_IMPORTED_MODULE_25__experimental_lib__["b" /* Effect */],
  ReflectionEffect: __WEBPACK_IMPORTED_MODULE_26__experimental_effects_reflection_effect__["a" /* default */]
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJhc3NlbWJsZVNoYWRlcnMiLCJMYXllciIsIkNvbXBvc2l0ZUxheWVyIiwiTGF5ZXJNYW5hZ2VyIiwiQXR0cmlidXRlTWFuYWdlciIsIkNPT1JESU5BVEVfU1lTVEVNIiwiZGVmYXVsdCIsIlZpZXdwb3J0IiwiUGVyc3BlY3RpdmVWaWV3cG9ydCIsIk9ydGhvZ3JhcGhpY1ZpZXdwb3J0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIkFyY0xheWVyIiwiSWNvbkxheWVyIiwiTGluZUxheWVyIiwiUG9pbnRDbG91ZExheWVyIiwiU2NhdHRlcnBsb3RMYXllciIsIlNjcmVlbkdyaWRMYXllciIsIkdyaWRMYXllciIsIkdyaWRDZWxsTGF5ZXIiLCJIZXhhZ29uTGF5ZXIiLCJIZXhhZ29uQ2VsbExheWVyIiwiUGF0aExheWVyIiwiUG9seWdvbkxheWVyIiwiR2VvSnNvbkxheWVyIiwiQ2hvcm9wbGV0aExheWVyIiwiQ2hvcm9wbGV0aExheWVyNjQiLCJFeHRydWRlZENob3JvcGxldGhMYXllcjY0IiwiRGVja0dMIiwiZ2V0IiwiY291bnQiLCJFZmZlY3RNYW5hZ2VyIiwiRWZmZWN0IiwiUmVmbGVjdGlvbkVmZmVjdCIsImV4cGVyaW1lbnRhbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLGVBQVIsUUFBOEIsZ0JBQTlCOztBQUVBO0FBQ0EsU0FBUUMsS0FBUixFQUFlQyxjQUFmLEVBQStCQyxZQUEvQixFQUE2Q0MsZ0JBQTdDLFFBQW9FLE9BQXBFO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0MsT0FBaEM7QUFDQTtBQUNBLFNBQVFDLFdBQVdDLFFBQW5CLFFBQWtDLDBCQUFsQztBQUNBLFNBQVFELFdBQVdFLG1CQUFuQixRQUE2QyxzQ0FBN0M7QUFDQSxTQUFRRixXQUFXRyxvQkFBbkIsUUFBOEMsdUNBQTlDO0FBQ0EsU0FBUUgsV0FBV0ksbUJBQW5CLFFBQTZDLHVDQUE3Qzs7QUFFQTtBQUNBLFNBQVFKLFdBQVdLLFFBQW5CLFFBQWtDLG1DQUFsQztBQUNBLFNBQVFMLFdBQVdNLFNBQW5CLFFBQW1DLHFDQUFuQztBQUNBLFNBQVFOLFdBQVdPLFNBQW5CLFFBQW1DLHFDQUFuQztBQUNBLFNBQVFQLFdBQVdRLGVBQW5CLFFBQXlDLG1EQUF6QztBQUNBLFNBQVFSLFdBQVdTLGdCQUFuQixRQUEwQyxtREFBMUM7O0FBRUEsU0FBUVQsV0FBV1UsZUFBbkIsUUFBeUMsbURBQXpDO0FBQ0EsU0FBUVYsV0FBV1csU0FBbkIsUUFBbUMscUNBQW5DO0FBQ0EsU0FBUVgsV0FBV1ksYUFBbkIsUUFBdUMsK0NBQXZDOztBQUVBLFNBQVFaLFdBQVdhLFlBQW5CLFFBQXNDLDJDQUF0QztBQUNBLFNBQVFiLFdBQVdjLGdCQUFuQixRQUEwQyxxREFBMUM7O0FBRUEsU0FBUWQsV0FBV2UsU0FBbkIsUUFBbUMscUNBQW5DO0FBQ0EsU0FBUWYsV0FBV2dCLFlBQW5CLFFBQXNDLDJDQUF0QztBQUNBLFNBQVFoQixXQUFXaUIsWUFBbkIsUUFBc0MsMkNBQXRDOztBQUVBO0FBQ0EsU0FBUWpCLFdBQVdrQixlQUFuQixRQUF5Qyx1REFBekM7QUFDQSxTQUFRbEIsV0FBV21CLGlCQUFuQixRQUEyQyw2REFBM0M7QUFDQSxTQUFRbkIsV0FBV29CLHlCQUFuQixRQUFtRCwrRUFBbkQ7O0FBRUE7QUFDQSxTQUFRcEIsV0FBV3FCLE1BQW5CLFFBQWdDLGdCQUFoQztBQUNBLFNBQVFyQixPQUFSLFFBQWlDLGdCQUFqQzs7QUFFQTtBQUNBLFNBQVFzQixHQUFSLFFBQWtCLGlCQUFsQjtBQUNBLFNBQVFDLEtBQVIsUUFBb0IsbUJBQXBCO0FBQ0EsU0FBUUMsYUFBUixFQUF1QkMsTUFBdkIsUUFBb0Msb0JBQXBDO0FBQ0EsU0FBUXpCLFdBQVcwQixnQkFBbkIsUUFBMEMsMENBQTFDOztBQUVBLE9BQU8sSUFBTUMsZUFBZTtBQUMxQkwsVUFEMEI7QUFFMUJDLGNBRjBCO0FBRzFCQyw4QkFIMEI7QUFJMUJDLGdCQUowQjtBQUsxQkM7QUFMMEIsQ0FBckIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLy8gVXRpbGl0aWVzXG5leHBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi9zaGFkZXItdXRpbHMnO1xuXG4vLyBMaWJcbmV4cG9ydCB7TGF5ZXIsIENvbXBvc2l0ZUxheWVyLCBMYXllck1hbmFnZXIsIEF0dHJpYnV0ZU1hbmFnZXJ9IGZyb20gJy4vbGliJztcbmV4cG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vbGliJztcbi8vIFZpZXdwb3J0c1xuZXhwb3J0IHtkZWZhdWx0IGFzIFZpZXdwb3J0fSBmcm9tICcuL2xpYi92aWV3cG9ydHMvdmlld3BvcnQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBlcnNwZWN0aXZlVmlld3BvcnR9IGZyb20gJy4vbGliL3ZpZXdwb3J0cy9wZXJzcGVjdGl2ZS12aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgT3J0aG9ncmFwaGljVmlld3BvcnR9IGZyb20gJy4vbGliL3ZpZXdwb3J0cy9vcnRob2dyYXBoaWMtdmlld3BvcnQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdlYk1lcmNhdG9yVmlld3BvcnR9IGZyb20gJy4vbGliL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuXG4vLyBDb3JlIExheWVyc1xuZXhwb3J0IHtkZWZhdWx0IGFzIEFyY0xheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEljb25MYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIExpbmVMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBvaW50Q2xvdWRMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgU2NhdHRlcnBsb3RMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBTY3JlZW5HcmlkTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdyaWRMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdyaWRDZWxsTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBIZXhhZ29uTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWxheWVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBIZXhhZ29uQ2VsbExheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2hleGFnb24tY2VsbC1sYXllci9oZXhhZ29uLWNlbGwtbGF5ZXInO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgUGF0aExheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL3BhdGgtbGF5ZXIvcGF0aC1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgUG9seWdvbkxheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL3BvbHlnb24tbGF5ZXIvcG9seWdvbi1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgR2VvSnNvbkxheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllcic7XG5cbi8vIERlcHJlY2F0ZWQgTGF5ZXJzXG5leHBvcnQge2RlZmF1bHQgYXMgQ2hvcm9wbGV0aExheWVyfSBmcm9tICcuL2xheWVycy9kZXByZWNhdGVkL2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgQ2hvcm9wbGV0aExheWVyNjR9IGZyb20gJy4vbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLTY0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFeHRydWRlZENob3JvcGxldGhMYXllcjY0fSBmcm9tICcuL2xheWVycy9kZXByZWNhdGVkL2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NCc7XG5cbi8vIFJlYWN0IGV4cG9ydHNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEZWNrR0x9IGZyb20gJy4vcmVhY3QvZGVja2dsJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZWZhdWx0fSBmcm9tICcuL3JlYWN0L2RlY2tnbCc7XG5cbi8vIEV4cGVyaW1lbnRhbCBGZWF0dXJlcyAoTWF5IGNoYW5nZSBpbiBtaW5vciB2ZXJzaW9uIGJ1bXBzLCB1c2UgYXQgeW91ciBvd24gcmlzaylcbmltcG9ydCB7Z2V0fSBmcm9tICcuL2xpYi91dGlscy9nZXQnO1xuaW1wb3J0IHtjb3VudH0gZnJvbSAnLi9saWIvdXRpbHMvY291bnQnO1xuaW1wb3J0IHtFZmZlY3RNYW5hZ2VyLCBFZmZlY3R9IGZyb20gJy4vZXhwZXJpbWVudGFsL2xpYic7XG5pbXBvcnQge2RlZmF1bHQgYXMgUmVmbGVjdGlvbkVmZmVjdH0gZnJvbSAnLi9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdCc7XG5cbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWwgPSB7XG4gIGdldCxcbiAgY291bnQsXG4gIEVmZmVjdE1hbmFnZXIsXG4gIEVmZmVjdCxcbiAgUmVmbGVjdGlvbkVmZmVjdFxufTtcbiJdfQ==

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _deck = __webpack_require__(125);

var _deck2 = _interopRequireDefault(_deck);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

mapboxgl.accessToken = 'pk.eyJ1IjoibGl1aml1c2hlbmciLCJhIjoiY2owbHp4M3FmMDAyNTJxcDlqeWN0b3JnNSJ9.Pr8p9_jRlRD4I1w8-2V8NA';
var map = new mapboxgl.Map({
    container: 'map', // container id
    style: 'mapbox://styles/mapbox/streets-v9', //stylesheet location
    center: [80, 40], // starting position
    zoom: 4 // starting zoom
});
map.addControl(new mapboxgl.FullscreenControl());
map.on('load', function () {
    new _deck2.default({ gl: map });
});

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_hexbin__ = __webpack_require__(128);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__src_hexbin__["a"]; });



/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

/* harmony default export */ __webpack_exports__["a"] = (function() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) continue;

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) bin.push(point);
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
});


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* global process, window, global, document */
var isBrowser = (typeof process === 'undefined' ? 'undefined' : _typeof(process)) !== 'object' || String(process) !== '[object process]' || process.browser;

module.exports = {
  window: typeof window !== 'undefined' ? window : global,
  global: typeof global !== 'undefined' ? global : window,
  document: typeof document !== 'undefined' ? document : {},
  isBrowser: isBrowser
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cm9sbGVycy9nbG9iYWxzLmpzIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsInByb2Nlc3MiLCJTdHJpbmciLCJicm93c2VyIiwibW9kdWxlIiwiZXhwb3J0cyIsIndpbmRvdyIsImdsb2JhbCIsImRvY3VtZW50Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQSxJQUFNQSxZQUNKLFFBQU9DLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFDQUMsT0FBT0QsT0FBUCxNQUFvQixrQkFEcEIsSUFFQUEsUUFBUUUsT0FIVjs7QUFLQUMsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxVQUFRLE9BQU9BLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDQyxNQURsQztBQUVmQSxVQUFRLE9BQU9BLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDRCxNQUZsQztBQUdmRSxZQUFVLE9BQU9BLFFBQVAsS0FBb0IsV0FBcEIsR0FBa0NBLFFBQWxDLEdBQTZDLEVBSHhDO0FBSWZSO0FBSmUsQ0FBakIiLCJmaWxlIjoiZ2xvYmFscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFB1cnBvc2U6IGluY2x1ZGUgdGhpcyBpbiB5b3VyIG1vZHVsZSB0byBhdm9pZHMgYWRkaW5nIGRlcGVuZGVuY2llcyBvblxuLy8gbWljcm8gbW9kdWxlcyBsaWtlICdnbG9iYWwnIGFuZCAnaXMtYnJvd3Nlcic7XG5cbi8qIGdsb2JhbCBwcm9jZXNzLCB3aW5kb3csIGdsb2JhbCwgZG9jdW1lbnQgKi9cbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAnb2JqZWN0JyB8fFxuICBTdHJpbmcocHJvY2VzcykgIT09ICdbb2JqZWN0IHByb2Nlc3NdJyB8fFxuICBwcm9jZXNzLmJyb3dzZXI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsLFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge30sXG4gIGlzQnJvd3NlclxufTtcbiJdfQ==
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(24)))

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME reflection-effect-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D reflectionTexture;\nuniform int reflectionTextureWidth;\nuniform int reflectionTextureHeight;\n\nuniform float reflectivity;\nuniform float blur;\n\n\nvarying vec2 uv;\n\n#define KERNEL_SIZE 7\n\n/*\n * Samples from tex with a gaussian-shaped patch, centered at uv and\n * with standard deviation sigma.  The size of the texture in\n * pixels must be specified by dim\n */\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\n  if (sigma == 0.0) {\n    return texture2D(tex, uv);\n  }\n\n  vec2 delta = 1.0 / dim;\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\n\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\n      vec2 uv2 = top_left + vec2(i, j) * delta;\n      float d = length((uv2 - uv) * dim);\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\n      color += f * texture2D(tex, uv2);\n      sum += f;\n    }\n  }\n  return color / sum;\n}\n\nvoid main(void) {\n  //map blur in [0, 1] to sigma in [0, inf]\n  //alpha will determine the \"steepness\" of our curve.\n  //this was picked just to make the scale feel \"natural\"\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\n  //to a sigma of 1 pixels\n  float alpha = 1000.0;\n  float sigma = blur / (alpha * (1.0 - blur));\n  //let this be our standard deviation in terms of screen-widths.\n  //rewrite this in terms of pixels.\n  sigma *= float(reflectionTextureWidth);\n\n\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth,\n    reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\n  //color vector by reflectivity, not just the alpha channel\n  gl_FragColor *= reflectivity;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9yZWZsZWN0aW9uLWVmZmVjdC1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InJlZmxlY3Rpb24tZWZmZWN0LWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHJlZmxlY3Rpb24tZWZmZWN0LWZzXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHJlZmxlY3Rpb25UZXh0dXJlO1xudW5pZm9ybSBpbnQgcmVmbGVjdGlvblRleHR1cmVXaWR0aDtcbnVuaWZvcm0gaW50IHJlZmxlY3Rpb25UZXh0dXJlSGVpZ2h0O1xuXG51bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcbnVuaWZvcm0gZmxvYXQgYmx1cjtcblxuXG52YXJ5aW5nIHZlYzIgdXY7XG5cbiNkZWZpbmUgS0VSTkVMX1NJWkUgN1xuXG4vKlxuICogU2FtcGxlcyBmcm9tIHRleCB3aXRoIGEgZ2F1c3NpYW4tc2hhcGVkIHBhdGNoLCBjZW50ZXJlZCBhdCB1diBhbmRcbiAqIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNpZ21hLiAgVGhlIHNpemUgb2YgdGhlIHRleHR1cmUgaW5cbiAqIHBpeGVscyBtdXN0IGJlIHNwZWNpZmllZCBieSBkaW1cbiAqL1xudmVjNCBzYW1wbGVfZ2F1c3NpYW4oc2FtcGxlcjJEIHRleCwgdmVjMiBkaW0sIHZlYzIgdXYsIGZsb2F0IHNpZ21hKSB7XG4gIGlmIChzaWdtYSA9PSAwLjApIHtcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdXYpO1xuICB9XG5cbiAgdmVjMiBkZWx0YSA9IDEuMCAvIGRpbTtcbiAgdmVjMiB0b3BfbGVmdCA9IHV2IC0gZGVsdGEgKiBmbG9hdChLRVJORUxfU0laRSsxKSAvIDIuMDtcblxuICB2ZWM0IGNvbG9yID0gdmVjNCgwKTtcbiAgZmxvYXQgc3VtID0gMC4wO1xuICBmb3IgKGludCBpID0gMDsgaSA8ICBLRVJORUxfU0laRTsgKytpKSB7XG4gICAgZm9yIChpbnQgaiA9IDA7IGogPCBLRVJORUxfU0laRTsgKytqKSB7XG4gICAgICB2ZWMyIHV2MiA9IHRvcF9sZWZ0ICsgdmVjMihpLCBqKSAqIGRlbHRhO1xuICAgICAgZmxvYXQgZCA9IGxlbmd0aCgodXYyIC0gdXYpICogZGltKTtcbiAgICAgIGZsb2F0IGYgPSBleHAoLShkKmQpIC8gKDIuMCpzaWdtYSAqIHNpZ21hKSk7XG4gICAgICBjb2xvciArPSBmICogdGV4dHVyZTJEKHRleCwgdXYyKTtcbiAgICAgIHN1bSArPSBmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29sb3IgLyBzdW07XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vbWFwIGJsdXIgaW4gWzAsIDFdIHRvIHNpZ21hIGluIFswLCBpbmZdXG4gIC8vYWxwaGEgd2lsbCBkZXRlcm1pbmUgdGhlIFwic3RlZXBuZXNzXCIgb2Ygb3VyIGN1cnZlLlxuICAvL3RoaXMgd2FzIHBpY2tlZCBqdXN0IHRvIG1ha2UgdGhlIHNjYWxlIGZlZWwgXCJuYXR1cmFsXCJcbiAgLy9pZiBvdXIgaW1hZ2UgaXMgMTAwMCBwaXhlbHMgd2lkZSwgYSBibHVyIG9mIDAuNSBzaG91bGQgY29ycmVzcG9uZFxuICAvL3RvIGEgc2lnbWEgb2YgMSBwaXhlbHNcbiAgZmxvYXQgYWxwaGEgPSAxMDAwLjA7XG4gIGZsb2F0IHNpZ21hID0gYmx1ciAvIChhbHBoYSAqICgxLjAgLSBibHVyKSk7XG4gIC8vbGV0IHRoaXMgYmUgb3VyIHN0YW5kYXJkIGRldmlhdGlvbiBpbiB0ZXJtcyBvZiBzY3JlZW4td2lkdGhzLlxuICAvL3Jld3JpdGUgdGhpcyBpbiB0ZXJtcyBvZiBwaXhlbHMuXG4gIHNpZ21hICo9IGZsb2F0KHJlZmxlY3Rpb25UZXh0dXJlV2lkdGgpO1xuXG5cbiAgZ2xfRnJhZ0NvbG9yID0gc2FtcGxlX2dhdXNzaWFuKHJlZmxlY3Rpb25UZXh0dXJlLCB2ZWMyKHJlZmxlY3Rpb25UZXh0dXJlV2lkdGgsXG4gICAgcmVmbGVjdGlvblRleHR1cmVIZWlnaHQpLCB2ZWMyKHV2LngsIDEuIC0gdXYueSksIHNpZ21hKTtcbiAgLy9iZWNhdXNlIG91ciBjYW52YXMgZXhwZWN0cyBhbHBoYXMgdG8gYmUgcHJlLW11bHRpcGxpZWQsIHdlIG11bHRpcGx5IGJ5IHdob2xlXG4gIC8vY29sb3IgdmVjdG9yIGJ5IHJlZmxlY3Rpdml0eSwgbm90IGp1c3QgdGhlIGFscGhhIGNoYW5uZWxcbiAgZ2xfRnJhZ0NvbG9yICo9IHJlZmxlY3Rpdml0eTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME reflection-effect-vs\n\nattribute vec3 vertices;\n\nvarying vec2 uv;\n\nvoid main(void) {\n  uv = vertices.xy;\n  gl_Position = vec4(2. * vertices.xy - vec2(1., 1.), 1., 1.);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9yZWZsZWN0aW9uLWVmZmVjdC12ZXJ0ZXguZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJyZWZsZWN0aW9uLWVmZmVjdC12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcmVmbGVjdGlvbi1lZmZlY3QtdnNcblxuYXR0cmlidXRlIHZlYzMgdmVydGljZXM7XG5cbnZhcnlpbmcgdmVjMiB1djtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdXYgPSB2ZXJ0aWNlcy54eTtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KDIuICogdmVydGljZXMueHkgLSB2ZWMyKDEuLCAxLiksIDEuLCAxLik7XG59XG5gO1xuIl19

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_viewports__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reflection_effect_vertex_glsl__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__reflection_effect_fragment_glsl__ = __webpack_require__(130);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */








var ReflectionEffect = function (_Effect) {
  _inherits(ReflectionEffect, _Effect);

  /**
   * @classdesc
   * ReflectionEffect
   *
   * @class
   * @param reflectivity How visible reflections should be over the map, between 0 and 1
   * @param blur how blurry the reflection should be, between 0 and 1
   */

  function ReflectionEffect() {
    var reflectivity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var blur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

    _classCallCheck(this, ReflectionEffect);

    var _this = _possibleConstructorReturn(this, (ReflectionEffect.__proto__ || Object.getPrototypeOf(ReflectionEffect)).call(this));

    _this.reflectivity = reflectivity;
    _this.blur = blur;
    _this.framebuffer = null;
    _this.setNeedsRedraw();
    return _this;
  }

  _createClass(ReflectionEffect, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: __WEBPACK_IMPORTED_MODULE_4__reflection_effect_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_5__reflection_effect_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initialize',
    value: function initialize(_ref) {
      var gl = _ref.gl,
          layerManager = _ref.layerManager;

      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      this.unitQuad = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__["a" /* Model */]({
        gl: gl,
        id: 'reflection-effect',
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_0_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].TRIANGLE_FAN,
          vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])
        })
      });
      this.framebuffer = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__["d" /* Framebuffer */](gl, { depth: true });
    }
  }, {
    key: 'preDraw',
    value: function preDraw(_ref2) {
      var gl = _ref2.gl,
          layerManager = _ref2.layerManager;
      var viewport = layerManager.context.viewport;
      /*
       * the renderer already has a reference to this, but we don't have a reference to the renderer.
       * when we refactor the camera code, we should make sure we get a reference to the renderer so
       * that we can keep this in one place.
       */

      var dpi = typeof window !== 'undefined' && window.devicePixelRatio || 1;
      this.framebuffer.resize({ width: dpi * viewport.width, height: dpi * viewport.height });
      var pitch = viewport.pitch;
      this.framebuffer.bind();
      /* this is a huge hack around the existing viewport class.
       * TODO in the future, once we implement bona-fide cameras, we really need to fix this.
       */
      layerManager.setViewport(new __WEBPACK_IMPORTED_MODULE_3__lib_viewports__["a" /* WebMercatorViewport */](Object.assign({}, viewport, { pitch: -180 - pitch })));
      gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].DEPTH_BUFFER_BIT);

      layerManager.drawLayers({ pass: 'reflection' });
      layerManager.setViewport(viewport);
      this.framebuffer.unbind();
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var gl = _ref3.gl,
          layerManager = _ref3.layerManager;

      /*
       * Render our unit quad.
       * This will cover the entire screen, but will lie behind all other geometry.
       * This quad will sample the previously generated reflection texture
       * in order to create the reflection effect
       */
      this.unitQuad.render({
        reflectionTexture: this.framebuffer.texture,
        reflectionTextureWidth: this.framebuffer.width,
        reflectionTextureHeight: this.framebuffer.height,
        reflectivity: this.reflectivity,
        blur: this.blur
      });
    }
  }, {
    key: 'finalize',
    value: function finalize(_ref4) {
      /* TODO: Free resources? */

      var gl = _ref4.gl,
          layerManager = _ref4.layerManager;
    }
  }]);

  return ReflectionEffect;
}(__WEBPACK_IMPORTED_MODULE_2__lib__["b" /* Effect */]);

/* harmony default export */ __webpack_exports__["a"] = (ReflectionEffect);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9yZWZsZWN0aW9uLWVmZmVjdC5qcyJdLCJuYW1lcyI6WyJHTCIsIkZyYW1lYnVmZmVyIiwiTW9kZWwiLCJHZW9tZXRyeSIsImFzc2VtYmxlU2hhZGVycyIsIkVmZmVjdCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJyZWZsZWN0aW9uVmVydGV4IiwicmVmbGVjdGlvbkZyYWdtZW50IiwiUmVmbGVjdGlvbkVmZmVjdCIsInJlZmxlY3Rpdml0eSIsImJsdXIiLCJmcmFtZWJ1ZmZlciIsInNldE5lZWRzUmVkcmF3IiwidnMiLCJmcyIsIm1vZHVsZXMiLCJzaGFkZXJDYWNoZSIsImNvbnRleHQiLCJnbCIsImxheWVyTWFuYWdlciIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwidW5pdFF1YWQiLCJpZCIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRV9GQU4iLCJ2ZXJ0aWNlcyIsIkZsb2F0MzJBcnJheSIsImRlcHRoIiwidmlld3BvcnQiLCJkcGkiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVzaXplIiwid2lkdGgiLCJoZWlnaHQiLCJwaXRjaCIsImJpbmQiLCJzZXRWaWV3cG9ydCIsIk9iamVjdCIsImFzc2lnbiIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJkcmF3TGF5ZXJzIiwicGFzcyIsInVuYmluZCIsInJlbmRlciIsInJlZmxlY3Rpb25UZXh0dXJlIiwidGV4dHVyZSIsInJlZmxlY3Rpb25UZXh0dXJlV2lkdGgiLCJyZWZsZWN0aW9uVGV4dHVyZUhlaWdodCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFB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QWlCb0MsTUFBakI7QUFDRDs7O2dDQUV3QjtBQUFBLFVBQW5CN0IsRUFBbUIsU0FBbkJBLEVBQW1CO0FBQUEsVUFBZkMsWUFBZSxTQUFmQSxZQUFlOztBQUN2Qjs7Ozs7O0FBTUEsV0FBS0csUUFBTCxDQUFjMEIsTUFBZCxDQUFxQjtBQUNuQkMsMkJBQW1CLEtBQUt0QyxXQUFMLENBQWlCdUMsT0FEakI7QUFFbkJDLGdDQUF3QixLQUFLeEMsV0FBTCxDQUFpQndCLEtBRnRCO0FBR25CaUIsaUNBQXlCLEtBQUt6QyxXQUFMLENBQWlCeUIsTUFIdkI7QUFJbkIzQixzQkFBYyxLQUFLQSxZQUpBO0FBS25CQyxjQUFNLEtBQUtBO0FBTFEsT0FBckI7QUFPRDs7O29DQUU0QjtBQUMzQjs7QUFEMkIsVUFBbkJRLEVBQW1CLFNBQW5CQSxFQUFtQjtBQUFBLFVBQWZDLFlBQWUsU0FBZkEsWUFBZTtBQUU1Qjs7OztFQXZGMkNmLE07O2VBQXpCSSxnQiIsImZpbGUiOiJyZWZsZWN0aW9uLWVmZmVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBGcmFtZWJ1ZmZlciwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtFZmZlY3R9IGZyb20gJy4uLy4uL2xpYic7XG5pbXBvcnQge1dlYk1lcmNhdG9yVmlld3BvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi92aWV3cG9ydHMnO1xuXG5pbXBvcnQgcmVmbGVjdGlvblZlcnRleCBmcm9tICcuL3JlZmxlY3Rpb24tZWZmZWN0LXZlcnRleC5nbHNsJztcbmltcG9ydCByZWZsZWN0aW9uRnJhZ21lbnQgZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdC1mcmFnbWVudC5nbHNsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmbGVjdGlvbkVmZmVjdCBleHRlbmRzIEVmZmVjdCB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVmbGVjdGlvbkVmZmVjdFxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHJlZmxlY3Rpdml0eSBIb3cgdmlzaWJsZSByZWZsZWN0aW9ucyBzaG91bGQgYmUgb3ZlciB0aGUgbWFwLCBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHBhcmFtIGJsdXIgaG93IGJsdXJyeSB0aGUgcmVmbGVjdGlvbiBzaG91bGQgYmUsIGJldHdlZW4gMCBhbmQgMVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihyZWZsZWN0aXZpdHkgPSAwLjUsIGJsdXIgPSAwLjUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gcmVmbGVjdGl2aXR5O1xuICAgIHRoaXMuYmx1ciA9IGJsdXI7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IHJlZmxlY3Rpb25WZXJ0ZXgsXG4gICAgICBmczogcmVmbGVjdGlvbkZyYWdtZW50LFxuICAgICAgbW9kdWxlczogW10sXG4gICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemUoe2dsLCBsYXllck1hbmFnZXJ9KSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgdGhpcy51bml0UXVhZCA9IG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiAncmVmbGVjdGlvbi1lZmZlY3QnLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfRkFOLFxuICAgICAgICB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHtkZXB0aDogdHJ1ZX0pO1xuXG4gIH1cblxuICBwcmVEcmF3KHtnbCwgbGF5ZXJNYW5hZ2VyfSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSBsYXllck1hbmFnZXIuY29udGV4dDtcbiAgICAvKlxuICAgICAqIHRoZSByZW5kZXJlciBhbHJlYWR5IGhhcyBhIHJlZmVyZW5jZSB0byB0aGlzLCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG4gICAgICogd2hlbiB3ZSByZWZhY3RvciB0aGUgY2FtZXJhIGNvZGUsIHdlIHNob3VsZCBtYWtlIHN1cmUgd2UgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlciBzb1xuICAgICAqIHRoYXQgd2UgY2FuIGtlZXAgdGhpcyBpbiBvbmUgcGxhY2UuXG4gICAgICovXG4gICAgY29uc3QgZHBpID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHt3aWR0aDogZHBpICogdmlld3BvcnQud2lkdGgsIGhlaWdodDogZHBpICogdmlld3BvcnQuaGVpZ2h0fSk7XG4gICAgY29uc3QgcGl0Y2ggPSB2aWV3cG9ydC5waXRjaDtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmJpbmQoKTtcbiAgICAvKiB0aGlzIGlzIGEgaHVnZSBoYWNrIGFyb3VuZCB0aGUgZXhpc3Rpbmcgdmlld3BvcnQgY2xhc3MuXG4gICAgICogVE9ETyBpbiB0aGUgZnV0dXJlLCBvbmNlIHdlIGltcGxlbWVudCBib25hLWZpZGUgY2FtZXJhcywgd2UgcmVhbGx5IG5lZWQgdG8gZml4IHRoaXMuXG4gICAgICovXG4gICAgbGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0KFxuICAgICAgbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdmlld3BvcnQsIHtwaXRjaDogLTE4MCAtIHBpdGNofSkpXG4gICAgKTtcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICBsYXllck1hbmFnZXIuZHJhd0xheWVycyh7cGFzczogJ3JlZmxlY3Rpb24nfSk7XG4gICAgbGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLnVuYmluZCgpO1xuICB9XG5cbiAgZHJhdyh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgICAvKlxuICAgICAqIFJlbmRlciBvdXIgdW5pdCBxdWFkLlxuICAgICAqIFRoaXMgd2lsbCBjb3ZlciB0aGUgZW50aXJlIHNjcmVlbiwgYnV0IHdpbGwgbGllIGJlaGluZCBhbGwgb3RoZXIgZ2VvbWV0cnkuXG4gICAgICogVGhpcyBxdWFkIHdpbGwgc2FtcGxlIHRoZSBwcmV2aW91c2x5IGdlbmVyYXRlZCByZWZsZWN0aW9uIHRleHR1cmVcbiAgICAgKiBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHJlZmxlY3Rpb24gZWZmZWN0XG4gICAgICovXG4gICAgdGhpcy51bml0UXVhZC5yZW5kZXIoe1xuICAgICAgcmVmbGVjdGlvblRleHR1cmU6IHRoaXMuZnJhbWVidWZmZXIudGV4dHVyZSxcbiAgICAgIHJlZmxlY3Rpb25UZXh0dXJlV2lkdGg6IHRoaXMuZnJhbWVidWZmZXIud2lkdGgsXG4gICAgICByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDogdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQsXG4gICAgICByZWZsZWN0aXZpdHk6IHRoaXMucmVmbGVjdGl2aXR5LFxuICAgICAgYmx1cjogdGhpcy5ibHVyXG4gICAgfSk7XG4gIH1cblxuICBmaW5hbGl6ZSh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgICAvKiBUT0RPOiBGcmVlIHJlc291cmNlcz8gKi9cbiAgfVxufVxuIl19

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(40);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effects_reflection_effect__ = __webpack_require__(69);
/* unused harmony reexport ReflectionEffect */
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9leHBlcmltZW50YWwvaW5kZXguanMiXSwibmFtZXMiOlsiRWZmZWN0TWFuYWdlciIsIkVmZmVjdCIsImRlZmF1bHQiLCJSZWZsZWN0aW9uRWZmZWN0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVFBLGFBQVIsRUFBdUJDLE1BQXZCLFFBQW9DLE9BQXBDO0FBQ0EsU0FBUUMsV0FBV0MsZ0JBQW5CLFFBQTBDLDZCQUExQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuZXhwb3J0IHtFZmZlY3RNYW5hZ2VyLCBFZmZlY3R9IGZyb20gJy4vbGliJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSZWZsZWN0aW9uRWZmZWN0fSBmcm9tICcuL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QnO1xuIl19

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable no-try-catch */

var EffectManager = function () {
  function EffectManager(_ref) {
    var gl = _ref.gl,
        layerManager = _ref.layerManager;

    _classCallCheck(this, EffectManager);

    this.gl = gl;
    this.layerManager = layerManager;
    this._effects = [];
  }

  /**
   * Adds an effect to be managed.  That effect's initialize function will
   * be called, and the effect's preDraw and draw callbacks will be
   * called at the appropriate times in the render loop
   * @param {Effect} effect - the effect to be added
   */


  _createClass(EffectManager, [{
    key: "addEffect",
    value: function addEffect(effect) {
      this._effects.push(effect);
      this._sortEffects();
      effect.initialize({ gl: this.gl, layerManager: this.layerManager });
    }

    /**
     * Removes an effect that is already being managed.  That effect's
     * finalize function will be called, and its callbacks will no longer
     * be envoked in the render loop
     * @param {Effect} effect - the effect to be removed
     * @return {bool} - True if the effect was already being managed, and
     * thus successfully removed; false otherwise
     */

  }, {
    key: "removeEffect",
    value: function removeEffect(effect) {
      var i = this._effects.indexOf(effect);
      if (i >= 0) {
        effect.finalize({ gl: this.gl, layerManager: this.layerManager });
        this._effects.splice(i, 1);
        return true;
      }
      return false;
    }

    /**
     * Envoke the preDraw callback of all managed events, in order of
     * decreasing priority
     */

  }, {
    key: "preDraw",
    value: function preDraw() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          if (effect.needsRedraw) {
            effect.preDraw({ gl: this.gl, layerManager: this.layerManager });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Envoke the draw callback of all managed events, in order of
     * decreasing priority
     */

  }, {
    key: "draw",
    value: function draw() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var effect = _step2.value;

          if (effect.needsRedraw) {
            effect.draw({ gl: this.gl, layerManager: this.layerManager });
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_sortEffects",
    value: function _sortEffects() {
      this._effects.sort(function (a, b) {
        if (a.priority > b.priority) {
          return -1;
        } else if (a.priority < b.priority) {
          return 1;
        }
        return a.count - b.count;
      });
    }
  }]);

  return EffectManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (EffectManager);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvbGliL2VmZmVjdC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkVmZmVjdE1hbmFnZXIiLCJnbCIsImxheWVyTWFuYWdlciIsIl9lZmZlY3RzIiwiZWZmZWN0IiwicHVzaCIsIl9zb3J0RWZmZWN0cyIsImluaXRpYWxpemUiLCJpIiwiaW5kZXhPZiIsImZpbmFsaXplIiwic3BsaWNlIiwibmVlZHNSZWRyYXciLCJwcmVEcmF3IiwiZHJhdyIsInNvcnQiLCJhIiwiYiIsInByaW9yaXR5IiwiY291bnQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7SUFFcUJBLGE7QUFDbkIsK0JBQWdDO0FBQUEsUUFBbkJDLEVBQW1CLFFBQW5CQSxFQUFtQjtBQUFBLFFBQWZDLFlBQWUsUUFBZkEsWUFBZTs7QUFBQTs7QUFDOUIsU0FBS0QsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OEJBTVVDLE0sRUFBUTtBQUNoQixXQUFLRCxRQUFMLENBQWNFLElBQWQsQ0FBbUJELE1BQW5CO0FBQ0EsV0FBS0UsWUFBTDtBQUNBRixhQUFPRyxVQUFQLENBQWtCLEVBQUNOLElBQUksS0FBS0EsRUFBVixFQUFjQyxjQUFjLEtBQUtBLFlBQWpDLEVBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFhRSxNLEVBQVE7QUFDbkIsVUFBTUksSUFBSSxLQUFLTCxRQUFMLENBQWNNLE9BQWQsQ0FBc0JMLE1BQXRCLENBQVY7QUFDQSxVQUFJSSxLQUFLLENBQVQsRUFBWTtBQUNWSixlQUFPTSxRQUFQLENBQWdCLEVBQUNULElBQUksS0FBS0EsRUFBVixFQUFjQyxjQUFjLEtBQUtBLFlBQWpDLEVBQWhCO0FBQ0EsYUFBS0MsUUFBTCxDQUFjUSxNQUFkLENBQXFCSCxDQUFyQixFQUF3QixDQUF4QjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OEJBSVU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDUiw2QkFBcUIsS0FBS0wsUUFBMUIsOEhBQW9DO0FBQUEsY0FBekJDLE1BQXlCOztBQUNsQyxjQUFJQSxPQUFPUSxXQUFYLEVBQXdCO0FBQ3RCUixtQkFBT1MsT0FBUCxDQUFlLEVBQUNaLElBQUksS0FBS0EsRUFBVixFQUFjQyxjQUFjLEtBQUtBLFlBQWpDLEVBQWY7QUFDRDtBQUNGO0FBTE87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1UOztBQUVEOzs7Ozs7OzJCQUlPO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0wsOEJBQXFCLEtBQUtDLFFBQTFCLG1JQUFvQztBQUFBLGNBQXpCQyxNQUF5Qjs7QUFDbEMsY0FBSUEsT0FBT1EsV0FBWCxFQUF3QjtBQUN0QlIsbUJBQU9VLElBQVAsQ0FBWSxFQUFDYixJQUFJLEtBQUtBLEVBQVYsRUFBY0MsY0FBYyxLQUFLQSxZQUFqQyxFQUFaO0FBQ0Q7QUFDRjtBQUxJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNTjs7O21DQUVjO0FBQ2IsV0FBS0MsUUFBTCxDQUFjWSxJQUFkLENBQW1CLFVBQUNDLENBQUQsRUFBSUMsQ0FBSixFQUFVO0FBQzNCLFlBQUlELEVBQUVFLFFBQUYsR0FBYUQsRUFBRUMsUUFBbkIsRUFBNkI7QUFDM0IsaUJBQU8sQ0FBQyxDQUFSO0FBQ0QsU0FGRCxNQUVPLElBQUlGLEVBQUVFLFFBQUYsR0FBYUQsRUFBRUMsUUFBbkIsRUFBNkI7QUFDbEMsaUJBQU8sQ0FBUDtBQUNEO0FBQ0QsZUFBT0YsRUFBRUcsS0FBRixHQUFVRixFQUFFRSxLQUFuQjtBQUNELE9BUEQ7QUFRRDs7Ozs7O2VBdEVrQm5CLGEiLCJmaWxlIjoiZWZmZWN0LW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdHJ5LWNhdGNoICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVmZmVjdE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBsYXllck1hbmFnZXI7XG4gICAgdGhpcy5fZWZmZWN0cyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWZmZWN0IHRvIGJlIG1hbmFnZWQuICBUaGF0IGVmZmVjdCdzIGluaXRpYWxpemUgZnVuY3Rpb24gd2lsbFxuICAgKiBiZSBjYWxsZWQsIGFuZCB0aGUgZWZmZWN0J3MgcHJlRHJhdyBhbmQgZHJhdyBjYWxsYmFja3Mgd2lsbCBiZVxuICAgKiBjYWxsZWQgYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWVzIGluIHRoZSByZW5kZXIgbG9vcFxuICAgKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0IC0gdGhlIGVmZmVjdCB0byBiZSBhZGRlZFxuICAgKi9cbiAgYWRkRWZmZWN0KGVmZmVjdCkge1xuICAgIHRoaXMuX2VmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIHRoaXMuX3NvcnRFZmZlY3RzKCk7XG4gICAgZWZmZWN0LmluaXRpYWxpemUoe2dsOiB0aGlzLmdsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGJlaW5nIG1hbmFnZWQuICBUaGF0IGVmZmVjdCdzXG4gICAqIGZpbmFsaXplIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLCBhbmQgaXRzIGNhbGxiYWNrcyB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBlbnZva2VkIGluIHRoZSByZW5kZXIgbG9vcFxuICAgKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0IC0gdGhlIGVmZmVjdCB0byBiZSByZW1vdmVkXG4gICAqIEByZXR1cm4ge2Jvb2x9IC0gVHJ1ZSBpZiB0aGUgZWZmZWN0IHdhcyBhbHJlYWR5IGJlaW5nIG1hbmFnZWQsIGFuZFxuICAgKiB0aHVzIHN1Y2Nlc3NmdWxseSByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHJlbW92ZUVmZmVjdChlZmZlY3QpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgZWZmZWN0LmZpbmFsaXplKHtnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlcn0pO1xuICAgICAgdGhpcy5fZWZmZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVudm9rZSB0aGUgcHJlRHJhdyBjYWxsYmFjayBvZiBhbGwgbWFuYWdlZCBldmVudHMsIGluIG9yZGVyIG9mXG4gICAqIGRlY3JlYXNpbmcgcHJpb3JpdHlcbiAgICovXG4gIHByZURyYXcoKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5fZWZmZWN0cykge1xuICAgICAgaWYgKGVmZmVjdC5uZWVkc1JlZHJhdykge1xuICAgICAgICBlZmZlY3QucHJlRHJhdyh7Z2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXJ9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW52b2tlIHRoZSBkcmF3IGNhbGxiYWNrIG9mIGFsbCBtYW5hZ2VkIGV2ZW50cywgaW4gb3JkZXIgb2ZcbiAgICogZGVjcmVhc2luZyBwcmlvcml0eVxuICAgKi9cbiAgZHJhdygpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLl9lZmZlY3RzKSB7XG4gICAgICBpZiAoZWZmZWN0Lm5lZWRzUmVkcmF3KSB7XG4gICAgICAgIGVmZmVjdC5kcmF3KHtnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlcn0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zb3J0RWZmZWN0cygpIHtcbiAgICB0aGlzLl9lZmZlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLnByaW9yaXR5ID4gYi5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEucHJpb3JpdHkgPCBiLnByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEuY291bnQgLSBiLmNvdW50O1xuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var counter = 0;

var Effect = function () {
  function Effect() {
    _classCallCheck(this, Effect);

    this.count = counter++;
    this.visible = true;
    this.priority = 0;
    this.needsRedraw = false;
  }

  /**
   * subclasses should override to set up any resources needed
   */


  _createClass(Effect, [{
    key: "initialize",
    value: function initialize(_ref) {
      var gl = _ref.gl,
          layerManager = _ref.layerManager;
    }
    /**
     * and subclasses should free those resources here
     */

  }, {
    key: "finalize",
    value: function finalize(_ref2) {
      var gl = _ref2.gl,
          layerManager = _ref2.layerManager;
    }
    /**
     * override for a callback immediately before drawing each frame
     */

  }, {
    key: "preDraw",
    value: function preDraw(_ref3) {
      var gl = _ref3.gl,
          layerManager = _ref3.layerManager;
    }
    /**
     * override for a callback immediately after drawing a frame's layers
     */

  }, {
    key: "draw",
    value: function draw(_ref4) {
      var gl = _ref4.gl,
          layerManager = _ref4.layerManager;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = redraw;
    }
  }]);

  return Effect;
}();

/* harmony default export */ __webpack_exports__["a"] = (Effect);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvbGliL2VmZmVjdC5qcyJdLCJuYW1lcyI6WyJjb3VudGVyIiwiRWZmZWN0IiwiY291bnQiLCJ2aXNpYmxlIiwicHJpb3JpdHkiLCJuZWVkc1JlZHJhdyIsImdsIiwibGF5ZXJNYW5hZ2VyIiwicmVkcmF3Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsVUFBVSxDQUFkOztJQUVxQkMsTTtBQUVuQixvQkFBYztBQUFBOztBQUNaLFNBQUtDLEtBQUwsR0FBYUYsU0FBYjtBQUNBLFNBQUtHLE9BQUwsR0FBZSxJQUFmO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixDQUFoQjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsS0FBbkI7QUFDRDs7QUFFRDs7Ozs7OztxQ0FHK0I7QUFBQSxVQUFuQkMsRUFBbUIsUUFBbkJBLEVBQW1CO0FBQUEsVUFBZkMsWUFBZSxRQUFmQSxZQUFlO0FBQzlCO0FBQ0Q7Ozs7OztvQ0FHNkI7QUFBQSxVQUFuQkQsRUFBbUIsU0FBbkJBLEVBQW1CO0FBQUEsVUFBZkMsWUFBZSxTQUFmQSxZQUFlO0FBQzVCO0FBQ0Q7Ozs7OzttQ0FHNEI7QUFBQSxVQUFuQkQsRUFBbUIsU0FBbkJBLEVBQW1CO0FBQUEsVUFBZkMsWUFBZSxTQUFmQSxZQUFlO0FBQzNCO0FBQ0Q7Ozs7OztnQ0FHeUI7QUFBQSxVQUFuQkQsRUFBbUIsU0FBbkJBLEVBQW1CO0FBQUEsVUFBZkMsWUFBZSxTQUFmQSxZQUFlO0FBQ3hCOzs7cUNBRTZCO0FBQUEsVUFBZkMsTUFBZSx1RUFBTixJQUFNOztBQUM1QixXQUFLSCxXQUFMLEdBQW1CRyxNQUFuQjtBQUNEOzs7Ozs7ZUFoQ2tCUCxNIiwiZmlsZSI6ImVmZmVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5sZXQgY291bnRlciA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVmZmVjdCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKztcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdXAgYW55IHJlc291cmNlcyBuZWVkZWRcbiAgICovXG4gIGluaXRpYWxpemUoe2dsLCBsYXllck1hbmFnZXJ9KSB7XG4gIH1cbiAgLyoqXG4gICAqIGFuZCBzdWJjbGFzc2VzIHNob3VsZCBmcmVlIHRob3NlIHJlc291cmNlcyBoZXJlXG4gICAqL1xuICBmaW5hbGl6ZSh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgfVxuICAvKipcbiAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYmVmb3JlIGRyYXdpbmcgZWFjaCBmcmFtZVxuICAgKi9cbiAgcHJlRHJhdyh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgfVxuICAvKipcbiAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYWZ0ZXIgZHJhd2luZyBhIGZyYW1lJ3MgbGF5ZXJzXG4gICAqL1xuICBkcmF3KHtnbCwgbGF5ZXJNYW5hZ2VyfSkge1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME arc-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiYXJjLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGFyYy1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME arc-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\n\nuniform float numSegments;\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec4 instanceSourcePositions64 = vec4(instancePositions.x,\n    instancePositions64Low.x, instancePositions.y, instancePositions64Low.y);\n  vec4 instanceTargetPositions64 = vec4(instancePositions.z,\n    instancePositions64Low.z, instancePositions.w, instancePositions64Low.w);\n\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_to_clipspace_fp64(next_pos_modelspace);\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLXZlcnRleC02NC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImFyYy1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLXZlcnRleC1zaGFkZXItNjRcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVRhcmdldENvbG9ycztcblxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0TG93O1xuXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgbnVtU2VnbWVudHM7XG51bmlmb3JtIHZlYzIgdmlld3BvcnRTaXplO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudmVjMiBwYXJhYm9sb2lkX2ZwNjQodmVjMiBzb3VyY2VbMl0sIHZlYzIgdGFyZ2V0WzJdLCBmbG9hdCByYXRpbykge1xuXG4gIHZlYzIgeFsyXTtcbiAgdmVjMl9taXhfZnA2NChzb3VyY2UsIHRhcmdldCwgcmF0aW8sIHgpO1xuICB2ZWMyIGNlbnRlclsyXTtcbiAgdmVjMl9taXhfZnA2NChzb3VyY2UsIHRhcmdldCwgMC41LCBjZW50ZXIpO1xuXG4gIHZlYzIgZFNvdXJjZUNlbnRlciA9IHZlYzJfZGlzdGFuY2VfZnA2NChzb3VyY2UsIGNlbnRlcik7XG4gIHZlYzIgZFhDZW50ZXIgPSB2ZWMyX2Rpc3RhbmNlX2ZwNjQoeCwgY2VudGVyKTtcbiAgcmV0dXJuIG11bF9mcDY0KHN1bV9mcDY0KGRTb3VyY2VDZW50ZXIsIGRYQ2VudGVyKSwgc3ViX2ZwNjQoZFNvdXJjZUNlbnRlciwgZFhDZW50ZXIpKTtcbn1cblxuLy8gb2Zmc2V0IHZlY3RvciBieSBzdHJva2VXaWR0aCBwaXhlbHNcbi8vIG9mZnNldF9kaXJlY3Rpb24gaXMgLTEgKGxlZnQpIG9yIDEgKHJpZ2h0KVxudmVjMiBnZXRFeHRydXNpb25PZmZzZXQodmVjMiBsaW5lX2NsaXBzcGFjZSwgZmxvYXQgb2Zmc2V0X2RpcmVjdGlvbikge1xuICAvLyBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxuICB2ZWMyIGRpcl9zY3JlZW5zcGFjZSA9IG5vcm1hbGl6ZShsaW5lX2NsaXBzcGFjZSAqIHZpZXdwb3J0U2l6ZSk7XG4gIC8vIHJvdGF0ZSBieSA5MCBkZWdyZWVzXG4gIGRpcl9zY3JlZW5zcGFjZSA9IHZlYzIoLWRpcl9zY3JlZW5zcGFjZS55LCBkaXJfc2NyZWVuc3BhY2UueCk7XG5cbiAgdmVjMiBvZmZzZXRfc2NyZWVuc3BhY2UgPSBkaXJfc2NyZWVuc3BhY2UgKiBvZmZzZXRfZGlyZWN0aW9uICogc3Ryb2tlV2lkdGggLyAyLjA7XG4gIHZlYzIgb2Zmc2V0X2NsaXBzcGFjZSA9IG9mZnNldF9zY3JlZW5zcGFjZSAvIHZpZXdwb3J0U2l6ZSAqIDIuMDtcblxuICByZXR1cm4gb2Zmc2V0X2NsaXBzcGFjZTtcbn1cblxuZmxvYXQgZ2V0U2VnbWVudFJhdGlvKGZsb2F0IGluZGV4KSB7XG4gIHJldHVybiBzbW9vdGhzdGVwKDAuMCwgMS4wLCBpbmRleCAvIChudW1TZWdtZW50cyAtIDEuMCkpO1xufVxuXG52b2lkIGdldF9wb3NfZnA2NCh2ZWMyIHNvdXJjZVsyXSwgdmVjMiB0YXJnZXRbMl0sIGZsb2F0IHNlZ21lbnRSYXRpbywgb3V0IHZlYzIgcG9zaXRpb25bNF0pIHtcblxuICB2ZWMyIHZlcnRleF9oZWlnaHQgPSBwYXJhYm9sb2lkX2ZwNjQoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbyk7XG5cbiAgdmVjMiBwb3NpdGlvbl90ZW1wWzJdO1xuXG4gIHZlYzJfbWl4X2ZwNjQoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbywgcG9zaXRpb25fdGVtcCk7XG5cbiAgcG9zaXRpb25bMF0gPSBwb3NpdGlvbl90ZW1wWzBdO1xuICBwb3NpdGlvblsxXSA9IHBvc2l0aW9uX3RlbXBbMV07XG5cbiAgaWYgKHZlcnRleF9oZWlnaHQueCA8IDAuMCB8fCAodmVydGV4X2hlaWdodC54ID09IDAuMCAmJiB2ZXJ0ZXhfaGVpZ2h0LnkgPD0gMC4wKSkge1xuICAgIHZlcnRleF9oZWlnaHQgPSB2ZWMyKDAuMCwgMC4wKTtcbiAgfVxuXG4gIHBvc2l0aW9uWzJdID0gc3FydF9mcDY0KHZlcnRleF9oZWlnaHQpO1xuICBwb3NpdGlvblszXSA9IHZlYzIoMS4wLCAwLjApO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IGluc3RhbmNlU291cmNlUG9zaXRpb25zNjQgPSB2ZWM0KGluc3RhbmNlUG9zaXRpb25zLngsXG4gICAgaW5zdGFuY2VQb3NpdGlvbnM2NExvdy54LCBpbnN0YW5jZVBvc2l0aW9ucy55LCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LnkpO1xuICB2ZWM0IGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjQgPSB2ZWM0KGluc3RhbmNlUG9zaXRpb25zLnosXG4gICAgaW5zdGFuY2VQb3NpdGlvbnM2NExvdy56LCBpbnN0YW5jZVBvc2l0aW9ucy53LCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LncpO1xuXG4gIHZlYzIgcHJvamVjdGVkX3NvdXJjZV9jb29yZFsyXTtcbiAgdmVjMiBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkWzJdO1xuXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczY0LCBwcm9qZWN0ZWRfc291cmNlX2Nvb3JkKTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjQsIHByb2plY3RlZF90YXJnZXRfY29vcmQpO1xuXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xuICBmbG9hdCBzZWdtZW50UmF0aW8gPSBnZXRTZWdtZW50UmF0aW8oc2VnbWVudEluZGV4KTtcblxuICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBwb2ludCwgdXNlIG5leHQgLSBjdXJyZW50IGFzIGRpcmVjdGlvblxuICAvLyBvdGhlcndpc2UgdXNlIGN1cnJlbnQgLSBwcmV2XG4gIGZsb2F0IGluZGV4RGlyID0gbWl4KC0xLjAsIDEuMCwgc3RlcChzZWdtZW50SW5kZXgsIDAuMCkpO1xuICBmbG9hdCBuZXh0U2VnbWVudFJhdGlvID0gZ2V0U2VnbWVudFJhdGlvKHNlZ21lbnRJbmRleCArIGluZGV4RGlyKTtcblxuICB2ZWMyIGN1cnJfcG9zX21vZGVsc3BhY2VbNF07XG5cbiAgZ2V0X3Bvc19mcDY0KHByb2plY3RlZF9zb3VyY2VfY29vcmQsIHByb2plY3RlZF90YXJnZXRfY29vcmQsIHNlZ21lbnRSYXRpbyxcbiAgICBjdXJyX3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWMyIG5leHRfcG9zX21vZGVsc3BhY2VbNF07XG5cbiAgZ2V0X3Bvc19mcDY0KHByb2plY3RlZF9zb3VyY2VfY29vcmQsIHByb2plY3RlZF90YXJnZXRfY29vcmQsIG5leHRTZWdtZW50UmF0aW8sXG4gICAgbmV4dF9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgdmVjNCBjdXJyX3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KGN1cnJfcG9zX21vZGVsc3BhY2UpO1xuICB2ZWM0IG5leHRfcG9zX2NsaXBzcGFjZSA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQobmV4dF9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQobmV4dF9wb3NfY2xpcHNwYWNlLnh5IC0gY3Vycl9wb3NfY2xpcHNwYWNlLnh5LCBwb3NpdGlvbnMueSk7XG5cbiAgZ2xfUG9zaXRpb24gPSBjdXJyX3Bvc19jbGlwc3BhY2UgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xuXG4gIHZlYzQgY29sb3IgPSBtaXgoaW5zdGFuY2VTb3VyY2VDb2xvcnMsIGluc3RhbmNlVGFyZ2V0Q29sb3JzLCBzZWdtZW50UmF0aW8pIC8gMjU1LjtcblxuICB2Q29sb3IgPSBtaXgoXG4gICAgdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiBvcGFjaXR5KSxcbiAgICB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKSxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXG4gICk7XG59XG5gO1xuIl19

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec3 instancePickingColors;\n\nuniform float numSegments;\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(instancePositions.xy);\n  vec2 target = project_position(instancePositions.zw);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_to_clipspace(vec4(nextPos, 1.0));\n\n  // extrude\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLXZlcnRleC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImFyYy1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLXZlcnRleC1zaGFkZXJcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVRhcmdldENvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IG51bVNlZ21lbnRzO1xudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbmZsb2F0IHBhcmFib2xvaWQodmVjMiBzb3VyY2UsIHZlYzIgdGFyZ2V0LCBmbG9hdCByYXRpbykge1xuXG4gIHZlYzIgeCA9IG1peChzb3VyY2UsIHRhcmdldCwgcmF0aW8pO1xuICB2ZWMyIGNlbnRlciA9IG1peChzb3VyY2UsIHRhcmdldCwgMC41KTtcblxuICBmbG9hdCBkU291cmNlQ2VudGVyID0gZGlzdGFuY2Uoc291cmNlLCBjZW50ZXIpO1xuICBmbG9hdCBkWENlbnRlciA9IGRpc3RhbmNlKHgsIGNlbnRlcik7XG4gIHJldHVybiAoZFNvdXJjZUNlbnRlciArIGRYQ2VudGVyKSAqIChkU291cmNlQ2VudGVyIC0gZFhDZW50ZXIpO1xufVxuXG4vLyBvZmZzZXQgdmVjdG9yIGJ5IHN0cm9rZVdpZHRoIHBpeGVsc1xuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCBmbG9hdCBvZmZzZXRfZGlyZWN0aW9uKSB7XG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogdmlld3BvcnRTaXplKTtcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcblxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBzdHJva2VXaWR0aCAvIDIuMDtcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gdmlld3BvcnRTaXplICogMi4wO1xuXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xufVxuXG5mbG9hdCBnZXRTZWdtZW50UmF0aW8oZmxvYXQgaW5kZXgpIHtcbiAgcmV0dXJuIHNtb290aHN0ZXAoMC4wLCAxLjAsIGluZGV4IC8gKG51bVNlZ21lbnRzIC0gMS4wKSk7XG59XG5cbnZlYzMgZ2V0UG9zKHZlYzIgc291cmNlLCB2ZWMyIHRhcmdldCwgZmxvYXQgc2VnbWVudFJhdGlvKSB7XG4gIGZsb2F0IHZlcnRleF9oZWlnaHQgPSBwYXJhYm9sb2lkKHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pO1xuXG4gIHJldHVybiB2ZWMzKFxuICAgIG1peChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvKSxcbiAgICBzcXJ0KG1heCgwLjAsIHZlcnRleF9oZWlnaHQpKVxuICApO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWMyIHNvdXJjZSA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpO1xuICB2ZWMyIHRhcmdldCA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMuencpO1xuXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xuICBmbG9hdCBzZWdtZW50UmF0aW8gPSBnZXRTZWdtZW50UmF0aW8oc2VnbWVudEluZGV4KTtcbiAgLy8gaWYgaXQncyB0aGUgZmlyc3QgcG9pbnQsIHVzZSBuZXh0IC0gY3VycmVudCBhcyBkaXJlY3Rpb25cbiAgLy8gb3RoZXJ3aXNlIHVzZSBjdXJyZW50IC0gcHJldlxuICBmbG9hdCBpbmRleERpciA9IG1peCgtMS4wLCAxLjAsIHN0ZXAoc2VnbWVudEluZGV4LCAwLjApKTtcbiAgZmxvYXQgbmV4dFNlZ21lbnRSYXRpbyA9IGdldFNlZ21lbnRSYXRpbyhzZWdtZW50SW5kZXggKyBpbmRleERpcik7XG5cbiAgdmVjMyBjdXJyUG9zID0gZ2V0UG9zKHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pO1xuICB2ZWMzIG5leHRQb3MgPSBnZXRQb3Moc291cmNlLCB0YXJnZXQsIG5leHRTZWdtZW50UmF0aW8pO1xuICB2ZWM0IGN1cnIgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KGN1cnJQb3MsIDEuMCkpO1xuICB2ZWM0IG5leHQgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KG5leHRQb3MsIDEuMCkpO1xuXG4gIC8vIGV4dHJ1ZGVcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQoKG5leHQueHkgLSBjdXJyLnh5KSAqIGluZGV4RGlyLCBwb3NpdGlvbnMueSk7XG4gIGdsX1Bvc2l0aW9uID0gY3VyciArIHZlYzQob2Zmc2V0LCAwLjAsIDAuMCk7XG5cbiAgdmVjNCBjb2xvciA9IG1peChpbnN0YW5jZVNvdXJjZUNvbG9ycywgaW5zdGFuY2VUYXJnZXRDb2xvcnMsIHNlZ21lbnRSYXRpbykgLyAyNTUuO1xuXG4gIHZDb2xvciA9IG1peChcbiAgICB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIG9wYWNpdHkpLFxuICAgIHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pLFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcbiAgKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__arc_layer_vertex_glsl__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__arc_layer_vertex_64_glsl__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__ = __webpack_require__(136);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [0, 0, 0, 255];

var defaultProps = {
  strokeWidth: 1,
  fp64: false,

  getSourcePosition: function getSourcePosition(x) {
    return x.sourcePosition;
  },
  getTargetPosition: function getTargetPosition(x) {
    return x.targetPosition;
  },
  getSourceColor: function getSourceColor(x) {
    return x.color || DEFAULT_COLOR;
  },
  getTargetColor: function getTargetColor(x) {
    return x.color || DEFAULT_COLOR;
  }
};

var ArcLayer = function (_Layer) {
  _inherits(ArcLayer, _Layer);

  function ArcLayer() {
    _classCallCheck(this, ArcLayer);

    return _possibleConstructorReturn(this, (ArcLayer.__proto__ || Object.getPrototypeOf(ArcLayer)).apply(this, arguments));
  }

  _createClass(ArcLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__arc_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__arc_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      var attributeManager = this.state.attributeManager;

      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 4, accessor: ['getSourcePosition', 'getTargetPosition'], update: this.calculateInstancePositions },
        instanceSourceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getSourceColor', update: this.calculateInstanceSourceColors },
        instanceTargetColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getTargetColor', update: this.calculateInstanceTargetColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64Low: {
              size: 4,
              accessor: ['getSourcePosition', 'getTargetPosition'],
              update: this.calculateInstancePositions64Low
            }
          });
        } else {
          attributeManager.remove(['instancePositions64Low']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(ArcLayer.prototype.__proto__ || Object.getPrototypeOf(ArcLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      // Re-generate model if geometry changed
      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var strokeWidth = this.props.strokeWidth;


      this.state.model.render(Object.assign({}, uniforms, {
        strokeWidth: strokeWidth
      }));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var positions = [];
      var NUM_SEGMENTS = 50;
      /*
       *  (0, -1)-------------_(1, -1)
       *       |          _,-"  |
       *       o      _,-"      o
       *       |  _,-"          |
       *   (0, 1)"-------------(1, 1)
       */
      for (var i = 0; i < NUM_SEGMENTS; i++) {
        positions = positions.concat([i, -1, 0, i, 1, 0]);
      }

      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());
      var model = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLE_STRIP,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      });

      model.setUniforms({ numSegments: NUM_SEGMENTS });

      return model;
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props = this.props,
          data = _props.data,
          getSourcePosition = _props.getSourcePosition,
          getTargetPosition = _props.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var sourcePosition = getSourcePosition(object);
          var targetPosition = getTargetPosition(object);
          value[i + 0] = sourcePosition[0];
          value[i + 1] = sourcePosition[1];
          value[i + 2] = targetPosition[0];
          value[i + 3] = targetPosition[1];
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64Low',
    value: function calculateInstancePositions64Low(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getSourcePosition = _props2.getSourcePosition,
          getTargetPosition = _props2.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var sourcePosition = getSourcePosition(object);
          var targetPosition = getTargetPosition(object);
          value[i + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(sourcePosition[0])[1];
          value[i + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(sourcePosition[1])[1];
          value[i + 2] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(targetPosition[0])[1];
          value[i + 3] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(targetPosition[1])[1];
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceSourceColors',
    value: function calculateInstanceSourceColors(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getSourceColor = _props3.getSourceColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          var color = getSourceColor(object);
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? 255 : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceTargetColors',
    value: function calculateInstanceTargetColors(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getTargetColor = _props4.getTargetColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;

          var color = getTargetColor(object);
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? 255 : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);

  return ArcLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (ArcLayer);


ArcLayer.layerName = 'ArcLayer';
ArcLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiYXNzZW1ibGVTaGFkZXJzIiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwiZnA2NGlmeSIsImVuYWJsZTY0Yml0U3VwcG9ydCIsIkNPT1JESU5BVEVfU1lTVEVNIiwiYXJjVmVydGV4IiwiYXJjVmVydGV4NjQiLCJhcmNGcmFnbWVudCIsIkRFRkFVTFRfQ09MT1IiLCJkZWZhdWx0UHJvcHMiLCJzdHJva2VXaWR0aCIsImZwNjQiLCJnZXRTb3VyY2VQb3NpdGlvbiIsIngiLCJzb3VyY2VQb3NpdGlvbiIsImdldFRhcmdldFBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJnZXRTb3VyY2VDb2xvciIsImNvbG9yIiwiZ2V0VGFyZ2V0Q29sb3IiLCJBcmNMYXllciIsInByb3BzIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJzaGFkZXJDYWNoZSIsImNvbnRleHQiLCJnbCIsInNldFN0YXRlIiwibW9kZWwiLCJfZ2V0TW9kZWwiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBvc2l0aW9ucyIsInNpemUiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIiwiaW5zdGFuY2VTb3VyY2VDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlU291cmNlQ29sb3JzIiwiaW5zdGFuY2VUYXJnZXRDb2xvcnMiLCJjYWxjdWxhdGVJbnN0YW5jZVRhcmdldENvbG9ycyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJpbnZhbGlkYXRlQWxsIiwicHJvamVjdGlvbk1vZGUiLCJMTkdMQVQiLCJpbnN0YW5jZVBvc2l0aW9uczY0TG93IiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NExvdyIsInJlbW92ZSIsInVwZGF0ZUF0dHJpYnV0ZSIsInVuaWZvcm1zIiwicmVuZGVyIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiTlVNX1NFR01FTlRTIiwiaSIsImNvbmNhdCIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIlRSSUFOR0xFX1NUUklQIiwiRmxvYXQzMkFycmF5IiwiaXNJbnN0YW5jZWQiLCJzZXRVbmlmb3JtcyIsIm51bVNlZ21lbnRzIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwib2JqZWN0IiwiaXNOYU4iLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDO0FBQ0EsU0FBUUMsT0FBUixFQUFpQkMsa0JBQWpCLFFBQTBDLHlCQUExQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDOztBQUVBLE9BQU9DLFNBQVAsTUFBc0IseUJBQXRCO0FBQ0EsT0FBT0MsV0FBUCxNQUF3Qiw0QkFBeEI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLDJCQUF4Qjs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQXRCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLGVBQWEsQ0FETTtBQUVuQkMsUUFBTSxLQUZhOztBQUluQkMscUJBQW1CO0FBQUEsV0FBS0MsRUFBRUMsY0FBUDtBQUFBLEdBSkE7QUFLbkJDLHFCQUFtQjtBQUFBLFdBQUtGLEVBQUVHLGNBQVA7QUFBQSxHQUxBO0FBTW5CQyxrQkFBZ0I7QUFBQSxXQUFLSixFQUFFSyxLQUFGLElBQVdWLGFBQWhCO0FBQUEsR0FORztBQU9uQlcsa0JBQWdCO0FBQUEsV0FBS04sRUFBRUssS0FBRixJQUFXVixhQUFoQjtBQUFBO0FBUEcsQ0FBckI7O0lBVXFCWSxROzs7Ozs7Ozs7OztpQ0FDTjtBQUNYLGFBQU9qQixtQkFBbUIsS0FBS2tCLEtBQXhCLElBQWlDO0FBQ3RDQyxZQUFJaEIsV0FEa0M7QUFFdENpQixZQUFJaEIsV0FGa0M7QUFHdENpQixpQkFBUyxDQUFDLE1BQUQsRUFBUyxXQUFULENBSDZCO0FBSXRDQyxxQkFBYSxLQUFLQyxPQUFMLENBQWFEO0FBSlksT0FBakMsR0FLSDtBQUNGSCxZQUFJakIsU0FERjtBQUVGa0IsWUFBSWhCLFdBRkY7QUFHRmlCLGlCQUFTLEVBSFA7QUFJRkMscUJBQWEsS0FBS0MsT0FBTCxDQUFhRDtBQUp4QixPQUxKO0FBV0Q7OztzQ0FFaUI7QUFBQSxVQUNURSxFQURTLEdBQ0gsS0FBS0QsT0FERixDQUNUQyxFQURTOztBQUVoQixXQUFLQyxRQUFMLENBQWMsRUFBQ0MsT0FBTyxLQUFLQyxTQUFMLENBQWVILEVBQWYsQ0FBUixFQUFkOztBQUZnQixVQUlUSSxnQkFKUyxHQUlXLEtBQUtDLEtBSmhCLENBSVRELGdCQUpTOztBQU1oQjs7QUFDQUEsdUJBQWlCRSxZQUFqQixDQUE4QjtBQUM1QkMsMkJBQW1CLEVBQUNDLE1BQU0sQ0FBUCxFQUFVQyxVQUFVLENBQUMsbUJBQUQsRUFBc0IsbUJBQXRCLENBQXBCLEVBQWdFQyxRQUFRLEtBQUtDLDBCQUE3RSxFQURTO0FBRTVCQyw4QkFBc0IsRUFBQ0osTUFBTSxDQUFQLEVBQVVLLE1BQU16QyxHQUFHMEMsYUFBbkIsRUFBa0NMLFVBQVUsZ0JBQTVDLEVBQThEQyxRQUFRLEtBQUtLLDZCQUEzRSxFQUZNO0FBRzVCQyw4QkFBc0IsRUFBQ1IsTUFBTSxDQUFQLEVBQVVLLE1BQU16QyxHQUFHMEMsYUFBbkIsRUFBa0NMLFVBQVUsZ0JBQTVDLEVBQThEQyxRQUFRLEtBQUtPLDZCQUEzRTtBQUhNLE9BQTlCO0FBS0E7QUFDRDs7OzBDQUUrQztBQUFBLFVBQS9CdkIsS0FBK0IsUUFBL0JBLEtBQStCO0FBQUEsVUFBeEJ3QixRQUF3QixRQUF4QkEsUUFBd0I7QUFBQSxVQUFkQyxXQUFjLFFBQWRBLFdBQWM7O0FBQzlDLFVBQUl6QixNQUFNVixJQUFOLEtBQWVrQyxTQUFTbEMsSUFBNUIsRUFBa0M7QUFBQSxZQUN6Qm9CLGdCQUR5QixHQUNMLEtBQUtDLEtBREEsQ0FDekJELGdCQUR5Qjs7QUFFaENBLHlCQUFpQmdCLGFBQWpCOztBQUVBLFlBQUkxQixNQUFNVixJQUFOLElBQWNVLE1BQU0yQixjQUFOLEtBQXlCNUMsa0JBQWtCNkMsTUFBN0QsRUFBcUU7QUFDbkVsQiwyQkFBaUJFLFlBQWpCLENBQThCO0FBQzVCaUIsb0NBQXdCO0FBQ3RCZixvQkFBTSxDQURnQjtBQUV0QkMsd0JBQVUsQ0FBQyxtQkFBRCxFQUFzQixtQkFBdEIsQ0FGWTtBQUd0QkMsc0JBQVEsS0FBS2M7QUFIUztBQURJLFdBQTlCO0FBT0QsU0FSRCxNQVFPO0FBQ0xwQiwyQkFBaUJxQixNQUFqQixDQUF3QixDQUN0Qix3QkFEc0IsQ0FBeEI7QUFHRDtBQUVGO0FBQ0Y7Ozt1Q0FFMkM7QUFBQSxVQUEvQi9CLEtBQStCLFNBQS9CQSxLQUErQjtBQUFBLFVBQXhCd0IsUUFBd0IsU0FBeEJBLFFBQXdCO0FBQUEsVUFBZEMsV0FBYyxTQUFkQSxXQUFjOztBQUMxQyxzSEFBa0IsRUFBQ3pCLFlBQUQsRUFBUXdCLGtCQUFSLEVBQWtCQyx3QkFBbEIsRUFBbEI7QUFDQTtBQUNBLFVBQUl6QixNQUFNVixJQUFOLEtBQWVrQyxTQUFTbEMsSUFBNUIsRUFBa0M7QUFBQSxZQUN6QmdCLEVBRHlCLEdBQ25CLEtBQUtELE9BRGMsQ0FDekJDLEVBRHlCOztBQUVoQyxhQUFLQyxRQUFMLENBQWMsRUFBQ0MsT0FBTyxLQUFLQyxTQUFMLENBQWVILEVBQWYsQ0FBUixFQUFkO0FBQ0Q7QUFDRCxXQUFLMEIsZUFBTCxDQUFxQixFQUFDaEMsWUFBRCxFQUFRd0Isa0JBQVIsRUFBa0JDLHdCQUFsQixFQUFyQjtBQUNEOzs7Z0NBRWdCO0FBQUEsVUFBWFEsUUFBVyxTQUFYQSxRQUFXO0FBQUEsVUFDUjVDLFdBRFEsR0FDTyxLQUFLVyxLQURaLENBQ1JYLFdBRFE7OztBQUdmLFdBQUtzQixLQUFMLENBQVdILEtBQVgsQ0FBaUIwQixNQUFqQixDQUF3QkMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILFFBQWxCLEVBQTRCO0FBQ2xENUM7QUFEa0QsT0FBNUIsQ0FBeEI7QUFHRDs7OzhCQUVTaUIsRSxFQUFJO0FBQ1osVUFBSStCLFlBQVksRUFBaEI7QUFDQSxVQUFNQyxlQUFlLEVBQXJCO0FBQ0E7Ozs7Ozs7QUFPQSxXQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsWUFBcEIsRUFBa0NDLEdBQWxDLEVBQXVDO0FBQ3JDRixvQkFBWUEsVUFBVUcsTUFBVixDQUFpQixDQUFDRCxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixFQUFXQSxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFqQixDQUFaO0FBQ0Q7O0FBRUQsVUFBTUUsVUFBVWhFLGdCQUFnQjZCLEVBQWhCLEVBQW9CLEtBQUtvQyxVQUFMLEVBQXBCLENBQWhCO0FBQ0EsVUFBTWxDLFFBQVEsSUFBSTdCLEtBQUosQ0FBVTtBQUN0QjJCLGNBRHNCO0FBRXRCTCxZQUFJd0MsUUFBUXhDLEVBRlU7QUFHdEJDLFlBQUl1QyxRQUFRdkMsRUFIVTtBQUl0QnlDLGtCQUFVLElBQUkvRCxRQUFKLENBQWE7QUFDckJnRSxvQkFBVWxFLEdBQUdtRSxjQURRO0FBRXJCUixxQkFBVyxJQUFJUyxZQUFKLENBQWlCVCxTQUFqQjtBQUZVLFNBQWIsQ0FKWTtBQVF0QlUscUJBQWE7QUFSUyxPQUFWLENBQWQ7O0FBV0F2QyxZQUFNd0MsV0FBTixDQUFrQixFQUFDQyxhQUFhWCxZQUFkLEVBQWxCOztBQUVBLGFBQU85QixLQUFQO0FBQ0Q7OzsrQ0FFMEIwQyxTLEVBQVc7QUFBQSxtQkFDaUIsS0FBS2xELEtBRHRCO0FBQUEsVUFDN0JtRCxJQUQ2QixVQUM3QkEsSUFENkI7QUFBQSxVQUN2QjVELGlCQUR1QixVQUN2QkEsaUJBRHVCO0FBQUEsVUFDSkcsaUJBREksVUFDSkEsaUJBREk7QUFBQSxVQUU3QjBELEtBRjZCLEdBRWRGLFNBRmMsQ0FFN0JFLEtBRjZCO0FBQUEsVUFFdEJ0QyxJQUZzQixHQUVkb0MsU0FGYyxDQUV0QnBDLElBRnNCOztBQUdwQyxVQUFJeUIsSUFBSSxDQUFSO0FBSG9DO0FBQUE7QUFBQTs7QUFBQTtBQUlwQyw2QkFBcUJZLElBQXJCLDhIQUEyQjtBQUFBLGNBQWhCRSxNQUFnQjs7QUFDekIsY0FBTTVELGlCQUFpQkYsa0JBQWtCOEQsTUFBbEIsQ0FBdkI7QUFDQSxjQUFNMUQsaUJBQWlCRCxrQkFBa0IyRCxNQUFsQixDQUF2QjtBQUNBRCxnQkFBTWIsSUFBSSxDQUFWLElBQWU5QyxlQUFlLENBQWYsQ0FBZjtBQUNBMkQsZ0JBQU1iLElBQUksQ0FBVixJQUFlOUMsZUFBZSxDQUFmLENBQWY7QUFDQTJELGdCQUFNYixJQUFJLENBQVYsSUFBZTVDLGVBQWUsQ0FBZixDQUFmO0FBQ0F5RCxnQkFBTWIsSUFBSSxDQUFWLElBQWU1QyxlQUFlLENBQWYsQ0FBZjtBQUNBNEMsZUFBS3pCLElBQUw7QUFDRDtBQVptQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYXJDOzs7b0RBRStCb0MsUyxFQUFXO0FBQUEsb0JBQ1ksS0FBS2xELEtBRGpCO0FBQUEsVUFDbENtRCxJQURrQyxXQUNsQ0EsSUFEa0M7QUFBQSxVQUM1QjVELGlCQUQ0QixXQUM1QkEsaUJBRDRCO0FBQUEsVUFDVEcsaUJBRFMsV0FDVEEsaUJBRFM7QUFBQSxVQUVsQzBELEtBRmtDLEdBRW5CRixTQUZtQixDQUVsQ0UsS0FGa0M7QUFBQSxVQUUzQnRDLElBRjJCLEdBRW5Cb0MsU0FGbUIsQ0FFM0JwQyxJQUYyQjs7QUFHekMsVUFBSXlCLElBQUksQ0FBUjtBQUh5QztBQUFBO0FBQUE7O0FBQUE7QUFJekMsOEJBQXFCWSxJQUFyQixtSUFBMkI7QUFBQSxjQUFoQkUsTUFBZ0I7O0FBQ3pCLGNBQU01RCxpQkFBaUJGLGtCQUFrQjhELE1BQWxCLENBQXZCO0FBQ0EsY0FBTTFELGlCQUFpQkQsa0JBQWtCMkQsTUFBbEIsQ0FBdkI7QUFDQUQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUQsUUFBUVksZUFBZSxDQUFmLENBQVIsRUFBMkIsQ0FBM0IsQ0FBZjtBQUNBMkQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUQsUUFBUVksZUFBZSxDQUFmLENBQVIsRUFBMkIsQ0FBM0IsQ0FBZjtBQUNBMkQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUQsUUFBUWMsZUFBZSxDQUFmLENBQVIsRUFBMkIsQ0FBM0IsQ0FBZjtBQUNBeUQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUQsUUFBUWMsZUFBZSxDQUFmLENBQVIsRUFBMkIsQ0FBM0IsQ0FBZjtBQUNBNEMsZUFBS3pCLElBQUw7QUFDRDtBQVp3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYTFDOzs7a0RBRTZCb0MsUyxFQUFXO0FBQUEsb0JBQ1IsS0FBS2xELEtBREc7QUFBQSxVQUNoQ21ELElBRGdDLFdBQ2hDQSxJQURnQztBQUFBLFVBQzFCdkQsY0FEMEIsV0FDMUJBLGNBRDBCO0FBQUEsVUFFaEN3RCxLQUZnQyxHQUVqQkYsU0FGaUIsQ0FFaENFLEtBRmdDO0FBQUEsVUFFekJ0QyxJQUZ5QixHQUVqQm9DLFNBRmlCLENBRXpCcEMsSUFGeUI7O0FBR3ZDLFVBQUl5QixJQUFJLENBQVI7QUFIdUM7QUFBQTtBQUFBOztBQUFBO0FBSXZDLDhCQUFxQlksSUFBckIsbUlBQTJCO0FBQUEsY0FBaEJFLE1BQWdCOztBQUN6QixjQUFNeEQsUUFBUUQsZUFBZXlELE1BQWYsQ0FBZDtBQUNBRCxnQkFBTWIsSUFBSSxDQUFWLElBQWUxQyxNQUFNLENBQU4sQ0FBZjtBQUNBdUQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUMsTUFBTSxDQUFOLENBQWY7QUFDQXVELGdCQUFNYixJQUFJLENBQVYsSUFBZTFDLE1BQU0sQ0FBTixDQUFmO0FBQ0F1RCxnQkFBTWIsSUFBSSxDQUFWLElBQWVlLE1BQU16RCxNQUFNLENBQU4sQ0FBTixJQUFrQixHQUFsQixHQUF3QkEsTUFBTSxDQUFOLENBQXZDO0FBQ0EwQyxlQUFLekIsSUFBTDtBQUNEO0FBWHNDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZeEM7OztrREFFNkJvQyxTLEVBQVc7QUFBQSxvQkFDUixLQUFLbEQsS0FERztBQUFBLFVBQ2hDbUQsSUFEZ0MsV0FDaENBLElBRGdDO0FBQUEsVUFDMUJyRCxjQUQwQixXQUMxQkEsY0FEMEI7QUFBQSxVQUVoQ3NELEtBRmdDLEdBRWpCRixTQUZpQixDQUVoQ0UsS0FGZ0M7QUFBQSxVQUV6QnRDLElBRnlCLEdBRWpCb0MsU0FGaUIsQ0FFekJwQyxJQUZ5Qjs7QUFHdkMsVUFBSXlCLElBQUksQ0FBUjtBQUh1QztBQUFBO0FBQUE7O0FBQUE7QUFJdkMsOEJBQXFCWSxJQUFyQixtSUFBMkI7QUFBQSxjQUFoQkUsTUFBZ0I7O0FBQ3pCLGNBQU14RCxRQUFRQyxlQUFldUQsTUFBZixDQUFkO0FBQ0FELGdCQUFNYixJQUFJLENBQVYsSUFBZTFDLE1BQU0sQ0FBTixDQUFmO0FBQ0F1RCxnQkFBTWIsSUFBSSxDQUFWLElBQWUxQyxNQUFNLENBQU4sQ0FBZjtBQUNBdUQsZ0JBQU1iLElBQUksQ0FBVixJQUFlMUMsTUFBTSxDQUFOLENBQWY7QUFDQXVELGdCQUFNYixJQUFJLENBQVYsSUFBZWUsTUFBTXpELE1BQU0sQ0FBTixDQUFOLElBQWtCLEdBQWxCLEdBQXdCQSxNQUFNLENBQU4sQ0FBdkM7QUFDQTBDLGVBQUt6QixJQUFMO0FBQ0Q7QUFYc0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVl4Qzs7OztFQTdKbUN0QyxLOztlQUFqQnVCLFE7OztBQWdLckJBLFNBQVN3RCxTQUFULEdBQXFCLFVBQXJCO0FBQ0F4RCxTQUFTWCxZQUFULEdBQXdCQSxZQUF4QiIsImZpbGUiOiJhcmMtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7ZnA2NGlmeSwgZW5hYmxlNjRiaXRTdXBwb3J0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuXG5pbXBvcnQgYXJjVmVydGV4IGZyb20gJy4vYXJjLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBhcmNWZXJ0ZXg2NCBmcm9tICcuL2FyYy1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgYXJjRnJhZ21lbnQgZnJvbSAnLi9hcmMtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VXaWR0aDogMSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0U291cmNlUG9zaXRpb246IHggPT4geC5zb3VyY2VQb3NpdGlvbixcbiAgZ2V0VGFyZ2V0UG9zaXRpb246IHggPT4geC50YXJnZXRQb3NpdGlvbixcbiAgZ2V0U291cmNlQ29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuICBnZXRUYXJnZXRDb2xvcjogeCA9PiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0xheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogYXJjVmVydGV4NjQsXG4gICAgICBmczogYXJjRnJhZ21lbnQsXG4gICAgICBtb2R1bGVzOiBbJ2ZwNjQnLCAncHJvamVjdDY0J10sXG4gICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgfSA6IHtcbiAgICAgIHZzOiBhcmNWZXJ0ZXgsXG4gICAgICBmczogYXJjRnJhZ21lbnQsXG4gICAgICBtb2R1bGVzOiBbXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge3NpemU6IDQsIGFjY2Vzc29yOiBbJ2dldFNvdXJjZVBvc2l0aW9uJywgJ2dldFRhcmdldFBvc2l0aW9uJ10sIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVNvdXJjZUNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0U291cmNlQ29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnN9LFxuICAgICAgaW5zdGFuY2VUYXJnZXRDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldFRhcmdldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjRMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICBhY2Nlc3NvcjogWydnZXRTb3VyY2VQb3NpdGlvbicsICdnZXRUYXJnZXRQb3NpdGlvbiddLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjRMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVBvc2l0aW9uczY0TG93J1xuICAgICAgICBdKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG4gICAgLy8gUmUtZ2VuZXJhdGUgbW9kZWwgaWYgZ2VvbWV0cnkgY2hhbmdlZFxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3N0cm9rZVdpZHRofSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgc3Ryb2tlV2lkdGhcbiAgICB9KSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBsZXQgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgTlVNX1NFR01FTlRTID0gNTA7XG4gICAgLypcbiAgICAgKiAgKDAsIC0xKS0tLS0tLS0tLS0tLS1fKDEsIC0xKVxuICAgICAqICAgICAgIHwgICAgICAgICAgXywtXCIgIHxcbiAgICAgKiAgICAgICBvICAgICAgXywtXCIgICAgICBvXG4gICAgICogICAgICAgfCAgXywtXCIgICAgICAgICAgfFxuICAgICAqICAgKDAsIDEpXCItLS0tLS0tLS0tLS0tKDEsIDEpXG4gICAgICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOVU1fU0VHTUVOVFM7IGkrKykge1xuICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLmNvbmNhdChbaSwgLTEsIDAsIGksIDEsIDBdKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG4gICAgY29uc3QgbW9kZWwgPSBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9TVFJJUCxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIG1vZGVsLnNldFVuaWZvcm1zKHtudW1TZWdtZW50czogTlVNX1NFR01FTlRTfSk7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0U291cmNlUG9zaXRpb24sIGdldFRhcmdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gc291cmNlUG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBzb3VyY2VQb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IHRhcmdldFBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSArIDNdID0gdGFyZ2V0UG9zaXRpb25bMV07XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NExvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0U291cmNlUG9zaXRpb24sIGdldFRhcmdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblswXSlbMV07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBmcDY0aWZ5KHNvdXJjZVBvc2l0aW9uWzFdKVsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGZwNjRpZnkodGFyZ2V0UG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSArIDNdID0gZnA2NGlmeSh0YXJnZXRQb3NpdGlvblsxXSlbMV07XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZUNvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRTb3VyY2VDb2xvcihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFRhcmdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRUYXJnZXRDb2xvcihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG59XG5cbkFyY0xheWVyLmxheWVyTmFtZSA9ICdBcmNMYXllcic7XG5BcmNMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geojson__ = __webpack_require__(141);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




// Use primitive layer to avoid "Composite Composite" layers for now




var defaultLineColor = [0x0, 0x0, 0x0, 0xFF];
var defaultFillColor = [0x0, 0x0, 0x0, 0xFF];

var defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,

  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  fp64: false,

  // Line and polygon outline color
  getLineColor: function getLineColor(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.lineColor') || defaultLineColor;
  },
  // Point and polygon fill color
  getFillColor: function getFillColor(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.fillColor') || defaultFillColor;
  },
  // Point radius
  getRadius: function getRadius(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.radius') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.size') || 1;
  },
  // Line and polygon outline accessors
  getLineWidth: function getLineWidth(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.lineWidth') || 1;
  },
  // Polygon extrusion accessor
  getElevation: function getElevation(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'properties.elevation') || 1000;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var getCoordinates = function getCoordinates(f) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'geometry.coordinates');
};

var GeoJsonLayer = function (_CompositeLayer) {
  _inherits(GeoJsonLayer, _CompositeLayer);

  function GeoJsonLayer() {
    _classCallCheck(this, GeoJsonLayer);

    return _possibleConstructorReturn(this, (GeoJsonLayer.__proto__ || Object.getPrototypeOf(GeoJsonLayer)).apply(this, arguments));
  }

  _createClass(GeoJsonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        features: {}
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged) {
        var data = this.props.data;

        var features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__["a" /* getGeojsonFeatures */])(data);
        this.state.features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__["b" /* separateGeojsonFeatures */])(features);
      }
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;

      return Object.assign(info, {
        // override object with picked feature
        object: info.object && info.object.feature || info.object
      });
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var features = this.state.features;
      var pointFeatures = features.pointFeatures,
          lineFeatures = features.lineFeatures,
          polygonFeatures = features.polygonFeatures,
          polygonOutlineFeatures = features.polygonOutlineFeatures;

      // Layer composition props

      var _props = this.props,
          id = _props.id,
          stroked = _props.stroked,
          filled = _props.filled,
          extruded = _props.extruded,
          wireframe = _props.wireframe,
          lightSettings = _props.lightSettings;

      // Rendering props underlying layer

      var _props2 = this.props,
          lineWidthScale = _props2.lineWidthScale,
          lineWidthMinPixels = _props2.lineWidthMinPixels,
          lineWidthMaxPixels = _props2.lineWidthMaxPixels,
          lineJointRounded = _props2.lineJointRounded,
          lineMiterLimit = _props2.lineMiterLimit,
          fp64 = _props2.fp64;

      // Accessor props for underlying layers

      var _props3 = this.props,
          getLineColor = _props3.getLineColor,
          getFillColor = _props3.getFillColor,
          getRadius = _props3.getRadius,
          getLineWidth = _props3.getLineWidth,
          getElevation = _props3.getElevation,
          updateTriggers = _props3.updateTriggers;

      // base layer props

      var _props4 = this.props,
          opacity = _props4.opacity,
          pickable = _props4.pickable,
          visible = _props4.visible,
          getPolygonOffset = _props4.getPolygonOffset;

      // viewport props

      var _props5 = this.props,
          positionOrigin = _props5.positionOrigin,
          projectionMode = _props5.projectionMode,
          modelMatrix = _props5.modelMatrix;


      var drawPoints = pointFeatures && pointFeatures.length > 0;
      var drawLines = lineFeatures && lineFeatures.length > 0;
      var hasPolygonLines = polygonOutlineFeatures && polygonOutlineFeatures.length > 0;
      var hasPolygon = polygonFeatures && polygonFeatures.length > 0;

      // Filled Polygon Layer
      var polygonFillLayer = filled && hasPolygon && new __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__["a" /* default */]({
        id: id + '-polygon-fill',
        data: polygonFeatures,
        extruded: extruded,
        wireframe: false,
        lightSettings: lightSettings,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPolygon: getCoordinates,
        getElevation: getElevation,
        getColor: getFillColor,
        updateTriggers: {
          getElevation: updateTriggers.getElevation,
          getColor: updateTriggers.getFillColor
        }
      });

      var polygonWireframeLayer = wireframe && extruded && hasPolygon && new __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__["a" /* default */]({
        id: id + '-polygon-wireframe',
        data: polygonFeatures,
        extruded: extruded,
        wireframe: true,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPolygon: getCoordinates,
        getElevation: getElevation,
        getColor: getLineColor,
        updateTriggers: {
          getElevation: updateTriggers.getElevation,
          getColor: updateTriggers.getLineColor
        }
      });

      var polygonLineLayer = !extruded && stroked && hasPolygonLines && new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__["a" /* default */]({
        id: id + '-polygon-outline',
        data: polygonOutlineFeatures,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPath: getCoordinates,
        getColor: getLineColor,
        getWidth: getLineWidth,
        updateTriggers: {
          getColor: updateTriggers.getLineColor,
          getWidth: updateTriggers.getLineWidth
        }
      });

      var pathLayer = drawLines && new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__["a" /* default */]({
        id: id + '-line-paths',
        data: lineFeatures,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPath: getCoordinates,
        getColor: getLineColor,
        getWidth: getLineWidth,
        updateTriggers: {
          getColor: updateTriggers.getLineColor,
          getWidth: updateTriggers.getLineWidth
        }
      });

      var pointLayer = drawPoints && new __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__["a" /* default */]({
        id: id + '-points',
        data: pointFeatures,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPosition: getCoordinates,
        getColor: getFillColor,
        getRadius: getRadius,
        updateTriggers: {
          getColor: updateTriggers.getFillColor,
          getRadius: updateTriggers.getRadius
        }
      });

      return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer, polygonWireframeLayer, polygonLineLayer, pathLayer, pointLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer].filter(Boolean);
    }
  }]);

  return GeoJsonLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["b" /* CompositeLayer */]);

/* harmony default export */ __webpack_exports__["a"] = (GeoJsonLayer);


GeoJsonLayer.layerName = 'GeoJsonLayer';
GeoJsonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9nZW9qc29uLWxheWVyL2dlb2pzb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJnZXQiLCJTY2F0dGVycGxvdExheWVyIiwiUGF0aExheWVyIiwiU29saWRQb2x5Z29uTGF5ZXIiLCJnZXRHZW9qc29uRmVhdHVyZXMiLCJzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyIsImRlZmF1bHRMaW5lQ29sb3IiLCJkZWZhdWx0RmlsbENvbG9yIiwiZGVmYXVsdFByb3BzIiwic3Ryb2tlZCIsImZpbGxlZCIsImV4dHJ1ZGVkIiwid2lyZWZyYW1lIiwibGluZVdpZHRoU2NhbGUiLCJsaW5lV2lkdGhNaW5QaXhlbHMiLCJsaW5lV2lkdGhNYXhQaXhlbHMiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibGluZUpvaW50Um91bmRlZCIsImxpbmVNaXRlckxpbWl0IiwiZnA2NCIsImdldExpbmVDb2xvciIsImYiLCJnZXRGaWxsQ29sb3IiLCJnZXRSYWRpdXMiLCJnZXRMaW5lV2lkdGgiLCJnZXRFbGV2YXRpb24iLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsImdldENvb3JkaW5hdGVzIiwiR2VvSnNvbkxheWVyIiwic3RhdGUiLCJmZWF0dXJlcyIsIm9sZFByb3BzIiwicHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiZGF0YSIsImluZm8iLCJPYmplY3QiLCJhc3NpZ24iLCJvYmplY3QiLCJmZWF0dXJlIiwicG9pbnRGZWF0dXJlcyIsImxpbmVGZWF0dXJlcyIsInBvbHlnb25GZWF0dXJlcyIsInBvbHlnb25PdXRsaW5lRmVhdHVyZXMiLCJpZCIsInVwZGF0ZVRyaWdnZXJzIiwib3BhY2l0eSIsInBpY2thYmxlIiwidmlzaWJsZSIsImdldFBvbHlnb25PZmZzZXQiLCJwb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25Nb2RlIiwibW9kZWxNYXRyaXgiLCJkcmF3UG9pbnRzIiwibGVuZ3RoIiwiZHJhd0xpbmVzIiwiaGFzUG9seWdvbkxpbmVzIiwiaGFzUG9seWdvbiIsInBvbHlnb25GaWxsTGF5ZXIiLCJnZXRQb2x5Z29uIiwiZ2V0Q29sb3IiLCJwb2x5Z29uV2lyZWZyYW1lTGF5ZXIiLCJwb2x5Z29uTGluZUxheWVyIiwid2lkdGhTY2FsZSIsIndpZHRoTWluUGl4ZWxzIiwid2lkdGhNYXhQaXhlbHMiLCJyb3VuZGVkIiwibWl0ZXJMaW1pdCIsImdldFBhdGgiLCJnZXRXaWR0aCIsInBhdGhMYXllciIsInBvaW50TGF5ZXIiLCJnZXRQb3NpdGlvbiIsImZpbHRlciIsIkJvb2xlYW4iLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixFQUF3QkMsR0FBeEIsUUFBa0MsY0FBbEM7QUFDQSxPQUFPQyxnQkFBUCxNQUE2Qix3Q0FBN0I7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLDBCQUF0QjtBQUNBO0FBQ0EsT0FBT0MsaUJBQVAsTUFBOEIsNENBQTlCOztBQUVBLFNBQVFDLGtCQUFSLEVBQTRCQyx1QkFBNUIsUUFBMEQsV0FBMUQ7O0FBRUEsSUFBTUMsbUJBQW1CLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLENBQXpCO0FBQ0EsSUFBTUMsbUJBQW1CLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLENBQXpCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLFdBQVMsSUFEVTtBQUVuQkMsVUFBUSxJQUZXO0FBR25CQyxZQUFVLEtBSFM7QUFJbkJDLGFBQVcsS0FKUTs7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QUFuQjJCLE9BQWQsQ0FBL0I7O0FBeUJBLFVBQU1zRCxhQUFhbEIsY0FBYyxJQUFJNUQsZ0JBQUosQ0FBcUI7QUFDcERtRCxZQUFPQSxFQUFQLFlBRG9EO0FBRXBEVixjQUFNTSxhQUY4QztBQUdwRDVCLGtCQUhvRDtBQUlwRGtDLHdCQUpvRDtBQUtwREMsMEJBTG9EO0FBTXBEQyx3QkFOb0Q7QUFPcERDLDBDQVBvRDtBQVFwREUsc0NBUm9EO0FBU3BERCxzQ0FUb0Q7QUFVcERFLGdDQVZvRDtBQVdwRG9CLHFCQUFhOUMsY0FYdUM7QUFZcERrQyxrQkFBVTdDLFlBWjBDO0FBYXBEQyw0QkFib0Q7QUFjcEQ2Qix3QkFBZ0I7QUFDZGUsb0JBQVVmLGVBQWU5QixZQURYO0FBRWRDLHFCQUFXNkIsZUFBZTdCO0FBRlo7QUFkb0MsT0FBckIsQ0FBakM7O0FBb0JBLGFBQU87QUFDTDtBQUNBLE9BQUNiLFFBQUQsSUFBYXVELGdCQUZSLEVBR0xHLHFCQUhLLEVBSUxDLGdCQUpLLEVBS0xRLFNBTEssRUFNTEMsVUFOSztBQU9MO0FBQ0FwRSxrQkFBWXVELGdCQVJQLEVBU0xlLE1BVEssQ0FTRUMsT0FURixDQUFQO0FBVUQ7Ozs7RUF0THVDbkYsYzs7ZUFBckJvQyxZOzs7QUF5THJCQSxhQUFhZ0QsU0FBYixHQUF5QixjQUF6QjtBQUNBaEQsYUFBYTNCLFlBQWIsR0FBNEJBLFlBQTVCIiwiZmlsZSI6Imdlb2pzb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllciwgZ2V0fSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IFNjYXR0ZXJwbG90TGF5ZXIgZnJvbSAnLi4vc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXInO1xuaW1wb3J0IFBhdGhMYXllciBmcm9tICcuLi9wYXRoLWxheWVyL3BhdGgtbGF5ZXInO1xuLy8gVXNlIHByaW1pdGl2ZSBsYXllciB0byBhdm9pZCBcIkNvbXBvc2l0ZSBDb21wb3NpdGVcIiBsYXllcnMgZm9yIG5vd1xuaW1wb3J0IFNvbGlkUG9seWdvbkxheWVyIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllcic7XG5cbmltcG9ydCB7Z2V0R2VvanNvbkZlYXR1cmVzLCBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlc30gZnJvbSAnLi9nZW9qc29uJztcblxuY29uc3QgZGVmYXVsdExpbmVDb2xvciA9IFsweDAsIDB4MCwgMHgwLCAweEZGXTtcbmNvbnN0IGRlZmF1bHRGaWxsQ29sb3IgPSBbMHgwLCAweDAsIDB4MCwgMHhGRl07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc3Ryb2tlZDogdHJ1ZSxcbiAgZmlsbGVkOiB0cnVlLFxuICBleHRydWRlZDogZmFsc2UsXG4gIHdpcmVmcmFtZTogZmFsc2UsXG5cbiAgbGluZVdpZHRoU2NhbGU6IDEsXG4gIGxpbmVXaWR0aE1pblBpeGVsczogMCxcbiAgbGluZVdpZHRoTWF4UGl4ZWxzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgbGluZUpvaW50Um91bmRlZDogZmFsc2UsXG4gIGxpbmVNaXRlckxpbWl0OiA0LFxuICBmcDY0OiBmYWxzZSxcblxuICAvLyBMaW5lIGFuZCBwb2x5Z29uIG91dGxpbmUgY29sb3JcbiAgZ2V0TGluZUNvbG9yOiBmID0+IGdldChmLCAncHJvcGVydGllcy5saW5lQ29sb3InKSB8fCBkZWZhdWx0TGluZUNvbG9yLFxuICAvLyBQb2ludCBhbmQgcG9seWdvbiBmaWxsIGNvbG9yXG4gIGdldEZpbGxDb2xvcjogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMuZmlsbENvbG9yJykgfHwgZGVmYXVsdEZpbGxDb2xvcixcbiAgLy8gUG9pbnQgcmFkaXVzXG4gIGdldFJhZGl1czogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMucmFkaXVzJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLnNpemUnKSB8fCAxLFxuICAvLyBMaW5lIGFuZCBwb2x5Z29uIG91dGxpbmUgYWNjZXNzb3JzXG4gIGdldExpbmVXaWR0aDogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMubGluZVdpZHRoJykgfHwgMSxcbiAgLy8gUG9seWdvbiBleHRydXNpb24gYWNjZXNzb3JcbiAgZ2V0RWxldmF0aW9uOiBmID0+IGdldChmLCAncHJvcGVydGllcy5lbGV2YXRpb24nKSB8fCAxMDAwLFxuXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmNvbnN0IGdldENvb3JkaW5hdGVzID0gZiA9PiBnZXQoZiwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlb0pzb25MYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmZWF0dXJlczoge31cbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgZmVhdHVyZXMgPSBnZXRHZW9qc29uRmVhdHVyZXMoZGF0YSk7XG4gICAgICB0aGlzLnN0YXRlLmZlYXR1cmVzID0gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIC8vIG92ZXJyaWRlIG9iamVjdCB3aXRoIHBpY2tlZCBmZWF0dXJlXG4gICAgICBvYmplY3Q6IChpbmZvLm9iamVjdCAmJiBpbmZvLm9iamVjdC5mZWF0dXJlKSB8fCBpbmZvLm9iamVjdFxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtmZWF0dXJlc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtwb2ludEZlYXR1cmVzLCBsaW5lRmVhdHVyZXMsIHBvbHlnb25GZWF0dXJlcywgcG9seWdvbk91dGxpbmVGZWF0dXJlc30gPSBmZWF0dXJlcztcblxuICAgIC8vIExheWVyIGNvbXBvc2l0aW9uIHByb3BzXG4gICAgY29uc3Qge2lkLCBzdHJva2VkLCBmaWxsZWQsIGV4dHJ1ZGVkLCB3aXJlZnJhbWUsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFJlbmRlcmluZyBwcm9wcyB1bmRlcmx5aW5nIGxheWVyXG4gICAgY29uc3Qge2xpbmVXaWR0aFNjYWxlLCBsaW5lV2lkdGhNaW5QaXhlbHMsIGxpbmVXaWR0aE1heFBpeGVscyxcbiAgICAgIGxpbmVKb2ludFJvdW5kZWQsIGxpbmVNaXRlckxpbWl0LCBmcDY0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBBY2Nlc3NvciBwcm9wcyBmb3IgdW5kZXJseWluZyBsYXllcnNcbiAgICBjb25zdCB7Z2V0TGluZUNvbG9yLCBnZXRGaWxsQ29sb3IsIGdldFJhZGl1cyxcbiAgICAgIGdldExpbmVXaWR0aCwgZ2V0RWxldmF0aW9uLCB1cGRhdGVUcmlnZ2Vyc30gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gYmFzZSBsYXllciBwcm9wc1xuICAgIGNvbnN0IHtvcGFjaXR5LCBwaWNrYWJsZSwgdmlzaWJsZSwgZ2V0UG9seWdvbk9mZnNldH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gdmlld3BvcnQgcHJvcHNcbiAgICBjb25zdCB7cG9zaXRpb25PcmlnaW4sIHByb2plY3Rpb25Nb2RlLCBtb2RlbE1hdHJpeH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZHJhd1BvaW50cyA9IHBvaW50RmVhdHVyZXMgJiYgcG9pbnRGZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGRyYXdMaW5lcyA9IGxpbmVGZWF0dXJlcyAmJiBsaW5lRmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBoYXNQb2x5Z29uTGluZXMgPSBwb2x5Z29uT3V0bGluZUZlYXR1cmVzICYmIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBoYXNQb2x5Z29uID0gcG9seWdvbkZlYXR1cmVzICYmIHBvbHlnb25GZWF0dXJlcy5sZW5ndGggPiAwO1xuXG4gICAgLy8gRmlsbGVkIFBvbHlnb24gTGF5ZXJcbiAgICBjb25zdCBwb2x5Z29uRmlsbExheWVyID0gZmlsbGVkICYmXG4gICAgICBoYXNQb2x5Z29uICYmXG4gICAgICBuZXcgU29saWRQb2x5Z29uTGF5ZXIoe1xuICAgICAgICBpZDogYCR7aWR9LXBvbHlnb24tZmlsbGAsXG4gICAgICAgIGRhdGE6IHBvbHlnb25GZWF0dXJlcyxcbiAgICAgICAgZXh0cnVkZWQsXG4gICAgICAgIHdpcmVmcmFtZTogZmFsc2UsXG4gICAgICAgIGxpZ2h0U2V0dGluZ3MsXG4gICAgICAgIGZwNjQsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHBpY2thYmxlLFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICAgICAgcG9zaXRpb25PcmlnaW4sXG4gICAgICAgIG1vZGVsTWF0cml4LFxuICAgICAgICBnZXRQb2x5Z29uOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0RWxldmF0aW9uLFxuICAgICAgICBnZXRDb2xvcjogZ2V0RmlsbENvbG9yLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEVsZXZhdGlvbjogdXBkYXRlVHJpZ2dlcnMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjb25zdCBwb2x5Z29uV2lyZWZyYW1lTGF5ZXIgPSB3aXJlZnJhbWUgJiZcbiAgICAgIGV4dHJ1ZGVkICYmXG4gICAgICBoYXNQb2x5Z29uICYmXG4gICAgICBuZXcgU29saWRQb2x5Z29uTGF5ZXIoe1xuICAgICAgICBpZDogYCR7aWR9LXBvbHlnb24td2lyZWZyYW1lYCxcbiAgICAgICAgZGF0YTogcG9seWdvbkZlYXR1cmVzLFxuICAgICAgICBleHRydWRlZCxcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICBmcDY0LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwaWNrYWJsZSxcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZ2V0UG9seWdvbk9mZnNldCxcbiAgICAgICAgcHJvamVjdGlvbk1vZGUsXG4gICAgICAgIHBvc2l0aW9uT3JpZ2luLFxuICAgICAgICBtb2RlbE1hdHJpeCxcbiAgICAgICAgZ2V0UG9seWdvbjogZ2V0Q29vcmRpbmF0ZXMsXG4gICAgICAgIGdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0Q29sb3I6IGdldExpbmVDb2xvcixcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldEVsZXZhdGlvbixcbiAgICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZUNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY29uc3QgcG9seWdvbkxpbmVMYXllciA9ICFleHRydWRlZCAmJlxuICAgICAgc3Ryb2tlZCAmJlxuICAgICAgaGFzUG9seWdvbkxpbmVzICYmXG4gICAgICBuZXcgUGF0aExheWVyKHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLW91dGxpbmVgLFxuICAgICAgICBkYXRhOiBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLFxuICAgICAgICB3aWR0aFNjYWxlOiBsaW5lV2lkdGhTY2FsZSxcbiAgICAgICAgd2lkdGhNaW5QaXhlbHM6IGxpbmVXaWR0aE1pblBpeGVscyxcbiAgICAgICAgd2lkdGhNYXhQaXhlbHM6IGxpbmVXaWR0aE1heFBpeGVscyxcbiAgICAgICAgcm91bmRlZDogbGluZUpvaW50Um91bmRlZCxcbiAgICAgICAgbWl0ZXJMaW1pdDogbGluZU1pdGVyTGltaXQsXG4gICAgICAgIGZwNjQsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHBpY2thYmxlLFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICAgICAgcG9zaXRpb25PcmlnaW4sXG4gICAgICAgIG1vZGVsTWF0cml4LFxuICAgICAgICBnZXRQYXRoOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0Q29sb3I6IGdldExpbmVDb2xvcixcbiAgICAgICAgZ2V0V2lkdGg6IGdldExpbmVXaWR0aCxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZUNvbG9yLFxuICAgICAgICAgIGdldFdpZHRoOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lV2lkdGhcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjb25zdCBwYXRoTGF5ZXIgPSBkcmF3TGluZXMgJiYgbmV3IFBhdGhMYXllcih7XG4gICAgICBpZDogYCR7aWR9LWxpbmUtcGF0aHNgLFxuICAgICAgZGF0YTogbGluZUZlYXR1cmVzLFxuICAgICAgd2lkdGhTY2FsZTogbGluZVdpZHRoU2NhbGUsXG4gICAgICB3aWR0aE1pblBpeGVsczogbGluZVdpZHRoTWluUGl4ZWxzLFxuICAgICAgd2lkdGhNYXhQaXhlbHM6IGxpbmVXaWR0aE1heFBpeGVscyxcbiAgICAgIHJvdW5kZWQ6IGxpbmVKb2ludFJvdW5kZWQsXG4gICAgICBtaXRlckxpbWl0OiBsaW5lTWl0ZXJMaW1pdCxcbiAgICAgIGZwNjQsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGlja2FibGUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgZ2V0UG9seWdvbk9mZnNldCxcbiAgICAgIHByb2plY3Rpb25Nb2RlLFxuICAgICAgcG9zaXRpb25PcmlnaW4sXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIGdldFBhdGg6IGdldENvb3JkaW5hdGVzLFxuICAgICAgZ2V0Q29sb3I6IGdldExpbmVDb2xvcixcbiAgICAgIGdldFdpZHRoOiBnZXRMaW5lV2lkdGgsXG4gICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZUNvbG9yLFxuICAgICAgICBnZXRXaWR0aDogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZVdpZHRoXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBwb2ludExheWVyID0gZHJhd1BvaW50cyAmJiBuZXcgU2NhdHRlcnBsb3RMYXllcih7XG4gICAgICBpZDogYCR7aWR9LXBvaW50c2AsXG4gICAgICBkYXRhOiBwb2ludEZlYXR1cmVzLFxuICAgICAgZnA2NCxcbiAgICAgIG9wYWNpdHksXG4gICAgICBwaWNrYWJsZSxcbiAgICAgIHZpc2libGUsXG4gICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgcHJvamVjdGlvbk1vZGUsXG4gICAgICBwb3NpdGlvbk9yaWdpbixcbiAgICAgIG1vZGVsTWF0cml4LFxuICAgICAgZ2V0UG9zaXRpb246IGdldENvb3JkaW5hdGVzLFxuICAgICAgZ2V0Q29sb3I6IGdldEZpbGxDb2xvcixcbiAgICAgIGdldFJhZGl1cyxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3IsXG4gICAgICAgIGdldFJhZGl1czogdXBkYXRlVHJpZ2dlcnMuZ2V0UmFkaXVzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgLy8gSWYgbm90IGV4dHJ1ZGVkOiBmbGF0IGZpbGwgbGF5ZXIgaXMgZHJhd24gYmVsb3cgb3V0bGluZXNcbiAgICAgICFleHRydWRlZCAmJiBwb2x5Z29uRmlsbExheWVyLFxuICAgICAgcG9seWdvbldpcmVmcmFtZUxheWVyLFxuICAgICAgcG9seWdvbkxpbmVMYXllcixcbiAgICAgIHBhdGhMYXllcixcbiAgICAgIHBvaW50TGF5ZXIsXG4gICAgICAvLyBJZiBleHRydWRlZDogZHJhdyBmaWxsIGxheWVyIGxhc3QgZm9yIGNvcnJlY3QgYmxlbmRpbmcgYmVoYXZpb3JcbiAgICAgIGV4dHJ1ZGVkICYmIHBvbHlnb25GaWxsTGF5ZXJcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgfVxufVxuXG5HZW9Kc29uTGF5ZXIubGF5ZXJOYW1lID0gJ0dlb0pzb25MYXllcic7XG5HZW9Kc29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getGeojsonFeatures;
/* harmony export (immutable) */ __webpack_exports__["b"] = separateGeojsonFeatures;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

// Linearize
function separateGeojsonFeatures(features) {
  var pointFeatures = [];
  var lineFeatures = [];
  var polygonFeatures = [];
  var polygonOutlineFeatures = [];

  features.forEach(function (feature) {
    var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(feature, 'geometry.type');
    var coordinates = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(feature, 'geometry.coordinates');
    var properties = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(feature, 'properties');
    switch (type) {
      case 'Point':
        pointFeatures.push(feature);
        break;
      case 'MultiPoint':
        // TODO - split multipoints
        coordinates.forEach(function (point) {
          pointFeatures.push({ geometry: { coordinates: point }, properties: properties, feature: feature });
        });
        break;
      case 'LineString':
        lineFeatures.push(feature);
        break;
      case 'MultiLineString':
        // Break multilinestrings into multiple lines with same properties
        coordinates.forEach(function (path) {
          lineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'Polygon':
        polygonFeatures.push(feature);
        // Break polygon into multiple lines with same properties
        coordinates.forEach(function (path) {
          polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'MultiPolygon':
        // Break multipolygons into multiple polygons with same properties
        coordinates.forEach(function (polygon) {
          polygonFeatures.push({ geometry: { coordinates: polygon }, properties: properties, feature: feature });
          // Break polygon into multiple lines with same properties
          polygon.forEach(function (path) {
            polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
          });
        });
        break;
      // Not yet supported
      case 'GeometryCollection':
      default:
        throw new Error('GeoJsonLayer: ' + type + ' not supported.');
    }
  });

  return {
    pointFeatures: pointFeatures,
    lineFeatures: lineFeatures,
    polygonFeatures: polygonFeatures,
    polygonOutlineFeatures: polygonOutlineFeatures
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9nZW9qc29uLWxheWVyL2dlb2pzb24uanMiXSwibmFtZXMiOlsiZ2V0IiwiZ2V0R2VvanNvbkZlYXR1cmVzIiwiZ2VvanNvbiIsIkFycmF5IiwiaXNBcnJheSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZ2VvbWV0cnkiLCJFcnJvciIsInNlcGFyYXRlR2VvanNvbkZlYXR1cmVzIiwiZmVhdHVyZXMiLCJwb2ludEZlYXR1cmVzIiwibGluZUZlYXR1cmVzIiwicG9seWdvbkZlYXR1cmVzIiwicG9seWdvbk91dGxpbmVGZWF0dXJlcyIsImZvckVhY2giLCJmZWF0dXJlIiwiY29vcmRpbmF0ZXMiLCJwdXNoIiwicG9pbnQiLCJwYXRoIiwicG9seWdvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsR0FBUixRQUFrQixjQUFsQjs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsT0FBTyxTQUFTQyxrQkFBVCxDQUE0QkMsT0FBNUIsRUFBcUM7QUFDMUM7QUFDQSxNQUFJQyxNQUFNQyxPQUFOLENBQWNGLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixXQUFPQSxPQUFQO0FBQ0Q7O0FBRUQsTUFBTUcsT0FBT0wsSUFBSUUsT0FBSixFQUFhLE1BQWIsQ0FBYjtBQUNBLFVBQVFHLElBQVI7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFlBQUw7QUFDQSxTQUFLLFlBQUw7QUFDQSxTQUFLLGlCQUFMO0FBQ0EsU0FBSyxTQUFMO0FBQ0EsU0FBSyxjQUFMO0FBQ0EsU0FBSyxvQkFBTDtBQUNFO0FBQ0EsYUFBTyxDQUNMLEVBQUNBLE1BQU0sU0FBUCxFQUFrQkMsWUFBWSxFQUE5QixFQUFrQ0MsVUFBVUwsT0FBNUMsRUFESyxDQUFQO0FBR0YsU0FBSyxTQUFMO0FBQ0U7QUFDQSxhQUFPLENBQUNBLE9BQUQsQ0FBUDtBQUNGLFNBQUssbUJBQUw7QUFDRTtBQUNBLGFBQU9GLElBQUlFLE9BQUosRUFBYSxVQUFiLENBQVA7QUFDRjtBQUNFLFlBQU0sSUFBSU0sS0FBSixDQUFVLHNCQUFWLENBQU47QUFuQkY7QUFxQkQ7O0FBRUQ7QUFDQSxPQUFPLFNBQVNDLHVCQUFULENBQWlDQyxRQUFqQyxFQUEyQztBQUNoRCxNQUFNQyxnQkFBZ0IsRUFBdEI7QUFDQSxNQUFNQyxlQUFlLEVBQXJCO0FBQ0EsTUFBTUMsa0JBQWtCLEVBQXhCO0FBQ0EsTUFBTUMseUJBQXlCLEVBQS9COztBQUVBSixXQUFTSyxPQUFULENBQWlCLG1CQUFXO0FBQzFCLFFBQU1WLE9BQU9MLElBQUlnQixPQUFKLEVBQWEsZUFBYixDQUFiO0FBQ0EsUUFBTUMsY0FBY2pCLElBQUlnQixPQUFKLEVBQWEsc0JBQWIsQ0FBcEI7QUFDQSxRQUFNVixhQUFhTixJQUFJZ0IsT0FBSixFQUFhLFlBQWIsQ0FBbkI7QUFDQSxZQUFRWCxJQUFSO0FBQ0EsV0FBSyxPQUFMO0FBQ0VNLHNCQUFjTyxJQUFkLENBQW1CRixPQUFuQjtBQUNBO0FBQ0YsV0FBSyxZQUFMO0FBQ0U7QUFDQUMsb0JBQVlGLE9BQVosQ0FBb0IsaUJBQVM7QUFDM0JKLHdCQUFjTyxJQUFkLENBQW1CLEVBQUNYLFVBQVUsRUFBQ1UsYUFBYUUsS0FBZCxFQUFYLEVBQWlDYixzQkFBakMsRUFBNkNVLGdCQUE3QyxFQUFuQjtBQUNELFNBRkQ7QUFHQTtBQUNGLFdBQUssWUFBTDtBQUNFSixxQkFBYU0sSUFBYixDQUFrQkYsT0FBbEI7QUFDQTtBQUNGLFdBQUssaUJBQUw7QUFDRTtBQUNBQyxvQkFBWUYsT0FBWixDQUFvQixnQkFBUTtBQUMxQkgsdUJBQWFNLElBQWIsQ0FBa0IsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhRyxJQUFkLEVBQVgsRUFBZ0NkLHNCQUFoQyxFQUE0Q1UsZ0JBQTVDLEVBQWxCO0FBQ0QsU0FGRDtBQUdBO0FBQ0YsV0FBSyxTQUFMO0FBQ0VILHdCQUFnQkssSUFBaEIsQ0FBcUJGLE9BQXJCO0FBQ0E7QUFDQUMsb0JBQVlGLE9BQVosQ0FBb0IsZ0JBQVE7QUFDMUJELGlDQUF1QkksSUFBdkIsQ0FBNEIsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhRyxJQUFkLEVBQVgsRUFBZ0NkLHNCQUFoQyxFQUE0Q1UsZ0JBQTVDLEVBQTVCO0FBQ0QsU0FGRDtBQUdBO0FBQ0YsV0FBSyxjQUFMO0FBQ0U7QUFDQUMsb0JBQVlGLE9BQVosQ0FBb0IsbUJBQVc7QUFDN0JGLDBCQUFnQkssSUFBaEIsQ0FBcUIsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhSSxPQUFkLEVBQVgsRUFBbUNmLHNCQUFuQyxFQUErQ1UsZ0JBQS9DLEVBQXJCO0FBQ0E7QUFDQUssa0JBQVFOLE9BQVIsQ0FBZ0IsZ0JBQVE7QUFDdEJELG1DQUF1QkksSUFBdkIsQ0FBNEIsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhRyxJQUFkLEVBQVgsRUFBZ0NkLHNCQUFoQyxFQUE0Q1UsZ0JBQTVDLEVBQTVCO0FBQ0QsV0FGRDtBQUdELFNBTkQ7QUFPQTtBQUNBO0FBQ0YsV0FBSyxvQkFBTDtBQUNBO0FBQ0UsY0FBTSxJQUFJUixLQUFKLG9CQUEyQkgsSUFBM0IscUJBQU47QUF2Q0Y7QUF5Q0QsR0E3Q0Q7O0FBK0NBLFNBQU87QUFDTE0sZ0NBREs7QUFFTEMsOEJBRks7QUFHTEMsb0NBSEs7QUFJTEM7QUFKSyxHQUFQO0FBTUQiLCJmaWxlIjoiZ2VvanNvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2dldH0gZnJvbSAnLi4vLi4vLi4vbGliJztcblxuLyoqXG4gKiBcIk5vcm1hbGl6ZXNcIiBjb21wbGV0ZSBvciBwYXJ0aWFsIEdlb0pTT04gZGF0YSBpbnRvIGl0ZXJhYmxlIGxpc3Qgb2YgZmVhdHVyZXNcbiAqIENhbiBhY2NlcHQgR2VvSlNPTiBnZW9tZXRyeSBvciBcIkZlYXR1cmVcIiwgXCJGZWF0dXJlQ29sbGVjdGlvblwiIGluIGFkZGl0aW9uXG4gKiB0byBwbGFpbiBhcnJheXMgYW5kIGl0ZXJhYmxlcy5cbiAqIFdvcmtzIGJ5IGV4dHJhY3RpbmcgdGhlIGZlYXR1cmUgYXJyYXkgb3Igd3JhcHBpbmcgc2luZ2xlIG9iamVjdHMgaW4gYW4gYXJyYXksXG4gKiBzbyB0aGF0IHN1YnNlcXVlbnQgY29kZSBjYW4gc2ltcGx5IGl0ZXJhdGUgb3ZlciBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ2VvanNvbiAtIGdlb2pzb24gZGF0YVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGEgLSBnZW9qc29uIG9iamVjdCAoRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmUgb3JcbiAqICBHZW9tZXRyeSkgb3IgYXJyYXkgb2YgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0FycmF5fFwiaXRlcmF0YWJsZVwifSAtIGl0ZXJhYmxlIGxpc3Qgb2YgZmVhdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25GZWF0dXJlcyhnZW9qc29uKSB7XG4gIC8vIElmIGFycmF5LCBhc3N1bWUgdGhpcyBpcyBhIGxpc3Qgb2YgZmVhdHVyZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvanNvbikpIHtcbiAgICByZXR1cm4gZ2VvanNvbjtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBnZXQoZ2VvanNvbiwgJ3R5cGUnKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgY2FzZSAnTXVsdGlQb2ludCc6XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICBjYXNlICdQb2x5Z29uJzpcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAvLyBXcmFwIHRoZSBnZW9tZXRyeSBvYmplY3QgaW4gYSAnRmVhdHVyZScgb2JqZWN0IGFuZCB3cmFwIGluIGFuIGFycmF5XG4gICAgcmV0dXJuIFtcbiAgICAgIHt0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZ2VvanNvbn1cbiAgICBdO1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICAvLyBXcmFwIHRoZSBmZWF0dXJlIGluIGEgJ0ZlYXR1cmVzJyBhcnJheVxuICAgIHJldHVybiBbZ2VvanNvbl07XG4gIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAvLyBKdXN0IHJldHVybiB0aGUgJ0ZlYXR1cmVzJyBhcnJheSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgcmV0dXJuIGdldChnZW9qc29uLCAnZmVhdHVyZXMnKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZ2VvanNvbiB0eXBlJyk7XG4gIH1cbn1cblxuLy8gTGluZWFyaXplXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgY29uc3QgcG9pbnRGZWF0dXJlcyA9IFtdO1xuICBjb25zdCBsaW5lRmVhdHVyZXMgPSBbXTtcbiAgY29uc3QgcG9seWdvbkZlYXR1cmVzID0gW107XG4gIGNvbnN0IHBvbHlnb25PdXRsaW5lRmVhdHVyZXMgPSBbXTtcblxuICBmZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5LnR5cGUnKTtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IGdldChmZWF0dXJlLCAnZ2VvbWV0cnkuY29vcmRpbmF0ZXMnKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2V0KGZlYXR1cmUsICdwcm9wZXJ0aWVzJyk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgcG9pbnRGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAvLyBUT0RPIC0gc3BsaXQgbXVsdGlwb2ludHNcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICBwb2ludEZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBvaW50fSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIGxpbmVGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIEJyZWFrIG11bHRpbGluZXN0cmluZ3MgaW50byBtdWx0aXBsZSBsaW5lcyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgICAgbGluZUZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBhdGh9LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgcG9seWdvbkZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMucHVzaCh7Z2VvbWV0cnk6IHtjb29yZGluYXRlczogcGF0aH0sIHByb3BlcnRpZXMsIGZlYXR1cmV9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIC8vIEJyZWFrIG11bHRpcG9seWdvbnMgaW50byBtdWx0aXBsZSBwb2x5Z29ucyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChwb2x5Z29uID0+IHtcbiAgICAgICAgcG9seWdvbkZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBvbHlnb259LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICAgIC8vIEJyZWFrIHBvbHlnb24gaW50byBtdWx0aXBsZSBsaW5lcyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgICBwb2x5Z29uLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwYXRofSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBOb3QgeWV0IHN1cHBvcnRlZFxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2VvSnNvbkxheWVyOiAke3R5cGV9IG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHBvaW50RmVhdHVyZXMsXG4gICAgbGluZUZlYXR1cmVzLFxuICAgIHBvbHlnb25GZWF0dXJlcyxcbiAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzXG4gIH07XG59XG4iXX0=

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME grid-cell-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiZ3JpZC1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGdyaWQtY2VsbC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Inspired by screen-grid-layer vertex shader in deck.gl

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME grid-cell-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec4 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float extruded;\nuniform float cellSize;\nuniform float opacity;\nuniform float elevationScale;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter\n#define ELEVATION_SCALE 0.8\n\n// Result\nvarying vec4 vColor;\n\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\n\nvoid main(void) {\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x,\n    instancePositions64xyLow.x,\n    instancePositions.y,\n    instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  projected_coord_xy[0] = sum_fp64(projected_coord_xy[0],\n    vec2((positions.x + 1.0) * cellSize / 2.0, 0.0));\n  projected_coord_xy[1] = sum_fp64(projected_coord_xy[1],\n    vec2((positions.y + 1.0) * cellSize / 2.0, 0.0));\n\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.w  * (positions.z + 1.0) *\n      ELEVATION_SCALE * elevationScale) + 1.0;\n  }\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(elevation, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether a bar is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace.xyz, // the w component is always 1.0\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n    vec4 color = vec4(lightWeightedColor, instanceColors.a * opacity) / 255.0;\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n     vColor = pickingColor;\n\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyLXZlcnRleC02NC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6ImdyaWQtY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBJbnNwaXJlZCBieSBzY3JlZW4tZ3JpZC1sYXllciB2ZXJ0ZXggc2hhZGVyIGluIGRlY2suZ2xcblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGdyaWQtY2VsbC1sYXllci12ZXJ0ZXgtc2hhZGVyLTY0XG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG5cbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbi8vIFBpY2tpbmcgdW5pZm9ybXNcbi8vIFNldCB0byAxLjAgaWYgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCAwLjAgaWYgcmVuZGVyaW5nIGZvciBkaXNwbGF5XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XG5cbi8vIEN1c3RvbSB1bmlmb3Jtc1xudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcbnVuaWZvcm0gZmxvYXQgY2VsbFNpemU7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IGVsZXZhdGlvblNjYWxlO1xuXG4vLyBBIG1hZ2ljIG51bWJlciB0byBzY2FsZSBlbGV2YXRpb24gc28gdGhhdCAxIHVuaXQgYXBwcm94aW1hdGUgdG8gMSBtZXRlclxuI2RlZmluZSBFTEVWQVRJT05fU0NBTEUgMC44XG5cbi8vIFJlc3VsdFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuZmxvYXQgaXNQaWNrZWQodmVjMyBwaWNraW5nQ29sb3JzLCB2ZWMzIHNlbGVjdGVkQ29sb3IpIHtcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcbiAmJiBwaWNraW5nQ29sb3JzLnogPT0gc2VsZWN0ZWRDb2xvci56KTtcbn1cblxuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IGluc3RhbmNlUG9zaXRpb25zNjR4eSA9IHZlYzQoXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueCxcbiAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueCxcbiAgICBpbnN0YW5jZVBvc2l0aW9ucy55LFxuICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlUG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICBwcm9qZWN0ZWRfY29vcmRfeHlbMF0gPSBzdW1fZnA2NChwcm9qZWN0ZWRfY29vcmRfeHlbMF0sXG4gICAgdmVjMigocG9zaXRpb25zLnggKyAxLjApICogY2VsbFNpemUgLyAyLjAsIDAuMCkpO1xuICBwcm9qZWN0ZWRfY29vcmRfeHlbMV0gPSBzdW1fZnA2NChwcm9qZWN0ZWRfY29vcmRfeHlbMV0sXG4gICAgdmVjMigocG9zaXRpb25zLnkgKyAxLjApICogY2VsbFNpemUgLyAyLjAsIDAuMCkpO1xuXG4gIGZsb2F0IGVsZXZhdGlvbiA9IDAuMDtcblxuICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICBlbGV2YXRpb24gPSBwcm9qZWN0X3NjYWxlKGluc3RhbmNlUG9zaXRpb25zLncgICogKHBvc2l0aW9ucy56ICsgMS4wKSAqXG4gICAgICBFTEVWQVRJT05fU0NBTEUgKiBlbGV2YXRpb25TY2FsZSkgKyAxLjA7XG4gIH1cblxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzBdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRfY29vcmRfeHlbMV07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIoZWxldmF0aW9uLCAwLjApO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSB2ZWM0KFxuICAgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXS54LCB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0ueCxcbiAgICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdLngpO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyIDwgMC41KSB7XG5cbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXG4gICAgLy8gY2hlY2sgd2hldGhlciBhIGJhciBpcyBjdXJyZW50bHkgcGlja2VkLlxuICAgIGZsb2F0IHNlbGVjdGVkID0gaXNQaWNrZWQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCBzZWxlY3RlZFBpY2tpbmdDb2xvcik7XG5cbiAgICBmbG9hdCBsaWdodFdlaWdodCA9IDEuMDtcblxuICAgIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgICAgbGlnaHRXZWlnaHQgPSBnZXRMaWdodFdlaWdodChcbiAgICAgICAgcG9zaXRpb25fd29ybGRzcGFjZS54eXosIC8vIHRoZSB3IGNvbXBvbmVudCBpcyBhbHdheXMgMS4wXG4gICAgICAgIG5vcm1hbHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGluc3RhbmNlQ29sb3JzLnJnYjtcbiAgICB2ZWM0IGNvbG9yID0gdmVjNChsaWdodFdlaWdodGVkQ29sb3IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS4wO1xuICAgIHZDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LjAsIDEuMCk7XG4gICAgIHZDb2xvciA9IHBpY2tpbmdDb2xvcjtcblxuICB9XG59XG5gO1xuIl19

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Inspired by screen-grid-layer vertex shader in deck.gl

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME grid-cell-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec4 instancePositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter\n#define ELEVATION_SCALE 0.8\n\n// Result\nvarying vec4 vColor;\n\n// whether is point picked\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  vec2 topLeftPos = project_position(instancePositions.xy);\n  \n  // if ahpha == 0.0, do not render element\n  float finalCellSize = cellSize * mix(1.0, 0.0, float(instanceColors.a == 0.0));\n\n  // cube gemoetry vertics are between -1 to 1, scale and transform it to between 0, 1\n  vec2 pos = topLeftPos + vec2(\n  (positions.x * coverage + 1.0) / 2.0 * finalCellSize, \n  (positions.y * coverage + 1.0) / 2.0 * finalCellSize);\n\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.w  * (positions.z + 1.0) *\n      ELEVATION_SCALE * elevationScale);\n  }\n\n  // extrude positions\n  vec3 extrudedPosition = vec3(pos.xy, elevation + 1.0);\n  vec4 position_worldspace = vec4(extrudedPosition, 1.0);\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether a bar is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace.xyz, // the w component is always 1.0\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n    vec4 color = vec4(lightWeightedColor, instanceColors.a * opacity) / 255.0;\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n     vColor = pickingColor;\n\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyLXZlcnRleC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6ImdyaWQtY2VsbC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBJbnNwaXJlZCBieSBzY3JlZW4tZ3JpZC1sYXllciB2ZXJ0ZXggc2hhZGVyIGluIGRlY2suZ2xcblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGdyaWQtY2VsbC1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG5cbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbi8vIFBpY2tpbmcgdW5pZm9ybXNcbi8vIFNldCB0byAxLjAgaWYgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCAwLjAgaWYgcmVuZGVyaW5nIGZvciBkaXNwbGF5XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XG5cbi8vIEN1c3RvbSB1bmlmb3Jtc1xudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcbnVuaWZvcm0gZmxvYXQgY2VsbFNpemU7XG51bmlmb3JtIGZsb2F0IGNvdmVyYWdlO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcblxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXJcbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxuXG4vLyBSZXN1bHRcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbi8vIHdoZXRoZXIgaXMgcG9pbnQgcGlja2VkXG5mbG9hdCBpc1BpY2tlZCh2ZWMzIHBpY2tpbmdDb2xvcnMsIHZlYzMgc2VsZWN0ZWRDb2xvcikge1xuIHJldHVybiBmbG9hdChwaWNraW5nQ29sb3JzLnggPT0gc2VsZWN0ZWRDb2xvci54XG4gJiYgcGlja2luZ0NvbG9ycy55ID09IHNlbGVjdGVkQ29sb3IueVxuICYmIHBpY2tpbmdDb2xvcnMueiA9PSBzZWxlY3RlZENvbG9yLnopO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuXG4gIHZlYzIgdG9wTGVmdFBvcyA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpO1xuICBcbiAgLy8gaWYgYWhwaGEgPT0gMC4wLCBkbyBub3QgcmVuZGVyIGVsZW1lbnRcbiAgZmxvYXQgZmluYWxDZWxsU2l6ZSA9IGNlbGxTaXplICogbWl4KDEuMCwgMC4wLCBmbG9hdChpbnN0YW5jZUNvbG9ycy5hID09IDAuMCkpO1xuXG4gIC8vIGN1YmUgZ2Vtb2V0cnkgdmVydGljcyBhcmUgYmV0d2VlbiAtMSB0byAxLCBzY2FsZSBhbmQgdHJhbnNmb3JtIGl0IHRvIGJldHdlZW4gMCwgMVxuICB2ZWMyIHBvcyA9IHRvcExlZnRQb3MgKyB2ZWMyKFxuICAocG9zaXRpb25zLnggKiBjb3ZlcmFnZSArIDEuMCkgLyAyLjAgKiBmaW5hbENlbGxTaXplLCBcbiAgKHBvc2l0aW9ucy55ICogY292ZXJhZ2UgKyAxLjApIC8gMi4wICogZmluYWxDZWxsU2l6ZSk7XG5cbiAgZmxvYXQgZWxldmF0aW9uID0gMC4wO1xuXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgIGVsZXZhdGlvbiA9IHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMudyAgKiAocG9zaXRpb25zLnogKyAxLjApICpcbiAgICAgIEVMRVZBVElPTl9TQ0FMRSAqIGVsZXZhdGlvblNjYWxlKTtcbiAgfVxuXG4gIC8vIGV4dHJ1ZGUgcG9zaXRpb25zXG4gIHZlYzMgZXh0cnVkZWRQb3NpdGlvbiA9IHZlYzMocG9zLnh5LCBlbGV2YXRpb24gKyAxLjApO1xuICB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSB2ZWM0KGV4dHJ1ZGVkUG9zaXRpb24sIDEuMCk7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb25fd29ybGRzcGFjZSk7XG5cbiAgaWYgKHJlbmRlclBpY2tpbmdCdWZmZXIgPCAwLjUpIHtcblxuICAgIC8vIFRPRE86IHdlIHNob3VsZCBhbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IHRoZSBjb2xvciBmb3IgXCJzZWxlY3RlZCBlbGVtZW50XCJcbiAgICAvLyBjaGVjayB3aGV0aGVyIGEgYmFyIGlzIGN1cnJlbnRseSBwaWNrZWQuXG4gICAgZmxvYXQgc2VsZWN0ZWQgPSBpc1BpY2tlZChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIHNlbGVjdGVkUGlja2luZ0NvbG9yKTtcblxuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMS4wO1xuXG4gICAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XG4gICAgICBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLnh5eiwgLy8gdGhlIHcgY29tcG9uZW50IGlzIGFsd2F5cyAxLjBcbiAgICAgICAgbm9ybWFsc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2ZWMzIGxpZ2h0V2VpZ2h0ZWRDb2xvciA9IGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiO1xuICAgIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ZWRDb2xvciwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjA7XG4gICAgdkNvbG9yID0gY29sb3I7XG5cbiAgfSBlbHNlIHtcblxuICAgIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuMCwgMS4wKTtcbiAgICAgdkNvbG9yID0gcGlja2luZ0NvbG9yO1xuXG4gIH1cbn1cbmA7XG4iXX0=

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = pointToDensityGridData;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var R_EARTH = 6378000;

/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {number} cellSize - cell size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid data, cell dimension
 */
function pointToDensityGridData(points, cellSize, getPosition) {
  var _pointsToGridHashing2 = _pointsToGridHashing(points, cellSize, getPosition),
      gridHash = _pointsToGridHashing2.gridHash,
      gridOffset = _pointsToGridHashing2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);

  return {
    gridOffset: gridOffset,
    layerData: layerData
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {array} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
function _pointsToGridHashing(points, cellSize, getPosition) {

  // find the geometric center of sample points
  var allLat = points.map(function (p) {
    return getPosition(p)[1];
  });
  var latMin = Math.min.apply(null, allLat);
  var latMax = Math.max.apply(null, allLat);

  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  // calculate count per cell
  var gridHash = points.reduce(function (accu, pt) {
    var latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);
    var lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);
    var key = latIdx + '-' + lonIdx;

    accu[key] = accu[key] || { count: 0, points: [] };
    accu[key].count += 1;
    accu[key].points.push(pt);

    return accu;
  }, {});

  return { gridHash: gridHash, gridOffset: gridOffset };
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);

    accu.push(Object.assign({
      index: i,
      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]
    }, gridHash[key]));

    return accu;
  }, []);
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);
  var xOffset = _calculateLonOffset(latitude, cellSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtYWdncmVnYXRvci5qcyJdLCJuYW1lcyI6WyJSX0VBUlRIIiwicG9pbnRUb0RlbnNpdHlHcmlkRGF0YSIsInBvaW50cyIsImNlbGxTaXplIiwiZ2V0UG9zaXRpb24iLCJfcG9pbnRzVG9HcmlkSGFzaGluZyIsImdyaWRIYXNoIiwiZ3JpZE9mZnNldCIsImxheWVyRGF0YSIsIl9nZXRHcmlkTGF5ZXJEYXRhRnJvbUdyaWRIYXNoIiwiYWxsTGF0IiwibWFwIiwicCIsImxhdE1pbiIsIk1hdGgiLCJtaW4iLCJhcHBseSIsImxhdE1heCIsIm1heCIsImNlbnRlckxhdCIsIl9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0IiwieE9mZnNldCIsInlPZmZzZXQiLCJyZWR1Y2UiLCJhY2N1IiwicHQiLCJsYXRJZHgiLCJmbG9vciIsImxvbklkeCIsImtleSIsImNvdW50IiwicHVzaCIsIk9iamVjdCIsImtleXMiLCJpIiwiaWR4cyIsInNwbGl0IiwicGFyc2VJbnQiLCJhc3NpZ24iLCJpbmRleCIsInBvc2l0aW9uIiwibGF0aXR1ZGUiLCJfY2FsY3VsYXRlTGF0T2Zmc2V0IiwiX2NhbGN1bGF0ZUxvbk9mZnNldCIsImR5IiwiUEkiLCJsYXQiLCJkeCIsImNvcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQSxVQUFVLE9BQWhCOztBQUVBOzs7Ozs7O0FBT0EsT0FBTyxTQUFTQyxzQkFBVCxDQUFnQ0MsTUFBaEMsRUFBd0NDLFFBQXhDLEVBQWtEQyxXQUFsRCxFQUErRDtBQUFBLDhCQUVyQ0MscUJBQXFCSCxNQUFyQixFQUE2QkMsUUFBN0IsRUFBdUNDLFdBQXZDLENBRnFDO0FBQUEsTUFFN0RFLFFBRjZELHlCQUU3REEsUUFG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QUFvQ2pCLFFBQXBDLEVBQThDc0MsUUFBOUMsRUFBd0Q7QUFDdEQsTUFBTW5CLFVBQVVvQixvQkFBb0J2QyxRQUFwQixDQUFoQjtBQUNBLE1BQU1rQixVQUFVc0Isb0JBQW9CRixRQUFwQixFQUE4QnRDLFFBQTlCLENBQWhCO0FBQ0EsU0FBTyxFQUFDbUIsZ0JBQUQsRUFBVUQsZ0JBQVYsRUFBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTcUIsbUJBQVQsQ0FBNkJFLEVBQTdCLEVBQWlDO0FBQy9CLFNBQVFBLEtBQUs1QyxPQUFOLElBQWtCLE1BQU1jLEtBQUsrQixFQUE3QixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU0YsbUJBQVQsQ0FBNkJHLEdBQTdCLEVBQWtDQyxFQUFsQyxFQUFzQztBQUNwQyxTQUFRQSxLQUFLL0MsT0FBTixJQUFrQixNQUFNYyxLQUFLK0IsRUFBN0IsSUFBbUMvQixLQUFLa0MsR0FBTCxDQUFTRixNQUFNaEMsS0FBSytCLEVBQVgsR0FBZ0IsR0FBekIsQ0FBMUM7QUFDRCIsImZpbGUiOiJncmlkLWFnZ3JlZ2F0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmNvbnN0IFJfRUFSVEggPSA2Mzc4MDAwO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkZW5zaXR5IGdyaWQgZnJvbSBhbiBhcnJheSBvZiBwb2ludHNcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIC0gY2VsbCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGRhdGEsIGNlbGwgZGltZW5zaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvRGVuc2l0eUdyaWREYXRhKHBvaW50cywgY2VsbFNpemUsIGdldFBvc2l0aW9uKSB7XG5cbiAgY29uc3Qge2dyaWRIYXNoLCBncmlkT2Zmc2V0fSA9IF9wb2ludHNUb0dyaWRIYXNoaW5nKHBvaW50cywgY2VsbFNpemUsIGdldFBvc2l0aW9uKTtcbiAgY29uc3QgbGF5ZXJEYXRhID0gX2dldEdyaWRMYXllckRhdGFGcm9tR3JpZEhhc2goZ3JpZEhhc2gsIGdyaWRPZmZzZXQpO1xuXG4gIHJldHVybiB7XG4gICAgZ3JpZE9mZnNldCxcbiAgICBsYXllckRhdGFcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm9qZWN0IHBvaW50cyBpbnRvIGVhY2ggY2VsbCwgcmV0dXJuIGEgaGFzaCB0YWJsZSBvZiBjZWxsc1xuICogQHBhcmFtIHthcnJheX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2VsbFNpemUgLSB1bml0IHNpemUgaW4gbWV0ZXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIHBvc2l0aW9uIGFjY2Vzc29yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgaGFzaCBhbmQgY2VsbCBkaW1lbnNpb25cbiAqL1xuZnVuY3Rpb24gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pIHtcblxuICAvLyBmaW5kIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHNhbXBsZSBwb2ludHNcbiAgY29uc3QgYWxsTGF0ID0gcG9pbnRzLm1hcChwID0+IGdldFBvc2l0aW9uKHApWzFdKTtcbiAgY29uc3QgbGF0TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYWxsTGF0KTtcbiAgY29uc3QgbGF0TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgYWxsTGF0KTtcblxuICBjb25zdCBjZW50ZXJMYXQgPSAobGF0TWluICsgbGF0TWF4KSAvIDI7XG5cbiAgY29uc3QgZ3JpZE9mZnNldCA9IF9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0KGNlbGxTaXplLCBjZW50ZXJMYXQpO1xuXG4gIGlmIChncmlkT2Zmc2V0LnhPZmZzZXQgPD0gMCB8fCBncmlkT2Zmc2V0LnlPZmZzZXQgPD0gMCkge1xuICAgIHJldHVybiB7Z3JpZEhhc2g6IHt9LCBncmlkT2Zmc2V0fTtcbiAgfVxuICAvLyBjYWxjdWxhdGUgY291bnQgcGVyIGNlbGxcbiAgY29uc3QgZ3JpZEhhc2ggPSBwb2ludHMucmVkdWNlKChhY2N1LCBwdCkgPT4ge1xuICAgIGNvbnN0IGxhdElkeCA9IE1hdGguZmxvb3IoKGdldFBvc2l0aW9uKHB0KVsxXSArIDkwKSAvIGdyaWRPZmZzZXQueU9mZnNldCk7XG4gICAgY29uc3QgbG9uSWR4ID0gTWF0aC5mbG9vcigoZ2V0UG9zaXRpb24ocHQpWzBdICsgMTgwKSAvIGdyaWRPZmZzZXQueE9mZnNldCk7XG4gICAgY29uc3Qga2V5ID0gYCR7bGF0SWR4fS0ke2xvbklkeH1gO1xuXG4gICAgYWNjdVtrZXldID0gYWNjdVtrZXldIHx8IHtjb3VudDogMCwgcG9pbnRzOiBbXX07XG4gICAgYWNjdVtrZXldLmNvdW50ICs9IDE7XG4gICAgYWNjdVtrZXldLnBvaW50cy5wdXNoKHB0KTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHtncmlkSGFzaCwgZ3JpZE9mZnNldH07XG59XG5cbmZ1bmN0aW9uIF9nZXRHcmlkTGF5ZXJEYXRhRnJvbUdyaWRIYXNoKGdyaWRIYXNoLCBncmlkT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhncmlkSGFzaCkucmVkdWNlKChhY2N1LCBrZXksIGkpID0+IHtcbiAgICBjb25zdCBpZHhzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY29uc3QgbGF0SWR4ID0gcGFyc2VJbnQoaWR4c1swXSwgMTApO1xuICAgIGNvbnN0IGxvbklkeCA9IHBhcnNlSW50KGlkeHNbMV0sIDEwKTtcblxuICAgIGFjY3UucHVzaChPYmplY3QuYXNzaWduKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcG9zaXRpb246IFtcbiAgICAgICAgLTE4MCArIGdyaWRPZmZzZXQueE9mZnNldCAqIGxvbklkeCxcbiAgICAgICAgLTkwICsgZ3JpZE9mZnNldC55T2Zmc2V0ICogbGF0SWR4XG4gICAgICBdXG4gICAgfSwgZ3JpZEhhc2hba2V5XSkpO1xuXG4gICAgcmV0dXJuIGFjY3U7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgZ3JpZCBsYXllciBjZWxsIHNpemUgaW4gbGF0IGxvbiBiYXNlZCBvbiB3b3JsZCB1bml0IHNpemVcbiAqIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBAcGFyYW0ge251bWJlcn0gY2VsbFNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXRpdHVkZVxuICogQHJldHVybnMge29iamVjdH0gLSBsYXQgZGVsdGEgYW5kIGxvbiBkZWx0YVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldChjZWxsU2l6ZSwgbGF0aXR1ZGUpIHtcbiAgY29uc3QgeU9mZnNldCA9IF9jYWxjdWxhdGVMYXRPZmZzZXQoY2VsbFNpemUpO1xuICBjb25zdCB4T2Zmc2V0ID0gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXRpdHVkZSwgY2VsbFNpemUpO1xuICByZXR1cm4ge3lPZmZzZXQsIHhPZmZzZXR9O1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbGF0aXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gZHkgLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbGF0aXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxhdE9mZnNldChkeSkge1xuICByZXR1cm4gKGR5IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSk7XG59XG5cbi8qKlxuICogd2l0aCBhIGdpdmVuIHgta20gY2hhbmdlLCBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbG9uZ2l0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIGxhdGl0dWRlIG9mIGN1cnJlbnQgbG9jYXRpb24gKGJhc2VkIG9uIGNpdHkpXG4gKiBAcGFyYW0ge251bWJlcn0gZHggLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbG9uZ2l0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMb25PZmZzZXQobGF0LCBkeCkge1xuICByZXR1cm4gKGR4IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSkgLyBNYXRoLmNvcyhsYXQgKiBNYXRoLlBJIC8gMTgwKTtcbn1cbiJdfQ==

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grid_cell_layer_grid_cell_layer__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grid_aggregator__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_bin_sorter__ = __webpack_require__(83);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.










var defaultProps = {
  cellSize: 1000,
  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__["a" /* defaultColorRange */],
  colorDomain: null,
  elevationRange: [0, 1000],
  elevationDomain: null,
  elevationScale: 1,
  lowerPercentile: 0,
  upperPercentile: 100,
  coverage: 1,
  getPosition: function getPosition(x) {
    return x.position;
  },
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  extruded: false,
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

function _needsReProjectPoints(oldProps, props) {
  return oldProps.cellSize !== props.cellSize;
}

function _percentileChanged(oldProps, props) {
  return oldProps.lowerPercentile !== props.lowerPercentile || oldProps.upperPercentile !== props.upperPercentile;
}

function _needsReSortBins(oldProps, props) {
  return oldProps.getColorValue !== props.getColorValue;
}

var GridLayer = function (_CompositeLayer) {
  _inherits(GridLayer, _CompositeLayer);

  function GridLayer() {
    _classCallCheck(this, GridLayer);

    return _possibleConstructorReturn(this, (GridLayer.__proto__ || Object.getPrototypeOf(GridLayer)).apply(this, arguments));
  }

  _createClass(GridLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        layerData: [],
        sortedBins: null,
        valueDomain: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedBins
        this.getLayerData();
        this.getSortedBins();

        // this needs sortedBins to be set
        this.getValueDomain();
      } else if (_needsReSortBins(oldProps, props)) {

        this.getSortedBins();
        this.getValueDomain();
      } else if (_percentileChanged(oldProps, props)) {

        this.getValueDomain();
      }
    }
  }, {
    key: 'getLayerData',
    value: function getLayerData() {
      var _props = this.props,
          data = _props.data,
          cellSize = _props.cellSize,
          getPosition = _props.getPosition;

      var _pointToDensityGridDa = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__grid_aggregator__["a" /* pointToDensityGridData */])(data, cellSize, getPosition),
          layerData = _pointToDensityGridDa.layerData;

      this.setState({ layerData: layerData });
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      var sortedBins = new __WEBPACK_IMPORTED_MODULE_5__utils_bin_sorter__["a" /* default */](this.state.layerData || [], this.props.getColorValue);
      this.setState({ sortedBins: sortedBins });
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      var _props2 = this.props,
          lowerPercentile = _props2.lowerPercentile,
          upperPercentile = _props2.upperPercentile;


      this.state.valueDomain = this.state.sortedBins.getValueRange([lowerPercentile, upperPercentile]);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;

      var pickedCell = info.picked && info.index > -1 ? this.state.layerData[info.index] : null;

      return Object.assign(info, {
        picked: Boolean(pickedCell),
        // override object with picked cell
        object: pickedCell
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      return {
        getColor: {
          colorRange: this.props.colorRange,
          colorDomain: this.props.colorDomain,
          getColorValue: this.props.getColorValue,
          lowerPercentile: this.props.lowerPercentile,
          upperPercentile: this.props.upperPercentile
        },
        getElevation: {
          elevationRange: this.props.elevationRange,
          elevationDomain: this.props.elevationDomain
        }
      };
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var colorRange = this.props.colorRange;
      var _state = this.state,
          valueDomain = _state.valueDomain,
          sortedBins = _state.sortedBins;

      var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;

      var colorDomain = this.props.colorDomain || valueDomain;
      var color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__["a" /* quantizeScale */])(colorDomain, colorRange, value);

      // if cell value is outside domain, set alpha to 0
      var alpha = value >= valueDomain[0] && value <= valueDomain[1] ? Number.isFinite(color[3]) ? color[3] : 255 : 0;

      // add final alpha to color
      color[3] = alpha;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _props3 = this.props,
          elevationDomain = _props3.elevationDomain,
          elevationRange = _props3.elevationRange;
      var sortedBins = this.state.sortedBins;

      // elevation is based on counts, it is not affected by percentile

      var domain = elevationDomain || [0, sortedBins.maxCount];
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__["b" /* linearScale */])(domain, elevationRange, cell.points.length);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var _props4 = this.props,
          id = _props4.id,
          elevationScale = _props4.elevationScale,
          fp64 = _props4.fp64,
          extruded = _props4.extruded,
          cellSize = _props4.cellSize,
          coverage = _props4.coverage,
          lightSettings = _props4.lightSettings;

      // base layer props

      var _props5 = this.props,
          opacity = _props5.opacity,
          pickable = _props5.pickable,
          visible = _props5.visible,
          getPolygonOffset = _props5.getPolygonOffset;

      // viewport props

      var _props6 = this.props,
          positionOrigin = _props6.positionOrigin,
          projectionMode = _props6.projectionMode,
          modelMatrix = _props6.modelMatrix;


      return new __WEBPACK_IMPORTED_MODULE_1__grid_cell_layer_grid_cell_layer__["a" /* default */]({
        id: id + '-grid-cell',
        data: this.state.layerData,
        cellSize: cellSize,
        coverage: coverage,
        lightSettings: lightSettings,
        elevationScale: elevationScale,
        extruded: extruded,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        getPosition: function getPosition(d) {
          return d.position;
        },
        updateTriggers: this.getUpdateTriggers()
      });
    }
  }]);

  return GridLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["b" /* CompositeLayer */]);

/* harmony default export */ __webpack_exports__["a"] = (GridLayer);


GridLayer.layerName = 'GridLayer';
GridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJHcmlkQ2VsbExheWVyIiwicG9pbnRUb0RlbnNpdHlHcmlkRGF0YSIsImxpbmVhclNjYWxlIiwicXVhbnRpemVTY2FsZSIsImRlZmF1bHRDb2xvclJhbmdlIiwiQmluU29ydGVyIiwiZGVmYXVsdFByb3BzIiwiY2VsbFNpemUiLCJjb2xvclJhbmdlIiwiY29sb3JEb21haW4iLCJlbGV2YXRpb25SYW5nZSIsImVsZXZhdGlvbkRvbWFpbiIsImVsZXZhdGlvblNjYWxlIiwibG93ZXJQZXJjZW50aWxlIiwidXBwZXJQZXJjZW50aWxlIiwiY292ZXJhZ2UiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsImdldENvbG9yVmFsdWUiLCJwb2ludHMiLCJsZW5ndGgiLCJleHRydWRlZCIsImZwNjQiLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIl9uZWVkc1JlUHJvamVjdFBvaW50cyIsIm9sZFByb3BzIiwicHJvcHMiLCJfcGVyY2VudGlsZUNoYW5nZWQiLCJfbmVlZHNSZVNvcnRCaW5zIiwiR3JpZExheWVyIiwic3RhdGUiLCJsYXllckRhdGEiLCJzb3J0ZWRCaW5zIiwidmFsdWVEb21haW4iLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiZ2V0TGF5ZXJEYXRhIiwiZ2V0U29ydGVkQmlucyIsImdldFZhbHVlRG9tYWluIiwiZGF0YSIsInNldFN0YXRlIiwiZ2V0VmFsdWVSYW5nZSIsImluZm8iLCJwaWNrZWRDZWxsIiwicGlja2VkIiwiaW5kZXgiLCJPYmplY3QiLCJhc3NpZ24iLCJCb29sZWFuIiwib2JqZWN0IiwiZ2V0Q29sb3IiLCJnZXRFbGV2YXRpb24iLCJjZWxsIiwidmFsdWUiLCJiaW5NYXAiLCJjb2xvciIsImFscGhhIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJkb21haW4iLCJtYXhDb3VudCIsImlkIiwib3BhY2l0eSIsInBpY2thYmxlIiwidmlzaWJsZSIsImdldFBvbHlnb25PZmZzZXQiLCJwb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25Nb2RlIiwibW9kZWxNYXRyaXgiLCJfb25HZXRTdWJsYXllckNvbG9yIiwiYmluZCIsIl9vbkdldFN1YmxheWVyRWxldmF0aW9uIiwiZCIsInVwZGF0ZVRyaWdnZXJzIiwiZ2V0VXBkYXRlVHJpZ2dlcnMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixRQUE2QixjQUE3QjtBQUNBLE9BQU9DLGFBQVAsTUFBMEIsb0NBQTFCOztBQUVBLFNBQVFDLHNCQUFSLFFBQXFDLG1CQUFyQztBQUNBLFNBQVFDLFdBQVIsRUFBcUJDLGFBQXJCLFFBQXlDLDRCQUF6QztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLDRCQUFoQzs7QUFFQSxPQUFPQyxTQUFQLE1BQXNCLDJCQUF0Qjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxZQUFVLElBRFM7QUFFbkJDLGNBQVlKLGlCQUZPO0FBR25CSyxlQUFhLElBSE07QUFJbkJDLGtCQUFnQixDQUFDLENBQUQsRUFBSSxJQUFKLENBSkc7QUFLbkJDLG1CQUFpQixJQUxFO0FBTW5CQyxrQkFBZ0IsQ0FORztBQU9uQkMsbUJBQWlCLENBUEU7QUFRbkJDLG1CQUFpQixHQVJFO0FBU25CQyxZQUFVLENBVFM7QUFVbkJDLGVBQWE7QUFBQSxXQUFLQyxFQUFFQyxRQUFQO0FBQUEsR0FWTTtBQVduQkMsaUJBQWU7QUFBQSxXQUFVQyxPQUFPQyxNQUFqQjtBQUFBLEdBWEk7QUFZ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QkMsZ0JBSnRCLFdBSXNCQSxnQkFKdEI7O0FBTWI7O0FBTmEsb0JBT3lDLEtBQUt2QyxLQVA5QztBQUFBLFVBT053QyxjQVBNLFdBT05BLGNBUE07QUFBQSxVQU9VQyxjQVBWLFdBT1VBLGNBUFY7QUFBQSxVQU8wQkMsV0FQMUIsV0FPMEJBLFdBUDFCOzs7QUFTYixhQUFPLElBQUkzRSxhQUFKLENBQWtCO0FBQ3ZCb0UsWUFBT0EsRUFBUCxlQUR1QjtBQUV2QnRCLGNBQU0sS0FBS1QsS0FBTCxDQUFXQyxTQUZNO0FBR3ZCL0IsMEJBSHVCO0FBSXZCUSwwQkFKdUI7QUFLdkJTLG9DQUx1QjtBQU12Qlosc0NBTnVCO0FBT3ZCVSwwQkFQdUI7QUFRdkJDLGtCQVJ1QjtBQVN2QjhDLHdCQVR1QjtBQVV2QkMsMEJBVnVCO0FBV3ZCQyx3QkFYdUI7QUFZdkJDLDBDQVp1QjtBQWF2QkUsc0NBYnVCO0FBY3ZCRCxzQ0FkdUI7QUFldkJFLGdDQWZ1QjtBQWdCdkJsQixrQkFBVSxLQUFLbUIsbUJBQUwsQ0FBeUJDLElBQXpCLENBQThCLElBQTlCLENBaEJhO0FBaUJ2Qm5CLHNCQUFjLEtBQUtvQix1QkFBTCxDQUE2QkQsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FqQlM7QUFrQnZCN0QscUJBQWE7QUFBQSxpQkFBSytELEVBQUU3RCxRQUFQO0FBQUEsU0FsQlU7QUFtQnZCOEQsd0JBQWdCLEtBQUtDLGlCQUFMO0FBbkJPLE9BQWxCLENBQVA7QUFxQkQ7Ozs7RUFuSW9DbEYsYzs7ZUFBbEJxQyxTOzs7QUFzSXJCQSxVQUFVOEMsU0FBVixHQUFzQixXQUF0QjtBQUNBOUMsVUFBVTlCLFlBQVYsR0FBeUJBLFlBQXpCIiwiZmlsZSI6ImdyaWQtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBHcmlkQ2VsbExheWVyIGZyb20gJy4uL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXInO1xuXG5pbXBvcnQge3BvaW50VG9EZW5zaXR5R3JpZERhdGF9IGZyb20gJy4vZ3JpZC1hZ2dyZWdhdG9yJztcbmltcG9ydCB7bGluZWFyU2NhbGUsIHF1YW50aXplU2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3NjYWxlLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdENvbG9yUmFuZ2V9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcblxuaW1wb3J0IEJpblNvcnRlciBmcm9tICcuLi8uLi8uLi91dGlscy9iaW4tc29ydGVyJztcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZTogMTAwMCxcbiAgY29sb3JSYW5nZTogZGVmYXVsdENvbG9yUmFuZ2UsXG4gIGNvbG9yRG9tYWluOiBudWxsLFxuICBlbGV2YXRpb25SYW5nZTogWzAsIDEwMDBdLFxuICBlbGV2YXRpb25Eb21haW46IG51bGwsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBsb3dlclBlcmNlbnRpbGU6IDAsXG4gIHVwcGVyUGVyY2VudGlsZTogMTAwLFxuICBjb3ZlcmFnZTogMSxcbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZ2V0Q29sb3JWYWx1ZTogcG9pbnRzID0+IHBvaW50cy5sZW5ndGgsXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmNlbGxTaXplICE9PSBwcm9wcy5jZWxsU2l6ZTtcbn1cblxuZnVuY3Rpb24gX3BlcmNlbnRpbGVDaGFuZ2VkKG9sZFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gb2xkUHJvcHMubG93ZXJQZXJjZW50aWxlICE9PSBwcm9wcy5sb3dlclBlcmNlbnRpbGUgfHxcbiAgICBvbGRQcm9wcy51cHBlclBlcmNlbnRpbGUgIT09IHByb3BzLnVwcGVyUGVyY2VudGlsZTtcbn1cblxuZnVuY3Rpb24gX25lZWRzUmVTb3J0QmlucyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmdldENvbG9yVmFsdWUgIT09IHByb3BzLmdldENvbG9yVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRMYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsYXllckRhdGE6IFtdLFxuICAgICAgc29ydGVkQmluczogbnVsbCxcbiAgICAgIHZhbHVlRG9tYWluOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgLy8gcHJvamVjdCBkYXRhIGludG8gaGV4YWdvbnMsIGFuZCBnZXQgc29ydGVkQmluc1xuICAgICAgdGhpcy5nZXRMYXllckRhdGEoKTtcbiAgICAgIHRoaXMuZ2V0U29ydGVkQmlucygpO1xuXG4gICAgICAvLyB0aGlzIG5lZWRzIHNvcnRlZEJpbnMgdG8gYmUgc2V0XG4gICAgICB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgfSBlbHNlIGlmIChfbmVlZHNSZVNvcnRCaW5zKG9sZFByb3BzLCBwcm9wcykpIHtcblxuICAgICAgdGhpcy5nZXRTb3J0ZWRCaW5zKCk7XG4gICAgICB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG5cbiAgICB9IGVsc2UgaWYgKF9wZXJjZW50aWxlQ2hhbmdlZChvbGRQcm9wcywgcHJvcHMpKSB7XG5cbiAgICAgIHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICB9XG4gIH1cblxuICBnZXRMYXllckRhdGEoKSB7XG4gICAgY29uc3Qge2RhdGEsIGNlbGxTaXplLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtsYXllckRhdGF9ID0gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShkYXRhLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7bGF5ZXJEYXRhfSk7XG4gIH1cblxuICBnZXRTb3J0ZWRCaW5zKCkge1xuICAgIGNvbnN0IHNvcnRlZEJpbnMgPSBuZXcgQmluU29ydGVyKHRoaXMuc3RhdGUubGF5ZXJEYXRhIHx8IFtdLCB0aGlzLnByb3BzLmdldENvbG9yVmFsdWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3NvcnRlZEJpbnN9KTtcbiAgfVxuXG4gIGdldFZhbHVlRG9tYWluKCkge1xuICAgIGNvbnN0IHtsb3dlclBlcmNlbnRpbGUsIHVwcGVyUGVyY2VudGlsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zdGF0ZS52YWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkQmluc1xuICAgICAgLmdldFZhbHVlUmFuZ2UoW2xvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlXSk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7aW5mb30pIHtcbiAgICBjb25zdCBwaWNrZWRDZWxsID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xID9cbiAgICAgIHRoaXMuc3RhdGUubGF5ZXJEYXRhW2luZm8uaW5kZXhdIDogbnVsbDtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIHBpY2tlZDogQm9vbGVhbihwaWNrZWRDZWxsKSxcbiAgICAgIC8vIG92ZXJyaWRlIG9iamVjdCB3aXRoIHBpY2tlZCBjZWxsXG4gICAgICBvYmplY3Q6IHBpY2tlZENlbGxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFVwZGF0ZVRyaWdnZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb2xvcjoge1xuICAgICAgICBjb2xvclJhbmdlOiB0aGlzLnByb3BzLmNvbG9yUmFuZ2UsXG4gICAgICAgIGNvbG9yRG9tYWluOiB0aGlzLnByb3BzLmNvbG9yRG9tYWluLFxuICAgICAgICBnZXRDb2xvclZhbHVlOiB0aGlzLnByb3BzLmdldENvbG9yVmFsdWUsXG4gICAgICAgIGxvd2VyUGVyY2VudGlsZTogdGhpcy5wcm9wcy5sb3dlclBlcmNlbnRpbGUsXG4gICAgICAgIHVwcGVyUGVyY2VudGlsZTogdGhpcy5wcm9wcy51cHBlclBlcmNlbnRpbGVcbiAgICAgIH0sXG4gICAgICBnZXRFbGV2YXRpb246IHtcbiAgICAgICAgZWxldmF0aW9uUmFuZ2U6IHRoaXMucHJvcHMuZWxldmF0aW9uUmFuZ2UsXG4gICAgICAgIGVsZXZhdGlvbkRvbWFpbjogdGhpcy5wcm9wcy5lbGV2YXRpb25Eb21haW5cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge2NvbG9yUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWVEb21haW4sIHNvcnRlZEJpbnN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmIHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuXG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHZhbHVlRG9tYWluO1xuICAgIGNvbnN0IGNvbG9yID0gcXVhbnRpemVTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgdmFsdWUpO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGFscGhhIHRvIDBcbiAgICBjb25zdCBhbHBoYSA9IHZhbHVlID49IHZhbHVlRG9tYWluWzBdICYmIHZhbHVlIDw9IHZhbHVlRG9tYWluWzFdID9cbiAgICAgIChOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTUpIDogMDtcblxuICAgIC8vIGFkZCBmaW5hbCBhbHBoYSB0byBjb2xvclxuICAgIGNvbG9yWzNdID0gYWxwaGE7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7c29ydGVkQmluc30gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gZWxldmF0aW9uIGlzIGJhc2VkIG9uIGNvdW50cywgaXQgaXMgbm90IGFmZmVjdGVkIGJ5IHBlcmNlbnRpbGVcbiAgICBjb25zdCBkb21haW4gPSBlbGV2YXRpb25Eb21haW4gfHwgWzAsIHNvcnRlZEJpbnMubWF4Q291bnRdO1xuICAgIHJldHVybiBsaW5lYXJTY2FsZShkb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLnBvaW50cy5sZW5ndGgpO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtpZCwgZWxldmF0aW9uU2NhbGUsIGZwNjQsIGV4dHJ1ZGVkLCBjZWxsU2l6ZSwgY292ZXJhZ2UsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIGJhc2UgbGF5ZXIgcHJvcHNcbiAgICBjb25zdCB7b3BhY2l0eSwgcGlja2FibGUsIHZpc2libGUsIGdldFBvbHlnb25PZmZzZXR9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHZpZXdwb3J0IHByb3BzXG4gICAgY29uc3Qge3Bvc2l0aW9uT3JpZ2luLCBwcm9qZWN0aW9uTW9kZSwgbW9kZWxNYXRyaXh9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXcgR3JpZENlbGxMYXllcih7XG4gICAgICBpZDogYCR7aWR9LWdyaWQtY2VsbGAsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmxheWVyRGF0YSxcbiAgICAgIGNlbGxTaXplLFxuICAgICAgY292ZXJhZ2UsXG4gICAgICBsaWdodFNldHRpbmdzLFxuICAgICAgZWxldmF0aW9uU2NhbGUsXG4gICAgICBleHRydWRlZCxcbiAgICAgIGZwNjQsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGlja2FibGUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgZ2V0UG9seWdvbk9mZnNldCxcbiAgICAgIHByb2plY3Rpb25Nb2RlLFxuICAgICAgcG9zaXRpb25PcmlnaW4sXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIGdldENvbG9yOiB0aGlzLl9vbkdldFN1YmxheWVyQ29sb3IuYmluZCh0aGlzKSxcbiAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5fb25HZXRTdWJsYXllckVsZXZhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZ2V0UG9zaXRpb246IGQgPT4gZC5wb3NpdGlvbixcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB0aGlzLmdldFVwZGF0ZVRyaWdnZXJzKClcbiAgICB9KTtcbiAgfVxufVxuXG5HcmlkTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRMYXllcic7XG5HcmlkTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME hexagon-cell-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiaGV4YWdvbi1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGhleGFnb24tY2VsbC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME hexagon-cell-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform float extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\n#define ELEVATION_SCALE 0.8\n\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n  vec2 rPos = rotationMatrix * positions.xz;\n  vec2 rNorm = rotationMatrix * normals.xz;\n\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) *\n      ELEVATION_SCALE * elevationScale);\n}\n\n  float dotRadius = radius * clamp(coverage, 0.0, 1.0);\n  // // project center of hexagon\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(rotatedPositions.xz * dotRadius, 0.0, 1.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2], vec2(elevation, 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  // render display\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether hexagon is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    // Light calculations\n    // Worldspace is the linear space after Mercator projection\n\n    vec3 normals_worldspace = rotatedNormals;\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace.xyz, // the w component is always 1.0\n        normals_worldspace\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n\n    // Color: Either opacity-multiplied instance color, or picking color\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\n\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n    vColor = pickingColor;\n\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyLXZlcnRleC02NC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImhleGFnb24tY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgaGV4YWdvbi1jZWxsLWxheWVyLXZlcnRleC1zaGFkZXItNjRcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgbm9ybWFscztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxuLy8gUGlja2luZyB1bmlmb3Jtc1xuLy8gU2V0IHRvIDEuMCBpZiByZW5kZXJpbmcgcGlja2luZyBidWZmZXIsIDAuMCBpZiByZW5kZXJpbmcgZm9yIGRpc3BsYXlcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcblxuLy8gQ3VzdG9tIHVuaWZvcm1zXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnVuaWZvcm0gZmxvYXQgYW5nbGU7XG51bmlmb3JtIGZsb2F0IGV4dHJ1ZGVkO1xudW5pZm9ybSBmbG9hdCBjb3ZlcmFnZTtcbnVuaWZvcm0gZmxvYXQgZWxldmF0aW9uU2NhbGU7XG5cbi8vIFJlc3VsdFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXIuXG4jZGVmaW5lIEVMRVZBVElPTl9TQ0FMRSAwLjhcblxuZmxvYXQgaXNQaWNrZWQodmVjMyBwaWNraW5nQ29sb3JzLCB2ZWMzIHNlbGVjdGVkQ29sb3IpIHtcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcbiAmJiBwaWNraW5nQ29sb3JzLnogPT0gc2VsZWN0ZWRDb2xvci56KTtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcblxuICAvLyByb3RhdGUgcHJpbWl0aXZlIHBvc2l0aW9uIGFuZCBub3JtYWxcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xuXG4gIHZlYzIgclBvcyA9IHJvdGF0aW9uTWF0cml4ICogcG9zaXRpb25zLnh6O1xuICB2ZWMyIHJOb3JtID0gcm90YXRpb25NYXRyaXggKiBub3JtYWxzLnh6O1xuXG4gIHZlYzMgcm90YXRlZFBvc2l0aW9ucyA9IHZlYzMoclBvcy54LCBwb3NpdGlvbnMueSwgclBvcy55KTtcbiAgdmVjMyByb3RhdGVkTm9ybWFscyA9IHZlYzMock5vcm0ueCwgbm9ybWFscy55LCByTm9ybS55KTtcblxuICAvLyBjYWxjdWxhdGUgZWxldmF0aW9uLCBpZiAzZCBub3QgZW5hYmxlZCBzZXQgdG8gMFxuICAvLyBjeWxpbmRhciBnZW1vZXRyeSBoZWlnaHQgYXJlIGJldHdlZW4gLTAuNSB0byAwLjUsIHRyYW5zZm9ybSBpdCB0byBiZXR3ZWVuIDAsIDFcbiAgZmxvYXQgZWxldmF0aW9uID0gMC4wO1xuXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgIGVsZXZhdGlvbiA9IHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiAqIChwb3NpdGlvbnMueSArIDAuNSkgKlxuICAgICAgRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpO1xufVxuXG4gIGZsb2F0IGRvdFJhZGl1cyA9IHJhZGl1cyAqIGNsYW1wKGNvdmVyYWdlLCAwLjAsIDEuMCk7XG4gIC8vIC8vIHByb2plY3QgY2VudGVyIG9mIGhleGFnb25cblxuICB2ZWM0IGluc3RhbmNlUG9zaXRpb25zNjR4eSA9IHZlYzQoXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueCwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LngsXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueSwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgcHJvamVjdGVkX2Nvb3JkX3h5WzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VQb3NpdGlvbnM2NHh5LCBwcm9qZWN0ZWRfY29vcmRfeHkpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19sb2NhbHNwYWNlWzRdO1xuICB2ZWM0X2ZwNjQodmVjNChyb3RhdGVkUG9zaXRpb25zLnh6ICogZG90UmFkaXVzLCAwLjAsIDEuMCksIHZlcnRleF9wb3NfbG9jYWxzcGFjZSk7XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVswXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzBdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzFdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMV0pO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMl0sIHZlYzIoZWxldmF0aW9uLCAwLjApKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChcbiAgICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdLngsXG4gICAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXS54KTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcblxuICAvLyByZW5kZXIgZGlzcGxheVxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA8IDAuNSkge1xuXG4gICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhlIGNvbG9yIGZvciBcInNlbGVjdGVkIGVsZW1lbnRcIlxuICAgIC8vIGNoZWNrIHdoZXRoZXIgaGV4YWdvbiBpcyBjdXJyZW50bHkgcGlja2VkLlxuICAgIGZsb2F0IHNlbGVjdGVkID0gaXNQaWNrZWQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCBzZWxlY3RlZFBpY2tpbmdDb2xvcik7XG5cbiAgICAvLyBMaWdodCBjYWxjdWxhdGlvbnNcbiAgICAvLyBXb3JsZHNwYWNlIGlzIHRoZSBsaW5lYXIgc3BhY2UgYWZ0ZXIgTWVyY2F0b3IgcHJvamVjdGlvblxuXG4gICAgdmVjMyBub3JtYWxzX3dvcmxkc3BhY2UgPSByb3RhdGVkTm9ybWFscztcblxuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMS4wO1xuXG4gICAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XG4gICAgICBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLnh5eiwgLy8gdGhlIHcgY29tcG9uZW50IGlzIGFsd2F5cyAxLjBcbiAgICAgICAgbm9ybWFsc193b3JsZHNwYWNlXG4gICAgICApO1xuICAgIH1cblxuICAgIHZlYzMgbGlnaHRXZWlnaHRlZENvbG9yID0gbGlnaHRXZWlnaHQgKiBpbnN0YW5jZUNvbG9ycy5yZ2I7XG5cbiAgICAvLyBDb2xvcjogRWl0aGVyIG9wYWNpdHktbXVsdGlwbGllZCBpbnN0YW5jZSBjb2xvciwgb3IgcGlja2luZyBjb2xvclxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ZWRDb2xvciwgb3BhY2l0eSAqIGluc3RhbmNlQ29sb3JzLmEpIC8gMjU1LjA7XG5cbiAgICB2Q29sb3IgPSBjb2xvcjtcblxuICB9IGVsc2Uge1xuXG4gICAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4wLCAxLjApO1xuICAgIHZDb2xvciA9IHBpY2tpbmdDb2xvcjtcblxuICB9XG59XG5gO1xuIl19

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform float extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\n#define ELEVATION_SCALE 0.8\n\n// whether is point picked\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n  vec2 rPos = rotationMatrix * positions.xz;\n  vec2 rNorm = rotationMatrix * normals.xz;\n\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) *\n      ELEVATION_SCALE * elevationScale);\n  }\n\n  float dotRadius = radius * mix(coverage, 0.0, float(instanceColors.a == 0.0));\n  // // project center of hexagon\n\n  vec4 centroidPosition = vec4(project_position(instancePositions.xy), elevation, 0.0);\n\n  vec4 position_worldspace = centroidPosition + vec4(vec2(rotatedPositions.xz * dotRadius), 0., 1.);\n\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  // render display\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether hexagon is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    // Light calculations\n    // Worldspace is the linear space after Mercator projection\n\n    vec3 normals_worldspace = rotatedNormals;\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace.xyz, // the w component is always 1.0\n        normals_worldspace\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n\n    // Color: Either opacity-multiplied instance color, or picking color\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\n\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n    vColor = pickingColor;\n\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyLXZlcnRleC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImhleGFnb24tY2VsbC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcblxuI2RlZmluZSBTSEFERVJfTkFNRSBoZXhhZ29uLWNlbGwtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4vLyBQaWNraW5nIHVuaWZvcm1zXG4vLyBTZXQgdG8gMS4wIGlmIHJlbmRlcmluZyBwaWNraW5nIGJ1ZmZlciwgMC4wIGlmIHJlbmRlcmluZyBmb3IgZGlzcGxheVxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBDdXN0b20gdW5pZm9ybXNcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudW5pZm9ybSBmbG9hdCBhbmdsZTtcbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XG51bmlmb3JtIGZsb2F0IGNvdmVyYWdlO1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcblxuLy8gUmVzdWx0XG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4vLyBBIG1hZ2ljIG51bWJlciB0byBzY2FsZSBlbGV2YXRpb24gc28gdGhhdCAxIHVuaXQgYXBwcm94aW1hdGUgdG8gMSBtZXRlci5cbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxuXG4vLyB3aGV0aGVyIGlzIHBvaW50IHBpY2tlZFxuZmxvYXQgaXNQaWNrZWQodmVjMyBwaWNraW5nQ29sb3JzLCB2ZWMzIHNlbGVjdGVkQ29sb3IpIHtcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcbiAmJiBwaWNraW5nQ29sb3JzLnogPT0gc2VsZWN0ZWRDb2xvci56KTtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcblxuICAvLyByb3RhdGUgcHJpbWl0aXZlIHBvc2l0aW9uIGFuZCBub3JtYWxcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xuXG4gIHZlYzIgclBvcyA9IHJvdGF0aW9uTWF0cml4ICogcG9zaXRpb25zLnh6O1xuICB2ZWMyIHJOb3JtID0gcm90YXRpb25NYXRyaXggKiBub3JtYWxzLnh6O1xuXG4gIHZlYzMgcm90YXRlZFBvc2l0aW9ucyA9IHZlYzMoclBvcy54LCBwb3NpdGlvbnMueSwgclBvcy55KTtcbiAgdmVjMyByb3RhdGVkTm9ybWFscyA9IHZlYzMock5vcm0ueCwgbm9ybWFscy55LCByTm9ybS55KTtcblxuICAvLyBjYWxjdWxhdGUgZWxldmF0aW9uLCBpZiAzZCBub3QgZW5hYmxlZCBzZXQgdG8gMFxuICAvLyBjeWxpbmRhciBnZW1vZXRyeSBoZWlnaHQgYXJlIGJldHdlZW4gLTAuNSB0byAwLjUsIHRyYW5zZm9ybSBpdCB0byBiZXR3ZWVuIDAsIDFcbiAgZmxvYXQgZWxldmF0aW9uID0gMC4wO1xuXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgIGVsZXZhdGlvbiA9IHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiAqIChwb3NpdGlvbnMueSArIDAuNSkgKlxuICAgICAgRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpO1xuICB9XG5cbiAgZmxvYXQgZG90UmFkaXVzID0gcmFkaXVzICogbWl4KGNvdmVyYWdlLCAwLjAsIGZsb2F0KGluc3RhbmNlQ29sb3JzLmEgPT0gMC4wKSk7XG4gIC8vIC8vIHByb2plY3QgY2VudGVyIG9mIGhleGFnb25cblxuICB2ZWM0IGNlbnRyb2lkUG9zaXRpb24gPSB2ZWM0KHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpLCBlbGV2YXRpb24sIDAuMCk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gY2VudHJvaWRQb3NpdGlvbiArIHZlYzQodmVjMihyb3RhdGVkUG9zaXRpb25zLnh6ICogZG90UmFkaXVzKSwgMC4sIDEuKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xuXG4gIC8vIHJlbmRlciBkaXNwbGF5XG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyIDwgMC41KSB7XG5cbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXG4gICAgLy8gY2hlY2sgd2hldGhlciBoZXhhZ29uIGlzIGN1cnJlbnRseSBwaWNrZWQuXG4gICAgZmxvYXQgc2VsZWN0ZWQgPSBpc1BpY2tlZChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIHNlbGVjdGVkUGlja2luZ0NvbG9yKTtcblxuICAgIC8vIExpZ2h0IGNhbGN1bGF0aW9uc1xuICAgIC8vIFdvcmxkc3BhY2UgaXMgdGhlIGxpbmVhciBzcGFjZSBhZnRlciBNZXJjYXRvciBwcm9qZWN0aW9uXG5cbiAgICB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZSA9IHJvdGF0ZWROb3JtYWxzO1xuXG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XG5cbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UueHl6LCAvLyB0aGUgdyBjb21wb25lbnQgaXMgYWx3YXlzIDEuMFxuICAgICAgICBub3JtYWxzX3dvcmxkc3BhY2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGluc3RhbmNlQ29sb3JzLnJnYjtcblxuICAgIC8vIENvbG9yOiBFaXRoZXIgb3BhY2l0eS1tdWx0aXBsaWVkIGluc3RhbmNlIGNvbG9yLCBvciBwaWNraW5nIGNvbG9yXG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBvcGFjaXR5ICogaW5zdGFuY2VDb2xvcnMuYSkgLyAyNTUuMDtcblxuICAgIHZDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LjAsIDEuMCk7XG4gICAgdkNvbG9yID0gcGlja2luZ0NvbG9yO1xuXG4gIH1cbn1cbmA7XG4iXX0=

/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = pointToHexbin;
/* unused harmony export getRadiusInPixel */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_hexbin__ = __webpack_require__(127);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



/**
 * Use d3-hexbin to performs hexagonal binning from geo points to hexagons
 * @param {Array} data - array of points
 * @param {Number} radius - hexagon radius in meter
 * @param {function} getPosition - get points lon lat
 * @param {Object} viewport - current viewport object

 * @return {Object} - hexagons and countRange
 */
function pointToHexbin(_ref, viewport) {
  var data = _ref.data,
      radius = _ref.radius,
      getPosition = _ref.getPosition;

  // get hexagon radius in mercator world unit
  var radiusInPixel = getRadiusInPixel(radius, viewport);

  // add world space coordinates to points
  var screenPoints = data.map(function (pt) {
    return Object.assign({
      screenCoord: viewport.projectFlat(getPosition(pt))
    }, pt);
  });

  var newHexbin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_hexbin__["a" /* hexbin */])().radius(radiusInPixel).x(function (d) {
    return d.screenCoord[0];
  }).y(function (d) {
    return d.screenCoord[1];
  });

  var hexagonBins = newHexbin(screenPoints);

  return {
    hexagons: hexagonBins.map(function (hex, index) {
      return {
        centroid: viewport.unprojectFlat([hex.x, hex.y]),
        points: hex,
        index: index
      };
    })
  };
}

/**
 * Get radius in mercator world space coordinates from meter
 * @param {Number} radius - in meter
 * @param {Object} viewport - current viewport object

 * @return {Number} radius in mercator world spcae coordinates
 */
function getRadiusInPixel(radius, viewport) {
  var _viewport$getDistance = viewport.getDistanceScales(),
      pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;

  // x, y distance should be the same


  return radius * pixelsPerMeter[0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWxheWVyL2hleGFnb24tYWdncmVnYXRvci5qcyJdLCJuYW1lcyI6WyJoZXhiaW4iLCJwb2ludFRvSGV4YmluIiwidmlld3BvcnQiLCJkYXRhIiwicmFkaXVzIiwiZ2V0UG9zaXRpb24iLCJyYWRpdXNJblBpeGVsIiwiZ2V0UmFkaXVzSW5QaXhlbCIsInNjcmVlblBvaW50cyIsIm1hcCIsIk9iamVjdCIsImFzc2lnbiIsInNjcmVlbkNvb3JkIiwicHJvamVjdEZsYXQiLCJwdCIsIm5ld0hleGJpbiIsIngiLCJkIiwieSIsImhleGFnb25CaW5zIiwiaGV4YWdvbnMiLCJoZXgiLCJpbmRleCIsImNlbnRyb2lkIiwidW5wcm9qZWN0RmxhdCIsInBvaW50cyIsImdldERpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLE1BQVIsUUFBcUIsV0FBckI7O0FBRUE7Ozs7Ozs7OztBQVNBLE9BQU8sU0FBU0MsYUFBVCxPQUFvREMsUUFBcEQsRUFBOEQ7QUFBQSxNQUF0Q0MsSUFBc0MsUUFBdENBLElBQXNDO0FBQUEsTUFBaENDLE1BQWdDLFFBQWhDQSxNQUFnQztBQUFBLE1BQXhCQyxXQUF3QixRQUF4QkEsV0FBd0I7O0FBQ25FO0FBQ0EsTUFBTUMsZ0JBQWdCQyxpQkFBaUJILE1BQWpCLEVBQXlCRixRQUF6QixDQUF0Qjs7QUFFQTtBQUNBLE1BQU1NLGVBQWVMLEtBQUtNLEdBQUwsQ0FBUztBQUFBLFdBQU1DLE9BQU9DLE1BQVAsQ0FBYztBQUNoREMsbUJBQWFWLFNBQVNXLFdBQVQsQ0FBcUJSLFlBQVlTLEVBQVosQ0FBckI7QUFEbUMsS0FBZCxFQUVqQ0EsRUFGaUMsQ0FBTjtBQUFBLEdBQVQsQ0FBckI7O0FBSUEsTUFBTUMsWUFBWWYsU0FDZkksTUFEZSxDQUNSRSxhQURRLEVBRWZVLENBRmUsQ0FFYjtBQUFBLFdBQUtDLEVBQUVMLFdBQUYsQ0FBYyxDQUFkLENBQUw7QUFBQSxHQUZhLEVBR2ZNLENBSGUsQ0FHYjtBQUFBLFdBQUtELEVBQUVMLFdBQUYsQ0FBYyxDQUFkLENBQUw7QUFBQSxHQUhhLENBQWxCOztBQUtBLE1BQU1PLGNBQWNKLFVBQVVQLFlBQVYsQ0FBcEI7O0FBRUEsU0FBTztBQUNMWSxjQUFVRCxZQUFZVixHQUFaLENBQWdCLFVBQUNZLEdBQUQsRUFBTUMsS0FBTjtBQUFBLGFBQWlCO0FBQ3pDQyxrQkFBVXJCLFNBQVNzQixhQUFULENBQXVCLENBQUNILElBQUlMLENBQUwsRUFBUUssSUFBSUgsQ0FBWixDQUF2QixDQUQrQjtBQUV6Q08sZ0JBQVFKLEdBRmlDO0FBR3pDQztBQUh5QyxPQUFqQjtBQUFBLEtBQWhCO0FBREwsR0FBUDtBQU9EOztBQUVEOzs7Ozs7O0FBT0EsT0FBTyxTQUFTZixnQkFBVCxDQUEwQkgsTUFBMUIsRUFBa0NGLFFBQWxDLEVBQTRDO0FBQUEsOEJBRXhCQSxTQUFTd0IsaUJBQVQsRUFGd0I7QUFBQSxNQUUxQ0MsY0FGMEMseUJBRTFDQSxjQUYwQzs7QUFJakQ7OztBQUNBLFNBQU92QixTQUFTdUIsZUFBZSxDQUFmLENBQWhCO0FBQ0QiLCJmaWxlIjoiaGV4YWdvbi1hZ2dyZWdhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7aGV4YmlufSBmcm9tICdkMy1oZXhiaW4nO1xuXG4vKipcbiAqIFVzZSBkMy1oZXhiaW4gdG8gcGVyZm9ybXMgaGV4YWdvbmFsIGJpbm5pbmcgZnJvbSBnZW8gcG9pbnRzIHRvIGhleGFnb25zXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gaGV4YWdvbiByYWRpdXMgaW4gbWV0ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gZ2V0IHBvaW50cyBsb24gbGF0XG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnQgLSBjdXJyZW50IHZpZXdwb3J0IG9iamVjdFxuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gaGV4YWdvbnMgYW5kIGNvdW50UmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9IZXhiaW4oe2RhdGEsIHJhZGl1cywgZ2V0UG9zaXRpb259LCB2aWV3cG9ydCkge1xuICAvLyBnZXQgaGV4YWdvbiByYWRpdXMgaW4gbWVyY2F0b3Igd29ybGQgdW5pdFxuICBjb25zdCByYWRpdXNJblBpeGVsID0gZ2V0UmFkaXVzSW5QaXhlbChyYWRpdXMsIHZpZXdwb3J0KTtcblxuICAvLyBhZGQgd29ybGQgc3BhY2UgY29vcmRpbmF0ZXMgdG8gcG9pbnRzXG4gIGNvbnN0IHNjcmVlblBvaW50cyA9IGRhdGEubWFwKHB0ID0+IE9iamVjdC5hc3NpZ24oe1xuICAgIHNjcmVlbkNvb3JkOiB2aWV3cG9ydC5wcm9qZWN0RmxhdChnZXRQb3NpdGlvbihwdCkpXG4gIH0sIHB0KSk7XG5cbiAgY29uc3QgbmV3SGV4YmluID0gaGV4YmluKClcbiAgICAucmFkaXVzKHJhZGl1c0luUGl4ZWwpXG4gICAgLngoZCA9PiBkLnNjcmVlbkNvb3JkWzBdKVxuICAgIC55KGQgPT4gZC5zY3JlZW5Db29yZFsxXSk7XG5cbiAgY29uc3QgaGV4YWdvbkJpbnMgPSBuZXdIZXhiaW4oc2NyZWVuUG9pbnRzKTtcblxuICByZXR1cm4ge1xuICAgIGhleGFnb25zOiBoZXhhZ29uQmlucy5tYXAoKGhleCwgaW5kZXgpID0+ICh7XG4gICAgICBjZW50cm9pZDogdmlld3BvcnQudW5wcm9qZWN0RmxhdChbaGV4LngsIGhleC55XSksXG4gICAgICBwb2ludHM6IGhleCxcbiAgICAgIGluZGV4XG4gICAgfSkpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHJhZGl1cyBpbiBtZXJjYXRvciB3b3JsZCBzcGFjZSBjb29yZGluYXRlcyBmcm9tIG1ldGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gaW4gbWV0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIGN1cnJlbnQgdmlld3BvcnQgb2JqZWN0XG5cbiAqIEByZXR1cm4ge051bWJlcn0gcmFkaXVzIGluIG1lcmNhdG9yIHdvcmxkIHNwY2FlIGNvb3JkaW5hdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYWRpdXNJblBpeGVsKHJhZGl1cywgdmlld3BvcnQpIHtcblxuICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXJ9ID0gdmlld3BvcnQuZ2V0RGlzdGFuY2VTY2FsZXMoKTtcblxuICAvLyB4LCB5IGRpc3RhbmNlIHNob3VsZCBiZSB0aGUgc2FtZVxuICByZXR1cm4gcmFkaXVzICogcGl4ZWxzUGVyTWV0ZXJbMF07XG59XG4iXX0=

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hexagon_cell_layer_hexagon_cell_layer__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_bin_sorter__ = __webpack_require__(83);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var defaultProps = {
  colorDomain: null,
  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__["a" /* defaultColorRange */],
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  elevationDomain: null,
  elevationRange: [0, 1000],
  elevationScale: 1,
  lowerPercentile: 0,
  upperPercentile: 100,
  radius: 1000,
  coverage: 1,
  extruded: false,
  hexagonAggregator: __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__["a" /* pointToHexbin */],
  getPosition: function getPosition(x) {
    return x.position;
  },
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

function _needsReProjectPoints(oldProps, props) {
  return oldProps.radius !== props.radius || oldProps.hexagonAggregator !== props.hexagonAggregator;
}

function _percentileChanged(oldProps, props) {
  return oldProps.lowerPercentile !== props.lowerPercentile || oldProps.upperPercentile !== props.upperPercentile;
}

function _needsReSortBins(oldProps, props) {
  return oldProps.getColorValue !== props.getColorValue;
}

var HexagonLayer = function (_CompositeLayer) {
  _inherits(HexagonLayer, _CompositeLayer);

  function HexagonLayer(props) {
    _classCallCheck(this, HexagonLayer);

    if (!props.hexagonAggregator && !props.radius) {
      __WEBPACK_IMPORTED_MODULE_2__lib_utils__["a" /* log */].once(0, 'HexagonLayer: Default hexagonAggregator requires radius prop to be set, ' + 'Now using 1000 meter as default');

      props.radius = defaultProps.radius;
    }

    if (Number.isFinite(props.upperPercentile) && (props.upperPercentile > 100 || props.upperPercentile < 0)) {
      __WEBPACK_IMPORTED_MODULE_2__lib_utils__["a" /* log */].once(0, 'HexagonLayer: upperPercentile should be between 0 and 100. ' + 'Assign to 100 by default');

      props.upperPercentile = defaultProps.upperPercentile;
    }

    if (Number.isFinite(props.lowerPercentile) && (props.lowerPercentile > 100 || props.lowerPercentile < 0)) {
      __WEBPACK_IMPORTED_MODULE_2__lib_utils__["a" /* log */].once(0, 'HexagonLayer: lowerPercentile should be between 0 and 100. ' + 'Assign to 0 by default');

      props.lowerPercentile = defaultProps.upperPercentile;
    }

    if (props.lowerPercentile >= props.upperPercentile) {
      __WEBPACK_IMPORTED_MODULE_2__lib_utils__["a" /* log */].once(0, 'HexagonLayer: lowerPercentile should not be bigger than ' + 'upperPercentile. Assign to 0 by default');

      props.lowerPercentile = defaultProps.lowerPercentile;
    }

    return _possibleConstructorReturn(this, (HexagonLayer.__proto__ || Object.getPrototypeOf(HexagonLayer)).call(this, props));
  }

  _createClass(HexagonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        hexagons: [],
        hexagonVertices: null,
        sortedBins: null,
        valueDomain: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedBins
        this.getHexagons();
        this.getSortedBins();

        // this needs sortedBins to be set
        this.getValueDomain();
      } else if (_needsReSortBins(oldProps, props)) {

        this.getSortedBins();
        this.getValueDomain();
      } else if (_percentileChanged(oldProps, props)) {

        this.getValueDomain();
      }
    }
  }, {
    key: 'getHexagons',
    value: function getHexagons() {
      var hexagonAggregator = this.props.hexagonAggregator;
      var viewport = this.context.viewport;

      var _hexagonAggregator = hexagonAggregator(this.props, viewport),
          hexagons = _hexagonAggregator.hexagons,
          hexagonVertices = _hexagonAggregator.hexagonVertices;

      this.setState({ hexagons: hexagons, hexagonVertices: hexagonVertices });
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      var sortedBins = new __WEBPACK_IMPORTED_MODULE_6__utils_bin_sorter__["a" /* default */](this.state.hexagons || [], this.props.getColorValue);
      this.setState({ sortedBins: sortedBins });
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;

      var pickedCell = info.picked && info.index > -1 ? this.state.hexagons[info.index] : null;

      return Object.assign(info, {
        picked: Boolean(pickedCell),
        // override object with picked cell
        object: pickedCell
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      return {
        getColor: {
          colorRange: this.props.colorRange,
          colorDomain: this.props.colorDomain,
          getColorValue: this.props.getColorValue,
          lowerPercentile: this.props.lowerPercentile,
          upperPercentile: this.props.upperPercentile
        },
        getElevation: {
          elevationRange: this.props.elevationRange,
          elevationDomain: this.props.elevationDomain
        }
      };
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      var _props = this.props,
          lowerPercentile = _props.lowerPercentile,
          upperPercentile = _props.upperPercentile;


      this.state.valueDomain = this.state.sortedBins.getValueRange([lowerPercentile, upperPercentile]);
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var colorRange = this.props.colorRange;
      var _state = this.state,
          valueDomain = _state.valueDomain,
          sortedBins = _state.sortedBins;

      var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;

      var colorDomain = this.props.colorDomain || valueDomain;
      var color = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__["a" /* quantizeScale */])(colorDomain, colorRange, value);

      // if cell value is outside domain, set alpha to 0
      var alpha = value >= valueDomain[0] && value <= valueDomain[1] ? Number.isFinite(color[3]) ? color[3] : 255 : 0;

      // add final alpha to color
      color[3] = alpha;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _props2 = this.props,
          elevationDomain = _props2.elevationDomain,
          elevationRange = _props2.elevationRange;
      var sortedBins = this.state.sortedBins;

      // elevation is based on counts, it is not affected by percentile

      var domain = elevationDomain || [0, sortedBins.maxCount];
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__["b" /* linearScale */])(domain, elevationRange, cell.points.length);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var _props3 = this.props,
          id = _props3.id,
          radius = _props3.radius,
          elevationScale = _props3.elevationScale,
          extruded = _props3.extruded,
          coverage = _props3.coverage,
          lightSettings = _props3.lightSettings,
          fp64 = _props3.fp64;

      // base layer props

      var _props4 = this.props,
          opacity = _props4.opacity,
          pickable = _props4.pickable,
          visible = _props4.visible,
          getPolygonOffset = _props4.getPolygonOffset;

      // viewport props

      var _props5 = this.props,
          positionOrigin = _props5.positionOrigin,
          projectionMode = _props5.projectionMode,
          modelMatrix = _props5.modelMatrix;


      return new __WEBPACK_IMPORTED_MODULE_1__hexagon_cell_layer_hexagon_cell_layer__["a" /* default */]({
        id: id + '-hexagon-cell',
        data: this.state.hexagons,
        hexagonVertices: this.state.hexagonVertices,
        radius: radius,
        elevationScale: elevationScale,
        angle: Math.PI,
        extruded: extruded,
        coverage: coverage,
        lightSettings: lightSettings,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        updateTriggers: this.getUpdateTriggers()
      });
    }
  }]);

  return HexagonLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["b" /* CompositeLayer */]);

/* harmony default export */ __webpack_exports__["a"] = (HexagonLayer);


HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWxheWVyL2hleGFnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJIZXhhZ29uQ2VsbExheWVyIiwibG9nIiwicXVhbnRpemVTY2FsZSIsImxpbmVhclNjYWxlIiwiZGVmYXVsdENvbG9yUmFuZ2UiLCJwb2ludFRvSGV4YmluIiwiQmluU29ydGVyIiwiZGVmYXVsdFByb3BzIiwiY29sb3JEb21haW4iLCJjb2xvclJhbmdlIiwiZ2V0Q29sb3JWYWx1ZSIsInBvaW50cyIsImxlbmd0aCIsImVsZXZhdGlvbkRvbWFpbiIsImVsZXZhdGlvblJhbmdlIiwiZWxldmF0aW9uU2NhbGUiLCJsb3dlclBlcmNlbnRpbGUiLCJ1cHBlclBlcmNlbnRpbGUiLCJyYWRpdXMiLCJjb3ZlcmFnZSIsImV4dHJ1ZGVkIiwiaGV4YWdvbkFnZ3JlZ2F0b3IiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsImZwNjQiLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIl9uZWVkc1JlUHJvamVjdFBvaW50cyIsIm9sZFByb3BzIiwicHJvcHMiLCJfcGVyY2VudGlsZUNoYW5nZWQiLCJfbmVlZHNSZVNvcnRCaW5zIiwiSGV4YWdvbkxheWVyIiwib25jZSIsIk51bWJlciIsImlzRmluaXRlIiwic3RhdGUiLCJoZXhhZ29ucyIsImhleGFnb25WZXJ0aWNlcyIsInNvcnRlZEJpbnMiLCJ2YWx1ZURvbWFpbiIsImNoYW5nZUZsYWdzIiwiZGF0YUNoYW5nZWQiLCJnZXRIZXhhZ29ucyIsImdldFNvcnRlZEJpbnMiLCJnZXRWYWx1ZURvbWFpbiIsInZpZXdwb3J0IiwiY29udGV4dCIsInNldFN0YXRlIiwiaW5mbyIsInBpY2tlZENlbGwiLCJwaWNrZWQiLCJpbmRleCIsIk9iamVjdCIsImFzc2lnbiIsIkJvb2xlYW4iLCJvYmplY3QiLCJnZXRDb2xvciIsImdldEVsZXZhdGlvbiIsImdldFZhbHVlUmFuZ2UiLCJjZWxsIiwidmFsdWUiLCJiaW5NYXAiLCJjb2xvciIsImFscGhhIiwiZG9tYWluIiwibWF4Q291bnQiLCJpZCIsIm9wYWNpdHkiLCJwaWNrYWJsZSIsInZpc2libGUiLCJnZXRQb2x5Z29uT2Zmc2V0IiwicG9zaXRpb25PcmlnaW4iLCJwcm9qZWN0aW9uTW9kZSIsIm1vZGVsTWF0cml4IiwiZGF0YSIsImFuZ2xlIiwiTWF0aCIsIlBJIiwiX29uR2V0U3VibGF5ZXJDb2xvciIsImJpbmQiLCJfb25HZXRTdWJsYXllckVsZXZhdGlvbiIsInVwZGF0ZVRyaWdnZXJzIiwiZ2V0VXBkYXRlVHJpZ2dlcnMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixRQUE2QixjQUE3QjtBQUNBLE9BQU9DLGdCQUFQLE1BQTZCLDBDQUE3QjtBQUNBLFNBQVFDLEdBQVIsUUFBa0Isb0JBQWxCOztBQUVBLFNBQVFDLGFBQVIsRUFBdUJDLFdBQXZCLFFBQXlDLDRCQUF6QztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLDRCQUFoQztBQUNBLFNBQVFDLGFBQVIsUUFBNEIsc0JBQTVCOztBQUVBLE9BQU9DLFNBQVAsTUFBc0IsMkJBQXRCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLGVBQWEsSUFETTtBQUVuQkMsY0FBWUwsaUJBRk87QUFHbkJNLGlCQUFlO0FBQUEsV0FBVUMsT0FBT0MsTUFBakI7QUFBQSxHQUhJO0FBSW5CQyxtQkFBaUIsSUFKRTtBQUtuQkMsa0JBQWdCLENBQUMsQ0FBRCxFQUFJLElBQUosQ0FMRztBQU1uQkMsa0JBQWdCLENBTkc7QUFP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IDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0NvbXBvc2l0ZUxheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IEhleGFnb25DZWxsTGF5ZXIgZnJvbSAnLi4vaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuaW1wb3J0IHtxdWFudGl6ZVNjYWxlLCBsaW5lYXJTY2FsZX0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2NhbGUtdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0Q29sb3JSYW5nZX0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29sb3ItdXRpbHMnO1xuaW1wb3J0IHtwb2ludFRvSGV4YmlufSBmcm9tICcuL2hleGFnb24tYWdncmVnYXRvcic7XG5cbmltcG9ydCBCaW5Tb3J0ZXIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvYmluLXNvcnRlcic7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY29sb3JEb21haW46IG51bGwsXG4gIGNvbG9yUmFuZ2U6IGRlZmF1bHRDb2xvclJhbmdlLFxuICBnZXRDb2xvclZhbHVlOiBwb2ludHMgPT4gcG9pbnRzLmxlbmd0aCxcbiAgZWxldmF0aW9uRG9tYWluOiBudWxsLFxuICBlbGV2YXRpb25SYW5nZTogWzAsIDEwMDBdLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgbG93ZXJQZXJjZW50aWxlOiAwLFxuICB1cHBlclBlcmNlbnRpbGU6IDEwMCxcbiAgcmFkaXVzOiAxMDAwLFxuICBjb3ZlcmFnZTogMSxcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICBoZXhhZ29uQWdncmVnYXRvcjogcG9pbnRUb0hleGJpbixcbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZnA2NDogZmFsc2UsXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLnJhZGl1cyAhPT0gcHJvcHMucmFkaXVzIHx8IG9sZFByb3BzLmhleGFnb25BZ2dyZWdhdG9yICE9PSBwcm9wcy5oZXhhZ29uQWdncmVnYXRvcjtcbn1cblxuZnVuY3Rpb24gX3BlcmNlbnRpbGVDaGFuZ2VkKG9sZFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gb2xkUHJvcHMubG93ZXJQZXJjZW50aWxlICE9PSBwcm9wcy5sb3dlclBlcmNlbnRpbGUgfHxcbiAgICBvbGRQcm9wcy51cHBlclBlcmNlbnRpbGUgIT09IHByb3BzLnVwcGVyUGVyY2VudGlsZTtcbn1cblxuZnVuY3Rpb24gX25lZWRzUmVTb3J0QmlucyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmdldENvbG9yVmFsdWUgIT09IHByb3BzLmdldENvbG9yVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhleGFnb25MYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmhleGFnb25BZ2dyZWdhdG9yICYmICFwcm9wcy5yYWRpdXMpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IERlZmF1bHQgaGV4YWdvbkFnZ3JlZ2F0b3IgcmVxdWlyZXMgcmFkaXVzIHByb3AgdG8gYmUgc2V0LCAnICtcbiAgICAgICAgJ05vdyB1c2luZyAxMDAwIG1ldGVyIGFzIGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMucmFkaXVzID0gZGVmYXVsdFByb3BzLnJhZGl1cztcbiAgICB9XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHByb3BzLnVwcGVyUGVyY2VudGlsZSkgJiZcbiAgICAgIChwcm9wcy51cHBlclBlcmNlbnRpbGUgPiAxMDAgfHwgcHJvcHMudXBwZXJQZXJjZW50aWxlIDwgMCkpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IHVwcGVyUGVyY2VudGlsZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxMDAuICcgK1xuICAgICAgICAnQXNzaWduIHRvIDEwMCBieSBkZWZhdWx0Jyk7XG5cbiAgICAgIHByb3BzLnVwcGVyUGVyY2VudGlsZSA9IGRlZmF1bHRQcm9wcy51cHBlclBlcmNlbnRpbGU7XG4gICAgfVxuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwcm9wcy5sb3dlclBlcmNlbnRpbGUpICYmXG4gICAgICAocHJvcHMubG93ZXJQZXJjZW50aWxlID4gMTAwIHx8IHByb3BzLmxvd2VyUGVyY2VudGlsZSA8IDApKSB7XG4gICAgICBsb2cub25jZSgwLCAnSGV4YWdvbkxheWVyOiBsb3dlclBlcmNlbnRpbGUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMTAwLiAnICtcbiAgICAgICAgJ0Fzc2lnbiB0byAwIGJ5IGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMubG93ZXJQZXJjZW50aWxlID0gZGVmYXVsdFByb3BzLnVwcGVyUGVyY2VudGlsZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMubG93ZXJQZXJjZW50aWxlID49IHByb3BzLnVwcGVyUGVyY2VudGlsZSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogbG93ZXJQZXJjZW50aWxlIHNob3VsZCBub3QgYmUgYmlnZ2VyIHRoYW4gJyArXG4gICAgICAgICd1cHBlclBlcmNlbnRpbGUuIEFzc2lnbiB0byAwIGJ5IGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMubG93ZXJQZXJjZW50aWxlID0gZGVmYXVsdFByb3BzLmxvd2VyUGVyY2VudGlsZTtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhleGFnb25zOiBbXSxcbiAgICAgIGhleGFnb25WZXJ0aWNlczogbnVsbCxcbiAgICAgIHNvcnRlZEJpbnM6IG51bGwsXG4gICAgICB2YWx1ZURvbWFpbjogbnVsbFxuICAgIH07XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgX25lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykpIHtcbiAgICAgIC8vIHByb2plY3QgZGF0YSBpbnRvIGhleGFnb25zLCBhbmQgZ2V0IHNvcnRlZEJpbnNcbiAgICAgIHRoaXMuZ2V0SGV4YWdvbnMoKTtcbiAgICAgIHRoaXMuZ2V0U29ydGVkQmlucygpO1xuXG4gICAgICAvLyB0aGlzIG5lZWRzIHNvcnRlZEJpbnMgdG8gYmUgc2V0XG4gICAgICB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG5cbiAgICB9IGVsc2UgaWYgKF9uZWVkc1JlU29ydEJpbnMob2xkUHJvcHMsIHByb3BzKSkge1xuXG4gICAgICB0aGlzLmdldFNvcnRlZEJpbnMoKTtcbiAgICAgIHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcblxuICAgIH0gZWxzZSBpZiAoX3BlcmNlbnRpbGVDaGFuZ2VkKG9sZFByb3BzLCBwcm9wcykpIHtcblxuICAgICAgdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xuICAgIH1cbiAgfVxuXG4gIGdldEhleGFnb25zKCkge1xuICAgIGNvbnN0IHtoZXhhZ29uQWdncmVnYXRvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qge2hleGFnb25zLCBoZXhhZ29uVmVydGljZXN9ID0gaGV4YWdvbkFnZ3JlZ2F0b3IodGhpcy5wcm9wcywgdmlld3BvcnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe2hleGFnb25zLCBoZXhhZ29uVmVydGljZXN9KTtcbiAgfVxuXG4gIGdldFNvcnRlZEJpbnMoKSB7XG4gICAgY29uc3Qgc29ydGVkQmlucyA9IG5ldyBCaW5Tb3J0ZXIodGhpcy5zdGF0ZS5oZXhhZ29ucyB8fCBbXSwgdGhpcy5wcm9wcy5nZXRDb2xvclZhbHVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHtzb3J0ZWRCaW5zfSk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7aW5mb30pIHtcbiAgICBjb25zdCBwaWNrZWRDZWxsID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xID9cbiAgICAgIHRoaXMuc3RhdGUuaGV4YWdvbnNbaW5mby5pbmRleF0gOiBudWxsO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgcGlja2VkOiBCb29sZWFuKHBpY2tlZENlbGwpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdDogcGlja2VkQ2VsbFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VXBkYXRlVHJpZ2dlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yOiB7XG4gICAgICAgIGNvbG9yUmFuZ2U6IHRoaXMucHJvcHMuY29sb3JSYW5nZSxcbiAgICAgICAgY29sb3JEb21haW46IHRoaXMucHJvcHMuY29sb3JEb21haW4sXG4gICAgICAgIGdldENvbG9yVmFsdWU6IHRoaXMucHJvcHMuZ2V0Q29sb3JWYWx1ZSxcbiAgICAgICAgbG93ZXJQZXJjZW50aWxlOiB0aGlzLnByb3BzLmxvd2VyUGVyY2VudGlsZSxcbiAgICAgICAgdXBwZXJQZXJjZW50aWxlOiB0aGlzLnByb3BzLnVwcGVyUGVyY2VudGlsZVxuICAgICAgfSxcbiAgICAgIGdldEVsZXZhdGlvbjoge1xuICAgICAgICBlbGV2YXRpb25SYW5nZTogdGhpcy5wcm9wcy5lbGV2YXRpb25SYW5nZSxcbiAgICAgICAgZWxldmF0aW9uRG9tYWluOiB0aGlzLnByb3BzLmVsZXZhdGlvbkRvbWFpblxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRWYWx1ZURvbWFpbigpIHtcbiAgICBjb25zdCB7bG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGV9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUudmFsdWVEb21haW4gPSB0aGlzLnN0YXRlLnNvcnRlZEJpbnNcbiAgICAgIC5nZXRWYWx1ZVJhbmdlKFtsb3dlclBlcmNlbnRpbGUsIHVwcGVyUGVyY2VudGlsZV0pO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge2NvbG9yUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWVEb21haW4sIHNvcnRlZEJpbnN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmIHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuXG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHZhbHVlRG9tYWluO1xuICAgIGNvbnN0IGNvbG9yID0gcXVhbnRpemVTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgdmFsdWUpO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGFscGhhIHRvIDBcbiAgICBjb25zdCBhbHBoYSA9IHZhbHVlID49IHZhbHVlRG9tYWluWzBdICYmIHZhbHVlIDw9IHZhbHVlRG9tYWluWzFdID9cbiAgICAgIChOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTUpIDogMDtcblxuICAgIC8vIGFkZCBmaW5hbCBhbHBoYSB0byBjb2xvclxuICAgIGNvbG9yWzNdID0gYWxwaGE7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7c29ydGVkQmluc30gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gZWxldmF0aW9uIGlzIGJhc2VkIG9uIGNvdW50cywgaXQgaXMgbm90IGFmZmVjdGVkIGJ5IHBlcmNlbnRpbGVcbiAgICBjb25zdCBkb21haW4gPSBlbGV2YXRpb25Eb21haW4gfHwgWzAsIHNvcnRlZEJpbnMubWF4Q291bnRdO1xuICAgIHJldHVybiBsaW5lYXJTY2FsZShkb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLnBvaW50cy5sZW5ndGgpO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtpZCwgcmFkaXVzLCBlbGV2YXRpb25TY2FsZSwgZXh0cnVkZWQsIGNvdmVyYWdlLCBsaWdodFNldHRpbmdzLCBmcDY0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBiYXNlIGxheWVyIHByb3BzXG4gICAgY29uc3Qge29wYWNpdHksIHBpY2thYmxlLCB2aXNpYmxlLCBnZXRQb2x5Z29uT2Zmc2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB2aWV3cG9ydCBwcm9wc1xuICAgIGNvbnN0IHtwb3NpdGlvbk9yaWdpbiwgcHJvamVjdGlvbk1vZGUsIG1vZGVsTWF0cml4fSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gbmV3IEhleGFnb25DZWxsTGF5ZXIoe1xuICAgICAgaWQ6IGAke2lkfS1oZXhhZ29uLWNlbGxgLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5oZXhhZ29ucyxcbiAgICAgIGhleGFnb25WZXJ0aWNlczogdGhpcy5zdGF0ZS5oZXhhZ29uVmVydGljZXMsXG4gICAgICByYWRpdXMsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGFuZ2xlOiBNYXRoLlBJLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGxpZ2h0U2V0dGluZ3MsXG4gICAgICBmcDY0LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHBpY2thYmxlLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGdldFBvbHlnb25PZmZzZXQsXG4gICAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICAgIHBvc2l0aW9uT3JpZ2luLFxuICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICBnZXRDb2xvcjogdGhpcy5fb25HZXRTdWJsYXllckNvbG9yLmJpbmQodGhpcyksXG4gICAgICBnZXRFbGV2YXRpb246IHRoaXMuX29uR2V0U3VibGF5ZXJFbGV2YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB0aGlzLmdldFVwZGF0ZVRyaWdnZXJzKClcbiAgICB9KTtcbiAgfVxufVxuXG5IZXhhZ29uTGF5ZXIubGF5ZXJOYW1lID0gJ0hleGFnb25MYXllcic7XG5IZXhhZ29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME icon-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform sampler2D iconsTexture;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb,\n    max(vColorMode, renderPickingBuffer)\n  );\n  float a = texColor.a * opacity * mix(1.0, vColor.a, vColorMode);\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  // if rendering to screen, use mixed alpha\n  // if rendering picking buffer, use binary alpha\n  a = mix(a, 1.0, renderPickingBuffer);\n\n  gl_FragColor = vec4(color, a);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJpY29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGljb24tbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gc2FtcGxlcjJEIGljb25zVGV4dHVyZTtcblxudmFyeWluZyBmbG9hdCB2Q29sb3JNb2RlO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcblxuY29uc3QgZmxvYXQgTUlOX0FMUEhBID0gMC4wNTtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChpY29uc1RleHR1cmUsIHZUZXh0dXJlQ29vcmRzKTtcblxuICAvLyBpZiBjb2xvck1vZGUgPT0gMCwgdXNlIHBpeGVsIGNvbG9yIGZyb20gdGhlIHRleHR1cmVcbiAgLy8gaWYgY29sb3JNb2RlID09IDEgb3IgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCB1c2UgdGV4dHVyZSBhcyB0cmFuc3BhcmVuY3kgbWFza1xuICB2ZWMzIGNvbG9yID0gbWl4KHRleENvbG9yLnJnYiwgdkNvbG9yLnJnYixcbiAgICBtYXgodkNvbG9yTW9kZSwgcmVuZGVyUGlja2luZ0J1ZmZlcilcbiAgKTtcbiAgZmxvYXQgYSA9IHRleENvbG9yLmEgKiBvcGFjaXR5ICogbWl4KDEuMCwgdkNvbG9yLmEsIHZDb2xvck1vZGUpO1xuXG4gIGlmIChhIDwgTUlOX0FMUEhBKSB7XG4gICAgZGlzY2FyZDtcbiAgfVxuXG4gIC8vIGlmIHJlbmRlcmluZyB0byBzY3JlZW4sIHVzZSBtaXhlZCBhbHBoYVxuICAvLyBpZiByZW5kZXJpbmcgcGlja2luZyBidWZmZXIsIHVzZSBiaW5hcnkgYWxwaGFcbiAgYSA9IG1peChhLCAxLjAsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xuXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGEpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME icon-layer-vertex-shader-64\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform vec2 viewportSize;\nuniform float sizeScale;\nuniform float renderPickingBuffer;\nuniform vec2 iconsTextureDim;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  vec2 iconSize_clipspace = iconSize / viewportSize * 2.0;\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : instanceSizes / iconSize.y;\n\n  // The vertex variable is in clip space and should not go through project_to_clipspace call\n  vec2 vertex = (positions / 2.0 + instanceOffsets);\n  vertex = rotate_by_angle(vertex, instanceAngles) * iconSize_clipspace *\n    sizeScale * instanceScale;\n\n  vertex.y *= -1.0;\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(project_scale(instancePositions.z), 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace) + vec4(vertex, 0.0, 0.0);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vec4 color = instanceColors / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  vColorMode = instanceColorModes;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiaWNvbi1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgaWNvbi1sYXllci12ZXJ0ZXgtc2hhZGVyLTY0XG5cbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9ucztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTaXplcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUFuZ2xlcztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VJY29uRnJhbWVzO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ29sb3JNb2RlcztcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlT2Zmc2V0cztcblxudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcbnVuaWZvcm0gZmxvYXQgc2l6ZVNjYWxlO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMyIGljb25zVGV4dHVyZURpbTtcblxudmFyeWluZyBmbG9hdCB2Q29sb3JNb2RlO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcblxudmVjMiByb3RhdGVfYnlfYW5nbGUodmVjMiB2ZXJ0ZXgsIGZsb2F0IGFuZ2xlKSB7XG4gIGZsb2F0IGFuZ2xlX3JhZGlhbiA9IGFuZ2xlICogUEkgLyAxODAuMDtcbiAgZmxvYXQgY29zX2FuZ2xlID0gY29zKGFuZ2xlX3JhZGlhbik7XG4gIGZsb2F0IHNpbl9hbmdsZSA9IHNxcnQoMS4wIC0gY29zX2FuZ2xlICogY29zX2FuZ2xlKTtcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zX2FuZ2xlLCAtc2luX2FuZ2xlLCBzaW5fYW5nbGUsIGNvc19hbmdsZSk7XG4gIHJldHVybiByb3RhdGlvbk1hdHJpeCAqIHZlcnRleDtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjMiBpY29uU2l6ZSA9IGluc3RhbmNlSWNvbkZyYW1lcy56dztcbiAgdmVjMiBpY29uU2l6ZV9jbGlwc3BhY2UgPSBpY29uU2l6ZSAvIHZpZXdwb3J0U2l6ZSAqIDIuMDtcbiAgLy8gc2NhbGUgaWNvbiBoZWlnaHQgdG8gbWF0Y2ggaW5zdGFuY2VTaXplXG4gIGZsb2F0IGluc3RhbmNlU2NhbGUgPSBpY29uU2l6ZS55ID09IDAuMCA/IDAuMCA6IGluc3RhbmNlU2l6ZXMgLyBpY29uU2l6ZS55O1xuXG4gIC8vIFRoZSB2ZXJ0ZXggdmFyaWFibGUgaXMgaW4gY2xpcCBzcGFjZSBhbmQgc2hvdWxkIG5vdCBnbyB0aHJvdWdoIHByb2plY3RfdG9fY2xpcHNwYWNlIGNhbGxcbiAgdmVjMiB2ZXJ0ZXggPSAocG9zaXRpb25zIC8gMi4wICsgaW5zdGFuY2VPZmZzZXRzKTtcbiAgdmVydGV4ID0gcm90YXRlX2J5X2FuZ2xlKHZlcnRleCwgaW5zdGFuY2VBbmdsZXMpICogaWNvblNpemVfY2xpcHNwYWNlICpcbiAgICBzaXplU2NhbGUgKiBpbnN0YW5jZVNjYWxlO1xuXG4gIHZlcnRleC55ICo9IC0xLjA7XG5cbiAgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0eHkgPSB2ZWM0KFxuICAgIGluc3RhbmNlUG9zaXRpb25zLngsIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy54LFxuICAgIGluc3RhbmNlUG9zaXRpb25zLnksIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlUG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzBdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRfY29vcmRfeHlbMV07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy56KSwgMC4wKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSkgKyB2ZWM0KHZlcnRleCwgMC4wLCAwLjApO1xuXG4gIHZUZXh0dXJlQ29vcmRzID0gbWl4KFxuICAgIGluc3RhbmNlSWNvbkZyYW1lcy54eSxcbiAgICBpbnN0YW5jZUljb25GcmFtZXMueHkgKyBpY29uU2l6ZSxcbiAgICAocG9zaXRpb25zLnh5ICsgMS4wKSAvIDIuMFxuICApIC8gaWNvbnNUZXh0dXJlRGltO1xuXG4gIHZUZXh0dXJlQ29vcmRzLnkgPSAxLjAgLSB2VGV4dHVyZUNvb3Jkcy55O1xuXG4gIHZlYzQgY29sb3IgPSBpbnN0YW5jZUNvbG9ycyAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcblxuICB2Q29sb3JNb2RlID0gaW5zdGFuY2VDb2xvck1vZGVzO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform vec2 viewportSize;\nuniform float sizeScale;\nuniform float renderPickingBuffer;\nuniform vec2 iconsTextureDim;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  vec2 iconSize_clipspace = iconSize / viewportSize * 2.0;\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : instanceSizes / iconSize.y;\n  vec3 center = project_position(instancePositions);\n  vec2 vertex = (positions / 2.0 + instanceOffsets);\n  vertex = rotate_by_angle(vertex, instanceAngles) * iconSize_clipspace *\n    sizeScale * instanceScale;\n  vertex.y *= -1.0;\n\n  gl_Position = project_to_clipspace(vec4(center, 1.0)) + vec4(vertex, 0.0, 0.0);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vec4 color = instanceColors / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  vColorMode = instanceColorModes;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiaWNvbi1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgaWNvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9ucztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTaXplcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUFuZ2xlcztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VJY29uRnJhbWVzO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ29sb3JNb2RlcztcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlT2Zmc2V0cztcblxudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcbnVuaWZvcm0gZmxvYXQgc2l6ZVNjYWxlO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMyIGljb25zVGV4dHVyZURpbTtcblxudmFyeWluZyBmbG9hdCB2Q29sb3JNb2RlO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcblxudmVjMiByb3RhdGVfYnlfYW5nbGUodmVjMiB2ZXJ0ZXgsIGZsb2F0IGFuZ2xlKSB7XG4gIGZsb2F0IGFuZ2xlX3JhZGlhbiA9IGFuZ2xlICogUEkgLyAxODAuMDtcbiAgZmxvYXQgY29zX2FuZ2xlID0gY29zKGFuZ2xlX3JhZGlhbik7XG4gIGZsb2F0IHNpbl9hbmdsZSA9IHNxcnQoMS4wIC0gY29zX2FuZ2xlICogY29zX2FuZ2xlKTtcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zX2FuZ2xlLCAtc2luX2FuZ2xlLCBzaW5fYW5nbGUsIGNvc19hbmdsZSk7XG4gIHJldHVybiByb3RhdGlvbk1hdHJpeCAqIHZlcnRleDtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjMiBpY29uU2l6ZSA9IGluc3RhbmNlSWNvbkZyYW1lcy56dztcbiAgdmVjMiBpY29uU2l6ZV9jbGlwc3BhY2UgPSBpY29uU2l6ZSAvIHZpZXdwb3J0U2l6ZSAqIDIuMDtcbiAgLy8gc2NhbGUgaWNvbiBoZWlnaHQgdG8gbWF0Y2ggaW5zdGFuY2VTaXplXG4gIGZsb2F0IGluc3RhbmNlU2NhbGUgPSBpY29uU2l6ZS55ID09IDAuMCA/IDAuMCA6IGluc3RhbmNlU2l6ZXMgLyBpY29uU2l6ZS55O1xuICB2ZWMzIGNlbnRlciA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMpO1xuICB2ZWMyIHZlcnRleCA9IChwb3NpdGlvbnMgLyAyLjAgKyBpbnN0YW5jZU9mZnNldHMpO1xuICB2ZXJ0ZXggPSByb3RhdGVfYnlfYW5nbGUodmVydGV4LCBpbnN0YW5jZUFuZ2xlcykgKiBpY29uU2l6ZV9jbGlwc3BhY2UgKlxuICAgIHNpemVTY2FsZSAqIGluc3RhbmNlU2NhbGU7XG4gIHZlcnRleC55ICo9IC0xLjA7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KGNlbnRlciwgMS4wKSkgKyB2ZWM0KHZlcnRleCwgMC4wLCAwLjApO1xuXG4gIHZUZXh0dXJlQ29vcmRzID0gbWl4KFxuICAgIGluc3RhbmNlSWNvbkZyYW1lcy54eSxcbiAgICBpbnN0YW5jZUljb25GcmFtZXMueHkgKyBpY29uU2l6ZSxcbiAgICAocG9zaXRpb25zLnh5ICsgMS4wKSAvIDIuMFxuICApIC8gaWNvbnNUZXh0dXJlRGltO1xuXG4gIHZUZXh0dXJlQ29vcmRzLnkgPSAxLjAgLSB2VGV4dHVyZUNvb3Jkcy55O1xuXG4gIHZlYzQgY29sb3IgPSBpbnN0YW5jZUNvbG9ycyAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcblxuICB2Q29sb3JNb2RlID0gaW5zdGFuY2VDb2xvck1vZGVzO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__icon_layer_vertex_glsl__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__icon_layer_vertex_64_glsl__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__ = __webpack_require__(152);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.










var DEFAULT_COLOR = [0, 0, 0, 255];

/*
 * @param {object} props
 * @param {Texture2D | string} props.iconAtlas - atlas image url or texture
 * @param {object} props.iconMapping - icon names mapped to icon definitions
 * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,
 *   default to width / 2
 * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,
 *   default to height / 2
 * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency
 *   mask. If true, user defined color is applied. If false, original color from the image is
 *   applied. Default to false.
 * @param {number} props.size - icon size in pixels
 * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]
 * @param {func} props.getIcon - returns icon name as a string
 * @param {func} props.getSize - returns icon size multiplier as a number
 * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons
 *   with mask: true.
 */
var defaultProps = {
  iconAtlas: null,
  iconMapping: {},
  sizeScale: 1,
  fp64: false,

  getPosition: function getPosition(x) {
    return x.position;
  },
  getIcon: function getIcon(x) {
    return x.icon;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  },
  getSize: function getSize(x) {
    return x.size || 1;
  },
  getAngle: function getAngle(x) {
    return x.angle || 0;
  }
};

var IconLayer = function (_Layer) {
  _inherits(IconLayer, _Layer);

  function IconLayer() {
    _classCallCheck(this, IconLayer);

    return _possibleConstructorReturn(this, (IconLayer.__proto__ || Object.getPrototypeOf(IconLayer)).apply(this, arguments));
  }

  _createClass(IconLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var attributeManager = this.state.attributeManager;
      var gl = this.context.gl;

      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },
        instanceSizes: { size: 1, accessor: 'getSize', update: this.calculateInstanceSizes },
        instanceOffsets: { size: 2, accessor: 'getIcon', update: this.calculateInstanceOffsets },
        instanceIconFrames: { size: 4, accessor: 'getIcon', update: this.calculateInstanceIconFrames },
        instanceColorModes: { size: 1, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getIcon', update: this.calculateInstanceColorMode },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors },
        instanceAngles: { size: 1, accessor: 'getAngle', update: this.calculateInstanceAngles }
      });
      /* eslint-enable max-len */

      this.setState({ model: this._getModel(gl) });
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64xyLow: {
              size: 2,
              accessor: 'getPosition',
              update: this.calculateInstancePositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instancePositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;

      _get(IconLayer.prototype.__proto__ || Object.getPrototypeOf(IconLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });

      var iconAtlas = props.iconAtlas,
          iconMapping = props.iconMapping;


      if (oldProps.iconMapping !== iconMapping) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidate('instanceOffsets');
        attributeManager.invalidate('instanceIconFrames');
        attributeManager.invalidate('instanceColorModes');
      }

      if (oldProps.iconAtlas !== iconAtlas) {
        var icons = {};
        this.state.icons = icons;

        if (iconAtlas instanceof __WEBPACK_IMPORTED_MODULE_2_luma_gl__["k" /* Texture2D */]) {
          icons.texture = iconAtlas;
        } else if (typeof iconAtlas === 'string') {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__["l" /* loadTextures */])(this.context.gl, {
            urls: [iconAtlas]
          }).then(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 1),
                texture = _ref4[0];

            icons.texture = texture;
          });
        }
      }

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'draw',
    value: function draw(_ref5) {
      var uniforms = _ref5.uniforms;
      var sizeScale = this.props.sizeScale;

      var iconsTexture = this.state.icons && this.state.icons.texture;

      if (iconsTexture) {
        this.state.model.render(Object.assign({}, uniforms, {
          iconsTexture: iconsTexture,
          iconsTextureDim: [iconsTexture.width, iconsTexture.height],
          sizeScale: sizeScale
        }));
      }
    }
  }, {
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__icon_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__icon_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {

      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLE_FAN,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props = this.props,
          data = _props.data,
          getPosition = _props.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var position = getPosition(object);
          value[i++] = position[0];
          value[i++] = position[1];
          value[i++] = position[2] || 0;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64xyLow',
    value: function calculateInstancePositions64xyLow(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getPosition = _props2.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;

          var position = getPosition(point);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[1])[1];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceSizes',
    value: function calculateInstanceSizes(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getSize = _props3.getSize;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          value[i++] = getSize(object);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceAngles',
    value: function calculateInstanceAngles(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getAngle = _props4.getAngle;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;

          value[i++] = getAngle(object);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props5 = this.props,
          data = _props5.data,
          getColor = _props5.getColor;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var object = _step5.value;

          var color = getColor(object);

          value[i++] = color[0];
          value[i++] = color[1];
          value[i++] = color[2];
          value[i++] = isNaN(color[3]) ? 255 : color[3];
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceOffsets',
    value: function calculateInstanceOffsets(attribute) {
      var _props6 = this.props,
          data = _props6.data,
          iconMapping = _props6.iconMapping,
          getIcon = _props6.getIcon;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = data[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var object = _step6.value;

          var icon = getIcon(object);
          var rect = iconMapping[icon] || {};
          value[i++] = 1 / 2 - rect.anchorX / rect.width || 0;
          value[i++] = 1 / 2 - rect.anchorY / rect.height || 0;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColorMode',
    value: function calculateInstanceColorMode(attribute) {
      var _props7 = this.props,
          data = _props7.data,
          iconMapping = _props7.iconMapping,
          getIcon = _props7.getIcon;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = data[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var object = _step7.value;

          var icon = getIcon(object);
          var colorMode = iconMapping[icon] && iconMapping[icon].mask;
          value[i++] = colorMode ? 1 : 0;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceIconFrames',
    value: function calculateInstanceIconFrames(attribute) {
      var _props8 = this.props,
          data = _props8.data,
          iconMapping = _props8.iconMapping,
          getIcon = _props8.getIcon;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = data[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var object = _step8.value;

          var icon = getIcon(object);
          var rect = iconMapping[icon] || {};
          value[i++] = rect.x || 0;
          value[i++] = rect.y || 0;
          value[i++] = rect.width || 0;
          value[i++] = rect.height || 0;
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }]);

  return IconLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (IconLayer);


IconLayer.layerName = 'IconLayer';
IconLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJHTCIsIk1vZGVsIiwiR2VvbWV0cnkiLCJUZXh0dXJlMkQiLCJsb2FkVGV4dHVyZXMiLCJmcDY0aWZ5IiwiZW5hYmxlNjRiaXRTdXBwb3J0IiwiQ09PUkRJTkFURV9TWVNURU0iLCJpY29uVmVydGV4IiwiaWNvblZlcnRleDY0IiwiaWNvbkZyYWdtZW50IiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsImljb25BdGxhcyIsImljb25NYXBwaW5nIiwic2l6ZVNjYWxlIiwiZnA2NCIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZ2V0SWNvbiIsImljb24iLCJnZXRDb2xvciIsImNvbG9yIiwiZ2V0U2l6ZSIsInNpemUiLCJnZXRBbmdsZSIsImFuZ2xlIiwiSWNvbkxheWVyIiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiZ2wiLCJjb250ZXh0IiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQb3NpdGlvbnMiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIiwiaW5zdGFuY2VTaXplcyIsImNhbGN1bGF0ZUluc3RhbmNlU2l6ZXMiLCJpbnN0YW5jZU9mZnNldHMiLCJjYWxjdWxhdGVJbnN0YW5jZU9mZnNldHMiLCJpbnN0YW5jZUljb25GcmFtZXMiLCJjYWxjdWxhdGVJbnN0YW5jZUljb25GcmFtZXMiLCJpbnN0YW5jZUNvbG9yTW9kZXMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlQ29sb3JNb2RlIiwiaW5zdGFuY2VDb2xvcnMiLCJjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyIsImluc3RhbmNlQW5nbGVzIiwiY2FsY3VsYXRlSW5zdGFuY2VBbmdsZXMiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiX2dldE1vZGVsIiwicHJvcHMiLCJvbGRQcm9wcyIsImNoYW5nZUZsYWdzIiwiaW52YWxpZGF0ZUFsbCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwiaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwicmVtb3ZlIiwiaW52YWxpZGF0ZSIsImljb25zIiwidGV4dHVyZSIsInVybHMiLCJ0aGVuIiwidXBkYXRlQXR0cmlidXRlIiwidW5pZm9ybXMiLCJpY29uc1RleHR1cmUiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJpY29uc1RleHR1cmVEaW0iLCJ3aWR0aCIsImhlaWdodCIsInZzIiwiZnMiLCJtb2R1bGVzIiwic2hhZGVyQ2FjaGUiLCJwb3NpdGlvbnMiLCJzaGFkZXJzIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIlRSSUFOR0xFX0ZBTiIsIkZsb2F0MzJBcnJheSIsImlzSW5zdGFuY2VkIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwiaSIsIm9iamVjdCIsInBvaW50IiwiaXNOYU4iLCJyZWN0IiwiYW5jaG9yWCIsImFuY2hvclkiLCJjb2xvck1vZGUiLCJtYXNrIiwieSIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLEVBQTZCQyxTQUE3QixFQUF3Q0MsWUFBeEMsUUFBMkQsU0FBM0Q7QUFDQSxTQUFRQyxPQUFSLEVBQWlCQyxrQkFBakIsUUFBMEMseUJBQTFDO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0MsY0FBaEM7O0FBRUEsT0FBT0MsVUFB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OztBQXdOckJBLFVBQVU0RSxTQUFWLEdBQXNCLFdBQXRCO0FBQ0E1RSxVQUFVaEIsWUFBVixHQUF5QkEsWUFBekIiLCJmaWxlIjoiaWNvbi1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5LCBUZXh0dXJlMkQsIGxvYWRUZXh0dXJlc30gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vLi4vbGliJztcblxuaW1wb3J0IGljb25WZXJ0ZXggZnJvbSAnLi9pY29uLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBpY29uVmVydGV4NjQgZnJvbSAnLi9pY29uLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBpY29uRnJhZ21lbnQgZnJvbSAnLi9pY29uLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbi8qXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7VGV4dHVyZTJEIHwgc3RyaW5nfSBwcm9wcy5pY29uQXRsYXMgLSBhdGxhcyBpbWFnZSB1cmwgb3IgdGV4dHVyZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nIC0gaWNvbiBuYW1lcyBtYXBwZWQgdG8gaWNvbiBkZWZpbml0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0ueCAtIHggcG9zaXRpb24gb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZ1tpY29uX25hbWVdLnkgLSB5IHBvc2l0aW9uIG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS53aWR0aCAtIHdpZHRoIG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5oZWlnaHQgLSBoZWlnaHQgb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZ1tpY29uX25hbWVdLmFuY2hvclggLSB4IGFuY2hvciBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZSxcbiAqICAgZGVmYXVsdCB0byB3aWR0aCAvIDJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZ1tpY29uX25hbWVdLmFuY2hvclkgLSB5IGFuY2hvciBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZSxcbiAqICAgZGVmYXVsdCB0byBoZWlnaHQgLyAyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5tYXNrIC0gd2hldGhlciBpY29uIGlzIHRyZWF0ZWQgYXMgYSB0cmFuc3BhcmVuY3lcbiAqICAgbWFzay4gSWYgdHJ1ZSwgdXNlciBkZWZpbmVkIGNvbG9yIGlzIGFwcGxpZWQuIElmIGZhbHNlLCBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBpbWFnZSBpc1xuICogICBhcHBsaWVkLiBEZWZhdWx0IHRvIGZhbHNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnNpemUgLSBpY29uIHNpemUgaW4gcGl4ZWxzXG4gKiBAcGFyYW0ge2Z1bmN9IHByb3BzLmdldFBvc2l0aW9uIC0gcmV0dXJucyBhbmNob3IgcG9zaXRpb24gb2YgdGhlIGljb24sIGluIFtsbmcsIGxhdCwgel1cbiAqIEBwYXJhbSB7ZnVuY30gcHJvcHMuZ2V0SWNvbiAtIHJldHVybnMgaWNvbiBuYW1lIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge2Z1bmN9IHByb3BzLmdldFNpemUgLSByZXR1cm5zIGljb24gc2l6ZSBtdWx0aXBsaWVyIGFzIGEgbnVtYmVyXG4gKiBAcGFyYW0ge2Z1bmN9IHByb3BzLmdldENvbG9yIC0gcmV0dXJucyBjb2xvciBvZiB0aGUgaWNvbiBpbiBbciwgZywgYiwgYV0uIE9ubHkgd29ya3Mgb24gaWNvbnNcbiAqICAgd2l0aCBtYXNrOiB0cnVlLlxuICovXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGljb25BdGxhczogbnVsbCxcbiAgaWNvbk1hcHBpbmc6IHt9LFxuICBzaXplU2NhbGU6IDEsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGdldEljb246IHggPT4geC5pY29uLFxuICBnZXRDb2xvcjogeCA9PiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1IsXG4gIGdldFNpemU6IHggPT4geC5zaXplIHx8IDEsXG4gIGdldEFuZ2xlOiB4ID0+IHguYW5nbGUgfHwgMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVNpemVzOiB7c2l6ZTogMSwgYWNjZXNzb3I6ICdnZXRTaXplJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU2l6ZXN9LFxuICAgICAgaW5zdGFuY2VPZmZzZXRzOiB7c2l6ZTogMiwgYWNjZXNzb3I6ICdnZXRJY29uJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlT2Zmc2V0c30sXG4gICAgICBpbnN0YW5jZUljb25GcmFtZXM6IHtzaXplOiA0LCBhY2Nlc3NvcjogJ2dldEljb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzfSxcbiAgICAgIGluc3RhbmNlQ29sb3JNb2Rlczoge3NpemU6IDEsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0SWNvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yTW9kZX0sXG4gICAgICBpbnN0YW5jZUNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnN9LFxuICAgICAgaW5zdGFuY2VBbmdsZXM6IHtzaXplOiAxLCBhY2Nlc3NvcjogJ2dldEFuZ2xlJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQW5nbGVzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuXG4gICAgY29uc3Qge2ljb25BdGxhcywgaWNvbk1hcHBpbmd9ID0gcHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMuaWNvbk1hcHBpbmcgIT09IGljb25NYXBwaW5nKSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdpbnN0YW5jZU9mZnNldHMnKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnaW5zdGFuY2VJY29uRnJhbWVzJyk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2luc3RhbmNlQ29sb3JNb2RlcycpO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcy5pY29uQXRsYXMgIT09IGljb25BdGxhcykge1xuICAgICAgY29uc3QgaWNvbnMgPSB7fTtcbiAgICAgIHRoaXMuc3RhdGUuaWNvbnMgPSBpY29ucztcblxuICAgICAgaWYgKGljb25BdGxhcyBpbnN0YW5jZW9mIFRleHR1cmUyRCkge1xuICAgICAgICBpY29ucy50ZXh0dXJlID0gaWNvbkF0bGFzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWNvbkF0bGFzID09PSAnc3RyaW5nJykge1xuICAgICAgICBsb2FkVGV4dHVyZXModGhpcy5jb250ZXh0LmdsLCB7XG4gICAgICAgICAgdXJsczogW2ljb25BdGxhc11cbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKFt0ZXh0dXJlXSkgPT4ge1xuICAgICAgICAgIGljb25zLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3NpemVTY2FsZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGljb25zVGV4dHVyZSA9IHRoaXMuc3RhdGUuaWNvbnMgJiYgdGhpcy5zdGF0ZS5pY29ucy50ZXh0dXJlO1xuXG4gICAgaWYgKGljb25zVGV4dHVyZSkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgaWNvbnNUZXh0dXJlLFxuICAgICAgICBpY29uc1RleHR1cmVEaW06IFtpY29uc1RleHR1cmUud2lkdGgsIGljb25zVGV4dHVyZS5oZWlnaHRdLFxuICAgICAgICBzaXplU2NhbGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogaWNvblZlcnRleDY0LFxuICAgICAgZnM6IGljb25GcmFnbWVudCxcbiAgICAgIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9IDoge1xuICAgICAgdnM6IGljb25WZXJ0ZXgsXG4gICAgICBmczogaWNvbkZyYWdtZW50LFxuICAgICAgbW9kdWxlczogW10sXG4gICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuXG4gICAgY29uc3QgcG9zaXRpb25zID0gWy0xLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIDEsIC0xLCAwXTtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9GQU4sXG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMl0gfHwgMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzFdKVsxXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNpemVzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRTaXplfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgdmFsdWVbaSsrXSA9IGdldFNpemUob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUFuZ2xlcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0QW5nbGV9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0QW5nbGUob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKG9iamVjdCk7XG5cbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2krK10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZU9mZnNldHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGljb25NYXBwaW5nLCBnZXRJY29ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgaWNvbiA9IGdldEljb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IHJlY3QgPSBpY29uTWFwcGluZ1tpY29uXSB8fCB7fTtcbiAgICAgIHZhbHVlW2krK10gPSAoMSAvIDIgLSByZWN0LmFuY2hvclggLyByZWN0LndpZHRoKSB8fCAwO1xuICAgICAgdmFsdWVbaSsrXSA9ICgxIC8gMiAtIHJlY3QuYW5jaG9yWSAvIHJlY3QuaGVpZ2h0KSB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JNb2RlKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBpY29uTWFwcGluZywgZ2V0SWNvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGljb24gPSBnZXRJY29uKG9iamVjdCk7XG4gICAgICBjb25zdCBjb2xvck1vZGUgPSBpY29uTWFwcGluZ1tpY29uXSAmJiBpY29uTWFwcGluZ1tpY29uXS5tYXNrO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yTW9kZSA/IDEgOiAwO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlSWNvbkZyYW1lcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgaWNvbk1hcHBpbmcsIGdldEljb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBpY29uID0gZ2V0SWNvbihvYmplY3QpO1xuICAgICAgY29uc3QgcmVjdCA9IGljb25NYXBwaW5nW2ljb25dIHx8IHt9O1xuICAgICAgdmFsdWVbaSsrXSA9IHJlY3QueCB8fCAwO1xuICAgICAgdmFsdWVbaSsrXSA9IHJlY3QueSB8fCAwO1xuICAgICAgdmFsdWVbaSsrXSA9IHJlY3Qud2lkdGggfHwgMDtcbiAgICAgIHZhbHVlW2krK10gPSByZWN0LmhlaWdodCB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG5JY29uTGF5ZXIubGF5ZXJOYW1lID0gJ0ljb25MYXllcic7XG5JY29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME line-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJsaW5lLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcbn1cbmA7XG4iXX0=

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME line-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceSourceTargetPositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  // Position\n  vec4 instanceSourcePositions64 = vec4(\n    instanceSourcePositions.x, instanceSourceTargetPositions64xyLow.x,\n    instanceSourcePositions.y, instanceSourceTargetPositions64xyLow.y);\n\n  vec4 instanceTargetPositions64 = vec4(\n    instanceTargetPositions.x, instanceSourceTargetPositions64xyLow.z,\n    instanceTargetPositions.y, instanceSourceTargetPositions64xyLow.w);\n\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\n\n  vec2 source_pos_modelspace[4];\n  source_pos_modelspace[0] =  projected_source_coord[0];\n  source_pos_modelspace[1] =  projected_source_coord[1];\n  source_pos_modelspace[2] = vec2(project_scale(instanceSourcePositions.z), 0.0);\n  source_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 source_pos_clipspace = project_to_clipspace_fp64(source_pos_modelspace);\n\n  vec2 target_pos_modelspace[4];\n  target_pos_modelspace[0] =  projected_target_coord[0];\n  target_pos_modelspace[1] =  projected_target_coord[1];\n  target_pos_modelspace[2] = vec2(project_scale(instanceTargetPositions.z), 0.0);\n  target_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 target_pos_clipspace = project_to_clipspace_fp64(target_pos_modelspace);\n\n  float segmentIndex = positions.x;\n  vec4 p = mix(source_pos_clipspace, target_pos_clipspace, segmentIndex);\n\n  vec2 offset = getExtrusionOffset(target_pos_clipspace.xy - source_pos_clipspace.xy, positions.y);\n\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n\n  // Color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n\n  vColor = mix(\n    color,\n    pickingColor,\n    renderPickingBuffer\n  );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoibGluZS1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci12ZXJ0ZXgtc2hhZGVyLTY0XG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU291cmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVNvdXJjZVRhcmdldFBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbi8vIG9mZnNldCB2ZWN0b3IgYnkgc3Ryb2tlV2lkdGggcGl4ZWxzXG4vLyBvZmZzZXRfZGlyZWN0aW9uIGlzIC0xIChsZWZ0KSBvciAxIChyaWdodClcbnZlYzIgZ2V0RXh0cnVzaW9uT2Zmc2V0KHZlYzIgbGluZV9jbGlwc3BhY2UsIGZsb2F0IG9mZnNldF9kaXJlY3Rpb24pIHtcbiAgLy8gbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcbiAgdmVjMiBkaXJfc2NyZWVuc3BhY2UgPSBub3JtYWxpemUobGluZV9jbGlwc3BhY2UgKiB2aWV3cG9ydFNpemUpO1xuICAvLyByb3RhdGUgYnkgOTAgZGVncmVlc1xuICBkaXJfc2NyZWVuc3BhY2UgPSB2ZWMyKC1kaXJfc2NyZWVuc3BhY2UueSwgZGlyX3NjcmVlbnNwYWNlLngpO1xuXG4gIHZlYzIgb2Zmc2V0X3NjcmVlbnNwYWNlID0gZGlyX3NjcmVlbnNwYWNlICogb2Zmc2V0X2RpcmVjdGlvbiAqIHN0cm9rZVdpZHRoIC8gMi4wO1xuICB2ZWMyIG9mZnNldF9jbGlwc3BhY2UgPSBvZmZzZXRfc2NyZWVuc3BhY2UgLyB2aWV3cG9ydFNpemUgKiAyLjA7XG5cbiAgcmV0dXJuIG9mZnNldF9jbGlwc3BhY2U7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vIFBvc2l0aW9uXG4gIHZlYzQgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NCA9IHZlYzQoXG4gICAgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMueCwgaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93LngsXG4gICAgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMueSwgaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzQgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NCA9IHZlYzQoXG4gICAgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMueCwgaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93LnosXG4gICAgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMueSwgaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93LncpO1xuXG4gIHZlYzIgcHJvamVjdGVkX3NvdXJjZV9jb29yZFsyXTtcbiAgdmVjMiBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkWzJdO1xuXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczY0LCBwcm9qZWN0ZWRfc291cmNlX2Nvb3JkKTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjQsIHByb2plY3RlZF90YXJnZXRfY29vcmQpO1xuXG4gIHZlYzIgc291cmNlX3Bvc19tb2RlbHNwYWNlWzRdO1xuICBzb3VyY2VfcG9zX21vZGVsc3BhY2VbMF0gPSAgcHJvamVjdGVkX3NvdXJjZV9jb29yZFswXTtcbiAgc291cmNlX3Bvc19tb2RlbHNwYWNlWzFdID0gIHByb2plY3RlZF9zb3VyY2VfY29vcmRbMV07XG4gIHNvdXJjZV9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucy56KSwgMC4wKTtcbiAgc291cmNlX3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgdmVjNCBzb3VyY2VfcG9zX2NsaXBzcGFjZSA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQoc291cmNlX3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWMyIHRhcmdldF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdGFyZ2V0X3Bvc19tb2RlbHNwYWNlWzBdID0gIHByb2plY3RlZF90YXJnZXRfY29vcmRbMF07XG4gIHRhcmdldF9wb3NfbW9kZWxzcGFjZVsxXSA9ICBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkWzFdO1xuICB0YXJnZXRfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKHByb2plY3Rfc2NhbGUoaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMueiksIDAuMCk7XG4gIHRhcmdldF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIHZlYzQgdGFyZ2V0X3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHRhcmdldF9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XG4gIHZlYzQgcCA9IG1peChzb3VyY2VfcG9zX2NsaXBzcGFjZSwgdGFyZ2V0X3Bvc19jbGlwc3BhY2UsIHNlZ21lbnRJbmRleCk7XG5cbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQodGFyZ2V0X3Bvc19jbGlwc3BhY2UueHkgLSBzb3VyY2VfcG9zX2NsaXBzcGFjZS54eSwgcG9zaXRpb25zLnkpO1xuXG4gIGdsX1Bvc2l0aW9uID0gcCArIHZlYzQob2Zmc2V0LCAwLjAsIDAuMCk7XG5cbiAgLy8gQ29sb3JcbiAgdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xuXG4gIHZDb2xvciA9IG1peChcbiAgICBjb2xvcixcbiAgICBwaWNraW5nQ29sb3IsXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxuICApO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  // Position\n  vec3 sourcePos = project_position(instanceSourcePositions);\n  vec3 targetPos = project_position(instanceTargetPositions);\n  vec4 source = project_to_clipspace(vec4(sourcePos, 1.0));\n  vec4 target = project_to_clipspace(vec4(targetPos, 1.0));\n\n  // linear interpolation of source & target to pick right coord\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n\n  // extrude\n  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y);\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n\n  // Color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(\n    color,\n    pickingColor,\n    renderPickingBuffer\n  );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoibGluZS1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU291cmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbi8vIG9mZnNldCB2ZWN0b3IgYnkgc3Ryb2tlV2lkdGggcGl4ZWxzXG4vLyBvZmZzZXRfZGlyZWN0aW9uIGlzIC0xIChsZWZ0KSBvciAxIChyaWdodClcbnZlYzIgZ2V0RXh0cnVzaW9uT2Zmc2V0KHZlYzIgbGluZV9jbGlwc3BhY2UsIGZsb2F0IG9mZnNldF9kaXJlY3Rpb24pIHtcbiAgLy8gbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcbiAgdmVjMiBkaXJfc2NyZWVuc3BhY2UgPSBub3JtYWxpemUobGluZV9jbGlwc3BhY2UgKiB2aWV3cG9ydFNpemUpO1xuICAvLyByb3RhdGUgYnkgOTAgZGVncmVlc1xuICBkaXJfc2NyZWVuc3BhY2UgPSB2ZWMyKC1kaXJfc2NyZWVuc3BhY2UueSwgZGlyX3NjcmVlbnNwYWNlLngpO1xuXG4gIHZlYzIgb2Zmc2V0X3NjcmVlbnNwYWNlID0gZGlyX3NjcmVlbnNwYWNlICogb2Zmc2V0X2RpcmVjdGlvbiAqIHN0cm9rZVdpZHRoIC8gMi4wO1xuICB2ZWMyIG9mZnNldF9jbGlwc3BhY2UgPSBvZmZzZXRfc2NyZWVuc3BhY2UgLyB2aWV3cG9ydFNpemUgKiAyLjA7XG5cbiAgcmV0dXJuIG9mZnNldF9jbGlwc3BhY2U7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vIFBvc2l0aW9uXG4gIHZlYzMgc291cmNlUG9zID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyk7XG4gIHZlYzMgdGFyZ2V0UG9zID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVRhcmdldFBvc2l0aW9ucyk7XG4gIHZlYzQgc291cmNlID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNChzb3VyY2VQb3MsIDEuMCkpO1xuICB2ZWM0IHRhcmdldCA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQodGFyZ2V0UG9zLCAxLjApKTtcblxuICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiBzb3VyY2UgJiB0YXJnZXQgdG8gcGljayByaWdodCBjb29yZFxuICBmbG9hdCBzZWdtZW50SW5kZXggPSBwb3NpdGlvbnMueDtcbiAgdmVjNCBwID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50SW5kZXgpO1xuXG4gIC8vIGV4dHJ1ZGVcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQodGFyZ2V0Lnh5IC0gc291cmNlLnh5LCBwb3NpdGlvbnMueSk7XG4gIGdsX1Bvc2l0aW9uID0gcCArIHZlYzQob2Zmc2V0LCAwLjAsIDAuMCk7XG5cbiAgLy8gQ29sb3JcbiAgdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xuICB2Q29sb3IgPSBtaXgoXG4gICAgY29sb3IsXG4gICAgcGlja2luZ0NvbG9yLFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcbiAgKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__line_layer_vertex_glsl__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__line_layer_vertex_64_glsl__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__ = __webpack_require__(156);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [0, 0, 0, 255];

var defaultProps = {
  strokeWidth: 1,
  fp64: false,

  getSourcePosition: function getSourcePosition(x) {
    return x.sourcePosition;
  },
  getTargetPosition: function getTargetPosition(x) {
    return x.targetPosition;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  }
};

var LineLayer = function (_Layer) {
  _inherits(LineLayer, _Layer);

  function LineLayer() {
    _classCallCheck(this, LineLayer);

    return _possibleConstructorReturn(this, (LineLayer.__proto__ || Object.getPrototypeOf(LineLayer)).apply(this, arguments));
  }

  _createClass(LineLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__line_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__line_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      var attributeManager = this.state.attributeManager;

      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instanceSourcePositions: { size: 3, accessor: 'getSourcePosition', update: this.calculateInstanceSourcePositions },
        instanceTargetPositions: { size: 3, accessor: 'getTargetPosition', update: this.calculateInstanceTargetPositions },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instanceSourceTargetPositions64xyLow: {
              size: 4,
              accessor: ['getSourcePosition', 'getTargetPosition'],
              update: this.calculateInstanceSourceTargetPositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instanceSourceTargetPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(LineLayer.prototype.__proto__ || Object.getPrototypeOf(LineLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var strokeWidth = this.props.strokeWidth;


      this.state.model.render(Object.assign({}, uniforms, {
        strokeWidth: strokeWidth
      }));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      /*
       *  (0, -1)-------------_(1, -1)
       *       |          _,-"  |
       *       o      _,-"      o
       *       |  _,-"          |
       *   (0, 1)"-------------(1, 1)
       */
      var positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLE_STRIP,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'calculateInstanceSourcePositions',
    value: function calculateInstanceSourcePositions(attribute) {
      var _props = this.props,
          data = _props.data,
          getSourcePosition = _props.getSourcePosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var sourcePosition = getSourcePosition(object);
          value[i + 0] = sourcePosition[0];
          value[i + 1] = sourcePosition[1];
          value[i + 2] = isNaN(sourcePosition[2]) ? 0 : sourcePosition[2];
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceTargetPositions',
    value: function calculateInstanceTargetPositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getTargetPosition = _props2.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var targetPosition = getTargetPosition(object);
          value[i + 0] = targetPosition[0];
          value[i + 1] = targetPosition[1];
          value[i + 2] = isNaN(targetPosition[2]) ? 0 : targetPosition[2];
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceSourceTargetPositions64xyLow',
    value: function calculateInstanceSourceTargetPositions64xyLow(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getSourcePosition = _props3.getSourcePosition,
          getTargetPosition = _props3.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          var sourcePosition = getSourcePosition(object);
          var targetPosition = getTargetPosition(object);
          value[i + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(sourcePosition[0])[1];
          value[i + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(sourcePosition[1])[1];
          value[i + 2] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(targetPosition[0])[1];
          value[i + 3] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(targetPosition[1])[1];
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getColor = _props4.getColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;

          var color = getColor(object);
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? 255 : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);

  return LineLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (LineLayer);


LineLayer.layerName = 'LineLayer';
LineLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJHTCIsIk1vZGVsIiwiR2VvbWV0cnkiLCJmcDY0aWZ5IiwiZW5hYmxlNjRiaXRTdXBwb3J0IiwiQ09PUkRJTkFURV9TWVNURU0iLCJsaW5lVmVydGV4IiwibGluZVZlcnRleDY0IiwibGluZUZyYWdtZW50IiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsInN0cm9rZVdpZHRoIiwiZnA2NCIsImdldFNvdXJjZVBvc2l0aW9uIiwieCIsInNvdXJjZVBvc2l0aW9uIiwiZ2V0VGFyZ2V0UG9zaXRpb24iLCJ0YXJnZXRQb3NpdGlvbiIsImdldENvbG9yIiwiY29sb3IiLCJMaW5lTGF5ZXIiLCJwcm9wcyIsInZzIiwiZnMiLCJtb2R1bGVzIiwic2hhZGVyQ2FjaGUiLCJjb250ZXh0IiwiZ2wiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiX2dldE1vZGVsIiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMiLCJzaXplIiwiYWNjZXNzb3IiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyIsImluc3RhbmNlVGFyZ2V0UG9zaXRpb25zIiwiY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMiLCJpbnN0YW5jZUNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMiLCJvbGRQcm9wcyIsImNoYW5nZUZsYWdzIiwiaW52YWxpZGF0ZUFsbCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwiaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93IiwiY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93IiwicmVtb3ZlIiwidXBkYXRlQXR0cmlidXRlIiwidW5pZm9ybXMiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbnMiLCJzaGFkZXJzIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIlRSSUFOR0xFX1NUUklQIiwiRmxvYXQzMkFycmF5IiwiaXNJbnN0YW5jZWQiLCJhdHRyaWJ1dGUiLCJkYXRhIiwidmFsdWUiLCJpIiwib2JqZWN0IiwiaXNOYU4iLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDO0FBQ0EsU0FBUUMsT0FBUixFQUFpQkMsa0JBQWpCLFFBQTBDLHlCQUExQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDOztBQUVBLE9BQU9DLFVBQVAsTUFBdUIsMEJBQXZCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5Qiw2QkFBekI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLDRCQUF6Qjs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQXRCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLGVBQWEsQ0FETTtBQUVuQkMsUUFBTSxLQUZhOztBQUluQkMscUJBQW1CO0FBQUEsV0FBS0MsRUFBRUMsY0FBUDtBQUFBLEdBSkE7QUFLbkJDLHFCQUFtQjtBQUFBLFdBQUtGLEVBQUVHLGNBQVA7QUFBQSxHQUxBO0FBTW5CQyxZQUFVO0FBQUEsV0FBS0osRUFBRUssS0FBRixJQUFXVixhQUFoQjtBQUFBO0FBTlMsQ0FBckI7O0lBU3FCVyxTOzs7Ozs7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b0I7QUFBQSxVQUUxQm1ELEtBRjBCLEdBRVhGLFNBRlcsQ0FFMUJFLEtBRjBCO0FBQUEsVUFFbkJsQyxJQUZtQixHQUVYZ0MsU0FGVyxDQUVuQmhDLElBRm1COztBQUdqQyxVQUFJbUMsSUFBSSxDQUFSO0FBSGlDO0FBQUE7QUFBQTs7QUFBQTtBQUlqQyw4QkFBcUJGLElBQXJCLG1JQUEyQjtBQUFBLGNBQWhCRyxNQUFnQjs7QUFDekIsY0FBTXBELFFBQVFELFNBQVNxRCxNQUFULENBQWQ7QUFDQUYsZ0JBQU1DLElBQUksQ0FBVixJQUFlbkQsTUFBTSxDQUFOLENBQWY7QUFDQWtELGdCQUFNQyxJQUFJLENBQVYsSUFBZW5ELE1BQU0sQ0FBTixDQUFmO0FBQ0FrRCxnQkFBTUMsSUFBSSxDQUFWLElBQWVuRCxNQUFNLENBQU4sQ0FBZjtBQUNBa0QsZ0JBQU1DLElBQUksQ0FBVixJQUFlRSxNQUFNckQsTUFBTSxDQUFOLENBQU4sSUFBa0IsR0FBbEIsR0FBd0JBLE1BQU0sQ0FBTixDQUF2QztBQUNBbUQsZUFBS25DLElBQUw7QUFDRDtBQVhnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWWxDOzs7O0VBbEpvQ3JDLEs7O2VBQWxCc0IsUzs7O0FBcUpyQkEsVUFBVXFELFNBQVYsR0FBc0IsV0FBdEI7QUFDQXJELFVBQVVWLFlBQVYsR0FBeUJBLFlBQXpCIiwiZmlsZSI6ImxpbmUtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7ZnA2NGlmeSwgZW5hYmxlNjRiaXRTdXBwb3J0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuXG5pbXBvcnQgbGluZVZlcnRleCBmcm9tICcuL2xpbmUtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGxpbmVWZXJ0ZXg2NCBmcm9tICcuL2xpbmUtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGxpbmVGcmFnbWVudCBmcm9tICcuL2xpbmUtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VXaWR0aDogMSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0U291cmNlUG9zaXRpb246IHggPT4geC5zb3VyY2VQb3NpdGlvbixcbiAgZ2V0VGFyZ2V0UG9zaXRpb246IHggPT4geC50YXJnZXRQb3NpdGlvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKSA/IHtcbiAgICAgIHZzOiBsaW5lVmVydGV4NjQsXG4gICAgICBmczogbGluZUZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH0gOiB7XG4gICAgICB2czogbGluZVZlcnRleCxcbiAgICAgIGZzOiBsaW5lRnJhZ21lbnQsXG4gICAgICBtb2R1bGVzOiBbXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczoge3NpemU6IDMsIGFjY2Vzc29yOiAnZ2V0U291cmNlUG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM6IHtzaXplOiAzLCBhY2Nlc3NvcjogJ2dldFRhcmdldFBvc2l0aW9uJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0UG9zaXRpb25zfSxcbiAgICAgIGluc3RhbmNlQ29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yc31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVNvdXJjZVRhcmdldFBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICBhY2Nlc3NvcjogWydnZXRTb3VyY2VQb3NpdGlvbicsICdnZXRUYXJnZXRQb3NpdGlvbiddLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3N0cm9rZVdpZHRofSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgc3Ryb2tlV2lkdGhcbiAgICB9KSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAvKlxuICAgICAqICAoMCwgLTEpLS0tLS0tLS0tLS0tLV8oMSwgLTEpXG4gICAgICogICAgICAgfCAgICAgICAgICBfLC1cIiAgfFxuICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgKiAgICAgICB8ICBfLC1cIiAgICAgICAgICB8XG4gICAgICogICAoMCwgMSlcIi0tLS0tLS0tLS0tLS0oMSwgMSlcbiAgICAgKi9cbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbMCwgLTEsIDAsIDAsIDEsIDAsIDEsIC0xLCAwLCAxLCAxLCAwXTtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9TVFJJUCxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRTb3VyY2VQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IHNvdXJjZVBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gc291cmNlUG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBpc05hTihzb3VyY2VQb3NpdGlvblsyXSkgPyAwIDogc291cmNlUG9zaXRpb25bMl07XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFRhcmdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gdGFyZ2V0UG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSB0YXJnZXRQb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGlzTmFOKHRhcmdldFBvc2l0aW9uWzJdKSA/IDAgOiB0YXJnZXRQb3NpdGlvblsyXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVRhcmdldFBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9uLCBnZXRUYXJnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGZwNjRpZnkoc291cmNlUG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSArIDFdID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblsxXSlbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGZwNjRpZnkodGFyZ2V0UG9zaXRpb25bMV0pWzFdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5MaW5lTGF5ZXIubGF5ZXJOYW1lID0gJ0xpbmVMYXllcic7XG5MaW5lTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME path-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nvoid main(void) {\n  // if joint is rounded, test distance from the corner\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJwYXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xudW5pZm9ybSBmbG9hdCBtaXRlckxpbWl0O1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHZDb3JuZXJPZmZzZXQ7XG52YXJ5aW5nIGZsb2F0IHZNaXRlckxlbmd0aDtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gaWYgam9pbnQgaXMgcm91bmRlZCwgdGVzdCBkaXN0YW5jZSBmcm9tIHRoZSBjb3JuZXJcbiAgaWYgKGpvaW50VHlwZSA+IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiAwLjAgJiYgbGVuZ3RoKHZDb3JuZXJPZmZzZXQpID4gMS4wKSB7XG4gICAgZGlzY2FyZDtcbiAgfVxuICBpZiAoam9pbnRUeXBlID09IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG59XG5gO1xuIl19

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  // Calculate previous position\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  // Calculate current position\n  // Only here we need to do the 64-bit calculations.\n\n  vec2 instanceStartPositions64[2];\n  instanceStartPositions64[0] = vec2(instanceStartPositions.x, instanceStartEndPositions64xyLow.x);\n  instanceStartPositions64[1] = vec2(instanceStartPositions.y, instanceStartEndPositions64xyLow.y);\n\n  vec2 instanceEndPositions64[2];\n  instanceEndPositions64[0] = vec2(instanceEndPositions.x, instanceStartEndPositions64xyLow.z);\n  instanceEndPositions64[1] = vec2(instanceEndPositions.y, instanceStartEndPositions64xyLow.w);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n\n  vec2 tempCurrPosition64[2];\n  vec2_mix_fp64(instanceStartPositions64, instanceEndPositions64, isEnd, tempCurrPosition64);\n\n  vec4 currPosition64 = vec4(tempCurrPosition64[0].xy, tempCurrPosition64[1].xy);\n\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition64, projected_curr_position);\n  float projected_curr_position_z = project_scale(currPosition.z);\n\n  currPosition = project_position(currPosition);\n\n  // Calculate next positions\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoicGF0aC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcblxuI2RlZmluZSBTSEFERVJfTkFNRSBwYXRoLWxheWVyLXZlcnRleC1zaGFkZXJcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlTGVmdERlbHRhcztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUmlnaHREZWx0YXM7XG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTdHJva2VXaWR0aHM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCB3aWR0aFNjYWxlO1xudW5pZm9ybSBmbG9hdCB3aWR0aE1pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgd2lkdGhNYXhQaXhlbHM7XG51bmlmb3JtIGZsb2F0IGpvaW50VHlwZTtcbnVuaWZvcm0gZmxvYXQgbWl0ZXJMaW1pdDtcblxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHZDb3JuZXJPZmZzZXQ7XG52YXJ5aW5nIGZsb2F0IHZNaXRlckxlbmd0aDtcblxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAxO1xuXG5mbG9hdCBmbGlwSWZUcnVlKGJvb2wgZmxhZykge1xuICByZXR1cm4gLShmbG9hdChmbGFnKSAqIDIuIC0gMS4pO1xufVxudmVjMyBsaW5lSm9pbih2ZWMzIHByZXZQb2ludCwgdmVjMyBjdXJyUG9pbnQsIHZlYzMgbmV4dFBvaW50KSB7XG5cbiAgZmxvYXQgd2lkdGggPSBjbGFtcChwcm9qZWN0X3NjYWxlKGluc3RhbmNlU3Ryb2tlV2lkdGhzICogd2lkdGhTY2FsZSksXG4gICAgd2lkdGhNaW5QaXhlbHMsIHdpZHRoTWF4UGl4ZWxzKSAvIDIuMDtcblxuICB2ZWMyIGRlbHRhQSA9IGN1cnJQb2ludC54eSAtIHByZXZQb2ludC54eTtcbiAgdmVjMiBkZWx0YUIgPSBuZXh0UG9pbnQueHkgLSBjdXJyUG9pbnQueHk7XG5cbiAgdmVjMiBvZmZzZXRWZWM7XG4gIGZsb2F0IG9mZnNldFNjYWxlO1xuICBmbG9hdCBvZmZzZXREaXJlY3Rpb247XG5cbiAgZmxvYXQgbGVuQSA9IGxlbmd0aChkZWx0YUEpO1xuICBmbG9hdCBsZW5CID0gbGVuZ3RoKGRlbHRhQik7XG4gIHZlYzIgZGlyQSA9IGxlbkEgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUEpIDogdmVjMigxLjAsIDAuMCk7XG4gIHZlYzIgZGlyQiA9IGxlbkIgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUIpIDogdmVjMigxLjAsIDAuMCk7XG4gIHZlYzIgcGVycEEgPSB2ZWMyKC1kaXJBLnksIGRpckEueCk7XG4gIHZlYzIgcGVycEIgPSB2ZWMyKC1kaXJCLnksIGRpckIueCk7XG5cbiAgLy8gdGFuZ2VudCBvZiB0aGUgY29ybmVyXG4gIHZlYzIgdGFuZ2VudCA9IHZlYzIoZGlyQSArIGRpckIpO1xuICB0YW5nZW50ID0gbGVuZ3RoKHRhbmdlbnQpID4gMC4gPyBub3JtYWxpemUodGFuZ2VudCkgOiBwZXJwQTtcbiAgLy8gZGlyZWN0aW9uIG9mIHRoZSBjb3JuZXJcbiAgdmVjMiBtaXRlclZlYyA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcbiAgLy8gd2lkdGggb2Zmc2V0IGZyb20gY3VycmVudCBwb3NpdGlvblxuICB2ZWMyIHBlcnAgPSBtaXgocGVycEIsIHBlcnBBLCBwb3NpdGlvbnMueCk7XG4gIGZsb2F0IEwgPSBtaXgobGVuQiwgbGVuQSwgcG9zaXRpb25zLngpO1xuXG4gIC8vIGNhcCBzdXBlciBzaGFycCBhbmdsZXNcbiAgZmxvYXQgc2luSGFsZkEgPSBhYnMoZG90KG1pdGVyVmVjLCBwZXJwKSk7XG4gIGZsb2F0IGNvc0hhbGZBID0gYWJzKGRvdChkaXJBLCBtaXRlclZlYykpO1xuICBib29sIHR1cm5zUmlnaHQgPSBkaXJBLnggKiBkaXJCLnkgPiBkaXJBLnkgKiBkaXJCLng7XG5cbiAgLy8gcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIGNvcm5lcjpcbiAgLy8gLTE6IGluc2lkZSAoc21hbGxlciBzaWRlIG9mIHRoZSBhbmdsZSlcbiAgLy8gMDogY2VudGVyXG4gIC8vIDE6IG91dHNpZGUgKGJpZ2dlciBzaWRlIG9mIHRoZSBhbmdsZSlcbiAgZmxvYXQgY29ybmVyUG9zaXRpb24gPSBtaXgoXG4gICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueSA+IDAuMCkpLFxuICAgIDAuMCxcbiAgICBwb3NpdGlvbnMuelxuICApO1xuXG4gIG9mZnNldFNjYWxlID0gMS4wIC8gbWF4KHNpbkhhbGZBLCBFUFNJTE9OKTtcblxuICAvLyBkbyBub3QgYmV2ZWwgaWYgbGluZSBzZWdtZW50IGlzIHRvbyBzaG9ydFxuICBjb3JuZXJQb3NpdGlvbiAqPSBmbG9hdChjb3JuZXJQb3NpdGlvbiA8PSAwLjAgfHwgc2luSGFsZkEgPCBtaW4obGVuQSwgbGVuQikgLyB3aWR0aCAqIGNvc0hhbGZBKTtcbiAgLy8gdHJpbSBpZiBpbnNpZGUgY29ybmVyIGV4dGVuZHMgZnVydGhlciB0aGFuIHRoZSBsaW5lIHNlZ21lbnRcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUsXG4gICAgbWluKG9mZnNldFNjYWxlLCBMIC8gd2lkdGggLyBtYXgoY29zSGFsZkEsIEVQU0lMT04pKSxcbiAgICBmbG9hdChjb3JuZXJQb3NpdGlvbiA8IDAuMClcbiAgKTtcblxuICB2TWl0ZXJMZW5ndGggPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUgKiBjb3JuZXJQb3NpdGlvbixcbiAgICBtaXgob2Zmc2V0U2NhbGUsIDAuMCwgY29ybmVyUG9zaXRpb24pLFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcbiAgKSAtIHNpbkhhbGZBICogam9pbnRUeXBlO1xuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXG4gICAgcG9zaXRpb25zLnksXG4gICAgbWl4KFxuICAgICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0KSxcbiAgICAgIHBvc2l0aW9ucy55ICogZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueCA9PSAxLikpLFxuICAgICAgY29ybmVyUG9zaXRpb25cbiAgICApLFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcbiAgKTtcbiAgb2Zmc2V0VmVjID0gbWl4KG1pdGVyVmVjLCAtdGFuZ2VudCwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XG4gIG9mZnNldFNjYWxlID0gbWl4KG9mZnNldFNjYWxlLCAxLjAgLyBtYXgoY29zSGFsZkEsIDAuMDAxKSwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XG5cbiAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yIHN0YXJ0IGNhcCBhbmQgZW5kIGNhcFxuICBmbG9hdCBpc1N0YXJ0Q2FwID0gc3RlcCgwLjAsIC1sZW5BKTtcbiAgZmxvYXQgaXNFbmRDYXAgPSBzdGVwKDAuMCwgLWxlbkIpO1xuICBmbG9hdCBpc0NhcCA9IG1heChpc1N0YXJ0Q2FwLCBpc0VuZENhcCk7XG5cbiAgLy8gMDogY2VudGVyLCAxOiBzaWRlXG4gIGNvcm5lclBvc2l0aW9uID0gaXNDYXAgKiAoMS4wIC0gcG9zaXRpb25zLnopO1xuXG4gIC8vIHN0YXJ0IG9mIHBhdGg6IHVzZSBuZXh0IC0gY3VyclxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQiwgcGVycEIsIGNvcm5lclBvc2l0aW9uKSwgaXNTdGFydENhcCk7XG4gIC8vIGVuZCBvZiBwYXRoOiB1c2UgY3VyciAtIHByZXZcbiAgb2Zmc2V0VmVjID0gbWl4KG9mZnNldFZlYywgbWl4KGRpckEsIHBlcnBBLCBjb3JuZXJQb3NpdGlvbiksIGlzRW5kQ2FwKTtcblxuICAvLyBleHRlbmQgb3V0IGEgdHJpYW5nbGUgdG8gZW52ZWxvcGUgdGhlIHJvdW5kIGNhcFxuICBvZmZzZXRTY2FsZSA9IG1peChcbiAgICBvZmZzZXRTY2FsZSxcbiAgICBtaXgoNC4wICogam9pbnRUeXBlLCAxLjAsIGNvcm5lclBvc2l0aW9uKSxcbiAgICBpc0NhcFxuICApO1xuICB2TWl0ZXJMZW5ndGggPSBtaXgodk1pdGVyTGVuZ3RoLCAxLjAgLSBjb3JuZXJQb3NpdGlvbiwgaXNDYXApO1xuXG4gIG9mZnNldERpcmVjdGlvbiA9IG1peChcbiAgICBvZmZzZXREaXJlY3Rpb24sXG4gICAgbWl4KGZsaXBJZlRydWUoaXNTdGFydENhcCA+IDAuKSwgcG9zaXRpb25zLnksIGNvcm5lclBvc2l0aW9uKSxcbiAgICBpc0NhcFxuICApO1xuXG4gIHZDb3JuZXJPZmZzZXQgPSBvZmZzZXRWZWMgKiBvZmZzZXREaXJlY3Rpb24gKiBvZmZzZXRTY2FsZTtcblxuICByZXR1cm4gdmVjMyh2Q29ybmVyT2Zmc2V0ICogd2lkdGgsIDAuMCk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCAyNTUuKSAvIDI1NS47XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcblxuICBmbG9hdCBpc0VuZCA9IHBvc2l0aW9ucy54O1xuXG4gIC8vIENhbGN1bGF0ZSBwcmV2aW91cyBwb3NpdGlvblxuICB2ZWMzIHByZXZQb3NpdGlvbiA9IG1peCgtaW5zdGFuY2VMZWZ0RGVsdGFzLCB2ZWMzKDAuMCksIGlzRW5kKSArIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM7XG4gIHByZXZQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24ocHJldlBvc2l0aW9uKTtcblxuICAvLyBDYWxjdWxhdGUgY3VycmVudCBwb3NpdGlvblxuICAvLyBPbmx5IGhlcmUgd2UgbmVlZCB0byBkbyB0aGUgNjQtYml0IGNhbGN1bGF0aW9ucy5cblxuICB2ZWMyIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NFsyXTtcbiAgaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0WzBdID0gdmVjMihpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLngsIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LngpO1xuICBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRbMV0gPSB2ZWMyKGluc3RhbmNlU3RhcnRQb3NpdGlvbnMueSwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueSk7XG5cbiAgdmVjMiBpbnN0YW5jZUVuZFBvc2l0aW9uczY0WzJdO1xuICBpbnN0YW5jZUVuZFBvc2l0aW9uczY0WzBdID0gdmVjMihpbnN0YW5jZUVuZFBvc2l0aW9ucy54LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy56KTtcbiAgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NFsxXSA9IHZlYzIoaW5zdGFuY2VFbmRQb3NpdGlvbnMueSwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cudyk7XG5cbiAgdmVjMyBjdXJyUG9zaXRpb24gPSBtaXgoaW5zdGFuY2VTdGFydFBvc2l0aW9ucywgaW5zdGFuY2VFbmRQb3NpdGlvbnMsIGlzRW5kKTtcblxuICB2ZWMyIHRlbXBDdXJyUG9zaXRpb242NFsyXTtcbiAgdmVjMl9taXhfZnA2NChpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjQsIGluc3RhbmNlRW5kUG9zaXRpb25zNjQsIGlzRW5kLCB0ZW1wQ3VyclBvc2l0aW9uNjQpO1xuXG4gIHZlYzQgY3VyclBvc2l0aW9uNjQgPSB2ZWM0KHRlbXBDdXJyUG9zaXRpb242NFswXS54eSwgdGVtcEN1cnJQb3NpdGlvbjY0WzFdLnh5KTtcblxuICB2ZWMyIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uWzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoY3VyclBvc2l0aW9uNjQsIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uKTtcbiAgZmxvYXQgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25feiA9IHByb2plY3Rfc2NhbGUoY3VyclBvc2l0aW9uLnopO1xuXG4gIGN1cnJQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24oY3VyclBvc2l0aW9uKTtcblxuICAvLyBDYWxjdWxhdGUgbmV4dCBwb3NpdGlvbnNcbiAgdmVjMyBuZXh0UG9zaXRpb24gPSBtaXgodmVjMygwLjApLCBpbnN0YW5jZVJpZ2h0RGVsdGFzLCBpc0VuZCkgKyBpbnN0YW5jZUVuZFBvc2l0aW9ucztcbiAgbmV4dFBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuXG4gIHZlYzMgcG9zID0gbGluZUpvaW4ocHJldlBvc2l0aW9uLCBjdXJyUG9zaXRpb24sIG5leHRQb3NpdGlvbik7XG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZWMyKHBvcy54LCAwLjApLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblswXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHN1bV9mcDY0KHZlYzIocG9zLnksIDAuMCksIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uWzFdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gdmVjMihwb3MueiArIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uX3osIDAuMCk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  currPosition = project_position(currPosition);\n\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos;\n\n  pos = lineJoin(prevPosition, currPosition, nextPosition);\n\n  gl_Position = project_to_clipspace(vec4(pos, 1.0));\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoicGF0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcGF0aC1sYXllci12ZXJ0ZXgtc2hhZGVyLTY0XG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VMZWZ0RGVsdGFzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VSaWdodERlbHRhcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVN0cm9rZVdpZHRocztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IHdpZHRoU2NhbGU7XG51bmlmb3JtIGZsb2F0IHdpZHRoTWluUGl4ZWxzO1xudW5pZm9ybSBmbG9hdCB3aWR0aE1heFBpeGVscztcbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xudW5pZm9ybSBmbG9hdCBtaXRlckxpbWl0O1xuXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdkNvcm5lck9mZnNldDtcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xuXG5jb25zdCBmbG9hdCBFUFNJTE9OID0gMC4wMDE7XG5cbmZsb2F0IGZsaXBJZlRydWUoYm9vbCBmbGFnKSB7XG4gIHJldHVybiAtKGZsb2F0KGZsYWcpICogMi4gLSAxLik7XG59XG5cbi8vIGNhbGN1bGF0ZSBsaW5lIGpvaW4gcG9zaXRpb25zXG52ZWMzIGxpbmVKb2luKHZlYzMgcHJldlBvaW50LCB2ZWMzIGN1cnJQb2ludCwgdmVjMyBuZXh0UG9pbnQpIHtcblxuICBmbG9hdCB3aWR0aCA9IGNsYW1wKHByb2plY3Rfc2NhbGUoaW5zdGFuY2VTdHJva2VXaWR0aHMgKiB3aWR0aFNjYWxlKSxcbiAgICB3aWR0aE1pblBpeGVscywgd2lkdGhNYXhQaXhlbHMpIC8gMi4wO1xuXG4gIHZlYzIgZGVsdGFBID0gY3VyclBvaW50Lnh5IC0gcHJldlBvaW50Lnh5O1xuICB2ZWMyIGRlbHRhQiA9IG5leHRQb2ludC54eSAtIGN1cnJQb2ludC54eTtcblxuICB2ZWMyIG9mZnNldFZlYztcbiAgZmxvYXQgb2Zmc2V0U2NhbGU7XG4gIGZsb2F0IG9mZnNldERpcmVjdGlvbjtcblxuICBmbG9hdCBsZW5BID0gbGVuZ3RoKGRlbHRhQSk7XG4gIGZsb2F0IGxlbkIgPSBsZW5ndGgoZGVsdGFCKTtcbiAgdmVjMiBkaXJBID0gbGVuQSA+IDAuID8gbm9ybWFsaXplKGRlbHRhQSkgOiB2ZWMyKDEuMCwgMC4wKTtcbiAgdmVjMiBkaXJCID0gbGVuQiA+IDAuID8gbm9ybWFsaXplKGRlbHRhQikgOiB2ZWMyKDEuMCwgMC4wKTtcbiAgdmVjMiBwZXJwQSA9IHZlYzIoLWRpckEueSwgZGlyQS54KTtcbiAgdmVjMiBwZXJwQiA9IHZlYzIoLWRpckIueSwgZGlyQi54KTtcblxuICAvLyB0YW5nZW50IG9mIHRoZSBjb3JuZXJcbiAgdmVjMiB0YW5nZW50ID0gdmVjMihkaXJBICsgZGlyQik7XG4gIHRhbmdlbnQgPSBsZW5ndGgodGFuZ2VudCkgPiAwLiA/IG5vcm1hbGl6ZSh0YW5nZW50KSA6IHBlcnBBO1xuICAvLyBkaXJlY3Rpb24gb2YgdGhlIGNvcm5lclxuICB2ZWMyIG1pdGVyVmVjID0gdmVjMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xuICAvLyB3aWR0aCBvZmZzZXQgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gIHZlYzIgcGVycCA9IG1peChwZXJwQiwgcGVycEEsIHBvc2l0aW9ucy54KTtcbiAgZmxvYXQgTCA9IG1peChsZW5CLCBsZW5BLCBwb3NpdGlvbnMueCk7XG5cbiAgLy8gY2FwIHN1cGVyIHNoYXJwIGFuZ2xlc1xuICBmbG9hdCBzaW5IYWxmQSA9IGFicyhkb3QobWl0ZXJWZWMsIHBlcnApKTtcbiAgZmxvYXQgY29zSGFsZkEgPSBhYnMoZG90KGRpckEsIG1pdGVyVmVjKSk7XG4gIGJvb2wgdHVybnNSaWdodCA9IGRpckEueCAqIGRpckIueSA+IGRpckEueSAqIGRpckIueDtcblxuICAvLyByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgY29ybmVyOlxuICAvLyAtMTogaW5zaWRlIChzbWFsbGVyIHNpZGUgb2YgdGhlIGFuZ2xlKVxuICAvLyAwOiBjZW50ZXJcbiAgLy8gMTogb3V0c2lkZSAoYmlnZ2VyIHNpZGUgb2YgdGhlIGFuZ2xlKVxuICBmbG9hdCBjb3JuZXJQb3NpdGlvbiA9IG1peChcbiAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy55ID4gMC4wKSksXG4gICAgMC4wLFxuICAgIHBvc2l0aW9ucy56XG4gICk7XG5cbiAgb2Zmc2V0U2NhbGUgPSAxLjAgLyBtYXgoc2luSGFsZkEsIEVQU0lMT04pO1xuXG4gIC8vIGRvIG5vdCBiZXZlbCBpZiBsaW5lIHNlZ21lbnQgaXMgdG9vIHNob3J0XG4gIGNvcm5lclBvc2l0aW9uICo9IGZsb2F0KGNvcm5lclBvc2l0aW9uIDw9IDAuMCB8fCBzaW5IYWxmQSA8IG1pbihsZW5BLCBsZW5CKSAvIHdpZHRoICogY29zSGFsZkEpO1xuICAvLyB0cmltIGlmIGluc2lkZSBjb3JuZXIgZXh0ZW5kcyBmdXJ0aGVyIHRoYW4gdGhlIGxpbmUgc2VnbWVudFxuICBvZmZzZXRTY2FsZSA9IG1peChcbiAgICBvZmZzZXRTY2FsZSxcbiAgICBtaW4ob2Zmc2V0U2NhbGUsIEwgLyB3aWR0aCAvIG1heChjb3NIYWxmQSwgRVBTSUxPTikpLFxuICAgIGZsb2F0KGNvcm5lclBvc2l0aW9uIDwgMC4wKVxuICApO1xuXG4gIHZNaXRlckxlbmd0aCA9IG1peChcbiAgICBvZmZzZXRTY2FsZSAqIGNvcm5lclBvc2l0aW9uLFxuICAgIG1peChvZmZzZXRTY2FsZSwgMC4wLCBjb3JuZXJQb3NpdGlvbiksXG4gICAgc3RlcCgwLjAsIGNvcm5lclBvc2l0aW9uKVxuICApIC0gc2luSGFsZkEgKiBqb2ludFR5cGU7XG4gIG9mZnNldERpcmVjdGlvbiA9IG1peChcbiAgICBwb3NpdGlvbnMueSxcbiAgICBtaXgoXG4gICAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQpLFxuICAgICAgcG9zaXRpb25zLnkgKiBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy54ID09IDEuKSksXG4gICAgICBjb3JuZXJQb3NpdGlvblxuICAgICksXG4gICAgc3RlcCgwLjAsIGNvcm5lclBvc2l0aW9uKVxuICApO1xuICBvZmZzZXRWZWMgPSBtaXgobWl0ZXJWZWMsIC10YW5nZW50LCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcbiAgb2Zmc2V0U2NhbGUgPSBtaXgob2Zmc2V0U2NhbGUsIDEuMCAvIG1heChjb3NIYWxmQSwgMC4wMDEpLCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcblxuICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3Igc3RhcnQgY2FwIGFuZCBlbmQgY2FwXG4gIGZsb2F0IGlzU3RhcnRDYXAgPSBzdGVwKDAuMCwgLWxlbkEpO1xuICBmbG9hdCBpc0VuZENhcCA9IHN0ZXAoMC4wLCAtbGVuQik7XG4gIGZsb2F0IGlzQ2FwID0gbWF4KGlzU3RhcnRDYXAsIGlzRW5kQ2FwKTtcblxuICAvLyAwOiBjZW50ZXIsIDE6IHNpZGVcbiAgY29ybmVyUG9zaXRpb24gPSBpc0NhcCAqICgxLjAgLSBwb3NpdGlvbnMueik7XG5cbiAgLy8gc3RhcnQgb2YgcGF0aDogdXNlIG5leHQgLSBjdXJyXG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJCLCBwZXJwQiwgY29ybmVyUG9zaXRpb24pLCBpc1N0YXJ0Q2FwKTtcbiAgLy8gZW5kIG9mIHBhdGg6IHVzZSBjdXJyIC0gcHJldlxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQSwgcGVycEEsIGNvcm5lclBvc2l0aW9uKSwgaXNFbmRDYXApO1xuXG4gIC8vIGV4dGVuZCBvdXQgYSB0cmlhbmdsZSB0byBlbnZlbG9wZSB0aGUgcm91bmQgY2FwXG4gIG9mZnNldFNjYWxlID0gbWl4KFxuICAgIG9mZnNldFNjYWxlLFxuICAgIG1peCg0LjAgKiBqb2ludFR5cGUsIDEuMCwgY29ybmVyUG9zaXRpb24pLFxuICAgIGlzQ2FwXG4gICk7XG4gIHZNaXRlckxlbmd0aCA9IG1peCh2TWl0ZXJMZW5ndGgsIDEuMCAtIGNvcm5lclBvc2l0aW9uLCBpc0NhcCk7XG5cbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxuICAgIG9mZnNldERpcmVjdGlvbixcbiAgICBtaXgoZmxpcElmVHJ1ZShpc1N0YXJ0Q2FwID4gMC4pLCBwb3NpdGlvbnMueSwgY29ybmVyUG9zaXRpb24pLFxuICAgIGlzQ2FwXG4gICk7XG5cbiAgdkNvcm5lck9mZnNldCA9IG9mZnNldFZlYyAqIG9mZnNldERpcmVjdGlvbiAqIG9mZnNldFNjYWxlO1xuXG4gIHJldHVybiBjdXJyUG9pbnQgKyB2ZWMzKHZDb3JuZXJPZmZzZXQgKiB3aWR0aCwgMC4wKTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIDI1NS4pIC8gMjU1LjtcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xuXG4gIGZsb2F0IGlzRW5kID0gcG9zaXRpb25zLng7XG5cbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoLWluc3RhbmNlTGVmdERlbHRhcywgdmVjMygwLjApLCBpc0VuZCkgKyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xuICBwcmV2UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKHByZXZQb3NpdGlvbik7XG5cbiAgdmVjMyBjdXJyUG9zaXRpb24gPSBtaXgoaW5zdGFuY2VTdGFydFBvc2l0aW9ucywgaW5zdGFuY2VFbmRQb3NpdGlvbnMsIGlzRW5kKTtcbiAgY3VyclBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihjdXJyUG9zaXRpb24pO1xuXG4gIHZlYzMgbmV4dFBvc2l0aW9uID0gbWl4KHZlYzMoMC4wKSwgaW5zdGFuY2VSaWdodERlbHRhcywgaXNFbmQpICsgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XG4gIG5leHRQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24obmV4dFBvc2l0aW9uKTtcblxuICB2ZWMzIHBvcztcblxuICBwb3MgPSBsaW5lSm9pbihwcmV2UG9zaXRpb24sIGN1cnJQb3NpdGlvbiwgbmV4dFBvc2l0aW9uKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQocG9zLCAxLjApKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME point-cloud-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter <= 1.0) {\n    gl_FragColor = vColor;\n  } else {\n    discard;\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InBvaW50LWNsb3VkLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBvaW50LWNsb3VkLWxheWVyLWZyYWdtZW50LXNoYWRlclxuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICBmbG9hdCBkaXN0VG9DZW50ZXIgPSBsZW5ndGgodW5pdFBvc2l0aW9uKTtcblxuICBpZiAoZGlzdFRvQ2VudGVyIDw9IDEuMCkge1xuICAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcbiAgfSBlbHNlIHtcbiAgICBkaXNjYXJkO1xuICB9XG59XG5gO1xuIl19

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME point-cloud-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float renderPickingBuffer;\nuniform float opacity;\nuniform float radiusPixels;\nuniform vec2 screenSize;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(positions.xy * radiusPixels / screenSize * 2.0, 0.0, 0.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2],\n    vec2(project_scale(instancePositions.z), 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 position_worldspace = vec4(\n    projected_coord_xy[0].x, projected_coord_xy[1].x,\n    project_scale(instancePositions.z), 1.0);\n\n  if (renderPickingBuffer > 0.5) {\n    vColor = vec4(instancePickingColors / 255., 1.);\n  } else {\n    // Apply lighting\n    float lightWeight = getLightWeight(position_worldspace.xyz, // the w component is always 1.0\n      instanceNormals);\n\n    // Apply opacity to instance color, or return instance picking color\n    vColor = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJwb2ludC1jbG91ZC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4LXNoYWRlci02NFxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VOb3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzUGl4ZWxzO1xudW5pZm9ybSB2ZWMyIHNjcmVlblNpemU7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdW5pdFBvc2l0aW9uO1xuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBwb3NpdGlvbiBvbiB0aGUgY29udGFpbmluZyBzcXVhcmUgaW4gWy0xLCAxXSBzcGFjZVxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XG5cbiAgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0eHkgPSB2ZWM0KFxuICAgIGluc3RhbmNlUG9zaXRpb25zLngsIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy54LFxuICAgIGluc3RhbmNlUG9zaXRpb25zLnksIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlUG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICB2ZWMyIHZlcnRleF9wb3NfbG9jYWxzcGFjZVs0XTtcbiAgdmVjNF9mcDY0KHZlYzQocG9zaXRpb25zLnh5ICogcmFkaXVzUGl4ZWxzIC8gc2NyZWVuU2l6ZSAqIDIuMCwgMC4wLCAwLjApLCB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2UpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMF0sIHByb2plY3RlZF9jb29yZF94eVswXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVsxXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzFdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLFxuICAgIHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy56KSwgMC4wKSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQoXG4gICAgcHJvamVjdGVkX2Nvb3JkX3h5WzBdLngsIHByb2plY3RlZF9jb29yZF94eVsxXS54LFxuICAgIHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiksIDEuMCk7XG5cbiAgaWYgKHJlbmRlclBpY2tpbmdCdWZmZXIgPiAwLjUpIHtcbiAgICB2Q29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBseSBsaWdodGluZ1xuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQocG9zaXRpb25fd29ybGRzcGFjZS54eXosIC8vIHRoZSB3IGNvbXBvbmVudCBpcyBhbHdheXMgMS4wXG4gICAgICBpbnN0YW5jZU5vcm1hbHMpO1xuXG4gICAgLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgICB2Q29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICB9XG59XG5gO1xuIl19

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float renderPickingBuffer;\nuniform float opacity;\nuniform float radiusPixels;\nuniform vec2 viewportSize;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  // Find the center of the point and add the current vertex\n  vec4 position_worldspace = vec4(project_position(instancePositions), 1.0);\n  vec2 vertex = positions.xy * radiusPixels / viewportSize * 2.0;\n  gl_Position = project_to_clipspace(position_worldspace) + vec4(vertex, 0.0, 0.0);\n\n  // Apply lighting\n  float lightWeight = getLightWeight(position_worldspace.xyz, // the w component is always 1.0\n    instanceNormals);\n\n  // Apply opacity to instance color, or return instance picking color\n  vec4 color = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci12ZXJ0ZXguZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJwb2ludC1jbG91ZC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VOb3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzUGl4ZWxzO1xudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vIHBvc2l0aW9uIG9uIHRoZSBjb250YWluaW5nIHNxdWFyZSBpbiBbLTEsIDFdIHNwYWNlXG4gIHVuaXRQb3NpdGlvbiA9IHBvc2l0aW9ucy54eTtcblxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQocHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucyksIDEuMCk7XG4gIHZlYzIgdmVydGV4ID0gcG9zaXRpb25zLnh5ICogcmFkaXVzUGl4ZWxzIC8gdmlld3BvcnRTaXplICogMi4wO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpICsgdmVjNCh2ZXJ0ZXgsIDAuMCwgMC4wKTtcblxuICAvLyBBcHBseSBsaWdodGluZ1xuICBmbG9hdCBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KHBvc2l0aW9uX3dvcmxkc3BhY2UueHl6LCAvLyB0aGUgdyBjb21wb25lbnQgaXMgYWx3YXlzIDEuMFxuICAgIGluc3RhbmNlTm9ybWFscyk7XG5cbiAgLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHQgKiBpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__point_cloud_layer_vertex_glsl__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__point_cloud_layer_vertex_64_glsl__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__ = __webpack_require__(163);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











var DEFAULT_COLOR = [0, 0, 0, 255];

var defaultProps = {
  radiusPixels: 10, //  point radius in pixels
  fp64: false,

  getPosition: function getPosition(x) {
    return x.position;
  },
  getNormal: function getNormal(x) {
    return x.normal;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  },

  lightSettings: {
    lightsPosition: [0, 0, 5000, -1000, 1000, 8000, 5000, -5000, 1000],
    ambientRatio: 0.2,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [1.0, 0.0, 0.8, 0.0, 0.4, 0.0],
    numberOfLights: 3
  }
};

var PointCloudLayer = function (_Layer) {
  _inherits(PointCloudLayer, _Layer);

  function PointCloudLayer() {
    _classCallCheck(this, PointCloudLayer);

    return _possibleConstructorReturn(this, (PointCloudLayer.__proto__ || Object.getPrototypeOf(PointCloudLayer)).apply(this, arguments));
  }

  _createClass(PointCloudLayer, [{
    key: 'getShaders',
    value: function getShaders(id) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["b" /* enable64bitSupport */])(this.props) ? {
        vs: __WEBPACK_IMPORTED_MODULE_5__point_cloud_layer_vertex_64_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__["a" /* default */],
        modules: ['fp64', 'project64', 'lighting'],
        shaderCache: this.context.shaderCache
      } : {
        vs: __WEBPACK_IMPORTED_MODULE_4__point_cloud_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__["a" /* default */],
        modules: ['lighting'],
        shaderCache: this.context.shaderCache
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._getModel(gl) });

      /* eslint-disable max-len */
      this.state.attributeManager.addInstanced({
        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },
        instanceNormals: { size: 3, accessor: 'getNormal', defaultValue: 1, update: this.calculateInstanceNormals },
        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;

        attributeManager.invalidateAll();

        if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__["e" /* COORDINATE_SYSTEM */].LNGLAT) {
          attributeManager.addInstanced({
            instancePositions64xyLow: {
              size: 2,
              accessor: 'getPosition',
              update: this.calculateInstancePositions64xyLow
            }
          });
        } else {
          attributeManager.remove(['instancePositions64xyLow']);
        }
      }
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(PointCloudLayer.prototype.__proto__ || Object.getPrototypeOf(PointCloudLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        this.setState({ model: this._getModel(gl) });
      }
      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });
    }
  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var _props = this.props,
          radiusPixels = _props.radiusPixels,
          lightSettings = _props.lightSettings;

      this.state.model.render(Object.assign({}, uniforms, {
        radiusPixels: radiusPixels
      }, lightSettings));
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      // a triangle that minimally cover the unit circle
      var positions = [];
      for (var i = 0; i < 3; i++) {
        var angle = i / 3 * Math.PI * 2;
        positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
      }

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLES,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getPosition = _props2.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;

          var position = getPosition(point);
          value[i++] = position[0];
          value[i++] = position[1];
          value[i++] = position[2] || 0;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstancePositions64xyLow',
    value: function calculateInstancePositions64xyLow(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getPosition = _props3.getPosition;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;

          var position = getPosition(point);
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[0])[1];
          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(position[1])[1];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceNormals',
    value: function calculateInstanceNormals(attribute) {
      var _props4 = this.props,
          data = _props4.data,
          getNormal = _props4.getNormal;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var point = _step3.value;

          var normal = getNormal(point);
          value[i++] = normal[0];
          value[i++] = normal[1];
          value[i++] = normal[2];
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props5 = this.props,
          data = _props5.data,
          getColor = _props5.getColor;
      var value = attribute.value;

      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var point = _step4.value;

          var color = getColor(point);
          value[i++] = color[0];
          value[i++] = color[1];
          value[i++] = color[2];
          value[i++] = isNaN(color[3]) ? 255 : color[3];
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);

  return PointCloudLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (PointCloudLayer);


PointCloudLayer.layerName = 'PointCloudLayer';
PointCloudLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImFzc2VtYmxlU2hhZGVycyIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsImZwNjRpZnkiLCJlbmFibGU2NGJpdFN1cHBvcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsInBvaW50Q2xvdWRWZXJ0ZXgiLCJwb2ludENsb3VkVmVydGV4NjQiLCJwb2ludENsb3VkRnJhZ21lbnQiLCJERUZBVUxUX0NPTE9SIiwiZGVmYXVsdFByb3BzIiwicmFkaXVzUGl4ZWxzIiwiZnA2NCIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZ2V0Tm9ybWFsIiwibm9ybWFsIiwiZ2V0Q29sb3IiLCJjb2xvciIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiUG9pbnRDbG91ZExheWVyIiwiaWQiLCJwcm9wcyIsInZzIiwiZnMiLCJtb2R1bGVzIiwic2hhZGVyQ2FjaGUiLCJjb250ZXh0IiwiZ2wiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiX2dldE1vZGVsIiwic3RhdGUiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQb3NpdGlvbnMiLCJzaXplIiwiYWNjZXNzb3IiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyIsImluc3RhbmNlTm9ybWFscyIsImRlZmF1bHRWYWx1ZSIsImNhbGN1bGF0ZUluc3RhbmNlTm9ybWFscyIsImluc3RhbmNlQ29sb3JzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJpbnZhbGlkYXRlQWxsIiwicHJvamVjdGlvbk1vZGUiLCJMTkdMQVQiLCJpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3ciLCJjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3ciLCJyZW1vdmUiLCJ1cGRhdGVBdHRyaWJ1dGUiLCJ1bmlmb3JtcyIsInJlbmRlciIsIk9iamVjdCIsImFzc2lnbiIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwicG9zaXRpb25zIiwiaSIsImFuZ2xlIiwiTWF0aCIsIlBJIiwicHVzaCIsImNvcyIsInNpbiIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJGbG9hdDMyQXJyYXkiLCJpc0luc3RhbmNlZCIsImF0dHJpYnV0ZSIsImRhdGEiLCJ2YWx1ZSIsInBvaW50IiwiaXNOYU4iLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDO0FBQ0EsU0FBUUMsT0FBUixFQUFpQkMsa0JBQWpCLFFBQTBDLHlCQUExQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGNBQWhDOztBQUVBLE9BQU9DLGdCQUFQLE1BQTZCLGlDQUE3QjtBQUNBLE9BQU9DLGtCQUFQLE1BQStCLG9DQUEvQjtBQUNBLE9BQU9DLGtCQUFQLE1BQStCLG1DQUEvQjs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQXRCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLGdCQUFjLEVBREssRUFDQTtBQUNuQkMsUUFBTSxLQUZhOztBQUluQkMsZUFBYTtBQUFBLFdBQUtDLEVBQUVDLFFBQVA7QUFBQSxH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QURvQjtBQUFBLFVBRTFCa0UsS0FGMEIsR0FFakJGLFNBRmlCLENBRTFCRSxLQUYwQjs7QUFHakMsVUFBSWQsSUFBSSxDQUFSO0FBSGlDO0FBQUE7QUFBQTs7QUFBQTtBQUlqQyw4QkFBb0JhLElBQXBCLG1JQUEwQjtBQUFBLGNBQWZFLEtBQWU7O0FBQ3hCLGNBQU1sRSxRQUFRRCxTQUFTbUUsS0FBVCxDQUFkO0FBQ0FELGdCQUFNZCxHQUFOLElBQWFuRCxNQUFNLENBQU4sQ0FBYjtBQUNBaUUsZ0JBQU1kLEdBQU4sSUFBYW5ELE1BQU0sQ0FBTixDQUFiO0FBQ0FpRSxnQkFBTWQsR0FBTixJQUFhbkQsTUFBTSxDQUFOLENBQWI7QUFDQWlFLGdCQUFNZCxHQUFOLElBQWFnQixNQUFNbkUsTUFBTSxDQUFOLENBQU4sSUFBa0IsR0FBbEIsR0FBd0JBLE1BQU0sQ0FBTixDQUFyQztBQUNEO0FBVmdDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXbEM7Ozs7RUEzSTBDckIsSzs7ZUFBeEI2QixlOzs7QUE4SXJCQSxnQkFBZ0I0RCxTQUFoQixHQUE0QixpQkFBNUI7QUFDQTVELGdCQUFnQmpCLFlBQWhCLEdBQStCQSxZQUEvQiIsImZpbGUiOiJwb2ludC1jbG91ZC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmcDY0aWZ5LCBlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbmltcG9ydCBwb2ludENsb3VkVmVydGV4IGZyb20gJy4vcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHBvaW50Q2xvdWRWZXJ0ZXg2NCBmcm9tICcuL3BvaW50LWNsb3VkLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBwb2ludENsb3VkRnJhZ21lbnQgZnJvbSAnLi9wb2ludC1jbG91ZC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHJhZGl1c1BpeGVsczogMTAsICAvLyAgcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICBmcDY0OiBmYWxzZSxcblxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBnZXROb3JtYWw6IHggPT4geC5ub3JtYWwsXG4gIGdldENvbG9yOiB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUixcblxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFswLCAwLCA1MDAwLCAtMTAwMCwgMTAwMCwgODAwMCwgNTAwMCwgLTUwMDAsIDEwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4yLFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMCwgMC4wLCAwLjgsIDAuMCwgMC40LCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAzXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50Q2xvdWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycyhpZCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogcG9pbnRDbG91ZFZlcnRleDY0LFxuICAgICAgZnM6IHBvaW50Q2xvdWRGcmFnbWVudCxcbiAgICAgIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnLCAnbGlnaHRpbmcnXSxcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICB9IDoge1xuICAgICAgdnM6IHBvaW50Q2xvdWRWZXJ0ZXgsXG4gICAgICBmczogcG9pbnRDbG91ZEZyYWdtZW50LFxuICAgICAgbW9kdWxlczogWydsaWdodGluZyddLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge3NpemU6IDMsIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VOb3JtYWxzOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXROb3JtYWwnLCBkZWZhdWx0VmFsdWU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZU5vcm1hbHN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3JhZGl1c1BpeGVscywgbGlnaHRTZXR0aW5nc30gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICByYWRpdXNQaXhlbHNcbiAgICB9LCBsaWdodFNldHRpbmdzKSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAvLyBhIHRyaWFuZ2xlIHRoYXQgbWluaW1hbGx5IGNvdmVyIHRoZSB1bml0IGNpcmNsZVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgLyAzICogTWF0aC5QSSAqIDI7XG4gICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgTWF0aC5jb3MoYW5nbGUpICogMixcbiAgICAgICAgTWF0aC5zaW4oYW5nbGUpICogMixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRVMsXG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzJdIHx8IDA7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShwb3NpdGlvblswXSlbMV07XG4gICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShwb3NpdGlvblsxXSlbMV07XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VOb3JtYWxzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXROb3JtYWx9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IG5vcm1hbCA9IGdldE5vcm1hbChwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gbm9ybWFsWzBdO1xuICAgICAgdmFsdWVbaSsrXSA9IG5vcm1hbFsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBub3JtYWxbMl07XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2krK10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICB9XG4gIH1cbn1cblxuUG9pbnRDbG91ZExheWVyLmxheWVyTmFtZSA9ICdQb2ludENsb3VkTGF5ZXInO1xuUG9pbnRDbG91ZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_polygon__ = __webpack_require__(42);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.






var defaultLineColor = [0x0, 0x0, 0x0, 0xFF];
var defaultFillColor = [0x0, 0x0, 0x0, 0xFF];

var defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,

  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  fp64: false,

  getPolygon: function getPolygon(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'polygon');
  },
  // Polygon fill color
  getFillColor: function getFillColor(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'fillColor') || defaultFillColor;
  },
  // Point, line and polygon outline color
  getLineColor: function getLineColor(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'lineColor') || defaultLineColor;
  },
  // Line and polygon outline accessors
  getLineWidth: function getLineWidth(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'lineWidth') || 1;
  },
  // Polygon extrusion accessor
  getElevation: function getElevation(f) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__["f" /* get */])(f, 'elevation') || 1000;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var PolygonLayer = function (_CompositeLayer) {
  _inherits(PolygonLayer, _CompositeLayer);

  function PolygonLayer() {
    _classCallCheck(this, PolygonLayer);

    return _possibleConstructorReturn(this, (PolygonLayer.__proto__ || Object.getPrototypeOf(PolygonLayer)).apply(this, arguments));
  }

  _createClass(PolygonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        paths: []
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var _this2 = this;

      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged) {
        var _props = this.props,
            data = _props.data,
            getPolygon = _props.getPolygon;

        this.state.paths = [];
        data.forEach(function (object) {
          var complexPolygon = __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_polygon__["a" /* normalize */](getPolygon(object));
          complexPolygon.forEach(function (polygon) {
            return _this2.state.paths.push({
              path: polygon,
              object: object
            });
          });
        });
      }
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;

      return Object.assign(info, {
        // override object with picked data
        object: info.object && info.object.object || info.object
      });
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      // Layer composition props
      var _props2 = this.props,
          data = _props2.data,
          id = _props2.id,
          stroked = _props2.stroked,
          filled = _props2.filled,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;

      // Rendering props underlying layer

      var _props3 = this.props,
          lineWidthScale = _props3.lineWidthScale,
          lineWidthMinPixels = _props3.lineWidthMinPixels,
          lineWidthMaxPixels = _props3.lineWidthMaxPixels,
          lineJointRounded = _props3.lineJointRounded,
          lineMiterLimit = _props3.lineMiterLimit,
          fp64 = _props3.fp64;

      // Accessor props for underlying layers

      var _props4 = this.props,
          getFillColor = _props4.getFillColor,
          getLineColor = _props4.getLineColor,
          getLineWidth = _props4.getLineWidth,
          getElevation = _props4.getElevation,
          getPolygon = _props4.getPolygon,
          updateTriggers = _props4.updateTriggers,
          lightSettings = _props4.lightSettings;

      // base layer props

      var _props5 = this.props,
          opacity = _props5.opacity,
          pickable = _props5.pickable,
          visible = _props5.visible,
          getPolygonOffset = _props5.getPolygonOffset;

      // viewport props

      var _props6 = this.props,
          positionOrigin = _props6.positionOrigin,
          projectionMode = _props6.projectionMode,
          modelMatrix = _props6.modelMatrix;
      var paths = this.state.paths;


      var hasData = data && data.length > 0;

      // Filled Polygon Layer
      var polygonLayer = filled && hasData && new __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__["a" /* default */]({
        id: id + '-fill',
        data: data,
        extruded: extruded,
        wireframe: false,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPolygon: getPolygon,
        getElevation: getElevation,
        getColor: getFillColor,
        updateTriggers: {
          getElevation: updateTriggers.getElevation,
          getColor: updateTriggers.getFillColor
        },
        lightSettings: lightSettings
      });

      var polygonWireframeLayer = extruded && wireframe && hasData && new __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__["a" /* default */]({
        id: id + '-wireframe',
        data: data,
        extruded: true,
        wireframe: true,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPolygon: getPolygon,
        getElevation: getElevation,
        getColor: getLineColor,
        updateTriggers: {
          getElevation: updateTriggers.getElevation,
          getColor: updateTriggers.getLineColor
        }
      });

      // Polygon line layer
      var polygonLineLayer = !extruded && stroked && hasData && new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__["a" /* default */]({
        id: id + '-stroke',
        data: paths,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getPath: function getPath(x) {
          return x.path;
        },
        getColor: getLineColor,
        getWidth: getLineWidth,
        updateTriggers: {
          getWidth: updateTriggers.getLineWidth,
          getColor: updateTriggers.getLineColor
        }
      });

      return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer, polygonWireframeLayer, polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer].filter(Boolean);
    }
  }]);

  return PolygonLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["b" /* CompositeLayer */]);

/* harmony default export */ __webpack_exports__["a"] = (PolygonLayer);


PolygonLayer.layerName = 'PolygonLayer';
PolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJnZXQiLCJTb2xpZFBvbHlnb25MYXllciIsIlBhdGhMYXllciIsIlBvbHlnb24iLCJkZWZhdWx0TGluZUNvbG9yIiwiZGVmYXVsdEZpbGxDb2xvciIsImRlZmF1bHRQcm9wcyIsInN0cm9rZWQiLCJmaWxsZWQiLCJleHRydWRlZCIsIndpcmVmcmFtZSIsImxpbmVXaWR0aFNjYWxlIiwibGluZVdpZHRoTWluUGl4ZWxzIiwibGluZVdpZHRoTWF4UGl4ZWxzIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImxpbmVKb2ludFJvdW5kZWQiLCJsaW5lTWl0ZXJMaW1pdCIsImZwNjQiLCJnZXRQb2x5Z29uIiwiZiIsImdldEZpbGxDb2xvciIsImdldExpbmVDb2xvciIsImdldExpbmVXaWR0aCIsImdldEVsZXZhdGlvbiIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiUG9seWdvbkxheWVyIiwic3RhdGUiLCJwYXRocyIsIm9sZFByb3BzIiwicHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiZGF0YSIsImZvckVhY2giLCJjb21wbGV4UG9seWdvbiIsIm5vcm1hbGl6ZSIsIm9iamVjdCIsInB1c2giLCJwYXRoIiwicG9seWdvbiIsImluZm8iLCJPYmplY3QiLCJhc3NpZ24iLCJpZCIsInVwZGF0ZVRyaWdnZXJzIiwib3BhY2l0eSIsInBpY2thYmxlIiwidmlzaWJsZSIsImdldFBvbHlnb25PZmZzZXQiLCJwb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25Nb2RlIiwibW9kZWxNYXRyaXgiLCJoYXNEYXRhIiwibGVuZ3RoIiwicG9seWdvbkxheWVyIiwiZ2V0Q29sb3IiLCJwb2x5Z29uV2lyZWZyYW1lTGF5ZXIiLCJwb2x5Z29uTGluZUxheWVyIiwid2lkdGhTY2FsZSIsIndpZHRoTWluUGl4ZWxzIiwid2lkdGhNYXhQaXhlbHMiLCJyb3VuZGVkIiwibWl0ZXJMaW1pdCIsImdldFBhdGgiLCJ4IiwiZ2V0V2lkdGgiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGF5ZXJOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLGNBQVIsRUFBd0JDLEdBQXhCLFFBQWtDLGNBQWxDO0FBQ0EsT0FBT0MsaUJBQVAsTUFBOEIsNENBQTlCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQiwwQkFBdEI7QUFDQSxPQUFPLEtBQUtDLE9BQVosTUFBeUIsZ0NBQXpCOztBQUVBLElBQU1DLG1CQUFtQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixJQUFoQixDQUF6QjtBQUNBLElBQU1DLG1CQUFtQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixJQUFoQixDQUF6Qjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxXQUFTLElBRFU7QUFFbkJDLFVBQVEsSUFGVztBQUduQkMsWUFBVSxLQUhTO0FBSW5CQyxhQUFXLEtBSlE7O0FBTW5CQyxrQkFBZ0IsQ0FORztBQU9uQkMsc0JBQW9CLENBUEQ7QUFRbkJDLHNCQUFvQkMsT0FBT0MsZ0JBUlI7QUFTbkJDLG9CQUFrQixLQVRDO0FBVW5CQyxrQkFBZ0IsQ0FWRztBQVduQkMsUUFBTSxLQVhhOztBQWFuQkMsY0FBWTtBQUFBLFdBQUtuQixJQUFJb0IsQ0FBSixFQUFPLFNBQVAsQ0FBTDtBQUFBLEdBYk87QUFjbkI7QUFDQUMsZ0JBQWM7QUFBQSxXQUFLckIsSUFBSW9CLENBQUosRUFBTyxXQUFQLEtBQXVC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LGFBQU87QUFDTDtBQUNBLE9BQUNiLFFBQUQsSUFBYW9ELFlBRlIsRUFHTEUscUJBSEssRUFJTEMsZ0JBSks7QUFLTDtBQUNBdkQsa0JBQVlvRCxZQU5QLEVBT0xZLE1BUEssQ0FPRUMsT0FQRixDQUFQO0FBUUQ7Ozs7RUF4SXVDM0UsYzs7ZUFBckJpQyxZOzs7QUEySXJCQSxhQUFhMkMsU0FBYixHQUF5QixjQUF6QjtBQUNBM0MsYUFBYTFCLFlBQWIsR0FBNEJBLFlBQTVCIiwiZmlsZSI6InBvbHlnb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllciwgZ2V0fSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IFNvbGlkUG9seWdvbkxheWVyIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllcic7XG5pbXBvcnQgUGF0aExheWVyIGZyb20gJy4uL3BhdGgtbGF5ZXIvcGF0aC1sYXllcic7XG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbic7XG5cbmNvbnN0IGRlZmF1bHRMaW5lQ29sb3IgPSBbMHgwLCAweDAsIDB4MCwgMHhGRl07XG5jb25zdCBkZWZhdWx0RmlsbENvbG9yID0gWzB4MCwgMHgwLCAweDAsIDB4RkZdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHN0cm9rZWQ6IHRydWUsXG4gIGZpbGxlZDogdHJ1ZSxcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICB3aXJlZnJhbWU6IGZhbHNlLFxuXG4gIGxpbmVXaWR0aFNjYWxlOiAxLFxuICBsaW5lV2lkdGhNaW5QaXhlbHM6IDAsXG4gIGxpbmVXaWR0aE1heFBpeGVsczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIGxpbmVKb2ludFJvdW5kZWQ6IGZhbHNlLFxuICBsaW5lTWl0ZXJMaW1pdDogNCxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0UG9seWdvbjogZiA9PiBnZXQoZiwgJ3BvbHlnb24nKSxcbiAgLy8gUG9seWdvbiBmaWxsIGNvbG9yXG4gIGdldEZpbGxDb2xvcjogZiA9PiBnZXQoZiwgJ2ZpbGxDb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3IsXG4gIC8vIFBvaW50LCBsaW5lIGFuZCBwb2x5Z29uIG91dGxpbmUgY29sb3JcbiAgZ2V0TGluZUNvbG9yOiBmID0+IGdldChmLCAnbGluZUNvbG9yJykgfHwgZGVmYXVsdExpbmVDb2xvcixcbiAgLy8gTGluZSBhbmQgcG9seWdvbiBvdXRsaW5lIGFjY2Vzc29yc1xuICBnZXRMaW5lV2lkdGg6IGYgPT4gZ2V0KGYsICdsaW5lV2lkdGgnKSB8fCAxLFxuICAvLyBQb2x5Z29uIGV4dHJ1c2lvbiBhY2Nlc3NvclxuICBnZXRFbGV2YXRpb246IGYgPT4gZ2V0KGYsICdlbGV2YXRpb24nKSB8fCAxMDAwLFxuXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25MYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBwYXRoczogW11cbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICBjb25zdCB7ZGF0YSwgZ2V0UG9seWdvbn0gPSB0aGlzLnByb3BzO1xuICAgICAgdGhpcy5zdGF0ZS5wYXRocyA9IFtdO1xuICAgICAgZGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXhQb2x5Z29uID0gUG9seWdvbi5ub3JtYWxpemUoZ2V0UG9seWdvbihvYmplY3QpKTtcbiAgICAgICAgY29tcGxleFBvbHlnb24uZm9yRWFjaChwb2x5Z29uID0+IHRoaXMuc3RhdGUucGF0aHMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcG9seWdvbixcbiAgICAgICAgICBvYmplY3RcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8oe2luZm99KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGRhdGFcbiAgICAgIG9iamVjdDogKGluZm8ub2JqZWN0ICYmIGluZm8ub2JqZWN0Lm9iamVjdCkgfHwgaW5mby5vYmplY3RcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICAvLyBMYXllciBjb21wb3NpdGlvbiBwcm9wc1xuICAgIGNvbnN0IHtkYXRhLCBpZCwgc3Ryb2tlZCwgZmlsbGVkLCBleHRydWRlZCwgd2lyZWZyYW1lfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBSZW5kZXJpbmcgcHJvcHMgdW5kZXJseWluZyBsYXllclxuICAgIGNvbnN0IHtsaW5lV2lkdGhTY2FsZSwgbGluZVdpZHRoTWluUGl4ZWxzLCBsaW5lV2lkdGhNYXhQaXhlbHMsXG4gICAgICBsaW5lSm9pbnRSb3VuZGVkLCBsaW5lTWl0ZXJMaW1pdCwgZnA2NH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQWNjZXNzb3IgcHJvcHMgZm9yIHVuZGVybHlpbmcgbGF5ZXJzXG4gICAgY29uc3Qge2dldEZpbGxDb2xvciwgZ2V0TGluZUNvbG9yLCBnZXRMaW5lV2lkdGgsIGdldEVsZXZhdGlvbixcbiAgICAgIGdldFBvbHlnb24sIHVwZGF0ZVRyaWdnZXJzLCBsaWdodFNldHRpbmdzfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBiYXNlIGxheWVyIHByb3BzXG4gICAgY29uc3Qge29wYWNpdHksIHBpY2thYmxlLCB2aXNpYmxlLCBnZXRQb2x5Z29uT2Zmc2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB2aWV3cG9ydCBwcm9wc1xuICAgIGNvbnN0IHtwb3NpdGlvbk9yaWdpbiwgcHJvamVjdGlvbk1vZGUsIG1vZGVsTWF0cml4fSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICYmIGRhdGEubGVuZ3RoID4gMDtcblxuICAgIC8vIEZpbGxlZCBQb2x5Z29uIExheWVyXG4gICAgY29uc3QgcG9seWdvbkxheWVyID0gZmlsbGVkICYmIGhhc0RhdGEgJiYgbmV3IFNvbGlkUG9seWdvbkxheWVyKHtcbiAgICAgIGlkOiBgJHtpZH0tZmlsbGAsXG4gICAgICBkYXRhLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgZnA2NCxcbiAgICAgIG9wYWNpdHksXG4gICAgICBwaWNrYWJsZSxcbiAgICAgIHZpc2libGUsXG4gICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgcHJvamVjdGlvbk1vZGUsXG4gICAgICBwb3NpdGlvbk9yaWdpbixcbiAgICAgIG1vZGVsTWF0cml4LFxuICAgICAgZ2V0UG9seWdvbixcbiAgICAgIGdldEVsZXZhdGlvbixcbiAgICAgIGdldENvbG9yOiBnZXRGaWxsQ29sb3IsXG4gICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICBnZXRFbGV2YXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldEZpbGxDb2xvclxuICAgICAgfSxcbiAgICAgIGxpZ2h0U2V0dGluZ3NcbiAgICB9KTtcblxuICAgIGNvbnN0IHBvbHlnb25XaXJlZnJhbWVMYXllciA9IGV4dHJ1ZGVkICYmXG4gICAgICB3aXJlZnJhbWUgJiZcbiAgICAgIGhhc0RhdGEgJiZcbiAgICAgIG5ldyBTb2xpZFBvbHlnb25MYXllcih7XG4gICAgICAgIGlkOiBgJHtpZH0td2lyZWZyYW1lYCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZXh0cnVkZWQ6IHRydWUsXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgZnA2NCxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGlja2FibGUsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIGdldFBvbHlnb25PZmZzZXQsXG4gICAgICAgIHByb2plY3Rpb25Nb2RlLFxuICAgICAgICBwb3NpdGlvbk9yaWdpbixcbiAgICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICAgIGdldFBvbHlnb24sXG4gICAgICAgIGdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0Q29sb3I6IGdldExpbmVDb2xvcixcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldEVsZXZhdGlvbixcbiAgICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZUNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gUG9seWdvbiBsaW5lIGxheWVyXG4gICAgY29uc3QgcG9seWdvbkxpbmVMYXllciA9ICFleHRydWRlZCAmJlxuICAgICAgc3Ryb2tlZCAmJlxuICAgICAgaGFzRGF0YSAmJlxuICAgICAgbmV3IFBhdGhMYXllcih7XG4gICAgICAgIGlkOiBgJHtpZH0tc3Ryb2tlYCxcbiAgICAgICAgZGF0YTogcGF0aHMsXG4gICAgICAgIHdpZHRoU2NhbGU6IGxpbmVXaWR0aFNjYWxlLFxuICAgICAgICB3aWR0aE1pblBpeGVsczogbGluZVdpZHRoTWluUGl4ZWxzLFxuICAgICAgICB3aWR0aE1heFBpeGVsczogbGluZVdpZHRoTWF4UGl4ZWxzLFxuICAgICAgICByb3VuZGVkOiBsaW5lSm9pbnRSb3VuZGVkLFxuICAgICAgICBtaXRlckxpbWl0OiBsaW5lTWl0ZXJMaW1pdCxcbiAgICAgICAgZnA2NCxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGlja2FibGUsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIGdldFBvbHlnb25PZmZzZXQsXG4gICAgICAgIHByb2plY3Rpb25Nb2RlLFxuICAgICAgICBwb3NpdGlvbk9yaWdpbixcbiAgICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICAgIGdldFBhdGg6IHggPT4geC5wYXRoLFxuICAgICAgICBnZXRDb2xvcjogZ2V0TGluZUNvbG9yLFxuICAgICAgICBnZXRXaWR0aDogZ2V0TGluZVdpZHRoLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldFdpZHRoOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lV2lkdGgsXG4gICAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldExpbmVDb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAvLyBJZiBub3QgZXh0cnVkZWQ6IGZsYXQgZmlsbCBsYXllciBpcyBkcmF3biBiZWxvdyBvdXRsaW5lc1xuICAgICAgIWV4dHJ1ZGVkICYmIHBvbHlnb25MYXllcixcbiAgICAgIHBvbHlnb25XaXJlZnJhbWVMYXllcixcbiAgICAgIHBvbHlnb25MaW5lTGF5ZXIsXG4gICAgICAvLyBJZiBleHRydWRlZDogZHJhdyBmaWxsIGxheWVyIGxhc3QgZm9yIGNvcnJlY3QgYmxlbmRpbmcgYmVoYXZpb3JcbiAgICAgIGV4dHJ1ZGVkICYmIHBvbHlnb25MYXllclxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICB9XG59XG5cblBvbHlnb25MYXllci5sYXllck5hbWUgPSAnUG9seWdvbkxheWVyJztcblBvbHlnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME scatterplot-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter <= 1.0 && distToCenter >= innerUnitRadius) {\n    gl_FragColor = vColor;\n  } else {\n    discard;\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InNjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHNjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50LXNoYWRlclxuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcbnZhcnlpbmcgZmxvYXQgaW5uZXJVbml0UmFkaXVzO1xuXG52b2lkIG1haW4odm9pZCkge1xuXG4gIGZsb2F0IGRpc3RUb0NlbnRlciA9IGxlbmd0aCh1bml0UG9zaXRpb24pO1xuXG4gIGlmIChkaXN0VG9DZW50ZXIgPD0gMS4wICYmIGRpc3RUb0NlbnRlciA+PSBpbm5lclVuaXRSYWRpdXMpIHtcbiAgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG4gIH0gZWxzZSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcbiJdfQ==

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME scatterplot-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceRadius;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Only one-dimensional arrays may be declared in GLSL ES 1.0. specs p.24\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float renderPickingBuffer;\nuniform float outline;\nuniform float strokeWidth;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  // Multiply out radius and clamp to limits\n  float outerRadiusPixels = clamp(\n    project_scale(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n\n  // outline is centered at the radius\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += outline * strokeWidth / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  // 0 - solid circle, 1 - stroke with lineWidth=0\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(positions * outerRadiusPixels, 0.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2],\n    vec2(project_scale(instancePositions.z), 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  if (renderPickingBuffer > 0.5) {\n    vColor = vec4(instancePickingColors / 255., 1.);\n  } else {\n    vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  }\n  // // Apply opacity to instance color, or return instance picking color\n  // vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  // vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  // vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LXNoYWRlci02NFxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbi8vIE9ubHkgb25lLWRpbWVuc2lvbmFsIGFycmF5cyBtYXkgYmUgZGVjbGFyZWQgaW4gR0xTTCBFUyAxLjAuIHNwZWNzIHAuMjRcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSBmbG9hdCBvdXRsaW5lO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gTXVsdGlwbHkgb3V0IHJhZGl1cyBhbmQgY2xhbXAgdG8gbGltaXRzXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXG4gICAgcHJvamVjdF9zY2FsZShyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xuICApO1xuXG4gIC8vIG91dGxpbmUgaXMgY2VudGVyZWQgYXQgdGhlIHJhZGl1c1xuICAvLyBvdXRlciByYWRpdXMgbmVlZHMgdG8gb2Zmc2V0IGJ5IGhhbGYgc3Ryb2tlIHdpZHRoXG4gIG91dGVyUmFkaXVzUGl4ZWxzICs9IG91dGxpbmUgKiBzdHJva2VXaWR0aCAvIDIuMDtcblxuICAvLyBwb3NpdGlvbiBvbiB0aGUgY29udGFpbmluZyBzcXVhcmUgaW4gWy0xLCAxXSBzcGFjZVxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XG4gIC8vIDAgLSBzb2xpZCBjaXJjbGUsIDEgLSBzdHJva2Ugd2l0aCBsaW5lV2lkdGg9MFxuICBpbm5lclVuaXRSYWRpdXMgPSBvdXRsaW5lICogKDEuMCAtIHN0cm9rZVdpZHRoIC8gb3V0ZXJSYWRpdXNQaXhlbHMpO1xuXG4gIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM2NHh5ID0gdmVjNChcbiAgICBpbnN0YW5jZVBvc2l0aW9ucy54LCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueCxcbiAgICBpbnN0YW5jZVBvc2l0aW9ucy55LCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueSk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfY29vcmRfeHlbMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVBvc2l0aW9uczY0eHksIHByb2plY3RlZF9jb29yZF94eSk7XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbNF07XG4gIHZlYzRfZnA2NCh2ZWM0KHBvc2l0aW9ucyAqIG91dGVyUmFkaXVzUGl4ZWxzLCAwLjApLCB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2UpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMF0sIHByb2plY3RlZF9jb29yZF94eVswXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVsxXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzFdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLFxuICAgIHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy56KSwgMC4wKSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyID4gMC41KSB7XG4gICAgdkNvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIH0gZWxzZSB7XG4gICAgdkNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIH1cbiAgLy8gLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgLy8gdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICAvLyB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xuICAvLyB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XG59XG5gO1xuIl19

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute float instanceRadius;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float renderPickingBuffer;\nuniform float outline;\nuniform float strokeWidth;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  // Multiply out radius and clamp to limits\n  float outerRadiusPixels = clamp(\n    project_scale(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  // outline is centered at the radius\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += outline * strokeWidth / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  // 0 - solid circle, 1 - stroke with lineWidth=0\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\n\n  // Find the center of the point and add the current vertex\n  vec3 center = project_position(instancePositions);\n  vec3 vertex = positions * outerRadiusPixels;\n  gl_Position = project_to_clipspace(vec4(center + vertex, 1.0));\n\n  // Apply opacity to instance color, or return instance picking color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXguZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzY2F0dGVycGxvdC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSBmbG9hdCBvdXRsaW5lO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gTXVsdGlwbHkgb3V0IHJhZGl1cyBhbmQgY2xhbXAgdG8gbGltaXRzXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXG4gICAgcHJvamVjdF9zY2FsZShyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xuICApO1xuICAvLyBvdXRsaW5lIGlzIGNlbnRlcmVkIGF0IHRoZSByYWRpdXNcbiAgLy8gb3V0ZXIgcmFkaXVzIG5lZWRzIHRvIG9mZnNldCBieSBoYWxmIHN0cm9rZSB3aWR0aFxuICBvdXRlclJhZGl1c1BpeGVscyArPSBvdXRsaW5lICogc3Ryb2tlV2lkdGggLyAyLjA7XG5cbiAgLy8gcG9zaXRpb24gb24gdGhlIGNvbnRhaW5pbmcgc3F1YXJlIGluIFstMSwgMV0gc3BhY2VcbiAgdW5pdFBvc2l0aW9uID0gcG9zaXRpb25zLnh5O1xuICAvLyAwIC0gc29saWQgY2lyY2xlLCAxIC0gc3Ryb2tlIHdpdGggbGluZVdpZHRoPTBcbiAgaW5uZXJVbml0UmFkaXVzID0gb3V0bGluZSAqICgxLjAgLSBzdHJva2VXaWR0aCAvIG91dGVyUmFkaXVzUGl4ZWxzKTtcblxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XG4gIHZlYzMgY2VudGVyID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucyk7XG4gIHZlYzMgdmVydGV4ID0gcG9zaXRpb25zICogb3V0ZXJSYWRpdXNQaXhlbHM7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNChjZW50ZXIgKyB2ZXJ0ZXgsIDEuMCkpO1xuXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gaW5zdGFuY2UgY29sb3IsIG9yIHJldHVybiBpbnN0YW5jZSBwaWNraW5nIGNvbG9yXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* fragment shader for the grid-layer */
/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME screen-grid-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY3JlZW4tZ3JpZC1sYXllci9zY3JlZW4tZ3JpZC1sYXllci1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoic2NyZWVuLWdyaWQtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBmcmFnbWVudCBzaGFkZXIgZm9yIHRoZSBncmlkLWxheWVyICovXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NyZWVuLWdyaWQtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcbn1cbmA7XG4iXX0=

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME screen-grid-layer-vertex-shader\n\nattribute vec3 vertices;\nattribute vec3 instancePositions;\nattribute float instanceCount;\nattribute vec3 instancePickingColors;\n\nuniform float maxCount;\nuniform float opacity;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform float renderPickingBuffer;\nuniform vec3 cellScale;\nuniform vec3 selectedPickingColor;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 color = mix(minColor, maxColor, instanceCount / maxCount) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n\n  gl_Position = vec4(instancePositions + vertices * cellScale, 1.);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY3JlZW4tZ3JpZC1sYXllci9zY3JlZW4tZ3JpZC1sYXllci12ZXJ0ZXguZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzY3JlZW4tZ3JpZC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NyZWVuLWdyaWQtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0aWNlcztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ291bnQ7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgbWF4Q291bnQ7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIHZlYzQgbWluQ29sb3I7XG51bmlmb3JtIHZlYzQgbWF4Q29sb3I7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgY2VsbFNjYWxlO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IGNvbG9yID0gbWl4KG1pbkNvbG9yLCBtYXhDb2xvciwgaW5zdGFuY2VDb3VudCAvIG1heENvdW50KSAvIDI1NS47XG5cbiAgdkNvbG9yID0gbWl4KFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxuICApO1xuXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChpbnN0YW5jZVBvc2l0aW9ucyArIHZlcnRpY2VzICogY2VsbFNjYWxlLCAxLik7XG59XG5gO1xuIl19

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__screen_grid_layer_vertex_glsl__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__screen_grid_layer_fragment_glsl__ = __webpack_require__(171);
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.








var defaultProps = {
  cellSizePixels: 100,

  // Color range?
  minColor: [0, 0, 0, 255],
  maxColor: [0, 255, 0, 255],

  getPosition: function getPosition(d) {
    return d.position;
  },
  getWeight: function getWeight(d) {
    return 1;
  }
};

var ScreenGridLayer = function (_Layer) {
  _inherits(ScreenGridLayer, _Layer);

  _createClass(ScreenGridLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: __WEBPACK_IMPORTED_MODULE_3__screen_grid_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_4__screen_grid_layer_fragment_glsl__["a" /* default */],
        modules: [],
        shaderCache: this.context.shaderCache
      };
    }
  }]);

  function ScreenGridLayer(props) {
    _classCallCheck(this, ScreenGridLayer);

    var _this = _possibleConstructorReturn(this, (ScreenGridLayer.__proto__ || Object.getPrototypeOf(ScreenGridLayer)).call(this, props));

    _this._checkRemovedProp('unitWidth', 'cellSizePixels');
    _this._checkRemovedProp('unitHeight', 'cellSizePixels');
    return _this;
  }

  _createClass(ScreenGridLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var attributeManager = this.state.attributeManager;
      var gl = this.context.gl;

      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 3, update: this.calculateInstancePositions },
        instanceCount: { size: 1, accessor: ['getPosition', 'getWeight'], update: this.calculateInstanceCount }
      });
      /* eslint-disable max-len */

      this.setState({ model: this._getModel(gl) });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      _get(ScreenGridLayer.prototype.__proto__ || Object.getPrototypeOf(ScreenGridLayer.prototype), 'updateState', this).call(this, { props: props, oldProps: oldProps, changeFlags: changeFlags });
      var cellSizeChanged = props.cellSizePixels !== oldProps.cellSizePixels;

      if (cellSizeChanged || changeFlags.viewportChanged) {
        this.updateCell();
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          minColor = _props.minColor,
          maxColor = _props.maxColor;
      var _state = this.state,
          model = _state.model,
          cellScale = _state.cellScale,
          maxCount = _state.maxCount;
      var gl = this.context.gl;

      gl.depthMask(true);
      uniforms = Object.assign({}, uniforms, { minColor: minColor, maxColor: maxColor, cellScale: cellScale, maxCount: maxCount });
      model.render(uniforms);
    }
  }, {
    key: '_getModel',
    value: function _getModel(gl) {
      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__["b" /* Geometry */]({
          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__["c" /* GL */].TRIANGLE_FAN,
          vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])
        }),
        isInstanced: true
      });
    }
  }, {
    key: 'updateCell',
    value: function updateCell() {
      var _context$viewport = this.context.viewport,
          width = _context$viewport.width,
          height = _context$viewport.height;
      var cellSizePixels = this.props.cellSizePixels;


      var MARGIN = 2;
      var cellScale = new Float32Array([(cellSizePixels - MARGIN) / width * 2, -(cellSizePixels - MARGIN) / height * 2, 1]);
      var numCol = Math.ceil(width / cellSizePixels);
      var numRow = Math.ceil(height / cellSizePixels);

      this.setState({
        cellScale: cellScale,
        numCol: numCol,
        numRow: numRow,
        numInstances: numCol * numRow
      });

      var attributeManager = this.state.attributeManager;

      attributeManager.invalidateAll();
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute, _ref3) {
      var numInstances = _ref3.numInstances;
      var _context$viewport2 = this.context.viewport,
          width = _context$viewport2.width,
          height = _context$viewport2.height;
      var cellSizePixels = this.props.cellSizePixels;
      var numCol = this.state.numCol;
      var value = attribute.value,
          size = attribute.size;


      for (var i = 0; i < numInstances; i++) {
        var x = i % numCol;
        var y = Math.floor(i / numCol);
        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;
        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;
        value[i * size + 2] = 0;
      }
    }
  }, {
    key: 'calculateInstanceCount',
    value: function calculateInstanceCount(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          cellSizePixels = _props2.cellSizePixels,
          getPosition = _props2.getPosition,
          getWeight = _props2.getWeight;
      var _state2 = this.state,
          numCol = _state2.numCol,
          numRow = _state2.numRow;
      var value = attribute.value;

      var maxCount = 0;

      value.fill(0.0);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;

          var pixel = this.project(getPosition(point));
          var colId = Math.floor(pixel[0] / cellSizePixels);
          var rowId = Math.floor(pixel[1] / cellSizePixels);
          if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {
            var i = colId + rowId * numCol;
            value[i] += getWeight(point);
            if (value[i] > maxCount) {
              maxCount = value[i];
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setState({ maxCount: maxCount });
    }
  }]);

  return ScreenGridLayer;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (ScreenGridLayer);


ScreenGridLayer.layerName = 'ScreenGridLayer';
ScreenGridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zY3JlZW4tZ3JpZC1sYXllci9zY3JlZW4tZ3JpZC1sYXllci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImFzc2VtYmxlU2hhZGVycyIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsInNjcmVlbkdyaWRWZXJ0ZXgiLCJzY3JlZW5HcmlkRnJhZ21lbnQiLCJkZWZhdWx0UHJvcHMiLCJjZWxsU2l6ZVBpeGVscyIsIm1pbkNvbG9yIiwibWF4Q29sb3IiLCJnZXRQb3NpdGlvbiIsImQiLCJwb3NpdGlvbiIsImdldFdlaWdodCIsIlNjcmVlbkdyaWRMYXllciIsInZzIiwiZnMiLCJtb2R1bGVzIiwic2hhZGVyQ2FjaGUiLCJjb250ZXh0IiwicHJvcHMiLCJfY2hlY2tSZW1vdmVkUHJvcCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImdsIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQb3NpdGlvbnMiLCJzaXplIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMiLCJpbnN0YW5jZUNvdW50IiwiYWNjZXNzb3IiLCJjYWxjdWxhdGVJbnN0YW5jZUNvdW50Iiwic2V0U3RhdGUiLCJtb2RlbCIsIl9nZXRNb2RlbCIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJjZWxsU2l6ZUNoYW5nZWQiLCJ2aWV3cG9ydENoYW5nZWQiLCJ1cGRhdGVDZWxsIiwidW5pZm9ybXMiLCJjZWxsU2NhbGUiLCJtYXhDb3VudCIsImRlcHRoTWFzayIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlciIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwiaWQiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiVFJJQU5HTEVfRkFOIiwidmVydGljZXMiLCJGbG9hdDMyQXJyYXkiLCJpc0luc3RhbmNlZCIsInZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJNQVJHSU4iLCJudW1Db2wiLCJNYXRoIiwiY2VpbCIsIm51bVJvdyIsIm51bUluc3RhbmNlcyIsImludmFsaWRhdGVBbGwiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsImkiLCJ4IiwieSIsImZsb29yIiwiZGF0YSIsImZpbGwiLCJwb2ludCIsInBpeGVsIiwicHJvamVjdCIsImNvbElkIiwicm93SWQiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsU0FBUUMsZUFBUixRQUE4Qix1QkFBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDOztBQUVBLE9BQU9DLGdCQUFQLE1BQTZCLGlDQUE3QjtBQUNBLE9BQU9DLGtCQUFQLE1BQStCLG1DQUEvQjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxrQkFBZ0IsR0FERzs7QUFHbkI7QUFDQUMsWUFBVSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FKUztBQUtuQkMsWUFBVSxDQUFDLENBQUQsRUFBSSxHQUFKLEVBQVMsQ0FBVCxFQUFZLEdBQVosQ0FMUzs7QUFPbkJDLGVBQWE7QUFBQSxXQUFLQyxFQUFFQyxRQUFQO0FBQUEsR0FQTTtBQVFuQkMsYUFBVztBQUFBLFdBQUssQ0FBTDtBQUFBO0FBUlEsQ0FBckI7O0lBV3FCQyxlOzs7OztpQ0FDTjtBQUNYLGFBQU87QUFDTEMsWUFBSVgsZ0JBREM7QUFFTFksWUFBSVgsa0JBRkM7QUFHTFksaUJBQVMsRUFISjtBQUlMQyxxQkFBYSxLQUFLQyxPQUFMLENBQWFEO0FBSnJCLE9BQVA7QUFNRDs7O0FBRUQsMkJBQVlFLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSUFDWEEsS0FEVzs7QUFFakIsVUFBS0MsaUJBQUwsQ0FBdUIsV0FBdkIsRUFBb0MsZ0JBQXBDO0FBQ0EsVUFBS0EsaUJB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Q0EsUUFBUWYsTUFBMUQsRUFBa0U7QUFDaEUsZ0JBQU1LLElBQUlTLFFBQVFDLFFBQVFsQixNQUExQjtBQUNBTyxrQkFBTUMsQ0FBTixLQUFZeEQsVUFBVThELEtBQVYsQ0FBWjtBQUNBLGdCQUFJUCxNQUFNQyxDQUFOLElBQVcxQixRQUFmLEVBQXlCO0FBQ3ZCQSx5QkFBV3lCLE1BQU1DLENBQU4sQ0FBWDtBQUNEO0FBQ0Y7QUFDRjtBQW5CK0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFxQmhDLFdBQUtwQyxRQUFMLENBQWMsRUFBQ1Usa0JBQUQsRUFBZDtBQUNEOzs7O0VBOUgwQzVDLEs7O2VBQXhCZSxlOzs7QUFpSXJCQSxnQkFBZ0JrRSxTQUFoQixHQUE0QixpQkFBNUI7QUFDQWxFLGdCQUFnQlIsWUFBaEIsR0FBK0JBLFlBQS9CIiwiZmlsZSI6InNjcmVlbi1ncmlkLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBzY3JlZW5HcmlkVmVydGV4IGZyb20gJy4vc2NyZWVuLWdyaWQtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHNjcmVlbkdyaWRGcmFnbWVudCBmcm9tICcuL3NjcmVlbi1ncmlkLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNlbGxTaXplUGl4ZWxzOiAxMDAsXG5cbiAgLy8gQ29sb3IgcmFuZ2U/XG4gIG1pbkNvbG9yOiBbMCwgMCwgMCwgMjU1XSxcbiAgbWF4Q29sb3I6IFswLCAyNTUsIDAsIDI1NV0sXG5cbiAgZ2V0UG9zaXRpb246IGQgPT4gZC5wb3NpdGlvbixcbiAgZ2V0V2VpZ2h0OiBkID0+IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcmVlbkdyaWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IHNjcmVlbkdyaWRWZXJ0ZXgsXG4gICAgICBmczogc2NyZWVuR3JpZEZyYWdtZW50LFxuICAgICAgbW9kdWxlczogW10sXG4gICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX2NoZWNrUmVtb3ZlZFByb3AoJ3VuaXRXaWR0aCcsICdjZWxsU2l6ZVBpeGVscycpO1xuICAgIHRoaXMuX2NoZWNrUmVtb3ZlZFByb3AoJ3VuaXRIZWlnaHQnLCAnY2VsbFNpemVQaXhlbHMnKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VDb3VudDoge3NpemU6IDEsIGFjY2Vzc29yOiBbJ2dldFBvc2l0aW9uJywgJ2dldFdlaWdodCddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb3VudH1cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGNvbnN0IGNlbGxTaXplQ2hhbmdlZCA9XG4gICAgICBwcm9wcy5jZWxsU2l6ZVBpeGVscyAhPT0gb2xkUHJvcHMuY2VsbFNpemVQaXhlbHM7XG5cbiAgICBpZiAoY2VsbFNpemVDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgdGhpcy51cGRhdGVDZWxsKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge21pbkNvbG9yLCBtYXhDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHttb2RlbCwgY2VsbFNjYWxlLCBtYXhDb3VudH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHttaW5Db2xvciwgbWF4Q29sb3IsIGNlbGxTY2FsZSwgbWF4Q291bnR9KTtcbiAgICBtb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfRkFOLFxuICAgICAgICB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVDZWxsKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICBjb25zdCB7Y2VsbFNpemVQaXhlbHN9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IE1BUkdJTiA9IDI7XG4gICAgY29uc3QgY2VsbFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAoY2VsbFNpemVQaXhlbHMgLSBNQVJHSU4pIC8gd2lkdGggKiAyLFxuICAgICAgLShjZWxsU2l6ZVBpeGVscyAtIE1BUkdJTikgLyBoZWlnaHQgKiAyLFxuICAgICAgMVxuICAgIF0pO1xuICAgIGNvbnN0IG51bUNvbCA9IE1hdGguY2VpbCh3aWR0aCAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICBjb25zdCBudW1Sb3cgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gY2VsbFNpemVQaXhlbHMpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjZWxsU2NhbGUsXG4gICAgICBudW1Db2wsXG4gICAgICBudW1Sb3csXG4gICAgICBudW1JbnN0YW5jZXM6IG51bUNvbCAqIG51bVJvd1xuICAgIH0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSwge251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgY29uc3Qge2NlbGxTaXplUGl4ZWxzfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge251bUNvbH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIG51bUNvbDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGkgLyBudW1Db2wpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHggKiBjZWxsU2l6ZVBpeGVscyAvIHdpZHRoICogMiAtIDE7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gMSAtIHkgKiBjZWxsU2l6ZVBpeGVscyAvIGhlaWdodCAqIDI7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvdW50KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBjZWxsU2l6ZVBpeGVscywgZ2V0UG9zaXRpb24sIGdldFdlaWdodH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtudW1Db2wsIG51bVJvd30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IG1heENvdW50ID0gMDtcblxuICAgIHZhbHVlLmZpbGwoMC4wKTtcblxuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSB0aGlzLnByb2plY3QoZ2V0UG9zaXRpb24ocG9pbnQpKTtcbiAgICAgIGNvbnN0IGNvbElkID0gTWF0aC5mbG9vcihwaXhlbFswXSAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICAgIGNvbnN0IHJvd0lkID0gTWF0aC5mbG9vcihwaXhlbFsxXSAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICAgIGlmIChjb2xJZCA+PSAwICYmIGNvbElkIDwgbnVtQ29sICYmIHJvd0lkID49IDAgJiYgcm93SWQgPCBudW1Sb3cpIHtcbiAgICAgICAgY29uc3QgaSA9IGNvbElkICsgcm93SWQgKiBudW1Db2w7XG4gICAgICAgIHZhbHVlW2ldICs9IGdldFdlaWdodChwb2ludCk7XG4gICAgICAgIGlmICh2YWx1ZVtpXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgbWF4Q291bnQgPSB2YWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe21heENvdW50fSk7XG4gIH1cbn1cblxuU2NyZWVuR3JpZExheWVyLmxheWVyTmFtZSA9ICdTY3JlZW5HcmlkTGF5ZXInO1xuU2NyZWVuR3JpZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonTesselatorExtruded; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_earcut__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.








function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(color, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(color, 1), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(color, 2), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

var PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return __WEBPACK_IMPORTED_MODULE_0__polygon__["a" /* normalize */](complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(coord, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(coord, 1), height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (vertexCount, polygon) {
    return vertexCount + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["e" /* count */])(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return acc.concat(acc[acc.length - 1] + countVertices(vertices) * multiplier);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = groupedVertices.map(function (vertices) {
    var topVertices = Array.prototype.concat.apply([], vertices);
    var baseVertices = topVertices.map(function (v) {
      return [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(v, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(v, 1), 0];
    });
    return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
  });

  return __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS.length / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__["a" /* fp64ify */])(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__["a" /* fp64ify */])(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, polygonIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(normals));
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        normals.push(n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [[normals.concat(normals[0])], [[normals[0]].concat(normals)]];
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, polygonIndex) {
    var numVertices = countVertices(vertices);
    var color = getPickingColor(polygonIndex);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return acc.concat(acc[acc.length - 1] + polygon.length);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = __WEBPACK_IMPORTED_MODULE_4_earcut___default()(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // polygon top
    var indices = [];

    // polygon sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices = indices.concat(drawRectangle(i));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  var p1x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(p1, 0);
  var p1y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(p1, 1);
  var p2x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(p2, 0);
  var p2y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__["d" /* get */])(p2, 1);

  if (p1x === p2x && p1y === p2y) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1x;
  var lon2 = degrees2radians * p2x;
  var lat1 = degrees2radians * p1y;
  var lat2 = degrees2radians * p2y;
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return __WEBPACK_IMPORTED_MODULE_1_gl_matrix__["vec3"].normalize([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwidmVjMyIsImZwNjRpZnkiLCJnZXQiLCJjb3VudCIsImVhcmN1dCIsImZsYXR0ZW5EZWVwIiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbnNKUyIsImNhbGN1bGF0ZVBvc2l0aW9uc0pTIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaW5kaWNlcyIsImNhbGN1bGF0ZUluZGljZXMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlQ29sb3JzIiwiY291bnRWZXJ0aWNlcyIsInZlcnRpY2VzIiwicmVkdWNlIiwidmVydGV4Q291bnQiLCJtdWx0aXBsaWVyIiwib2Zmc2V0cyIsImFjYyIsImNvbmNhdCIsImxlbmd0aCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJVaW50MzJBcnJheSIsInRvcFZlcnRpY2VzIiwicHJvdG90eXBlIiwiYXBwbHkiLCJiYXNlVmVydGljZXMiLCJ2IiwicG9zaXRpb25Mb3ciLCJGbG9hdDMyQXJyYXkiLCJpIiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwidG9wTm9ybWFscyIsImZpbGwiLCJzaWRlTm9ybWFscyIsImNhbGN1bGF0ZVNpZGVOb3JtYWxzIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwibiIsInNpZGVOb3JtYWxzQmFja3dhcmQiLCJsYXN0VmVydGljZSIsInZlcnRpY2UiLCJnZXROb3JtYWwiLCJwdXNoIiwiY29sb3JzIiwibnVtVmVydGljZXMiLCJ0b3BDb2xvcnMiLCJiYXNlQ29sb3JzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvZmZzZXQiLCJzdHJpZGUiLCJxdWFkIiwiZHJhd1JlY3RhbmdsZSIsImhvbGVzIiwic2xpY2UiLCJ0b3BJbmRpY2VzIiwic2lkZUluZGljZXMiLCJwMSIsInAyIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwiZGVncmVlczJyYWRpYW5zIiwiTWF0aCIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxLQUFLQSxPQUFaLE1BQXlCLFdBQXpCO0FBQ0EsU0FBUUMsSUFBUixRQUFtQixXQUFuQjtBQUNBLFNBQVFDLE9BQVIsUUFBc0IseUJBQXRCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxLQUFiLFFBQXlCLG9CQUF6QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLG9CQUF4Qjs7QUFFQSxTQUFTQyxlQUFULENBQXlCQyxLQUF6QixFQUFnQztBQUM5QixTQUFPLENBQ0pBLFFBQVEsQ0FBVCxHQUFjLEdBRFQsRUFFSEEsUUFBUSxDQUFULElBQWUsQ0FBaEIsR0FBcUIsR0FGaEIsRUFHRkEsUUFBUSxDQUFULElBQWUsQ0FBaEIsSUFBc0IsQ0FBdkIsR0FBNEIsR0FIdkIsQ0FBUDtBQUtEOztBQUVELFNBQVNDLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUwsRUFBMkI7QUFDekJBLFlBQVEsQ0FBQ1AsSUFBSU8sS0FBSixFQUFXLENBQVgsQ0FBRCxFQUFnQlAsSUFBSU8sS0FBSixFQUFXLENBQVgsQ0FBaEIsRUFBK0JQLElBQUlPLEtBQUosRUFBVyxDQUFYLENBQS9CLEVBQThDUCxJQUFJTyxLQUFKLEVBQVcsQ0FBWCxDQUE5QyxDQUFSO0FBQ0Q7QUFDREEsUUFBTSxDQUFOLElBQVdHLE9BQU9DLFFBQVAsQ0FBZ0JKLE1BQU0sQ0FBTixDQUFoQixJQUE0QkEsTUFBTSxDQUFOLENBQTVCLEdBQXVDLEdBQWxEO0FBQ0EsU0FBT0EsS0FBUDtBQUNEOztBQUVELElBQU1LLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBdEIsQyxDQUFzQzs7QUFFdEMsV0FBYUMseUJBQWI7QUFFRSwyQ0FNRztBQUFBLFFBTERDLFFBS0MsUUFMREEsUUFLQztBQUFBLDhCQUpEQyxTQUlDO0FBQUEsUUFKREEsU0FJQyxrQ0FKVztBQUFBLGFBQUssSUFBTDtBQUFBLEtBSVg7QUFBQSw2QkFIREMsUUFHQztBQUFBLFFBSERBLFFBR0MsaUNBSFU7QUFBQSxhQUFLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUFMO0FBQUEsS0FHVjtBQUFBLDhCQUZEQyxTQUVDO0FBQUEsUUFGREEsU0FFQyxrQ0FGVyxLQUVYO0FBQUEsdUJBRERDLElBQ0M7QUFBQSxRQUREQSxJQUNDLDJCQURNLEtBQ047O0FBQUE7O0FBQ0QsU0FBS0EsSUFBTCxHQUFZQSxJQUFaOztBQUVBO0FBQ0FKLGVBQVdBLFNBQVNLLEdBQVQsQ0FBYSxVQUFDQyxjQUFELEVBQWlCQyxZQUFqQixFQUFrQztBQUN4RCxVQUFNQyxTQUFTUCxVQUFVTSxZQUFWLEtBQTJCLENBQTFDO0FBQ0EsYUFBT3hCLFFBQVEwQixTQUFSLENBQWtCSCxjQUFsQixFQUFrQ0QsR0FBbEMsQ0FDTDtBQUFBLGVBQVdLLFFBQVFMLEdBQVIsQ0FBWTtBQUFBLGlCQUFTLENBQUNuQixJQUFJeUIsS0FBSixFQUFXLENBQVgsQ0FBRCxFQUFnQnpCLElBQUl5QixLQUFKLEVBQVcsQ0FBWCxDQUFoQixFQUErQkgsTUFBL0IsQ0FBVDtBQUFBLFNBQVosQ0FBWDtBQUFBLE9BREssQ0FBUDtBQUdELEtBTFUsQ0FBWDs7QUFPQSxRQUFNSSxrQkFBa0JaLFFBQXhCO0FBQ0EsU0FBS1ksZUFBTCxHQUF1QlosUUFBdkI7QUFDQSxTQUFLRyxTQUFMLEdBQWlCQSxTQUFqQjs7QUFFQSxTQUFLVSxVQUFMLEdBQWtCLEVBQWxCOztBQUVBLFFBQU1DLGNBQWNDLHFCQUFxQixFQUFDSCxnQ0FBRCxFQUFrQlQsb0JBQWxCLEVBQXJCLENBQXBCO0FBQ0FhLFdBQU9DLE1BQVAsQ0FBYyxLQUFLSixVQUFuQixFQUErQjtBQUM3QkssaUJBQVdDLG1CQUFtQkwsV0FBbkIsRUFBZ0MsS0FBS1YsSUFBckMsQ0FEa0I7QUFFN0JnQixlQUFTQyxpQkFBaUIsRUFBQ1QsZ0NBQUQsRUFBa0JULG9CQUFsQixFQUFqQixDQUZvQjtBQUc3Qm1CLGVBQVNDLGlCQUFpQixFQUFDWCxnQ0FBRCxFQUFrQlQsb0JBQWxCLEVBQWpCLENBSG9CO0FBSTdCO0FBQ0FxQixxQkFBZUMsdUJBQXVCLEVBQUNiLGdDQUFELEVBQWtCVCxvQkFBbEIsRUFBdkI7QUFMYyxLQUEvQjtBQU9EOztBQWpDSDtBQUFBO0FBQUEsOEJBbUNZO0FBQ1IsYUFBTyxLQUFLVSxVQUFMLENBQWdCTyxPQUF2QjtBQUNEO0FBckNIO0FBQUE7QUFBQSxnQ0F1Q2M7QUFDVixhQUFPLEtBQUtQLFVBQUwsQ0FBZ0JLLFNBQXZCO0FBQ0Q7QUF6Q0g7QUFBQTtBQUFBLDhCQTJDWTtBQUNSLGFBQU8sS0FBS0wsVUFBTCxDQUFnQlMsT0FBdkI7QUFDRDtBQTdDSDtBQUFBO0FBQUEsNkJBK0MrQztBQUFBLHNGQUFKLEVBQUk7QUFBQSxpQ0FBckNwQixRQUFxQztBQUFBLFVBQXJDQSxRQUFxQyxrQ0FBMUI7QUFBQSxlQUFLSixhQUFMO0FBQUEsT0FBMEI7O0FBQUEsVUFDcENjLGVBRG9DLEdBQ04sSUFETSxDQUNwQ0EsZUFEb0M7QUFBQSxVQUNuQlQsU0FEbUIsR0FDTixJQURNLENBQ25CQSxTQURtQjs7QUFFM0MsYUFBT3VCLGdCQUFnQixFQUFDZCxnQ0FBRCxFQUFrQlQsb0JBQWxCLEVBQTZCRCxrQkFBN0IsRUFBaEIsQ0FBUDtBQUNEO0FBbERIO0FBQUE7QUFBQSxvQ0FvRGtCO0FBQ2QsYUFBTyxLQUFLVyxVQUFMLENBQWdCVyxhQUF2QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNURGOztBQUFBO0FBQUE7O0FBK0RBLFNBQVNHLGFBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDO0FBQy9CLFNBQU9BLFNBQVNDLE1BQVQsQ0FBZ0IsVUFBQ0MsV0FBRCxFQUFjcEIsT0FBZDtBQUFBLFdBQTBCb0IsY0FBYzNDLE1BQU11QixPQUFOLENBQXhDO0FBQUEsR0FBaEIsRUFBd0UsQ0FBeEUsQ0FBUDtBQUNEOztBQUVELFNBQVNXLGdCQUFULFFBQWdFO0FBQUEsTUFBckNULGVBQXFDLFNBQXJDQSxlQUFxQztBQUFBLDhCQUFwQlQsU0FBb0I7QUFBQSxNQUFwQkEsU0FBb0IsbUNBQVIsS0FBUTs7QUFDOUQ7QUFDQSxNQUFNNEIsYUFBYTVCLFlBQVksQ0FBWixHQUFnQixDQUFuQztBQUNBLE1BQU02QixVQUFVcEIsZ0JBQWdCaUIsTUFBaEIsQ0FDZCxVQUFDSSxHQUFELEVBQU1MLFFBQU47QUFBQSxXQUNFSyxJQUFJQyxNQUFKLENBQVdELElBQUlBLElBQUlFLE1BQUosR0FBYSxDQUFqQixJQUFzQlIsY0FBY0MsUUFBZCxJQUEwQkcsVUFBM0QsQ0FERjtBQUFBLEdBRGMsRUFHZCxDQUFDLENBQUQsQ0FIYyxDQUFoQjs7QUFNQSxNQUFNWCxVQUFVUixnQkFBZ0JQLEdBQWhCLENBQW9CLFVBQUN1QixRQUFELEVBQVdyQixZQUFYO0FBQUEsV0FDbENKO0FBQ0U7QUFDQTtBQUNBaUMsNEJBQXdCUixRQUF4QixFQUFrQ0ksUUFBUXpCLFlBQVIsQ0FBbEMsQ0FIRjtBQUlFO0FBQ0E7QUFDQThCLDRCQUF3QlQsUUFBeEIsRUFBa0NJLFFBQVF6QixZQUFSLENBQWxDLENBUGdDO0FBQUEsR0FBcEIsQ0FBaEI7O0FBVUEsU0FBTyxJQUFJK0IsV0FBSixDQUFnQmpELFlBQVkrQixPQUFaLENBQWhCLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNMLG9CQUFULFFBQW9FO0FBQUEsTUFBckNILGVBQXFDLFNBQXJDQSxlQUFxQztBQUFBLDhCQUFwQlQsU0FBb0I7QUFBQSxNQUFwQkEsU0FBb0IsbUNBQVIsS0FBUTs7QUFDbEUsTUFBTWUsWUFBWU4sZ0JBQWdCUCxHQUFoQixDQUNoQixvQkFBWTtBQUNWLFFBQU1rQyxjQUFjN0MsTUFBTThDLFNBQU4sQ0FBZ0JOLE1BQWhCLENBQXVCTyxLQUF2QixDQUE2QixFQUE3QixFQUFpQ2IsUUFBakMsQ0FBcEI7QUFDQSxRQUFNYyxlQUFlSCxZQUFZbEMsR0FBWixDQUFnQjtBQUFBLGFBQUssQ0FBQ25CLElBQUl5RCxDQUFKLEVBQU8sQ0FBUCxDQUFELEVBQVl6RCxJQUFJeUQsQ0FBSixFQUFPLENBQVAsQ0FBWixFQUF1QixDQUF2QixDQUFMO0FBQUEsS0FBaEIsQ0FBckI7QUFDQSxXQUFPeEMsWUFBWSxDQUFDb0MsV0FBRCxFQUFjRyxZQUFkLENBQVosR0FDTCxDQUFDSCxXQUFELEVBQWNBLFdBQWQsRUFBMkJBLFdBQTNCLEVBQXdDRyxZQUF4QyxFQUFzREEsWUFBdEQsQ0FERjtBQUVELEdBTmUsQ0FBbEI7O0FBU0EsU0FBT3JELFlBQVk2QixTQUFaLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxrQkFBVCxDQUE0QkwsV0FBNUIsRUFBeUNWLElBQXpDLEVBQStDO0FBQzdDLE1BQUl3QyxvQkFBSjtBQUNBLE1BQUl4QyxJQUFKLEVBQVU7QUFDUjtBQUNBd0Msa0JBQWMsSUFBSUMsWUFBSixDQUFpQi9CLFlBQVlxQixNQUFaLEdBQXFCLENBQXJCLEdBQXlCLENBQTFDLENBQWQ7QUFDQSxTQUFLLElBQUlXLElBQUksQ0FBYixFQUFnQkEsSUFBSWhDLFlBQVlxQixNQUFaLEdBQXFCLENBQXpDLEVBQTRDVyxHQUE1QyxFQUFpRDtBQUMvQ0Ysa0JBQVlFLElBQUksQ0FBSixHQUFRLENBQXBCLElBQXlCN0QsUUFBUTZCLFlBQVlnQyxJQUFJLENBQUosR0FBUSxDQUFwQixDQUFSLEVBQWdDLENBQWhDLENBQXpCO0FBQ0FGLGtCQUFZRSxJQUFJLENBQUosR0FBUSxDQUFwQixJQUF5QjdELFFBQVE2QixZQUFZZ0MsSUFBSSxDQUFKLEdBQVEsQ0FBcEIsQ0FBUixFQUFnQyxDQUFoQyxDQUF6QjtBQUNEO0FBRUY7QUFDRCxTQUFPLEVBQUM1QixXQUFXLElBQUkyQixZQUFKLENBQWlCL0IsV0FBakIsQ0FBWixFQUEyQ2lDLGtCQUFrQkgsV0FBN0QsRUFBUDtBQUNEOztBQUVELFNBQVNyQixnQkFBVCxRQUF3RDtBQUFBLE1BQTdCWCxlQUE2QixTQUE3QkEsZUFBNkI7QUFBQSxNQUFaVCxTQUFZLFNBQVpBLFNBQVk7O0FBQ3RELE1BQU02QyxLQUFLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVg7O0FBRUEsTUFBTTFCLFVBQVVWLGdCQUFnQlAsR0FBaEIsQ0FBb0IsVUFBQ3VCLFFBQUQsRUFBV3JCLFlBQVgsRUFBNEI7QUFDOUQsUUFBTTBDLGFBQWEsSUFBSXZELEtBQUosQ0FBVWlDLGNBQWNDLFFBQWQsQ0FBVixFQUFtQ3NCLElBQW5DLENBQXdDRixFQUF4QyxDQUFuQjtBQUNBLFFBQU1HLGNBQWN2QixTQUFTdkIsR0FBVCxDQUFhO0FBQUEsYUFBVytDLHFCQUFxQjFDLE9BQXJCLENBQVg7QUFBQSxLQUFiLENBQXBCO0FBQ0EsUUFBTTJDLHFCQUFxQkYsWUFBWTlDLEdBQVosQ0FBZ0I7QUFBQSxhQUFLaUQsRUFBRSxDQUFGLENBQUw7QUFBQSxLQUFoQixDQUEzQjtBQUNBLFFBQU1DLHNCQUFzQkosWUFBWTlDLEdBQVosQ0FBZ0I7QUFBQSxhQUFLaUQsRUFBRSxDQUFGLENBQUw7QUFBQSxLQUFoQixDQUE1Qjs7QUFFQSxXQUFPbkQsWUFDUCxDQUFDOEMsVUFBRCxFQUFhQSxVQUFiLENBRE8sR0FFUCxDQUFDQSxVQUFELEVBQWFJLGtCQUFiLEVBQWlDRSxtQkFBakMsRUFBc0RGLGtCQUF0RCxFQUEwRUUsbUJBQTFFLENBRkE7QUFHRCxHQVRlLENBQWhCOztBQVdBLFNBQU8sSUFBSVYsWUFBSixDQUFpQnhELFlBQVlpQyxPQUFaLENBQWpCLENBQVA7QUFDRDs7QUFFRCxTQUFTOEIsb0JBQVQsQ0FBOEJ4QixRQUE5QixFQUF3QztBQUN0QyxNQUFNTixVQUFVLEVBQWhCOztBQUVBLE1BQUlrQyxjQUFjLElBQWxCO0FBSHNDO0FBQUE7QUFBQTs7QUFBQTtBQUl0Qyx5QkFBc0I1QixRQUF0Qiw4SEFBZ0M7QUFBQSxVQUFyQjZCLE9BQXFCOztBQUM5QixVQUFJRCxXQUFKLEVBQWlCO0FBQ2Y7QUFDQSxZQUFNRixJQUFJSSxVQUFVRixXQUFWLEVBQXVCQyxPQUF2QixDQUFWO0FBQ0FuQyxnQkFBUXFDLElBQVIsQ0FBYUwsQ0FBYjtBQUNEO0FBQ0RFLG9CQUFjQyxPQUFkO0FBQ0Q7QUFYcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFhdEMsU0FBTyxDQUFDLENBQUNuQyxRQUFRWSxNQUFSLENBQWVaLFFBQVEsQ0FBUixDQUFmLENBQUQsQ0FBRCxFQUErQixDQUFDLENBQUNBLFFBQVEsQ0FBUixDQUFELEVBQWFZLE1BQWIsQ0FBb0JaLE9BQXBCLENBQUQsQ0FBL0IsQ0FBUDtBQUNEOztBQUVELFNBQVNJLGVBQVQsUUFBeUU7QUFBQSxNQUEvQ2QsZUFBK0MsU0FBL0NBLGVBQStDO0FBQUEsTUFBOUJWLFFBQThCLFNBQTlCQSxRQUE4QjtBQUFBLDhCQUFwQkMsU0FBb0I7QUFBQSxNQUFwQkEsU0FBb0IsbUNBQVIsS0FBUTs7QUFDdkUsTUFBTXlELFNBQVNoRCxnQkFBZ0JQLEdBQWhCLENBQW9CLFVBQUNDLGNBQUQsRUFBaUJDLFlBQWpCLEVBQWtDO0FBQ25FLFFBQUlkLFFBQVFTLFNBQVNLLFlBQVQsQ0FBWjtBQUNBZCxZQUFRRCxXQUFXQyxLQUFYLENBQVI7O0FBRUEsUUFBTW9FLGNBQWNsQyxjQUFjckIsY0FBZCxDQUFwQjtBQUNBLFFBQU13RCxZQUFZLElBQUlwRSxLQUFKLENBQVVtRSxXQUFWLEVBQXVCWCxJQUF2QixDQUE0QnpELEtBQTVCLENBQWxCO0FBQ0EsUUFBTXNFLGFBQWEsSUFBSXJFLEtBQUosQ0FBVW1FLFdBQVYsRUFBdUJYLElBQXZCLENBQTRCekQsS0FBNUIsQ0FBbkI7QUFDQSxXQUFPVSxZQUNMLENBQUMyRCxTQUFELEVBQVlDLFVBQVosQ0FESyxHQUVMLENBQUNELFNBQUQsRUFBWUEsU0FBWixFQUF1QkEsU0FBdkIsRUFBa0NDLFVBQWxDLEVBQThDQSxVQUE5QyxDQUZGO0FBR0QsR0FWYyxDQUFmO0FBV0EsU0FBTyxJQUFJQyxpQkFBSixDQUFzQjNFLFlBQVl1RSxNQUFaLENBQXRCLENBQVA7QUFDRDs7QUFFRCxTQUFTbkMsc0JBQVQsUUFBc0U7QUFBQSxNQUFyQ2IsZUFBcUMsU0FBckNBLGVBQXFDO0FBQUEsOEJBQXBCVCxTQUFvQjtBQUFBLE1BQXBCQSxTQUFvQixtQ0FBUixLQUFROztBQUNwRSxNQUFNeUQsU0FBU2hELGdCQUFnQlAsR0FBaEIsQ0FBb0IsVUFBQ3VCLFFBQUQsRUFBV3JCLFlBQVgsRUFBNEI7QUFDN0QsUUFBTXNELGNBQWNsQyxjQUFjQyxRQUFkLENBQXBCO0FBQ0EsUUFBTW5DLFFBQVFILGdCQUFnQmlCLFlBQWhCLENBQWQ7QUFDQSxRQUFNdUQsWUFBWSxJQUFJcEUsS0FBSixDQUFVbUUsV0FBVixFQUF1QlgsSUFBdkIsQ0FBNEJ6RCxLQUE1QixDQUFsQjtBQUNBLFFBQU1zRSxhQUFhLElBQUlyRSxLQUFKLENBQVVtRSxXQUFWLEVBQXVCWCxJQUF2QixDQUE0QnpELEtBQTVCLENBQW5CO0FBQ0EsV0FBT1UsWUFDTCxDQUFDMkQsU0FBRCxFQUFZQyxVQUFaLENBREssR0FFTCxDQUFDRCxTQUFELEVBQVlBLFNBQVosRUFBdUJBLFNBQXZCLEVBQWtDQyxVQUFsQyxFQUE4Q0EsVUFBOUMsQ0FGRjtBQUdELEdBUmMsQ0FBZjtBQVNBLFNBQU8sSUFBSUMsaUJBQUosQ0FBc0IzRSxZQUFZdUUsTUFBWixDQUF0QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU3hCLHVCQUFULENBQWlDUixRQUFqQyxFQUEyQ3FDLE1BQTNDLEVBQW1EO0FBQ2pELE1BQU1DLFNBQVN2QyxjQUFjQyxRQUFkLENBQWY7O0FBRUEsU0FBT0EsU0FBU3ZCLEdBQVQsQ0FBYSxtQkFBVztBQUM3QixRQUFNZSxVQUFVLENBQUM2QyxNQUFELENBQWhCO0FBQ0EsUUFBTUosY0FBY25ELFFBQVF5QixNQUE1Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBSyxJQUFJVyxJQUFJLENBQWIsRUFBZ0JBLElBQUllLGNBQWMsQ0FBbEMsRUFBcUNmLEdBQXJDLEVBQTBDO0FBQ3hDMUIsY0FBUXVDLElBQVIsQ0FBYWIsSUFBSW1CLE1BQWpCLEVBQXlCbkIsSUFBSW1CLE1BQTdCO0FBQ0Q7QUFDRDdDLFlBQVF1QyxJQUFSLENBQWFNLE1BQWI7O0FBRUE7QUFDQSxTQUFLLElBQUluQixLQUFJLENBQWIsRUFBZ0JBLEtBQUllLGNBQWMsQ0FBbEMsRUFBcUNmLElBQXJDLEVBQTBDO0FBQ3hDMUIsY0FBUXVDLElBQVIsQ0FBYWIsS0FBSW1CLE1BQWpCLEVBQXlCbkIsS0FBSW9CLE1BQUosR0FBYUQsTUFBdEM7QUFDRDs7QUFFREEsY0FBVUosV0FBVjtBQUNBLFdBQU96QyxPQUFQO0FBQ0QsR0FsQk0sQ0FBUDtBQW1CRDs7QUFFRCxTQUFTaUIsdUJBQVQsQ0FBaUNULFFBQWpDLEVBQTJDcUMsTUFBM0MsRUFBbUQ7QUFDakQsTUFBTUMsU0FBU3ZDLGNBQWNDLFFBQWQsQ0FBZjtBQUNBLE1BQU11QyxPQUFPLENBQ1gsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURXLEVBQ0gsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURHLEVBQ0ssQ0FBQyxDQUFELEVBQUksQ0FBSixDQURMLEVBRVgsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZXLEVBRUgsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZHLEVBRUssQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZMLENBQWI7O0FBS0EsV0FBU0MsYUFBVCxDQUF1QnRCLENBQXZCLEVBQTBCO0FBQ3hCLFdBQU9xQixLQUFLOUQsR0FBTCxDQUFTO0FBQUEsYUFBS3lDLElBQUlILEVBQUUsQ0FBRixDQUFKLEdBQVd1QixTQUFTdkIsRUFBRSxDQUFGLENBQXBCLEdBQTJCc0IsTUFBaEM7QUFBQSxLQUFULENBQVA7QUFDRDs7QUFFRCxNQUFJSSxRQUFRLElBQVo7O0FBRUEsTUFBSXpDLFNBQVNPLE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkJrQyxZQUFRekMsU0FBU0MsTUFBVCxDQUNOLFVBQUNJLEdBQUQsRUFBTXZCLE9BQU47QUFBQSxhQUFrQnVCLElBQUlDLE1BQUosQ0FBV0QsSUFBSUEsSUFBSUUsTUFBSixHQUFhLENBQWpCLElBQXNCekIsUUFBUXlCLE1BQXpDLENBQWxCO0FBQUEsS0FETSxFQUVOLENBQUMsQ0FBRCxDQUZNLEVBR05tQyxLQUhNLENBR0EsQ0FIQSxFQUdHMUMsU0FBU08sTUFIWixDQUFSO0FBSUQ7O0FBRUQsTUFBTW9DLGFBQWFuRixPQUFPQyxZQUFZdUMsUUFBWixDQUFQLEVBQThCeUMsS0FBOUIsRUFBcUMsQ0FBckMsRUFBd0NoRSxHQUF4QyxDQUE0QztBQUFBLFdBQVNkLFFBQVEwRSxNQUFqQjtBQUFBLEdBQTVDLENBQW5COztBQUVBLE1BQU1PLGNBQWM1QyxTQUFTdkIsR0FBVCxDQUFhLG1CQUFXO0FBQzFDLFFBQU13RCxjQUFjbkQsUUFBUXlCLE1BQTVCO0FBQ0E7QUFDQSxRQUFJZixVQUFVLEVBQWQ7O0FBRUE7QUFDQSxTQUFLLElBQUkwQixJQUFJLENBQWIsRUFBZ0JBLElBQUllLGNBQWMsQ0FBbEMsRUFBcUNmLEdBQXJDLEVBQTBDO0FBQ3hDMUIsZ0JBQVVBLFFBQVFjLE1BQVIsQ0FBZWtDLGNBQWN0QixDQUFkLENBQWYsQ0FBVjtBQUNEOztBQUVEbUIsY0FBVUosV0FBVjtBQUNBLFdBQU96QyxPQUFQO0FBQ0QsR0FabUIsQ0FBcEI7O0FBY0EsU0FBTyxDQUFDbUQsVUFBRCxFQUFhQyxXQUFiLENBQVA7QUFDRDs7QUFFRDs7QUFFQTtBQUNBLFNBQVNkLFNBQVQsQ0FBbUJlLEVBQW5CLEVBQXVCQyxFQUF2QixFQUEyQjtBQUN6QixNQUFNQyxNQUFNekYsSUFBSXVGLEVBQUosRUFBUSxDQUFSLENBQVo7QUFDQSxNQUFNRyxNQUFNMUYsSUFBSXVGLEVBQUosRUFBUSxDQUFSLENBQVo7QUFDQSxNQUFNSSxNQUFNM0YsSUFBSXdGLEVBQUosRUFBUSxDQUFSLENBQVo7QUFDQSxNQUFNSSxNQUFNNUYsSUFBSXdGLEVBQUosRUFBUSxDQUFSLENBQVo7O0FBRUEsTUFBSUMsUUFBUUUsR0FBUixJQUFlRCxRQUFRRSxHQUEzQixFQUFnQztBQUM5QixXQUFPLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVA7QUFDRDs7QUFFRCxNQUFNQyxrQkFBa0JDLEtBQUtDLEVBQUwsR0FBVSxHQUFsQztBQUNBLE1BQU1DLE9BQU9ILGtCQUFrQkosR0FBL0I7QUFDQSxNQUFNUSxPQUFPSixrQkFBa0JGLEdBQS9CO0FBQ0EsTUFBTU8sT0FBT0wsa0JBQWtCSCxHQUEvQjtBQUNBLE1BQU1TLE9BQU9OLGtCQUFrQkQsR0FBL0I7QUFDQSxNQUFNUSxJQUFJTixLQUFLTyxHQUFMLENBQVNKLE9BQU9ELElBQWhCLElBQXdCRixLQUFLUSxHQUFMLENBQVNILElBQVQsQ0FBbEM7QUFDQSxNQUFNSSxJQUFJVCxLQUFLUSxHQUFMLENBQVNKLElBQVQsSUFBaUJKLEtBQUtPLEdBQUwsQ0FBU0YsSUFBVCxDQUFqQixHQUNSTCxLQUFLTyxHQUFMLENBQVNILElBQVQsSUFBaUJKLEtBQUtRLEdBQUwsQ0FBU0gsSUFBVCxDQUFqQixHQUFrQ0wsS0FBS1EsR0FBTCxDQUFTTCxPQUFPRCxJQUFoQixDQURwQztBQUVBLFNBQU9sRyxLQUFLeUIsU0FBTCxDQUFlLEVBQWYsRUFBbUIsQ0FBQ2dGLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ0gsQ0FBUixDQUFuQixDQUFQO0FBQ0QiLCJmaWxlIjoicG9seWdvbi10ZXNzZWxhdG9yLWV4dHJ1ZGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCB7dmVjM30gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7ZnA2NGlmeX0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtnZXQsIGNvdW50fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5cbmZ1bmN0aW9uIGdldFBpY2tpbmdDb2xvcihpbmRleCkge1xuICByZXR1cm4gW1xuICAgIChpbmRleCArIDEpICYgMjU1LFxuICAgICgoaW5kZXggKyAxKSA+PiA4KSAmIDI1NSxcbiAgICAoKChpbmRleCArIDEpID4+IDgpID4+IDgpICYgMjU1XG4gIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGNvbG9yID0gW2dldChjb2xvciwgMCksIGdldChjb2xvciwgMSksIGdldChjb2xvciwgMiksIGdldChjb2xvciwgMyldO1xuICB9XG4gIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuICByZXR1cm4gY29sb3I7XG59XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTsgLy8gQmxhY2tcblxuZXhwb3J0IGNsYXNzIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQge1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb2x5Z29ucyxcbiAgICBnZXRIZWlnaHQgPSB4ID0+IDEwMDAsXG4gICAgZ2V0Q29sb3IgPSB4ID0+IFswLCAwLCAwLCAyNTVdLFxuICAgIHdpcmVmcmFtZSA9IGZhbHNlLFxuICAgIGZwNjQgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5mcDY0ID0gZnA2NDtcblxuICAgIC8vIEV4cGVuc2l2ZSBvcGVyYXRpb24sIGNvbnZlcnQgYWxsIHBvbHlnb25zIHRvIGFycmF5c1xuICAgIHBvbHlnb25zID0gcG9seWdvbnMubWFwKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQocG9seWdvbkluZGV4KSB8fCAwO1xuICAgICAgcmV0dXJuIFBvbHlnb24ubm9ybWFsaXplKGNvbXBsZXhQb2x5Z29uKS5tYXAoXG4gICAgICAgIHBvbHlnb24gPT4gcG9seWdvbi5tYXAoY29vcmQgPT4gW2dldChjb29yZCwgMCksIGdldChjb29yZCwgMSksIGhlaWdodF0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy5ncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgY29uc3QgcG9zaXRpb25zSlMgPSBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb25zOiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIHRoaXMuZnA2NCksXG4gICAgICBpbmRpY2VzOiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pLFxuICAgICAgbm9ybWFsczogY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIC8vIGNvbG9yczogY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSwgZ2V0Q29sb3J9KSxcbiAgICAgIHBpY2tpbmdDb2xvcnM6IGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSlcbiAgICB9KTtcbiAgfVxuXG4gIGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pbmRpY2VzO1xuICB9XG5cbiAgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb25zO1xuICB9XG5cbiAgbm9ybWFscygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbHM7XG4gIH1cblxuICBjb2xvcnMoe2dldENvbG9yID0geCA9PiBERUZBVUxUX0NPTE9SfSA9IHt9KSB7XG4gICAgY29uc3Qge2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSk7XG4gIH1cblxuICBwaWNraW5nQ29sb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucGlja2luZ0NvbG9ycztcbiAgfVxuXG4gIC8vIHVwZGF0ZVRyaWdnZXJzOiB7XG4gIC8vICAgcG9zaXRpb25zOiBbJ2dldEhlaWdodCddLFxuICAvLyAgIGNvbG9yczogWydnZXRDb2xvcnMnXVxuICAvLyAgIHBpY2tpbmdDb2xvcnM6ICdub25lJ1xuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZSgodmVydGV4Q291bnQsIHBvbHlnb24pID0+IHZlcnRleENvdW50ICsgY291bnQocG9seWdvbiksIDApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBwb2x5Z29uc1xuICBjb25zdCBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIGNvbnN0IG9mZnNldHMgPSBncm91cGVkVmVydGljZXMucmVkdWNlKFxuICAgIChhY2MsIHZlcnRpY2VzKSA9PlxuICAgICAgYWNjLmNvbmNhdChhY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyKSxcbiAgICBbMF1cbiAgKTtcblxuICBjb25zdCBpbmRpY2VzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT5cbiAgICB3aXJlZnJhbWUgP1xuICAgICAgLy8gMS4gZ2V0IHNlcXVlbnRpYWxseSBvcmRlcmVkIGluZGljZXMgb2YgZWFjaCBwb2x5Z29ucyB3aXJlZnJhbWVcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldHNbcG9seWdvbkluZGV4XSkgOlxuICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICAgICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldHNbcG9seWdvbkluZGV4XSlcbiAgKTtcblxuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW5EZWVwKGluZGljZXMpKTtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgZmxhdCBwb3NpdGlvbiBhcnJheSBpbiBKUyAtIGNhbiBiZSBtYXBwZWQgdG8gMzIgb3IgNjQgYml0IHR5cGVkIGFycmF5c1xuLy8gUmVtYXJrczpcbi8vICogZWFjaCB0b3AgdmVydGV4IGlzIG9uIDMgc3VyZmFjZXNcbi8vICogZWFjaCBib3R0b20gdmVydGV4IGlzIG9uIDIgc3VyZmFjZXNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uc0pTKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBwb3NpdGlvbnMgPSBncm91cGVkVmVydGljZXMubWFwKFxuICAgIHZlcnRpY2VzID0+IHtcbiAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdmVydGljZXMpO1xuICAgICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKHYgPT4gW2dldCh2LCAwKSwgZ2V0KHYsIDEpLCAwXSk7XG4gICAgICByZXR1cm4gd2lyZWZyYW1lID8gW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDpcbiAgICAgICAgW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIGZsYXR0ZW5EZWVwKHBvc2l0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnNKUywgZnA2NCkge1xuICBsZXQgcG9zaXRpb25Mb3c7XG4gIGlmIChmcDY0KSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHgsIHkgY29tcG9uZW50XG4gICAgcG9zaXRpb25Mb3cgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uc0pTLmxlbmd0aCAvIDMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uc0pTLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAwXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAwXSlbMV07XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDFdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDFdKVsxXTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4ge3Bvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUyksIHBvc2l0aW9uczY0eHlMb3c6IHBvc2l0aW9uTG93fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSB7XG4gIGNvbnN0IHVwID0gWzAsIDEsIDBdO1xuXG4gIGNvbnN0IG5vcm1hbHMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgdG9wTm9ybWFscyA9IG5ldyBBcnJheShjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSkuZmlsbCh1cCk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHMgPSB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiBjYWxjdWxhdGVTaWRlTm9ybWFscyhwb2x5Z29uKSk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHNGb3J3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblswXSk7XG4gICAgY29uc3Qgc2lkZU5vcm1hbHNCYWNrd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChuID0+IG5bMV0pO1xuXG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgW3RvcE5vcm1hbHMsIHRvcE5vcm1hbHNdIDpcbiAgICBbdG9wTm9ybWFscywgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmRdO1xuICB9KTtcblxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuRGVlcChub3JtYWxzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHZlcnRpY2VzKSB7XG4gIGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuICBsZXQgbGFzdFZlcnRpY2UgPSBudWxsO1xuICBmb3IgKGNvbnN0IHZlcnRpY2Ugb2YgdmVydGljZXMpIHtcbiAgICBpZiAobGFzdFZlcnRpY2UpIHtcbiAgICAgIC8vIHZlcnRleFtpLTFdLCB2ZXJ0ZXhbaV1cbiAgICAgIGNvbnN0IG4gPSBnZXROb3JtYWwobGFzdFZlcnRpY2UsIHZlcnRpY2UpO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgIH1cbiAgICBsYXN0VmVydGljZSA9IHZlcnRpY2U7XG4gIH1cblxuICByZXR1cm4gW1tub3JtYWxzLmNvbmNhdChub3JtYWxzWzBdKV0sIFtbbm9ybWFsc1swXV0uY29uY2F0KG5vcm1hbHMpXV07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBnZXRDb2xvciwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBsZXQgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvcik7XG5cbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IGNvdW50VmVydGljZXMoY29tcGxleFBvbHlnb24pO1xuICAgIGNvbnN0IHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBjb2xvcnMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgICBjb25zdCBjb2xvciA9IGdldFBpY2tpbmdDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbnN0IHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyBwb2x5Z29uIHRvcFxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIEdMLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMSwgbi0xLCAwXVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBzdHJpZGUgKyBvZmZzZXQpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gIGNvbnN0IHF1YWQgPSBbXG4gICAgWzAsIDFdLCBbMCwgM10sIFsxLCAyXSxcbiAgICBbMSwgMl0sIFswLCAzXSwgWzEsIDRdXG4gIF07XG5cbiAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgcmV0dXJuIHF1YWQubWFwKHYgPT4gaSArIHZbMF0gKyBzdHJpZGUgKiB2WzFdICsgb2Zmc2V0KTtcbiAgfVxuXG4gIGxldCBob2xlcyA9IG51bGw7XG5cbiAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IHZlcnRpY2VzLnJlZHVjZShcbiAgICAgIChhY2MsIHBvbHlnb24pID0+IGFjYy5jb25jYXQoYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoKSxcbiAgICAgIFswXVxuICAgICkuc2xpY2UoMSwgdmVydGljZXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IHRvcEluZGljZXMgPSBlYXJjdXQoZmxhdHRlbkRlZXAodmVydGljZXMpLCBob2xlcywgMykubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0KTtcblxuICBjb25zdCBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIC8vIHBvbHlnb24gdG9wXG4gICAgbGV0IGluZGljZXMgPSBbXTtcblxuICAgIC8vIHBvbHlnb24gc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzID0gaW5kaWNlcy5jb25jYXQoZHJhd1JlY3RhbmdsZShpKSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcblxuICByZXR1cm4gW3RvcEluZGljZXMsIHNpZGVJbmRpY2VzXTtcbn1cblxuLy8gaGVscGVyc1xuXG4vLyBnZXQgbm9ybWFsIHZlY3RvciBvZiBsaW5lIHNlZ21lbnRcbmZ1bmN0aW9uIGdldE5vcm1hbChwMSwgcDIpIHtcbiAgY29uc3QgcDF4ID0gZ2V0KHAxLCAwKTtcbiAgY29uc3QgcDF5ID0gZ2V0KHAxLCAxKTtcbiAgY29uc3QgcDJ4ID0gZ2V0KHAyLCAwKTtcbiAgY29uc3QgcDJ5ID0gZ2V0KHAyLCAxKTtcblxuICBpZiAocDF4ID09PSBwMnggJiYgcDF5ID09PSBwMnkpIHtcbiAgICByZXR1cm4gWzEsIDAsIDBdO1xuICB9XG5cbiAgY29uc3QgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgY29uc3QgbG9uMSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxeDtcbiAgY29uc3QgbG9uMiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyeDtcbiAgY29uc3QgbGF0MSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxeTtcbiAgY29uc3QgbGF0MiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyeTtcbiAgY29uc3QgYSA9IE1hdGguc2luKGxvbjIgLSBsb24xKSAqIE1hdGguY29zKGxhdDIpO1xuICBjb25zdCBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIgLSBsb24xKTtcbiAgcmV0dXJuIHZlYzMubm9ybWFsaXplKFtdLCBbYiwgMCwgLWFdKTtcbn1cbiJdfQ==

/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonTesselator; });
/* unused harmony export flattenVertices2 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(10);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Handles tesselation of polygons with holes
// - 2D surfaces
// - 2D outlines
// - 3D surfaces (top and sides only)
// - 3D wireframes (not yet)





// Maybe deck.gl or luma.gl needs to export this
function getPickingColor(index) {
  return [(index + 1) % 256, Math.floor((index + 1) / 256) % 256, Math.floor((index + 1) / 256 / 256) % 256];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 1), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 2), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

// This class is set up to allow querying one attribute at a time
// the way the AttributeManager expects it
var PolygonTesselator = function () {
  function PolygonTesselator(_ref) {
    var polygons = _ref.polygons,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselator);

    // Normalize all polygons
    this.polygons = polygons.map(function (polygon) {
      return __WEBPACK_IMPORTED_MODULE_0__polygon__["a" /* normalize */](polygon);
    });
    // Count all polygon vertices
    this.pointCount = getPointCount(this.polygons);
    this.fp64 = fp64;
  }

  _createClass(PolygonTesselator, [{
    key: 'indices',
    value: function indices() {
      var polygons = this.polygons,
          indexCount = this.indexCount;

      return calculateIndices({ polygons: polygons, indexCount: indexCount });
    }
  }, {
    key: 'positions',
    value: function positions() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculatePositions({ polygons: polygons, pointCount: pointCount, fp64: this.fp64 });
    }
  }, {
    key: 'normals',
    value: function normals() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculateNormals({ polygons: polygons, pointCount: pointCount });
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculateColors({ polygons: polygons, pointCount: pointCount, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculatePickingColors({ polygons: polygons, pointCount: pointCount });
    }

    // getAttribute({size, accessor}) {
    //   const {polygons, pointCount} = this;
    //   return calculateAttribute({polygons, pointCount, size, accessor});
    // }

  }]);

  return PolygonTesselator;
}();

// Count number of points in a list of complex polygons
function getPointCount(polygons) {
  return polygons.reduce(function (points, polygon) {
    return points + __WEBPACK_IMPORTED_MODULE_0__polygon__["b" /* getVertexCount */](polygon);
  }, 0);
}

// COunt number of triangles in a list of complex polygons
function getTriangleCount(polygons) {
  return polygons.reduce(function (triangles, polygon) {
    return triangles + __WEBPACK_IMPORTED_MODULE_0__polygon__["c" /* getTriangleCount */](polygon);
  }, 0);
}

// Returns the offsets of each complex polygon in the combined array of all polygons
function getPolygonOffsets(polygons) {
  var offsets = new Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["e" /* count */])(polygons) + 1);
  offsets[0] = 0;
  var offset = 0;
  polygons.forEach(function (polygon, i) {
    offset += __WEBPACK_IMPORTED_MODULE_0__polygon__["b" /* getVertexCount */](polygon);
    offsets[i + 1] = offset;
  });
  return offsets;
}

// Returns the offset of each hole polygon in the flattened array for that polygon
function getHoleIndices(complexPolygon) {
  var holeIndices = null;
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["e" /* count */])(complexPolygon) > 1) {
    var polygonStartIndex = 0;
    holeIndices = [];
    complexPolygon.forEach(function (polygon) {
      polygonStartIndex += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["e" /* count */])(polygon);
      holeIndices.push(polygonStartIndex);
    });
    // Last element points to end of the flat array, remove it
    holeIndices.pop();
  }
  return holeIndices;
}

function calculateIndices(_ref3) {
  var polygons = _ref3.polygons,
      _ref3$IndexType = _ref3.IndexType,
      IndexType = _ref3$IndexType === undefined ? Uint32Array : _ref3$IndexType;

  // Calculate length of index array (3 * number of triangles)
  var indexCount = 3 * getTriangleCount(polygons);
  var offsets = getPolygonOffsets(polygons);

  // Allocate the attribute
  // TODO it's not the index count but the vertex count that must be checked
  if (IndexType === Uint16Array && indexCount > 65535) {
    throw new Error('Vertex count exceeds browser\'s limit');
  }
  var attribute = new IndexType(indexCount);

  // 1. get triangulated indices for the internal areas
  // 2. offset them by the number of indices in previous polygons
  var i = 0;
  polygons.forEach(function (polygon, polygonIndex) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = calculateSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var index = _step.value;

        attribute[i++] = index + offsets[polygonIndex];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  return attribute;
}

/*
 * Get vertex indices for drawing complexPolygon mesh
 * @private
 * @param {[Number,Number,Number][][]} complexPolygon
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(complexPolygon) {
  // Prepare an array of hole indices as expected by earcut
  var holeIndices = getHoleIndices(complexPolygon);
  // Flatten the polygon as expected by earcut
  var verts = flattenVertices2(complexPolygon);
  // Let earcut triangulate the polygon
  return __WEBPACK_IMPORTED_MODULE_1_earcut___default()(verts, holeIndices, 3);
}

// TODO - refactor
function isContainer(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) || value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

// TODO - refactor, this file should not need a separate flatten func
// Flattens nested array of vertices, padding third coordinate as needed
function flattenVertices2(nestedArray) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$result = _ref4.result,
      result = _ref4$result === undefined ? [] : _ref4$result,
      _ref4$dimensions = _ref4.dimensions,
      dimensions = _ref4$dimensions === undefined ? 3 : _ref4$dimensions;

  var index = -1;
  var vertexLength = 0;
  var length = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["e" /* count */])(nestedArray);
  while (++index < length) {
    var value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(nestedArray, index);
    if (isContainer(value)) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["f" /* flattenVertices */])(value, { result: result, dimensions: dimensions });
    } else {
      if (vertexLength < dimensions) {
        // eslint-disable-line
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

function calculatePositions(_ref5) {
  var polygons = _ref5.polygons,
      pointCount = _ref5.pointCount,
      fp64 = _ref5.fp64;

  // Flatten out all the vertices of all the sub subPolygons
  var attribute = new Float32Array(pointCount * 3);
  var attributeLow = void 0;
  if (fp64) {
    // We only need x, y component
    attributeLow = new Float32Array(pointCount * 2);
  }
  var i = 0;
  var j = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = polygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var polygon = _step2.value;

      __WEBPACK_IMPORTED_MODULE_0__polygon__["d" /* forEachVertex */](polygon, function (vertex) {
        // eslint-disable-line
        var x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(vertex, 0);
        var y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(vertex, 1);
        var z = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["d" /* get */])(vertex, 2) || 0;
        attribute[i++] = x;
        attribute[i++] = y;
        attribute[i++] = z;
        if (fp64) {
          attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(x)[1];
          attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__["a" /* fp64ify */])(y)[1];
        }
      });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return { positions: attribute, positions64xyLow: attributeLow };
}

function calculateNormals(_ref6) {
  var polygons = _ref6.polygons,
      pointCount = _ref6.pointCount;

  // TODO - use generic vertex attribute?
  var attribute = new Float32Array(pointCount * 3);
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["g" /* fillArray */])({ target: attribute, source: [0, 1, 0], start: 0, pointCount: pointCount });
  return attribute;
}

function calculateColors(_ref7) {
  var polygons = _ref7.polygons,
      pointCount = _ref7.pointCount,
      getColor = _ref7.getColor;

  var attribute = new Uint8ClampedArray(pointCount * 4);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    // Calculate polygon color
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var vertexCount = __WEBPACK_IMPORTED_MODULE_0__polygon__["b" /* getVertexCount */](complexPolygon);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["g" /* fillArray */])({ target: attribute, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return attribute;
}

function calculatePickingColors(_ref8) {
  var polygons = _ref8.polygons,
      pointCount = _ref8.pointCount;

  var attribute = new Uint8ClampedArray(pointCount * 3);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    var color = getPickingColor(polygonIndex);
    var vertexCount = __WEBPACK_IMPORTED_MODULE_0__polygon__["b" /* getVertexCount */](complexPolygon);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__["g" /* fillArray */])({ target: attribute, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return attribute;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZWFyY3V0IiwiZ2V0IiwiY291bnQiLCJmbGF0dGVuVmVydGljZXMiLCJmaWxsQXJyYXkiLCJmcDY0aWZ5IiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvciIsInBvbHlnb25zIiwiZnA2NCIsIm1hcCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJwb2ludENvdW50IiwiZ2V0UG9pbnRDb3VudCIsImluZGV4Q291bnQiLCJjYWxjdWxhdGVJbmRpY2VzIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiY2FsY3VsYXRlTm9ybWFscyIsImdldENvbG9yIiwiY2FsY3VsYXRlQ29sb3JzIiwiY2FsY3VsYXRlUGlja2luZ0NvbG9ycyIsInJlZHVjZSIsInBvaW50cyIsImdldFZlcnRleENvdW50IiwiZ2V0VHJpYW5nbGVDb3VudCIsInRyaWFuZ2xlcyIsImdldFBvbHlnb25PZmZzZXRzIiwib2Zmc2V0cyIsIm9mZnNldCIsImZvckVhY2giLCJpIiwiZ2V0SG9sZUluZGljZXMiLCJjb21wbGV4UG9seWdvbiIsImhvbGVJbmRpY2VzIiwicG9seWdvblN0YXJ0SW5kZXgiLCJwdXNoIiwicG9wIiwiSW5kZXhUeXBlIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkVycm9yIiwiYXR0cmlidXRlIiwicG9seWdvbkluZGV4IiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJ2ZXJ0cyIsImZsYXR0ZW5WZXJ0aWNlczIiLCJpc0NvbnRhaW5lciIsInZhbHVlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJuZXN0ZWRBcnJheSIsInJlc3VsdCIsImRpbWVuc2lvbnMiLCJ2ZXJ0ZXhMZW5ndGgiLCJsZW5ndGgiLCJGbG9hdDMyQXJyYXkiLCJhdHRyaWJ1dGVMb3ciLCJqIiwiZm9yRWFjaFZlcnRleCIsIngiLCJ2ZXJ0ZXgiLCJ5IiwieiIsInBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJ0YXJnZXQiLCJzb3VyY2UiLCJzdGFydCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwidmVydGV4Q291bnQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUtBLE9BQVosTUFBeUIsV0FBekI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxLQUFiLEVBQW9CQyxlQUFwQixFQUFxQ0MsU0FBckMsUUFBcUQsb0JBQXJEO0FBQ0EsU0FBUUMsT0FBUixRQUFzQix5QkFBdEI7O0FBRUE7QUFDQSxTQUFTQyxlQUFULENBQXlCQyxLQUF6QixFQUFnQztBQUM5QixTQUFPLENBQ0wsQ0FBQ0EsUUFBUSxDQUFULElBQWMsR0FEVCxFQUVMQyxLQUFLQyxLQUFMLENBQVcsQ0FBQ0YsUUFBUSxDQUFULElBQWMsR0FBekIsSUFBZ0MsR0FGM0IsRUFHTEMsS0FBS0MsS0FBTCxDQUFXLENBQUNGLFFBQVEsQ0FBVCxJQUFjLEdBQWQsR0FBb0IsR0FBL0IsSUFBc0MsR0FIakMsQ0FBUDtBQUtEOztBQUVELFNBQVNHLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUwsRUFBMkI7QUFDekJBLFlBQVEsQ0FBQ1YsSUFBSVUsS0FBSixFQUFXLENBQVgsQ0FBRCxFQUFnQlYsSUFBSVUsS0FBSixFQUFXLENBQVgsQ0FBaEIsRUFB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QyxjQUFVLEVBQUN3RSxRQUFReEIsU0FBVCxFQUFvQnlCLFFBQVFsRSxLQUE1QixFQUFtQ21FLE9BQU9yQyxDQUExQyxFQUE2Q3ZDLE9BQU84RSxXQUFwRCxFQUFWO0FBQ0F2QyxTQUFLOUIsTUFBTXNELE1BQU4sR0FBZWUsV0FBcEI7QUFDRCxHQUxEO0FBTUEsU0FBTzVCLFNBQVA7QUFDRCIsImZpbGUiOiJwb2x5Z29uLXRlc3NlbGF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gSGFuZGxlcyB0ZXNzZWxhdGlvbiBvZiBwb2x5Z29ucyB3aXRoIGhvbGVzXG4vLyAtIDJEIHN1cmZhY2VzXG4vLyAtIDJEIG91dGxpbmVzXG4vLyAtIDNEIHN1cmZhY2VzICh0b3AgYW5kIHNpZGVzIG9ubHkpXG4vLyAtIDNEIHdpcmVmcmFtZXMgKG5vdCB5ZXQpXG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQge2dldCwgY291bnQsIGZsYXR0ZW5WZXJ0aWNlcywgZmlsbEFycmF5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHtmcDY0aWZ5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5cbi8vIE1heWJlIGRlY2suZ2wgb3IgbHVtYS5nbCBuZWVkcyB0byBleHBvcnQgdGhpc1xuZnVuY3Rpb24gZ2V0UGlja2luZ0NvbG9yKGluZGV4KSB7XG4gIHJldHVybiBbXG4gICAgKGluZGV4ICsgMSkgJSAyNTYsXG4gICAgTWF0aC5mbG9vcigoaW5kZXggKyAxKSAvIDI1NikgJSAyNTYsXG4gICAgTWF0aC5mbG9vcigoaW5kZXggKyAxKSAvIDI1NiAvIDI1NikgJSAyNTZcbiAgXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb2xvcihjb2xvcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgY29sb3IgPSBbZ2V0KGNvbG9yLCAwKSwgZ2V0KGNvbG9yLCAxKSwgZ2V0KGNvbG9yLCAyKSwgZ2V0KGNvbG9yLCAzKV07XG4gIH1cbiAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdOyAvLyBCbGFja1xuXG4vLyBUaGlzIGNsYXNzIGlzIHNldCB1cCB0byBhbGxvdyBxdWVyeWluZyBvbmUgYXR0cmlidXRlIGF0IGEgdGltZVxuLy8gdGhlIHdheSB0aGUgQXR0cmlidXRlTWFuYWdlciBleHBlY3RzIGl0XG5leHBvcnQgY2xhc3MgUG9seWdvblRlc3NlbGF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7cG9seWdvbnMsIGZwNjQgPSBmYWxzZX0pIHtcbiAgICAvLyBOb3JtYWxpemUgYWxsIHBvbHlnb25zXG4gICAgdGhpcy5wb2x5Z29ucyA9IHBvbHlnb25zLm1hcChwb2x5Z29uID0+IFBvbHlnb24ubm9ybWFsaXplKHBvbHlnb24pKTtcbiAgICAvLyBDb3VudCBhbGwgcG9seWdvbiB2ZXJ0aWNlc1xuICAgIHRoaXMucG9pbnRDb3VudCA9IGdldFBvaW50Q291bnQodGhpcy5wb2x5Z29ucyk7XG4gICAgdGhpcy5mcDY0ID0gZnA2NDtcbiAgfVxuXG4gIGluZGljZXMoKSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBpbmRleENvdW50fSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUluZGljZXMoe3BvbHlnb25zLCBpbmRleENvdW50fSk7XG4gIH1cblxuICBwb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBwb2ludENvdW50fSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9ucyh7cG9seWdvbnMsIHBvaW50Q291bnQsIGZwNjQ6IHRoaXMuZnA2NH0pO1xuICB9XG5cbiAgbm9ybWFscygpIHtcbiAgICBjb25zdCB7cG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlTm9ybWFscyh7cG9seWdvbnMsIHBvaW50Q291bnR9KTtcbiAgfVxuXG4gIGNvbG9ycyh7Z2V0Q29sb3IgPSB4ID0+IERFRkFVTFRfQ09MT1J9ID0ge30pIHtcbiAgICBjb25zdCB7cG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0Q29sb3J9KTtcbiAgfVxuXG4gIHBpY2tpbmdDb2xvcnMoKSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBwb2ludENvdW50fSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe3BvbHlnb25zLCBwb2ludENvdW50fSk7XG4gIH1cblxuICAvLyBnZXRBdHRyaWJ1dGUoe3NpemUsIGFjY2Vzc29yfSkge1xuICAvLyAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAvLyAgIHJldHVybiBjYWxjdWxhdGVBdHRyaWJ1dGUoe3BvbHlnb25zLCBwb2ludENvdW50LCBzaXplLCBhY2Nlc3Nvcn0pO1xuICAvLyB9XG59XG5cbi8vIENvdW50IG51bWJlciBvZiBwb2ludHMgaW4gYSBsaXN0IG9mIGNvbXBsZXggcG9seWdvbnNcbmZ1bmN0aW9uIGdldFBvaW50Q291bnQocG9seWdvbnMpIHtcbiAgcmV0dXJuIHBvbHlnb25zLnJlZHVjZSgocG9pbnRzLCBwb2x5Z29uKSA9PiBwb2ludHMgKyBQb2x5Z29uLmdldFZlcnRleENvdW50KHBvbHlnb24pLCAwKTtcbn1cblxuLy8gQ091bnQgbnVtYmVyIG9mIHRyaWFuZ2xlcyBpbiBhIGxpc3Qgb2YgY29tcGxleCBwb2x5Z29uc1xuZnVuY3Rpb24gZ2V0VHJpYW5nbGVDb3VudChwb2x5Z29ucykge1xuICByZXR1cm4gcG9seWdvbnMucmVkdWNlKCh0cmlhbmdsZXMsIHBvbHlnb24pID0+IHRyaWFuZ2xlcyArIFBvbHlnb24uZ2V0VHJpYW5nbGVDb3VudChwb2x5Z29uKSwgMCk7XG59XG5cbi8vIFJldHVybnMgdGhlIG9mZnNldHMgb2YgZWFjaCBjb21wbGV4IHBvbHlnb24gaW4gdGhlIGNvbWJpbmVkIGFycmF5IG9mIGFsbCBwb2x5Z29uc1xuZnVuY3Rpb24gZ2V0UG9seWdvbk9mZnNldHMocG9seWdvbnMpIHtcbiAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudChwb2x5Z29ucykgKyAxKTtcbiAgb2Zmc2V0c1swXSA9IDA7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChwb2x5Z29uLCBpKSA9PiB7XG4gICAgb2Zmc2V0ICs9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQocG9seWdvbik7XG4gICAgb2Zmc2V0c1tpICsgMV0gPSBvZmZzZXQ7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLy8gUmV0dXJucyB0aGUgb2Zmc2V0IG9mIGVhY2ggaG9sZSBwb2x5Z29uIGluIHRoZSBmbGF0dGVuZWQgYXJyYXkgZm9yIHRoYXQgcG9seWdvblxuZnVuY3Rpb24gZ2V0SG9sZUluZGljZXMoY29tcGxleFBvbHlnb24pIHtcbiAgbGV0IGhvbGVJbmRpY2VzID0gbnVsbDtcbiAgaWYgKGNvdW50KGNvbXBsZXhQb2x5Z29uKSA+IDEpIHtcbiAgICBsZXQgcG9seWdvblN0YXJ0SW5kZXggPSAwO1xuICAgIGhvbGVJbmRpY2VzID0gW107XG4gICAgY29tcGxleFBvbHlnb24uZm9yRWFjaChwb2x5Z29uID0+IHtcbiAgICAgIHBvbHlnb25TdGFydEluZGV4ICs9IGNvdW50KHBvbHlnb24pO1xuICAgICAgaG9sZUluZGljZXMucHVzaChwb2x5Z29uU3RhcnRJbmRleCk7XG4gICAgfSk7XG4gICAgLy8gTGFzdCBlbGVtZW50IHBvaW50cyB0byBlbmQgb2YgdGhlIGZsYXQgYXJyYXksIHJlbW92ZSBpdFxuICAgIGhvbGVJbmRpY2VzLnBvcCgpO1xuICB9XG4gIHJldHVybiBob2xlSW5kaWNlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW5kaWNlcyh7cG9seWdvbnMsIEluZGV4VHlwZSA9IFVpbnQzMkFycmF5fSkge1xuICAvLyBDYWxjdWxhdGUgbGVuZ3RoIG9mIGluZGV4IGFycmF5ICgzICogbnVtYmVyIG9mIHRyaWFuZ2xlcylcbiAgY29uc3QgaW5kZXhDb3VudCA9IDMgKiBnZXRUcmlhbmdsZUNvdW50KHBvbHlnb25zKTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGdldFBvbHlnb25PZmZzZXRzKHBvbHlnb25zKTtcblxuICAvLyBBbGxvY2F0ZSB0aGUgYXR0cmlidXRlXG4gIC8vIFRPRE8gaXQncyBub3QgdGhlIGluZGV4IGNvdW50IGJ1dCB0aGUgdmVydGV4IGNvdW50IHRoYXQgbXVzdCBiZSBjaGVja2VkXG4gIGlmIChJbmRleFR5cGUgPT09IFVpbnQxNkFycmF5ICYmIGluZGV4Q291bnQgPiA2NTUzNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IGNvdW50IGV4Y2VlZHMgYnJvd3NlclxcJ3MgbGltaXQnKTtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgSW5kZXhUeXBlKGluZGV4Q291bnQpO1xuXG4gIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICBsZXQgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKHBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgY2FsY3VsYXRlU3VyZmFjZUluZGljZXMocG9seWdvbikpIHtcbiAgICAgIGF0dHJpYnV0ZVtpKytdID0gaW5kZXggKyBvZmZzZXRzW3BvbHlnb25JbmRleF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlO1xufVxuXG4vKlxuICogR2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNvbXBsZXhQb2x5Z29uIG1lc2hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjb21wbGV4UG9seWdvblxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNvbXBsZXhQb2x5Z29uKSB7XG4gIC8vIFByZXBhcmUgYW4gYXJyYXkgb2YgaG9sZSBpbmRpY2VzIGFzIGV4cGVjdGVkIGJ5IGVhcmN1dFxuICBjb25zdCBob2xlSW5kaWNlcyA9IGdldEhvbGVJbmRpY2VzKGNvbXBsZXhQb2x5Z29uKTtcbiAgLy8gRmxhdHRlbiB0aGUgcG9seWdvbiBhcyBleHBlY3RlZCBieSBlYXJjdXRcbiAgY29uc3QgdmVydHMgPSBmbGF0dGVuVmVydGljZXMyKGNvbXBsZXhQb2x5Z29uKTtcbiAgLy8gTGV0IGVhcmN1dCB0cmlhbmd1bGF0ZSB0aGUgcG9seWdvblxuICByZXR1cm4gZWFyY3V0KHZlcnRzLCBob2xlSW5kaWNlcywgMyk7XG59XG5cbi8vIFRPRE8gLSByZWZhY3RvclxuZnVuY3Rpb24gaXNDb250YWluZXIodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHxcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4vLyBUT0RPIC0gcmVmYWN0b3IsIHRoaXMgZmlsZSBzaG91bGQgbm90IG5lZWQgYSBzZXBhcmF0ZSBmbGF0dGVuIGZ1bmNcbi8vIEZsYXR0ZW5zIG5lc3RlZCBhcnJheSBvZiB2ZXJ0aWNlcywgcGFkZGluZyB0aGlyZCBjb29yZGluYXRlIGFzIG5lZWRlZFxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5WZXJ0aWNlczIobmVzdGVkQXJyYXksIHtyZXN1bHQgPSBbXSwgZGltZW5zaW9ucyA9IDN9ID0ge30pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCB2ZXJ0ZXhMZW5ndGggPSAwO1xuICBjb25zdCBsZW5ndGggPSBjb3VudChuZXN0ZWRBcnJheSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXQobmVzdGVkQXJyYXksIGluZGV4KTtcbiAgICBpZiAoaXNDb250YWluZXIodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuVmVydGljZXModmFsdWUsIHtyZXN1bHQsIGRpbWVuc2lvbnN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0LnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZnA2NH0pIHtcbiAgLy8gRmxhdHRlbiBvdXQgYWxsIHRoZSB2ZXJ0aWNlcyBvZiBhbGwgdGhlIHN1YiBzdWJQb2x5Z29uc1xuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAzKTtcbiAgbGV0IGF0dHJpYnV0ZUxvdztcbiAgaWYgKGZwNjQpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgeCwgeSBjb21wb25lbnRcbiAgICBhdHRyaWJ1dGVMb3cgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAyKTtcbiAgfVxuICBsZXQgaSA9IDA7XG4gIGxldCBqID0gMDtcbiAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHBvbHlnb25zKSB7XG4gICAgUG9seWdvbi5mb3JFYWNoVmVydGV4KHBvbHlnb24sIHZlcnRleCA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnN0IHggPSBnZXQodmVydGV4LCAwKTtcbiAgICAgIGNvbnN0IHkgPSBnZXQodmVydGV4LCAxKTtcbiAgICAgIGNvbnN0IHogPSBnZXQodmVydGV4LCAyKSB8fCAwO1xuICAgICAgYXR0cmlidXRlW2krK10gPSB4O1xuICAgICAgYXR0cmlidXRlW2krK10gPSB5O1xuICAgICAgYXR0cmlidXRlW2krK10gPSB6O1xuICAgICAgaWYgKGZwNjQpIHtcbiAgICAgICAgYXR0cmlidXRlTG93W2orK10gPSBmcDY0aWZ5KHgpWzFdO1xuICAgICAgICBhdHRyaWJ1dGVMb3dbaisrXSA9IGZwNjRpZnkoeSlbMV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtwb3NpdGlvbnM6IGF0dHJpYnV0ZSwgcG9zaXRpb25zNjR4eUxvdzogYXR0cmlidXRlTG93fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFscyh7cG9seWdvbnMsIHBvaW50Q291bnR9KSB7XG4gIC8vIFRPRE8gLSB1c2UgZ2VuZXJpYyB2ZXJ0ZXggYXR0cmlidXRlP1xuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAzKTtcbiAgZmlsbEFycmF5KHt0YXJnZXQ6IGF0dHJpYnV0ZSwgc291cmNlOiBbMCwgMSwgMF0sIHN0YXJ0OiAwLCBwb2ludENvdW50fSk7XG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnQsIGdldENvbG9yfSkge1xuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocG9pbnRDb3VudCAqIDQpO1xuICBsZXQgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICAvLyBDYWxjdWxhdGUgcG9seWdvbiBjb2xvclxuICAgIGxldCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3IgPSBwYXJzZUNvbG9yKGNvbG9yKTtcblxuICAgIGNvbnN0IHZlcnRleENvdW50ID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChjb21wbGV4UG9seWdvbik7XG4gICAgZmlsbEFycmF5KHt0YXJnZXQ6IGF0dHJpYnV0ZSwgc291cmNlOiBjb2xvciwgc3RhcnQ6IGksIGNvdW50OiB2ZXJ0ZXhDb3VudH0pO1xuICAgIGkgKz0gY29sb3IubGVuZ3RoICogdmVydGV4Q291bnQ7XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudH0pIHtcbiAgY29uc3QgYXR0cmlidXRlID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBvaW50Q291bnQgKiAzKTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgY29sb3IgPSBnZXRQaWNraW5nQ29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIHZlcnRleENvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cbiJdfQ==

/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME solid-polygon-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHNvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbi8vIFBJQ0tJTkdcbi8vIHVuaWZvcm0gYm9vbCBwaWNraW5nRW5hYmxlZDtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xudmVjNCBwaWNraW5nX2dldENvbG9yKCkge1xuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcbn1cbi8vIFBJQ0tJTkdcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19nZXRDb2xvcigpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME solid-polygon-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float extruded;\nuniform float opacity;\n\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\n\nvoid main(void) {\n  vec4 positions64xy = vec4(positions.x, positions64xyLow.x, positions.y, positions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(positions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(project_scale(positions.z), 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  if (pickingEnabled < 0.5) {\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace.xyz, // the w component is always 1.0\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\n\n    vPickingColor = color;\n\n  } else {\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoic29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2hhZGVyLTY0XG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xuYXR0cmlidXRlIHZlYzMgcGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcblxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBQSUNLSU5HXG51bmlmb3JtIGZsb2F0IHBpY2tpbmdFbmFibGVkO1xudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzQgcG9zaXRpb25zNjR4eSA9IHZlYzQocG9zaXRpb25zLngsIHBvc2l0aW9uczY0eHlMb3cueCwgcG9zaXRpb25zLnksIHBvc2l0aW9uczY0eHlMb3cueSk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfY29vcmRfeHlbMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChwb3NpdGlvbnM2NHh5LCBwcm9qZWN0ZWRfY29vcmRfeHkpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBwcm9qZWN0ZWRfY29vcmRfeHlbMF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHByb2plY3RlZF9jb29yZF94eVsxXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gdmVjMihwcm9qZWN0X3NjYWxlKHBvc2l0aW9ucy56KSwgMC4wKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChcbiAgICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdLngsXG4gICAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXS54KTtcblxuICBpZiAocGlja2luZ0VuYWJsZWQgPCAwLjUpIHtcbiAgICBmbG9hdCBsaWdodFdlaWdodCA9IDEuMDtcblxuICAgIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgICAgbGlnaHRXZWlnaHQgPSBnZXRMaWdodFdlaWdodChcbiAgICAgICAgcG9zaXRpb25fd29ybGRzcGFjZS54eXosIC8vIHRoZSB3IGNvbXBvbmVudCBpcyBhbHdheXMgMS4wXG4gICAgICAgIG5vcm1hbHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGNvbG9ycy5yZ2I7XG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjA7XG5cbiAgICB2UGlja2luZ0NvbG9yID0gY29sb3I7XG5cbiAgfSBlbHNlIHtcbiAgICB2UGlja2luZ0NvbG9yID0gdmVjNChwaWNraW5nQ29sb3JzLnJnYiAvIDI1NS4wLCAxLjApO1xuICB9XG59XG5gO1xuIl19

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float extruded;\nuniform float opacity;\n\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\n\nvoid main(void) {\n  vec4 position_worldspace = vec4(project_position(positions), 1.0);\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  if (pickingEnabled < 0.5) {\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      // Here, the input parameters should be\n      // position_worldspace.xyz / position_worldspace.w.\n      // However, this calculation generates all zeros on\n      // MacBook Pro with Intel Iris Pro GPUs for unclear reasons.\n      // (see https://github.com/uber/deck.gl/issues/559)\n      // Since the w component is always 1.0 in our shaders,\n      // we decided to just provide xyz component of position_worldspace\n      // to the getLightWeight() function\n      lightWeight = getLightWeight(\n        position_worldspace.xyz,\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\n\n    vPickingColor = color;\n\n  } else {\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoic29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG5hdHRyaWJ1dGUgdmVjNCBjb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBwaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IGV4dHJ1ZGVkO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XG5cbi8vIFBJQ0tJTkdcbnVuaWZvcm0gZmxvYXQgcGlja2luZ0VuYWJsZWQ7XG52YXJ5aW5nIHZlYzQgdlBpY2tpbmdDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9ucyksIDEuMCk7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb25fd29ybGRzcGFjZSk7XG5cbiAgaWYgKHBpY2tpbmdFbmFibGVkIDwgMC41KSB7XG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XG5cbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICAgIC8vIEhlcmUsIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgICAgLy8gcG9zaXRpb25fd29ybGRzcGFjZS54eXogLyBwb3NpdGlvbl93b3JsZHNwYWNlLncuXG4gICAgICAvLyBIb3dldmVyLCB0aGlzIGNhbGN1bGF0aW9uIGdlbmVyYXRlcyBhbGwgemVyb3Mgb25cbiAgICAgIC8vIE1hY0Jvb2sgUHJvIHdpdGggSW50ZWwgSXJpcyBQcm8gR1BVcyBmb3IgdW5jbGVhciByZWFzb25zLlxuICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy81NTkpXG4gICAgICAvLyBTaW5jZSB0aGUgdyBjb21wb25lbnQgaXMgYWx3YXlzIDEuMCBpbiBvdXIgc2hhZGVycyxcbiAgICAgIC8vIHdlIGRlY2lkZWQgdG8ganVzdCBwcm92aWRlIHh5eiBjb21wb25lbnQgb2YgcG9zaXRpb25fd29ybGRzcGFjZVxuICAgICAgLy8gdG8gdGhlIGdldExpZ2h0V2VpZ2h0KCkgZnVuY3Rpb25cbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UueHl6LFxuICAgICAgICBub3JtYWxzXG4gICAgICApO1xuICAgIH1cblxuICAgIHZlYzMgbGlnaHRXZWlnaHRlZENvbG9yID0gbGlnaHRXZWlnaHQgKiBjb2xvcnMucmdiO1xuICAgIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ZWRDb2xvciwgY29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS4wO1xuXG4gICAgdlBpY2tpbmdDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG4gICAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9ycy5yZ2IgLyAyNTUuMCwgMS4wKTtcbiAgfVxufVxuYDtcbiJdfQ==

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__choropleth_layer_vertex_64_glsl__ = __webpack_require__(180);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.







var ChoroplethLayer64 = function (_ChoroplethLayer) {
  _inherits(ChoroplethLayer64, _ChoroplethLayer);

  function ChoroplethLayer64(props) {
    _classCallCheck(this, ChoroplethLayer64);

    var _this = _possibleConstructorReturn(this, (ChoroplethLayer64.__proto__ || Object.getPrototypeOf(ChoroplethLayer64)).call(this, props));

    __WEBPACK_IMPORTED_MODULE_1__lib_utils__["a" /* log */].once('ChoroplethLayer64 is deprecated. Consider using GeoJsonLayer instead');
    return _this;
  }

  _createClass(ChoroplethLayer64, [{
    key: 'initializeState',
    value: function initializeState() {
      _get(ChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer64.prototype), 'initializeState', this).call(this);

      this.state.attributeManager.add({
        positions64: { size: 4, update: this.calculatePositions64 },
        heights64: { size: 2, update: this.calculateHeights64 }
      });
    }
  }, {
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: __WEBPACK_IMPORTED_MODULE_3__choropleth_layer_vertex_64_glsl__["a" /* default */],
        fs: _get(ChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer64.prototype), 'getShaders', this).call(this).fs,
        fp64: true,
        project64: true
      };
    }
  }, {
    key: 'calculatePositions64',
    value: function calculatePositions64(attribute) {
      var vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);
      attribute.value = new Float32Array(vertices.length / 3 * 4);
      for (var index = 0; index < vertices.length / 3; index++) {
        var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__["c" /* fp64ify */])(vertices[index * 3]);

        var _fp64ify2 = _slicedToArray(_fp64ify, 2);

        attribute.value[index * 4] = _fp64ify2[0];
        attribute.value[index * 4 + 1] = _fp64ify2[1];

        var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__["c" /* fp64ify */])(vertices[index * 3 + 1]);

        var _fp64ify4 = _slicedToArray(_fp64ify3, 2);

        attribute.value[index * 4 + 2] = _fp64ify4[0];
        attribute.value[index * 4 + 3] = _fp64ify4[1];
      }
    }
  }, {
    key: 'calculateHeights64',
    value: function calculateHeights64(attribute) {
      var vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);
      attribute.value = new Float32Array(vertices.length / 3 * 2);
      for (var index = 0; index < vertices.length / 3; index++) {
        var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__["c" /* fp64ify */])(vertices[index * 3 + 2]);

        var _fp64ify6 = _slicedToArray(_fp64ify5, 2);

        attribute.value[index * 2] = _fp64ify6[0];
        attribute.value[index * 2 + 1] = _fp64ify6[1];
      }
    }
  }]);

  return ChoroplethLayer64;
}(__WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ChoroplethLayer64);


ChoroplethLayer64.layerName = 'ChoroplethLayer64';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyLTY0L2Nob3JvcGxldGgtbGF5ZXItNjQuanMiXSwibmFtZXMiOlsiQ2hvcm9wbGV0aExheWVyIiwiZnA2NGlmeSIsImxvZyIsImZsYXR0ZW5EZWVwIiwiY2hvcm9wbGV0aFZlcnRleDY0IiwiQ2hvcm9wbGV0aExheWVyNjQiLCJwcm9wcyIsIm9uY2UiLCJzdGF0ZSIsImF0dHJpYnV0ZU1hbmFnZXIiLCJhZGQiLCJwb3NpdGlvbnM2NCIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVQb3NpdGlvbnM2NCIsImhlaWdodHM2NCIsImNhbGN1bGF0ZUhlaWdodHM2NCIsInZzIiwiZnMiLCJmcDY0IiwicHJvamVjdDY0IiwiYXR0cmlidXRlIiwidmVydGljZXMiLCJjaG9yb3BsZXRocyIsInZhbHVlIiwiRmxvYXQzMkFycmF5IiwibGVuZ3RoIiwiaW5kZXgiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQVAsTUFBNEIsc0NBQTVCO0FBQ0EsU0FBUUMsT0FBUixFQUFpQkMsR0FBakIsUUFBMkIsb0JBQTNCO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QixvQkFBeEI7O0FBRUEsT0FBT0Msa0JBQVAsTUFBK0IsbUNBQS9COztJQUVxQkMsaUI7OztBQUVuQiw2QkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLHNJQUNYQSxLQURXOztBQUVqQkosUUFBSUssSUFBSixDQUFTLHNFQUFUO0FBRmlCO0FBR2xCOzs7O3NDQUVpQjtBQUNoQjs7QUFFQSxXQUFLQyxLQUFMLENBQVdDLGdCQUFYLENBQTRCQyxHQUE1QixDQUFnQztBQUM5QkMscUJBQWEsRUFBQ0MsTUFBTSxDQUFQLEVBQVVDLFFBQVEsS0FBS0Msb0JBQXZCLEVBRGlCO0FBRTlCQyxtQkFBVyxFQUFDSCxNQUFNLENBQVAsRUFBVUMsUUFBUSxLQUFLRyxrQkFBdkI7QUFGbUIsT0FBaEM7QUFJRDs7O2lDQUVZO0FBQ1gsYUFBTztBQUNMQyxZQUFJYixrQkFEQztBQUVMYyxZQUFJLGlJQUFtQkEsRUFGbEI7QUFHTEMsY0FBTSxJQUhEO0FBSUxDLG1CQUFXO0FBSk4sT0FBUDtBQU1EOzs7eUNBRW9CQyxTLEVBQVc7QUFDOUIsVUFBTUMsV0FBV25CLFlBQVksS0FBS0ssS0FBTCxDQUFXZSxXQUF2QixDQUFqQjtBQUNBRixnQkFBVUcsS0FBVixHQUFrQixJQUFJQyxZQUFKLENBQWlCSCxTQUFTSSxNQUFULEdBQWtCLENBQWxCLEdBQXNCLENBQXZDLENBQWxCO0FBQ0EsV0FBSyxJQUFJQyxRQUFRLENBQWpCLEVBQW9CQSxRQUFRTCxTQUFTSSxNQUFULEdBQWtCLENBQTlDLEVBQWlEQyxPQUFqRCxFQUEwRDtBQUFBLHVCQUlwRDFCLFFBQVFxQixTQUFTSyxRQUFRLENBQWpCLENBQVIsQ0FKb0Q7O0FBQUE7O0FBRXRETixrQkFBVUcsS0FBVixDQUFnQkcsUUFBUSxDQUF4QixDQUZzRDtBQUd0RE4sa0JBQVVHLEtBQVYsQ0FBZ0JHLFFBQVEsQ0FBUixHQUFZLENBQTVCLENBSHNEOztBQUFBLHdCQVFwRDFCLFFBQVFxQixTQUFTSyxRQUFRLENBQVIsR0FBWSxDQUFyQixDQUFSLENBUm9EOztBQUFBOztBQU10RE4sa0JBQVVHLEtBQVYsQ0FBZ0JHLFFBQVEsQ0FBUixHQUFZLENBQTVCLENBTnNEO0FBT3RETixrQkFBVUcsS0FBVixDQUFnQkcsUUFBUSxDQUFSLEdBQVksQ0FBNUIsQ0FQc0Q7QUFTekQ7QUFDRjs7O3VDQUVrQk4sUyxFQUFXO0FBQzVCLFVBQU1DLFdBQVduQixZQUFZLEtBQUtLLEtBQUwsQ0FBV2UsV0FBdkIsQ0FBakI7QUFDQUYsZ0JBQVVHLEtBQVYsR0FBa0IsSUFBSUMsWUFBSixDQUFpQkgsU0FBU0ksTUFBVCxHQUFrQixDQUFsQixHQUFzQixDQUF2QyxDQUFsQjtBQUNBLFdBQUssSUFBSUMsUUFBUSxDQUFqQixFQUFvQkEsUUFBUUwsU0FBU0ksTUFBVCxHQUFrQixDQUE5QyxFQUFpREMsT0FBakQsRUFBMEQ7QUFBQSx3QkFJcEQxQixRQUFRcUIsU0FBU0ssUUFBUSxDQUFSLEdBQVksQ0FBckIsQ0FBUixDQUpvRDs7QUFBQTs7QUFFdEROLGtCQUFVRyxLQUFWLENBQWdCRyxRQUFRLENBQXhCLENBRnNEO0FBR3RETixrQkFBVUcsS0FBVixDQUFnQkcsUUFBUSxDQUFSLEdBQVksQ0FBNUIsQ0FIc0Q7QUFLekQ7QUFDRjs7OztFQWpENEMzQixlOztlQUExQkssaUI7OztBQW9EckJBLGtCQUFrQnVCLFNBQWxCLEdBQThCLG1CQUE5QiIsImZpbGUiOiJjaG9yb3BsZXRoLWxheWVyLTY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBDaG9yb3BsZXRoTGF5ZXIgZnJvbSAnLi4vY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyJztcbmltcG9ydCB7ZnA2NGlmeSwgbG9nfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5cbmltcG9ydCBjaG9yb3BsZXRoVmVydGV4NjQgZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC02NC5nbHNsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvcm9wbGV0aExheWVyNjQgZXh0ZW5kcyBDaG9yb3BsZXRoTGF5ZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGxvZy5vbmNlKCdDaG9yb3BsZXRoTGF5ZXI2NCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciB1c2luZyBHZW9Kc29uTGF5ZXIgaW5zdGVhZCcpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHN1cGVyLmluaXRpYWxpemVTdGF0ZSgpO1xuXG4gICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBwb3NpdGlvbnM2NDoge3NpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnM2NH0sXG4gICAgICBoZWlnaHRzNjQ6IHtzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSGVpZ2h0czY0fVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IGNob3JvcGxldGhWZXJ0ZXg2NCxcbiAgICAgIGZzOiBzdXBlci5nZXRTaGFkZXJzKCkuZnMsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9uczY0KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGggLyAzICogNCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgIFtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNF0sXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzXSk7XG4gICAgICBbXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAyXSxcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNCArIDNdXG4gICAgICBdID0gZnA2NGlmeSh2ZXJ0aWNlc1tpbmRleCAqIDMgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSGVpZ2h0czY0KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgIFtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogMl0sXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzICsgMl0pO1xuICAgIH1cbiAgfVxufVxuXG5DaG9yb3BsZXRoTGF5ZXI2NC5sYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyNjQnO1xuIl19

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME choropleth-layer-vertex-64-shader\n\nattribute vec4 positions64;\nattribute vec2 heights64;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\nvoid main(void) {\n  // For some reason, need to add one to elevation to show up in untilted mode\n  vec2 projectedCoord[2];\n  project_position_fp64(positions64, projectedCoord);\n\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = projectedCoord[0];\n  vertex_pos_modelspace[1] = projectedCoord[1];\n  vertex_pos_modelspace[2] = heights64;\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyLTY0L2Nob3JvcGxldGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXgtNjQtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uczY0O1xuYXR0cmlidXRlIHZlYzIgaGVpZ2h0czY0O1xuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xuYXR0cmlidXRlIHZlYzMgcGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG51bmlmb3JtIGZsb2F0IHBpY2tpbmdFbmFibGVkO1xudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XG52b2lkIHBpY2tpbmdfc2V0UGlja0NvbG9yKHZlYzMgcGlja2luZ0NvbG9yKSB7XG4gIHZQaWNraW5nQ29sb3IgPSB2ZWM0KHBpY2tpbmdDb2xvciwgIDEuKTtcbn1cbnZlYzQgcGlja2luZ19zZXROb3JtYWxBbmRQaWNrQ29sb3JzKHZlYzQgY29sb3IsIHZlYzMgcGlja2luZ0NvbG9yKSB7XG4gIHZlYzQgcGlja2luZ0NvbG9yNCA9IHZlYzQocGlja2luZ0NvbG9yLnJnYiwgMS4pO1xuICB2UGlja2luZ0NvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3I0LCBwaWNraW5nRW5hYmxlZCk7XG4gIHJldHVybiB2UGlja2luZ0NvbG9yO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBGb3Igc29tZSByZWFzb24sIG5lZWQgdG8gYWRkIG9uZSB0byBlbGV2YXRpb24gdG8gc2hvdyB1cCBpbiB1bnRpbHRlZCBtb2RlXG4gIHZlYzIgcHJvamVjdGVkQ29vcmRbMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChwb3NpdGlvbnM2NCwgcHJvamVjdGVkQ29vcmQpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHByb2plY3RlZENvb3JkWzBdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRDb29yZFsxXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gaGVpZ2h0czY0O1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWM0IGNvbG9yID0gdmVjNChjb2xvcnMucmdiLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcblxuICBwaWNraW5nX3NldE5vcm1hbEFuZFBpY2tDb2xvcnMoXG4gICAgY29sb3IsXG4gICAgcGlja2luZ0NvbG9ycyAvIDI1NS5cbiAgKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME choropleth-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJjaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbi8vIFBJQ0tJTkdcbi8vIHVuaWZvcm0gYm9vbCBwaWNraW5nRW5hYmxlZDtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xudmVjNCBwaWNraW5nX2dldENvbG9yKCkge1xuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcbn1cbi8vIFBJQ0tJTkdcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19nZXRDb2xvcigpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME choropleth-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\n// PICKING\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\n//   return mix(color4, pickingColor4, renderPickingBuffer);\n// }\n\nvoid main(void) {\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n\n  vec3 p = project_position(positions);\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcblxuLy8gUElDS0lOR1xudW5pZm9ybSBmbG9hdCBwaWNraW5nRW5hYmxlZDtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xudm9pZCBwaWNraW5nX3NldFBpY2tDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xuICB2UGlja2luZ0NvbG9yID0gdmVjNChwaWNraW5nQ29sb3IsICAxLik7XG59XG52ZWM0IHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyh2ZWM0IGNvbG9yLCB2ZWMzIHBpY2tpbmdDb2xvcikge1xuICB2ZWM0IHBpY2tpbmdDb2xvcjQgPSB2ZWM0KHBpY2tpbmdDb2xvci5yZ2IsIDEuKTtcbiAgdlBpY2tpbmdDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yNCwgcGlja2luZ0VuYWJsZWQpO1xuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcbn1cblxuLy8gUElDS0lOR1xuLy8gdmVjNCBnZXRDb2xvcih2ZWM0IGNvbG9yLCBmbG9hdCBvcGFjaXR5LCB2ZWMzIHBpY2tpbmdDb2xvciwgZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcikge1xuLy8gICB2ZWM0IGNvbG9yNCA9IHZlYzQoY29sb3IueHl6IC8gMjU1LiwgY29sb3IudyAvIDI1NS4gKiBvcGFjaXR5KTtcbi8vICAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IgLyAyNTUuLCAxLik7XG4vLyAgIHJldHVybiBtaXgoY29sb3I0LCBwaWNraW5nQ29sb3I0LCByZW5kZXJQaWNraW5nQnVmZmVyKTtcbi8vIH1cblxudm9pZCBtYWluKHZvaWQpIHtcblxuICB2ZWM0IGNvbG9yID0gdmVjNChjb2xvcnMucmdiLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcblxuICBwaWNraW5nX3NldE5vcm1hbEFuZFBpY2tDb2xvcnMoXG4gICAgY29sb3IsXG4gICAgcGlja2luZ0NvbG9ycyAvIDI1NS5cbiAgKTtcblxuICB2ZWMzIHAgPSBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9ucyk7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNChwLCAxLikpO1xufVxuYDtcbiJdfQ==

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getGeojsonFeatures */
/* unused harmony export featureToPolygons */
/* harmony export (immutable) */ __webpack_exports__["a"] = extractPolygons;
/* unused harmony export normalizeGeojson */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(7);
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

/*
 * converts a GeoJSON "Feature" object to a list of GeoJSON polygon-style coordinates
 * @param {Object | Array} data - geojson object or array of feature
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
function featureToPolygons(feature) {
  var geometry = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(feature, 'geometry');
  // If no geometry field, assume that "feature" is the polygon list
  if (geometry === undefined) {
    return feature;
  }

  var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(geometry, 'type');
  var coordinates = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(geometry, 'coordinates');

  var polygons = void 0;
  switch (type) {
    case 'MultiPolygon':
      polygons = coordinates;
      break;
    case 'Polygon':
      polygons = [coordinates];
      break;
    case 'LineString':
      // TODO - should lines really be handled in this switch?
      polygons = [[coordinates]];
      break;
    case 'MultiLineString':
      // TODO - should lines really be handled in this switch?
      polygons = coordinates.map(function (coords) {
        return [coords];
      });
      break;
    default:
      polygons = [];
  }
  return polygons;
}

// DEPRECATED - USED BY OLD CHOROPLETH LAYERS

/*
 * converts list of features from a GeoJSON object to a list of GeoJSON
 * polygon-style coordinates
 * @param {Object} data - geojson object
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
function extractPolygons(data) {
  var normalizedGeojson = normalizeGeojson(data);
  var features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(normalizedGeojson, 'features');

  var result = [];
  features.forEach(function (feature, featureIndex) {
    var choropleths = featureToPolygons(feature);

    /* eslint-disable max-nested-callbacks */
    choropleths = choropleths.map(function (choropleth) {
      return choropleth.map(function (polygon) {
        return polygon.map(function (coord) {
          return [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(coord, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(coord, 1), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(coord, 2) || 0];
        });
      });
    });
    /* eslint-enable max-nested-callbacks */

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = choropleths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var choropleth = _step.value;

        choropleth.featureIndex = featureIndex;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    result.push.apply(result, _toConsumableArray(choropleths));
  });
  return result;
}

/**
 * "Normalizes" a GeoJSON geometry or "Feature" into a "FeatureCollection",
 * by wrapping it in an extra object/array.
 *
 * @param {object} geojson - geojson data
 * @return {object} - normalized geojson data
 */
function normalizeGeojson(geojson) {
  var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__["d" /* get */])(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a "Feature" and add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [{ type: 'Feature', properties: {}, geometry: geojson }]
      };
    case 'Feature':
      // Add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [geojson]
      };
    case 'FeatureCollection':
      // Just return the feature collection
      return geojson;
    default:
      throw new Error('Unknown geojson type');
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2dlb2pzb24uanMiXSwibmFtZXMiOlsiZ2V0IiwiZ2V0R2VvanNvbkZlYXR1cmVzIiwiZ2VvanNvbiIsIkFycmF5IiwiaXNBcnJheSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZ2VvbWV0cnkiLCJFcnJvciIsImZlYXR1cmVUb1BvbHlnb25zIiwiZmVhdHVyZSIsInVuZGVmaW5lZCIsImNvb3JkaW5hdGVzIiwicG9seWdvbnMiLCJtYXAiLCJjb29yZHMiLCJleHRyYWN0UG9seWdvbnMiLCJkYXRhIiwibm9ybWFsaXplZEdlb2pzb24iLCJub3JtYWxpemVHZW9qc29uIiwiZmVhdHVyZXMiLCJyZXN1bHQiLCJmb3JFYWNoIiwiZmVhdHVyZUluZGV4IiwiY2hvcm9wbGV0aHMiLCJjaG9yb3BsZXRoIiwicG9seWdvbiIsImNvb3JkIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVFBLEdBQVIsUUFBa0Isb0JBQWxCOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxPQUFPLFNBQVNDLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUMxQztBQUNBLE1BQUlDLE1BQU1DLE9BQU4sQ0FBY0YsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFdBQU9BLE9BQVA7QUFDRDs7QUFFRCxNQUFNRyxPQUFPTCxJQUFJRSxPQUFKLEVBQWEsTUFBYixDQUFiO0FBQ0EsVUFBUUcsSUFBUjtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssaUJBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLGNBQUw7QUFDQSxTQUFLLG9CQUFMO0FBQ0U7QUFDQSxhQUFPLENBQ0wsRUFBQ0EsTUFBTSxTQUFQLEVBQWtCQyxZQUFZLEVBQTlCLEVBQWtDQyxVQUFVTCxPQUE1QyxFQURLLENBQVA7QUFHRixTQUFLLFNBQUw7QUFDRTtBQUNBLGFBQU8sQ0FBQ0EsT0FBRCxDQUFQO0FBQ0YsU0FBSyxtQkFBTDtBQUNFO0FBQ0EsYUFBT0YsSUFBSUUsT0FBSixFQUFhLFVBQWIsQ0FBUDtBQUNGO0FBQ0UsWUFBTSxJQUFJTSxLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQW5CRjtBQXFCRDs7QUFFRDs7Ozs7QUFLQSxPQUFPLFNBQVNDLGlCQUFULENBQTJCQyxPQUEzQixFQUFvQztBQUN6QyxNQUFNSCxXQUFXUCxJQUFJVSxPQUFKLEVBQWEsVUFBYixDQUFqQjtBQUNBO0FBQ0EsTUFBSUgsYUFBYUksU0FBakIsRUFBNEI7QUFDMUIsV0FBT0QsT0FBUDtBQUNEOztBQUVELE1BQU1MLE9BQU9MLElBQUlPLFFBQUosRUFBYyxNQUFkLENBQWI7QUFDQSxNQUFNSyxjQUFjWixJQUFJTyxRQUFKLEVBQWMsYUFBZCxDQUFwQjs7QUFFQSxNQUFJTSxpQkFBSjtBQUNBLFVBQVFSLElBQVI7QUFDQSxTQUFLLGNBQUw7QUFDRVEsaUJBQVdELFdBQVg7QUFDQTtBQUNGLFNBQUssU0FBTDtBQUNFQyxpQkFBVyxDQUFDRCxXQUFELENBQVg7QUFDQTtBQUNGLFNBQUssWUFBTDtBQUNFO0FBQ0FDLGlCQUFXLENBQUMsQ0FBQ0QsV0FBRCxDQUFELENBQVg7QUFDQTtBQUNGLFNBQUssaUJBQUw7QUFDRTtBQUNBQyxpQkFBV0QsWUFBWUUsR0FBWixDQUFnQjtBQUFBLGVBQVUsQ0FBQ0MsTUFBRCxDQUFWO0FBQUEsT0FBaEIsQ0FBWDtBQUNBO0FBQ0Y7QUFDRUYsaUJBQVcsRUFBWDtBQWhCRjtBQWtCQSxTQUFPQSxRQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BLE9BQU8sU0FBU0csZUFBVCxDQUF5QkMsSUFBekIsRUFBK0I7QUFDcEMsTUFBTUMsb0JBQW9CQyxpQkFBaUJGLElBQWpCLENBQTFCO0FBQ0EsTUFBTUcsV0FBV3BCLElBQUlrQixpQkFBSixFQUF1QixVQUF2QixDQUFqQjs7QUFFQSxNQUFNRyxTQUFTLEVBQWY7QUFDQUQsV0FBU0UsT0FBVCxDQUFpQixVQUFDWixPQUFELEVBQVVhLFlBQVYsRUFBMkI7QUFDMUMsUUFBSUMsY0FBY2Ysa0JBQWtCQyxPQUFsQixDQUFsQjs7QUFFQTtBQUNBYyxrQkFBY0EsWUFBWVYsR0FBWixDQUNaO0FBQUEsYUFBY1csV0FBV1gsR0FBWCxDQUNaO0FBQUEsZUFBV1ksUUFBUVosR0FBUixDQUNUO0FBQUEsaUJBQVMsQ0FDUGQsSUFBSTJCLEtBQUosRUFBVyxDQUFYLENBRE8sRUFFUDNCLElBQUkyQixLQUFKLEVBQVcsQ0FBWCxDQUZPLEVBR1AzQixJQUFJMkIsS0FBSixFQUFXLENBQVgsS0FBaUIsQ0FIVixDQUFUO0FBQUEsU0FEUyxDQUFYO0FBQUEsT0FEWSxDQUFkO0FBQUEsS0FEWSxDQUFkO0FBV0E7O0FBZjBDO0FBQUE7QUFBQTs7QUFBQTtBQWlCMUMsMkJBQXlCSCxXQUF6Qiw4SEFBc0M7QUFBQSxZQUEzQkMsVUFBMkI7O0FBQ3BDQSxtQkFBV0YsWUFBWCxHQUEwQkEsWUFBMUI7QUFDRDtBQW5CeUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFvQjFDRixXQUFPTyxJQUFQLGtDQUFlSixXQUFmO0FBQ0QsR0FyQkQ7QUFzQkEsU0FBT0gsTUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsT0FBTyxTQUFTRixnQkFBVCxDQUEwQmpCLE9BQTFCLEVBQW1DO0FBQ3hDLE1BQU1HLE9BQU9MLElBQUlFLE9BQUosRUFBYSxNQUFiLENBQWI7QUFDQSxVQUFRRyxJQUFSO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0EsU0FBSyxpQkFBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssY0FBTDtBQUNBLFNBQUssb0JBQUw7QUFDRTtBQUNBLGFBQU87QUFDTEEsY0FBTSxtQkFERDtBQUVMZSxrQkFBVSxDQUNSLEVBQUNmLE1BQU0sU0FBUCxFQUFrQkMsWUFBWSxFQUE5QixFQUFrQ0MsVUFBVUwsT0FBNUMsRUFEUTtBQUZMLE9BQVA7QUFNRixTQUFLLFNBQUw7QUFDRTtBQUNBLGFBQU87QUFDTEcsY0FBTSxtQkFERDtBQUVMZSxrQkFBVSxDQUFDbEIsT0FBRDtBQUZMLE9BQVA7QUFJRixTQUFLLG1CQUFMO0FBQ0U7QUFDQSxhQUFPQSxPQUFQO0FBQ0Y7QUFDRSxZQUFNLElBQUlNLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBekJGO0FBMkJEIiwiZmlsZSI6Imdlb2pzb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCB7Z2V0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGNvbXBsZXRlIG9yIHBhcnRpYWwgR2VvSlNPTiBkYXRhIGludG8gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICogQ2FuIGFjY2VwdCBHZW9KU09OIGdlb21ldHJ5IG9yIFwiRmVhdHVyZVwiLCBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgaW4gYWRkaXRpb25cbiAqIHRvIHBsYWluIGFycmF5cyBhbmQgaXRlcmFibGVzLlxuICogV29ya3MgYnkgZXh0cmFjdGluZyB0aGUgZmVhdHVyZSBhcnJheSBvciB3cmFwcGluZyBzaW5nbGUgb2JqZWN0cyBpbiBhbiBhcnJheSxcbiAqIHNvIHRoYXQgc3Vic2VxdWVudCBjb2RlIGNhbiBzaW1wbHkgaXRlcmF0ZSBvdmVyIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YSAtIGdlb2pzb24gb2JqZWN0IChGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZSBvclxuICogIEdlb21ldHJ5KSBvciBhcnJheSBvZiBmZWF0dXJlc1xuICogQHJldHVybiB7QXJyYXl8XCJpdGVyYXRhYmxlXCJ9IC0gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvanNvbkZlYXR1cmVzKGdlb2pzb24pIHtcbiAgLy8gSWYgYXJyYXksIGFzc3VtZSB0aGlzIGlzIGEgbGlzdCBvZiBmZWF0dXJlc1xuICBpZiAoQXJyYXkuaXNBcnJheShnZW9qc29uKSkge1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IGdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnUG9pbnQnOlxuICBjYXNlICdNdWx0aVBvaW50JzpcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gIGNhc2UgJ1BvbHlnb24nOlxuICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgIC8vIFdyYXAgdGhlIGdlb21ldHJ5IG9iamVjdCBpbiBhICdGZWF0dXJlJyBvYmplY3QgYW5kIHdyYXAgaW4gYW4gYXJyYXlcbiAgICByZXR1cm4gW1xuICAgICAge3R5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiBnZW9qc29ufVxuICAgIF07XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIC8vIFdyYXAgdGhlIGZlYXR1cmUgaW4gYSAnRmVhdHVyZXMnIGFycmF5XG4gICAgcmV0dXJuIFtnZW9qc29uXTtcbiAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgIC8vIEp1c3QgcmV0dXJuIHRoZSAnRmVhdHVyZXMnIGFycmF5IGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICByZXR1cm4gZ2V0KGdlb2pzb24sICdmZWF0dXJlcycpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuXG4vKlxuICogY29udmVydHMgYSBHZW9KU09OIFwiRmVhdHVyZVwiIG9iamVjdCB0byBhIGxpc3Qgb2YgR2VvSlNPTiBwb2x5Z29uLXN0eWxlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3Qgb3IgYXJyYXkgb2YgZmVhdHVyZVxuICogQHJldHVybnMge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdW119IGFycmF5IG9mIGNob3JvcGxldGhzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKSB7XG4gIGNvbnN0IGdlb21ldHJ5ID0gZ2V0KGZlYXR1cmUsICdnZW9tZXRyeScpO1xuICAvLyBJZiBubyBnZW9tZXRyeSBmaWVsZCwgYXNzdW1lIHRoYXQgXCJmZWF0dXJlXCIgaXMgdGhlIHBvbHlnb24gbGlzdFxuICBpZiAoZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IGdldChnZW9tZXRyeSwgJ3R5cGUnKTtcbiAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZXQoZ2VvbWV0cnksICdjb29yZGluYXRlcycpO1xuXG4gIGxldCBwb2x5Z29ucztcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgcG9seWdvbnMgPSBjb29yZGluYXRlcztcbiAgICBicmVhaztcbiAgY2FzZSAnUG9seWdvbic6XG4gICAgcG9seWdvbnMgPSBbY29vcmRpbmF0ZXNdO1xuICAgIGJyZWFrO1xuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAvLyBUT0RPIC0gc2hvdWxkIGxpbmVzIHJlYWxseSBiZSBoYW5kbGVkIGluIHRoaXMgc3dpdGNoP1xuICAgIHBvbHlnb25zID0gW1tjb29yZGluYXRlc11dO1xuICAgIGJyZWFrO1xuICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIC8vIFRPRE8gLSBzaG91bGQgbGluZXMgcmVhbGx5IGJlIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2g/XG4gICAgcG9seWdvbnMgPSBjb29yZGluYXRlcy5tYXAoY29vcmRzID0+IFtjb29yZHNdKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICBwb2x5Z29ucyA9IFtdO1xuICB9XG4gIHJldHVybiBwb2x5Z29ucztcbn1cblxuLy8gREVQUkVDQVRFRCAtIFVTRUQgQlkgT0xEIENIT1JPUExFVEggTEFZRVJTXG5cbi8qXG4gKiBjb252ZXJ0cyBsaXN0IG9mIGZlYXR1cmVzIGZyb20gYSBHZW9KU09OIG9iamVjdCB0byBhIGxpc3Qgb2YgR2VvSlNPTlxuICogcG9seWdvbi1zdHlsZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBnZW9qc29uIG9iamVjdFxuICogQHJldHVybnMge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdW119IGFycmF5IG9mIGNob3JvcGxldGhzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UG9seWdvbnMoZGF0YSkge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZUdlb2pzb24oZGF0YSk7XG4gIGNvbnN0IGZlYXR1cmVzID0gZ2V0KG5vcm1hbGl6ZWRHZW9qc29uLCAnZmVhdHVyZXMnKTtcblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSwgZmVhdHVyZUluZGV4KSA9PiB7XG4gICAgbGV0IGNob3JvcGxldGhzID0gZmVhdHVyZVRvUG9seWdvbnMoZmVhdHVyZSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbmVzdGVkLWNhbGxiYWNrcyAqL1xuICAgIGNob3JvcGxldGhzID0gY2hvcm9wbGV0aHMubWFwKFxuICAgICAgY2hvcm9wbGV0aCA9PiBjaG9yb3BsZXRoLm1hcChcbiAgICAgICAgcG9seWdvbiA9PiBwb2x5Z29uLm1hcChcbiAgICAgICAgICBjb29yZCA9PiBbXG4gICAgICAgICAgICBnZXQoY29vcmQsIDApLFxuICAgICAgICAgICAgZ2V0KGNvb3JkLCAxKSxcbiAgICAgICAgICAgIGdldChjb29yZCwgMikgfHwgMFxuICAgICAgICAgIF1cbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbmVzdGVkLWNhbGxiYWNrcyAqL1xuXG4gICAgZm9yIChjb25zdCBjaG9yb3BsZXRoIG9mIGNob3JvcGxldGhzKSB7XG4gICAgICBjaG9yb3BsZXRoLmZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goLi4uY2hvcm9wbGV0aHMpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBcIk5vcm1hbGl6ZXNcIiBhIEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIgaW50byBhIFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqIGJ5IHdyYXBwaW5nIGl0IGluIGFuIGV4dHJhIG9iamVjdC9hcnJheS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ2VvanNvbiAtIGdlb2pzb24gZGF0YVxuICogQHJldHVybiB7b2JqZWN0fSAtIG5vcm1hbGl6ZWQgZ2VvanNvbiBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVHZW9qc29uKGdlb2pzb24pIHtcbiAgY29uc3QgdHlwZSA9IGdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnUG9pbnQnOlxuICBjYXNlICdNdWx0aVBvaW50JzpcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gIGNhc2UgJ1BvbHlnb24nOlxuICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgIC8vIFdyYXAgdGhlIGdlb21ldHJ5IG9iamVjdCBpbiBhIFwiRmVhdHVyZVwiIGFuZCBhZGQgdGhlIGZlYXR1cmUgdG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIHt0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZ2VvanNvbn1cbiAgICAgIF1cbiAgICB9O1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICAvLyBBZGQgdGhlIGZlYXR1cmUgdG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbZ2VvanNvbl1cbiAgICB9O1xuICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlIGZlYXR1cmUgY29sbGVjdGlvblxuICAgIHJldHVybiBnZW9qc29uO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuIl19

/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_gl_matrix__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extruded_choropleth_layer_vertex_glsl__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__extruded_choropleth_layer_fragment_glsl__ = __webpack_require__(185);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.












var DEFAULT_COLOR = [180, 180, 200, 255];
var DEFAULT_AMBIENT_COLOR = [255, 255, 255];
var DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT = 0.1;
var DEFAULT_POINTLIGHT_LOCATION = [40.4406, -79.9959, 100];
var DEFAULT_POINTLIGHT_COLOR = [255, 255, 255];
var DEFAULT_POINTLIGHT_ATTENUATION = 1.0;
var DEFAULT_MATERIAL_SPECULAR_COLOR = [255, 255, 255];
var DEFAULT_MATERIAL_SHININESS = 1;

var defaultProps = {
  opacity: 1,
  elevation: 1
};

var ExtrudedChoroplethLayer64 = function (_Layer) {
  _inherits(ExtrudedChoroplethLayer64, _Layer);

  function ExtrudedChoroplethLayer64(props) {
    _classCallCheck(this, ExtrudedChoroplethLayer64);

    var _this = _possibleConstructorReturn(this, (ExtrudedChoroplethLayer64.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64)).call(this, props));

    __WEBPACK_IMPORTED_MODULE_4__lib_utils__["a" /* log */].once('ExtrudedChoroplethLayer64 is deprecated. Consider using GeoJsonLayer instead');
    return _this;
  }

  _createClass(ExtrudedChoroplethLayer64, [{
    key: 'initializeState',
    value: function initializeState() {
      var attributeManager = this.state.attributeManager;

      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices },
        positions: { size: 4, update: this.calculatePositions },
        heights: { size: 2, update: this.calculateHeights },
        normals: { size: 3, update: this.calculateNormals },
        colors: { size: 4, update: this.calculateColors }
      });

      var gl = this.context.gl;

      this.setState({
        numInstances: 0,
        model: this.getModel(gl)
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.extractExtrudedChoropleth();
        attributeManager.invalidateAll();
      }

      var _props = this.props,
          elevation = _props.elevation,
          ambientColor = _props.ambientColor,
          pointLightColor = _props.pointLightColor,
          pointLightLocation = _props.pointLightLocation,
          pointLightAmbientCoefficient = _props.pointLightAmbientCoefficient,
          pointLightAttenuation = _props.pointLightAttenuation,
          materialSpecularColor = _props.materialSpecularColor,
          materialShininess = _props.materialShininess;


      this.setUniforms({
        elevation: Number.isFinite(elevation) ? elevation : 1,
        uAmbientColor: ambientColor || DEFAULT_AMBIENT_COLOR,
        uPointLightAmbientCoefficient: pointLightAmbientCoefficient || DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT,
        uPointLightLocation: pointLightLocation || DEFAULT_POINTLIGHT_LOCATION,
        uPointLightColor: pointLightColor || DEFAULT_POINTLIGHT_COLOR,
        uPointLightAttenuation: pointLightAttenuation || DEFAULT_POINTLIGHT_ATTENUATION,
        uMaterialSpecularColor: materialSpecularColor || DEFAULT_MATERIAL_SPECULAR_COLOR,
        uMaterialShininess: materialShininess || DEFAULT_MATERIAL_SHININESS
      });
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;

      this.state.model.render(uniforms);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(ExtrudedChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64.prototype), 'getPickingInfo', this).call(this, opts);
      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? this.props.data.features[index] : null;
      info.feature = feature;
      info.object = feature;
      return info;
    }
  }, {
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: __WEBPACK_IMPORTED_MODULE_7__extruded_choropleth_layer_vertex_glsl__["a" /* default */],
        fs: __WEBPACK_IMPORTED_MODULE_8__extruded_choropleth_layer_fragment_glsl__["a" /* default */],
        fp64: true,
        project64: true
      };
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      // Make sure we have 32 bit support
      // TODO - this could be done automatically by luma in "draw"
      // when it detects 32 bit indices
      if (!gl.getExtension('OES_element_index_uint')) {
        throw new Error('Extruded choropleth layer needs 32 bit indices');
      }

      // Buildings are 3d so depth test should be enabled
      // TODO - it is a little heavy handed to have a layer set this
      // Alternatively, check depth test and warn if not set, or add a prop
      // setDepthTest that is on by default.
      gl.enable(__WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].DEPTH_TEST);
      gl.depthFunc(__WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].LEQUAL);

      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__["a" /* assembleShaders */])(gl, this.getShaders());

      return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__["a" /* Model */]({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__["b" /* Geometry */]({
          drawMode: this.props.drawWireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      });
    }

    // each top vertex is on 3 surfaces
    // each bottom vertex is on 2 surfaces

  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var _this2 = this;

      var positions = this.state.positions;

      if (!positions) {
        positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(this.state.groupedVertices.map(function (vertices) {
          var topVertices = Array.prototype.concat.apply([], vertices);
          var baseVertices = topVertices.map(function (v) {
            return [v[0], v[1], 0];
          });
          return _this2.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
        }));
      }

      attribute.value = new Float32Array(positions.length / 3 * 4);

      for (var i = 0; i < positions.length / 3; i++) {
        var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__["a" /* fp64ify */])(positions[i * 3 + 0]);

        var _fp64ify2 = _slicedToArray(_fp64ify, 2);

        attribute.value[i * 4 + 0] = _fp64ify2[0];
        attribute.value[i * 4 + 1] = _fp64ify2[1];

        var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__["a" /* fp64ify */])(positions[i * 3 + 1]);

        var _fp64ify4 = _slicedToArray(_fp64ify3, 2);

        attribute.value[i * 4 + 2] = _fp64ify4[0];
        attribute.value[i * 4 + 3] = _fp64ify4[1];
      }
    }
  }, {
    key: 'calculateHeights',
    value: function calculateHeights(attribute) {
      var _this3 = this;

      var positions = this.state.positions;

      if (!positions) {
        positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(this.state.groupedVertices.map(function (vertices) {
          var topVertices = Array.prototype.concat.apply([], vertices);
          var baseVertices = topVertices.map(function (v) {
            return [v[0], v[1], 0];
          });
          return _this3.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
        }));
      }

      attribute.value = new Float32Array(positions.length / 3 * 2);
      for (var i = 0; i < positions.length / 3; i++) {
        var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__["a" /* fp64ify */])(positions[i * 3 + 2] + 0.1);

        var _fp64ify6 = _slicedToArray(_fp64ify5, 2);

        attribute.value[i * 2 + 0] = _fp64ify6[0];
        attribute.value[i * 2 + 1] = _fp64ify6[1];
      }
    }
  }, {
    key: 'calculateNormals',
    value: function calculateNormals(attribute) {
      var _this4 = this;

      var up = [0, 1, 0];

      var normals = this.state.groupedVertices.map(function (vertices, buildingIndex) {
        var topNormals = new Array(countVertices(vertices)).fill(up);
        var sideNormals = vertices.map(function (polygon) {
          return _this4.calculateSideNormals(polygon);
        });
        var sideNormalsForward = sideNormals.map(function (n) {
          return n[0];
        });
        var sideNormalsBackward = sideNormals.map(function (n) {
          return n[1];
        });

        return _this4.props.drawWireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
      });

      attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(normals));
    }
  }, {
    key: 'calculateSideNormals',
    value: function calculateSideNormals(vertices) {
      var numVertices = vertices.length;
      var normals = [];

      for (var i = 0; i < numVertices - 1; i++) {
        var n = getNormal(vertices[i], vertices[i + 1]);
        normals.push(n);
      }

      return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this5 = this;

      // adjust index offset for multiple buildings
      var multiplier = this.props.drawWireframe ? 2 : 5;
      var offsets = this.state.groupedVertices.reduce(function (acc, vertices) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);
      }, [0]);

      var indices = this.state.groupedVertices.map(function (vertices, buildingIndex) {
        return _this5.props.drawWireframe ?
        // 1. get sequentially ordered indices of each building wireframe
        // 2. offset them by the number of indices in previous buildings
        _this5.calculateContourIndices(vertices, offsets[buildingIndex]) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous buildings
        _this5.calculateSurfaceIndices(vertices, offsets[buildingIndex]);
      });

      attribute.value = new Uint32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(indices));
      attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__["c" /* GL */].ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _this6 = this;

      var colors = this.state.groupedVertices.map(function (vertices, buildingIndex) {
        var color = _this6.props.color;

        var baseColor = color || DEFAULT_COLOR;
        var topColor = color || DEFAULT_COLOR;
        var numVertices = countVertices(vertices);

        var topColors = new Array(numVertices).fill(topColor);
        var baseColors = new Array(numVertices).fill(baseColor);
        return _this6.props.drawWireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
      });
      attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(colors));
    }
  }, {
    key: 'extractExtrudedChoropleth',
    value: function extractExtrudedChoropleth() {
      var _this7 = this;

      var data = this.props.data;
      // Generate a flat list of buildings

      this.state.buildings = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var _state$buildings;

          var building = _step.value;
          var properties = building.properties,
              geometry = building.geometry;
          var coordinates = geometry.coordinates,
              type = geometry.type;

          if (!properties.height) {
            properties.height = Math.random() * 1000;
          }
          switch (type) {
            case 'MultiPolygon':
              // Maps to multiple buildings
              var buildings = coordinates.map(function (coords) {
                return { coordinates: coords, properties: properties };
              });
              (_state$buildings = _this7.state.buildings).push.apply(_state$buildings, _toConsumableArray(buildings));
              break;
            case 'Polygon':
              // Maps to a single building
              _this7.state.buildings.push({ coordinates: coordinates, properties: properties });
              break;
            default:
            // We are ignoring Points for now
          }
        };

        for (var _iterator = data.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }

        // Generate vertices for the building list
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.state.groupedVertices = this.state.buildings.map(function (building) {
        return building.coordinates.map(function (polygon) {
          return polygon.map(function (coordinate) {
            return [coordinate[0], coordinate[1], building.properties.height || 10];
          });
        });
      });
    }
  }, {
    key: 'calculateContourIndices',
    value: function calculateContourIndices(vertices, offset) {
      var stride = countVertices(vertices);

      return vertices.map(function (polygon) {
        var indices = [offset];
        var numVertices = polygon.length;

        // building top
        // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
        for (var i = 1; i < numVertices - 1; i++) {
          indices.push(i + offset, i + offset);
        }
        indices.push(offset);

        // building sides
        for (var _i = 0; _i < numVertices - 1; _i++) {
          indices.push(_i + offset, _i + stride + offset);
        }

        offset += numVertices;
        return indices;
      });
    }
  }, {
    key: 'calculateSurfaceIndices',
    value: function calculateSurfaceIndices(vertices, offset) {
      var stride = countVertices(vertices);
      var holes = null;
      var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

      if (vertices.length > 1) {
        holes = vertices.reduce(function (acc, polygon) {
          return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
        }, [0]).slice(1, vertices.length);
      }

      var topIndices = __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__["b" /* flatten */])(vertices), holes, 3).map(function (index) {
        return index + offset;
      });

      var sideIndices = vertices.map(function (polygon) {
        var numVertices = polygon.length;
        // building top
        var indices = [];

        // building sides
        for (var i = 0; i < numVertices - 1; i++) {
          indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));
        }

        offset += numVertices;
        return indices;
      });

      return [topIndices, sideIndices];

      function drawRectangle(i) {
        return quad.map(function (v) {
          return i + v[0] + stride * v[1] + offset;
        });
      }
    }
  }]);

  return ExtrudedChoroplethLayer64;
}(__WEBPACK_IMPORTED_MODULE_0__lib__["a" /* Layer */]);

/* harmony default export */ __webpack_exports__["a"] = (ExtrudedChoroplethLayer64);


ExtrudedChoroplethLayer64.layerName = 'ExtrudedChoroplethLayer64';
ExtrudedChoroplethLayer64.defaultProps = defaultProps;

/*
 * helpers
 */
// get normal vector of line segment
function getNormal(p1, p2) {
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;

  var lon1 = degrees2radians * p1[0];
  var lon2 = degrees2radians * p2[0];
  var lat1 = degrees2radians * p1[1];
  var lat2 = degrees2radians * p2[1];

  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

  return __WEBPACK_IMPORTED_MODULE_6_gl_matrix__["vec3"].normalize([], [b, 0, -a]);
}

// count number of vertices in geojson polygon
function countVertices(vertices) {
  return vertices.reduce(function (count, polygon) {
    return count + polygon.length;
  }, 0);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJmcDY0aWZ5IiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwiZmxhdHRlbiIsImxvZyIsImVhcmN1dCIsInZlYzMiLCJleHRydWRlZENob3JvcGxldGhWZXJ0ZXgiLCJleHRydWRlZENob3JvcGxldGhGcmFnbWVudCIsIkRFRkFVTFRfQ09MT1IiLCJERUZBVUxUX0FNQklFTlRfQ09MT1IiLCJERUZBVUxUX1BPSU5UTElHSFRfQU1CSUVOVF9DT0VGRklDSUVOVCIsIkRFRkFVTFRfUE9JTlRMSUdIVF9MT0NBVElPTiIsIkRFRkFVTFRfUE9JTlRMSUdIVF9DT0xPUiIsIkRFRkFVTFRfUE9JTlRMSUdIVF9BVFRFTlVBVElPTiIsIkRFRkFVTFRfTUFURVJJQUxfU1BFQ1VMQVJfQ09MT1IiLCJERUZBVUxUX01BVEVSSUFMX1NISU5JTkVTUyIsImRlZmF1bHRQcm9wcyIsIm9wYWNpdHkiLCJlbGV2YXRpb24iLCJFeHRydWRlZENob3JvcGxldGhMYXllcjY0IiwicHJvcHMiLCJvbmNlIiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkIiwiaW5kaWNlcyIsInNpemUiLCJpc0luZGV4ZWQiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbmRpY2VzIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaGVpZ2h0cyIsImNhbGN1bGF0ZUhlaWdodHMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsImNvbG9ycyIsImNhbGN1bGF0ZUNvbG9ycyIsImdsIiwiY29udGV4dCIsInNldFN0YXRlIiwibnVtSW5zdGFuY2VzIiwibW9kZWwiLCJnZXRNb2RlbCIsImNoYW5nZUZsYWdzIiwiZGF0YUNoYW5nZWQiLCJleHRyYWN0RXh0cnVkZWRDaG9yb3BsZXRoIiwiaW52YWxpZGF0ZUFsbCIsImFtYmllbnRDb2xvciIsInBvaW50TGlnaHRDb2xvciIsInBvaW50TGlnaHRMb2NhdGlvbiIsInBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQiLCJwb2ludExpZ2h0QXR0ZW51YXRpb24iLCJtYXRlcmlhbFNwZWN1bGFyQ29sb3IiLCJtYXRlcmlhbFNoaW5pbmVzcyIsInNldFVuaWZvcm1zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ1QW1iaWVudENvbG9yIiwidVBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQiLCJ1UG9pbnRMaWdodExvY2F0aW9uIiwidVBvaW50TGlnaHRDb2xvciIsInVQb2ludExpZ2h0QXR0ZW51YXRpb24iLCJ1TWF0ZXJpYWxTcGVjdWxhckNvbG9yIiwidU1hdGVyaWFsU2hpbmluZXNzIiwidW5pZm9ybXMiLCJyZW5kZXIiLCJvcHRzIiwiaW5mbyIsImluZGV4IiwiZGVjb2RlUGlja2luZ0NvbG9yIiwiY29sb3IiLCJmZWF0dXJlIiwiZGF0YSIsImZlYXR1cmVzIiwib2JqZWN0IiwidnMiLCJmcyIsImZwNjQiLCJwcm9qZWN0NjQiLCJnZXRFeHRlbnNpb24iLCJFcnJvciIsImVuYWJsZSIsIkRFUFRIX1RFU1QiLCJkZXB0aEZ1bmMiLCJMRVFVQUwiLCJzaGFkZXJzIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsImRyYXdXaXJlZnJhbWUiLCJMSU5FUyIsIlRSSUFOR0xFUyIsInZlcnRleENvdW50IiwiYXR0cmlidXRlIiwiZ3JvdXBlZFZlcnRpY2VzIiwibWFwIiwidG9wVmVydGljZXMiLCJBcnJheSIsInByb3RvdHlwZSIsImNvbmNhdCIsImFwcGx5IiwidmVydGljZXMiLCJiYXNlVmVydGljZXMiLCJ2IiwidmFsdWUiLCJGbG9hdDMyQXJyYXkiLCJsZW5ndGgiLCJpIiwidXAiLCJidWlsZGluZ0luZGV4IiwidG9wTm9ybWFscyIsImNvdW50VmVydGljZXMiLCJmaWxsIiwic2lkZU5vcm1hbHMiLCJjYWxjdWxhdGVTaWRlTm9ybWFscyIsInBvbHlnb24iLCJzaWRlTm9ybWFsc0ZvcndhcmQiLCJuIiwic2lkZU5vcm1hbHNCYWNrd2FyZCIsIm51bVZlcnRpY2VzIiwiZ2V0Tm9ybWFsIiwicHVzaCIsIm11bHRpcGxpZXIiLCJvZmZzZXRzIiwicmVkdWNlIiwiYWNjIiwiY2FsY3VsYXRlQ29udG91ckluZGljZXMiLCJjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyIsIlVpbnQzMkFycmF5IiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJzZXRWZXJ0ZXhDb3VudCIsImJhc2VDb2xvciIsInRvcENvbG9yIiwidG9wQ29sb3JzIiwiYmFzZUNvbG9ycyIsImJ1aWxkaW5ncyIsImJ1aWxkaW5nIiwicHJvcGVydGllcyIsImNvb3JkaW5hdGVzIiwidHlwZSIsImhlaWdodCIsIk1hdGgiLCJyYW5kb20iLCJjb29yZHMiLCJjb29yZGluYXRlIiwib2Zmc2V0Iiwic3RyaWRlIiwiaG9sZXMiLCJxdWFkIiwic2xpY2UiLCJ0b3BJbmRpY2VzIiwic2lkZUluZGljZXMiLCJkcmF3UmVjdGFuZ2xlIiwibGF5ZXJOYW1lIiwicDEiLCJwMiIsImRlZ3JlZXMycmFkaWFucyIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIiwibm9ybWFsaXplIiwiY291bnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsS0FBUixRQUFvQixjQUFwQjtBQUNBLFNBQVFDLGVBQVIsUUFBOEIsdUJBQTlCO0FBQ0EsU0FBUUMsT0FBUixRQUFzQix5QkFBdEI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDO0FBQ0EsU0FBUUMsT0FBUixF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TUssT0FBT0osa0JBQWtCRixHQUFHLENBQUgsQ0FBL0I7QUFDQSxNQUFNTyxPQUFPTCxrQkFBa0JELEdBQUcsQ0FBSCxDQUEvQjs7QUFFQSxNQUFNTyxJQUFJckIsS0FBS3NCLEdBQUwsQ0FBU0osT0FBT0QsSUFBaEIsSUFBd0JqQixLQUFLdUIsR0FBTCxDQUFTSCxJQUFULENBQWxDO0FBQ0EsTUFBTUksSUFBSXhCLEtBQUt1QixHQUFMLENBQVNKLElBQVQsSUFBaUJuQixLQUFLc0IsR0FBTCxDQUFTRixJQUFULENBQWpCLEdBQ1BwQixLQUFLc0IsR0FBTCxDQUFTSCxJQUFULElBQWlCbkIsS0FBS3VCLEdBQUwsQ0FBU0gsSUFBVCxDQUFqQixHQUFrQ3BCLEtBQUt1QixHQUFMLENBQVNMLE9BQU9ELElBQWhCLENBRHJDOztBQUdBLFNBQU81SixLQUFLb0ssU0FBTCxDQUFlLEVBQWYsRUFBbUIsQ0FBQ0QsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDSCxDQUFSLENBQW5CLENBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQVNwRCxhQUFULENBQXVCVixRQUF2QixFQUFpQztBQUMvQixTQUFPQSxTQUFTdUIsTUFBVCxDQUFnQixVQUFDNEMsS0FBRCxFQUFRckQsT0FBUjtBQUFBLFdBQW9CcUQsUUFBUXJELFFBQVFULE1BQXBDO0FBQUEsR0FBaEIsRUFBNEQsQ0FBNUQsQ0FBUDtBQUNEIiwiZmlsZSI6ImV4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtmcDY0aWZ5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmbGF0dGVuLCBsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBleHRydWRlZENob3JvcGxldGhWZXJ0ZXggZnJvbSAnLi9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBleHRydWRlZENob3JvcGxldGhGcmFnbWVudCBmcm9tICcuL2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMTgwLCAxODAsIDIwMCwgMjU1XTtcbmNvbnN0IERFRkFVTFRfQU1CSUVOVF9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbmNvbnN0IERFRkFVTFRfUE9JTlRMSUdIVF9BTUJJRU5UX0NPRUZGSUNJRU5UID0gMC4xO1xuY29uc3QgREVGQVVMVF9QT0lOVExJR0hUX0xPQ0FUSU9OID0gWzQwLjQ0MDYsIC03OS45OTU5LCAxMDBdO1xuY29uc3QgREVGQVVMVF9QT0lOVExJR0hUX0NPTE9SID0gWzI1NSwgMjU1LCAyNTVdO1xuY29uc3QgREVGQVVMVF9QT0lOVExJR0hUX0FUVEVOVUFUSU9OID0gMS4wO1xuY29uc3QgREVGQVVMVF9NQVRFUklBTF9TUEVDVUxBUl9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbmNvbnN0IERFRkFVTFRfTUFURVJJQUxfU0hJTklORVNTID0gMTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBvcGFjaXR5OiAxLFxuICBlbGV2YXRpb246IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGxvZy5vbmNlKCdFeHRydWRlZENob3JvcGxldGhMYXllcjY0IGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIEdlb0pzb25MYXllciBpbnN0ZWFkJyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgaXNJbmRleGVkOiB0cnVlLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlc30sXG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiA0LCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zfSxcbiAgICAgIGhlaWdodHM6IHtzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSGVpZ2h0c30sXG4gICAgICBub3JtYWxzOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZU5vcm1hbHN9LFxuICAgICAgY29sb3JzOiB7c2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc31cbiAgICB9KTtcblxuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbClcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5leHRyYWN0RXh0cnVkZWRDaG9yb3BsZXRoKCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBlbGV2YXRpb24sXG4gICAgICBhbWJpZW50Q29sb3IsIHBvaW50TGlnaHRDb2xvcixcbiAgICAgIHBvaW50TGlnaHRMb2NhdGlvbiwgcG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudCxcbiAgICAgIHBvaW50TGlnaHRBdHRlbnVhdGlvbiwgbWF0ZXJpYWxTcGVjdWxhckNvbG9yLCBtYXRlcmlhbFNoaW5pbmVzc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICBlbGV2YXRpb246IE51bWJlci5pc0Zpbml0ZShlbGV2YXRpb24pID8gZWxldmF0aW9uIDogMSxcbiAgICAgIHVBbWJpZW50Q29sb3I6IGFtYmllbnRDb2xvciB8fCBERUZBVUxUX0FNQklFTlRfQ09MT1IsXG4gICAgICB1UG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudDpcbiAgICAgICAgcG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudCB8fCBERUZBVUxUX1BPSU5UTElHSFRfQU1CSUVOVF9DT0VGRklDSUVOVCxcbiAgICAgIHVQb2ludExpZ2h0TG9jYXRpb246IHBvaW50TGlnaHRMb2NhdGlvbiB8fCBERUZBVUxUX1BPSU5UTElHSFRfTE9DQVRJT04sXG4gICAgICB1UG9pbnRMaWdodENvbG9yOiBwb2ludExpZ2h0Q29sb3IgfHwgREVGQVVMVF9QT0lOVExJR0hUX0NPTE9SLFxuICAgICAgdVBvaW50TGlnaHRBdHRlbnVhdGlvbjogcG9pbnRMaWdodEF0dGVudWF0aW9uIHx8IERFRkFVTFRfUE9JTlRMSUdIVF9BVFRFTlVBVElPTixcbiAgICAgIHVNYXRlcmlhbFNwZWN1bGFyQ29sb3I6IG1hdGVyaWFsU3BlY3VsYXJDb2xvciB8fCBERUZBVUxUX01BVEVSSUFMX1NQRUNVTEFSX0NPTE9SLFxuICAgICAgdU1hdGVyaWFsU2hpbmluZXNzOiBtYXRlcmlhbFNoaW5pbmVzcyB8fCBERUZBVUxUX01BVEVSSUFMX1NISU5JTkVTU1xuICAgIH0pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVjb2RlUGlja2luZ0NvbG9yKGluZm8uY29sb3IpO1xuICAgIGNvbnN0IGZlYXR1cmUgPSBpbmRleCA+PSAwID8gdGhpcy5wcm9wcy5kYXRhLmZlYXR1cmVzW2luZGV4XSA6IG51bGw7XG4gICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICBpbmZvLm9iamVjdCA9IGZlYXR1cmU7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogZXh0cnVkZWRDaG9yb3BsZXRoVmVydGV4LFxuICAgICAgZnM6IGV4dHJ1ZGVkQ2hvcm9wbGV0aEZyYWdtZW50LFxuICAgICAgZnA2NDogdHJ1ZSxcbiAgICAgIHByb2plY3Q2NDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIDMyIGJpdCBzdXBwb3J0XG4gICAgLy8gVE9ETyAtIHRoaXMgY291bGQgYmUgZG9uZSBhdXRvbWF0aWNhbGx5IGJ5IGx1bWEgaW4gXCJkcmF3XCJcbiAgICAvLyB3aGVuIGl0IGRldGVjdHMgMzIgYml0IGluZGljZXNcbiAgICBpZiAoIWdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dHJ1ZGVkIGNob3JvcGxldGggbGF5ZXIgbmVlZHMgMzIgYml0IGluZGljZXMnKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZGluZ3MgYXJlIDNkIHNvIGRlcHRoIHRlc3Qgc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAvLyBUT0RPIC0gaXQgaXMgYSBsaXR0bGUgaGVhdnkgaGFuZGVkIHRvIGhhdmUgYSBsYXllciBzZXQgdGhpc1xuICAgIC8vIEFsdGVybmF0aXZlbHksIGNoZWNrIGRlcHRoIHRlc3QgYW5kIHdhcm4gaWYgbm90IHNldCwgb3IgYWRkIGEgcHJvcFxuICAgIC8vIHNldERlcHRoVGVzdCB0aGF0IGlzIG9uIGJ5IGRlZmF1bHQuXG4gICAgZ2wuZW5hYmxlKEdMLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRlcHRoRnVuYyhHTC5MRVFVQUwpO1xuXG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGVhY2ggdG9wIHZlcnRleCBpcyBvbiAzIHN1cmZhY2VzXG4gIC8vIGVhY2ggYm90dG9tIHZlcnRleCBpcyBvbiAyIHN1cmZhY2VzXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBsZXQge3Bvc2l0aW9uc30gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghcG9zaXRpb25zKSB7XG4gICAgICBwb3NpdGlvbnMgPSBmbGF0dGVuKHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLm1hcChcbiAgICAgICAgdmVydGljZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdmVydGljZXMpO1xuICAgICAgICAgIGNvbnN0IGJhc2VWZXJ0aWNlcyA9IHRvcFZlcnRpY2VzLm1hcCh2ID0+IFt2WzBdLCB2WzFdLCAwXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6XG4gICAgICAgICAgICBbdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzLCBiYXNlVmVydGljZXNdO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzICogNCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIFthdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAwXSwgYXR0cmlidXRlLnZhbHVlW2kgKiA0ICsgMV1dID0gZnA2NGlmeShwb3NpdGlvbnNbaSAqIDMgKyAwXSk7XG4gICAgICBbYXR0cmlidXRlLnZhbHVlW2kgKiA0ICsgMl0sIGF0dHJpYnV0ZS52YWx1ZVtpICogNCArIDNdXSA9IGZwNjRpZnkocG9zaXRpb25zW2kgKiAzICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUhlaWdodHMoYXR0cmlidXRlKSB7XG4gICAgbGV0IHtwb3NpdGlvbnN9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIXBvc2l0aW9ucykge1xuICAgICAgcG9zaXRpb25zID0gZmxhdHRlbih0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgICAgIHZlcnRpY2VzID0+IHtcbiAgICAgICAgICBjb25zdCB0b3BWZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHZlcnRpY2VzKTtcbiAgICAgICAgICBjb25zdCBiYXNlVmVydGljZXMgPSB0b3BWZXJ0aWNlcy5tYXAodiA9PiBbdlswXSwgdlsxXSwgMF0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBbdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlc10gOlxuICAgICAgICAgICAgW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoIC8gMyAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgW2F0dHJpYnV0ZS52YWx1ZVtpICogMiArIDBdLCBhdHRyaWJ1dGUudmFsdWVbaSAqIDIgKyAxXV0gPVxuICAgICAgIGZwNjRpZnkocG9zaXRpb25zW2kgKiAzICsgMl0gKyAwLjEpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZU5vcm1hbHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgdXAgPSBbMCwgMSwgMF07XG5cbiAgICBjb25zdCBub3JtYWxzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKFxuICAgICAgKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRvcE5vcm1hbHMgPSBuZXcgQXJyYXkoY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykpLmZpbGwodXApO1xuICAgICAgICBjb25zdCBzaWRlTm9ybWFscyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVTaWRlTm9ybWFscyhwb2x5Z29uKSk7XG4gICAgICAgIGNvbnN0IHNpZGVOb3JtYWxzRm9yd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChuID0+IG5bMF0pO1xuICAgICAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblsxXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IFt0b3BOb3JtYWxzLCB0b3BOb3JtYWxzXSA6XG4gICAgICAgIFt0b3BOb3JtYWxzLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmQsXG4gICAgICAgICAgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuKG5vcm1hbHMpKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHZlcnRpY2VzKSB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgY29uc3Qgbm9ybWFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgY29uc3QgbiA9IGdldE5vcm1hbCh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbaSArIDFdKTtcbiAgICAgIG5vcm1hbHMucHVzaChuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgWy4uLm5vcm1hbHMsIG5vcm1hbHNbMF1dLFxuICAgICAgW25vcm1hbHNbMF0sIC4uLm5vcm1hbHNdXG4gICAgXTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgYnVpbGRpbmdzXG4gICAgY29uc3QgbXVsdGlwbGllciA9IHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IDIgOiA1O1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5yZWR1Y2UoXG4gICAgICAoYWNjLCB2ZXJ0aWNlcykgPT5cbiAgICAgICAgWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIGNvdW50VmVydGljZXModmVydGljZXMpICogbXVsdGlwbGllcl0sXG4gICAgICBbMF1cbiAgICApO1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLm1hcChcbiAgICAgICh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkgPT4gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID9cbiAgICAgICAgLy8gMS4gZ2V0IHNlcXVlbnRpYWxseSBvcmRlcmVkIGluZGljZXMgb2YgZWFjaCBidWlsZGluZyB3aXJlZnJhbWVcbiAgICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGJ1aWxkaW5nc1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKSA6XG4gICAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBidWlsZGluZ3NcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1tidWlsZGluZ0luZGV4XSlcbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW4oaW5kaWNlcykpO1xuICAgIGF0dHJpYnV0ZS50YXJnZXQgPSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFZlcnRleENvdW50KGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKFxuICAgICAgKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHtjb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBiYXNlQ29sb3IgPSBjb2xvciB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgICBjb25zdCB0b3BDb2xvciA9IGNvbG9yIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgICAgICAgY29uc3QgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKHRvcENvbG9yKTtcbiAgICAgICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChiYXNlQ29sb3IpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgICAgIFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgICAgIH1cbiAgICApO1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgfVxuXG4gIGV4dHJhY3RFeHRydWRlZENob3JvcGxldGgoKSB7XG4gICAgY29uc3Qge2RhdGF9ID0gdGhpcy5wcm9wcztcbiAgICAvLyBHZW5lcmF0ZSBhIGZsYXQgbGlzdCBvZiBidWlsZGluZ3NcbiAgICB0aGlzLnN0YXRlLmJ1aWxkaW5ncyA9IFtdO1xuICAgIGZvciAoY29uc3QgYnVpbGRpbmcgb2YgZGF0YS5mZWF0dXJlcykge1xuICAgICAgY29uc3Qge3Byb3BlcnRpZXMsIGdlb21ldHJ5fSA9IGJ1aWxkaW5nO1xuICAgICAgY29uc3Qge2Nvb3JkaW5hdGVzLCB0eXBlfSA9IGdlb21ldHJ5O1xuICAgICAgaWYgKCFwcm9wZXJ0aWVzLmhlaWdodCkge1xuICAgICAgICBwcm9wZXJ0aWVzLmhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAxMDAwO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAvLyBNYXBzIHRvIG11bHRpcGxlIGJ1aWxkaW5nc1xuICAgICAgICBjb25zdCBidWlsZGluZ3MgPSBjb29yZGluYXRlcy5tYXAoXG4gICAgICAgICAgY29vcmRzID0+ICh7Y29vcmRpbmF0ZXM6IGNvb3JkcywgcHJvcGVydGllc30pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhdGUuYnVpbGRpbmdzLnB1c2goLi4uYnVpbGRpbmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgLy8gTWFwcyB0byBhIHNpbmdsZSBidWlsZGluZ1xuICAgICAgICB0aGlzLnN0YXRlLmJ1aWxkaW5ncy5wdXNoKHtjb29yZGluYXRlcywgcHJvcGVydGllc30pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFdlIGFyZSBpZ25vcmluZyBQb2ludHMgZm9yIG5vd1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHZlcnRpY2VzIGZvciB0aGUgYnVpbGRpbmcgbGlzdFxuICAgIHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzID0gdGhpcy5zdGF0ZS5idWlsZGluZ3MubWFwKFxuICAgICAgYnVpbGRpbmcgPT4gYnVpbGRpbmcuY29vcmRpbmF0ZXMubWFwKFxuICAgICAgICBwb2x5Z29uID0+IHBvbHlnb24ubWFwKFxuICAgICAgICAgIGNvb3JkaW5hdGUgPT4gW1xuICAgICAgICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICAgICAgICBidWlsZGluZy5wcm9wZXJ0aWVzLmhlaWdodCB8fCAxMFxuICAgICAgICAgIF1cbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgICByZXR1cm4gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBHTC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTEsIG4tMSwgMF1cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG5cbiAgICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgc3RyaWRlICsgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gICAgbGV0IGhvbGVzID0gbnVsbDtcbiAgICBjb25zdCBxdWFkID0gW1xuICAgICAgWzAsIDFdLCBbMCwgM10sIFsxLCAyXSxcbiAgICAgIFsxLCAyXSwgWzAsIDNdLCBbMSwgNF1cbiAgICBdO1xuXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGhvbGVzID0gdmVydGljZXMucmVkdWNlKFxuICAgICAgICAoYWNjLCBwb2x5Z29uKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdLFxuICAgICAgICBbMF1cbiAgICAgICkuc2xpY2UoMSwgdmVydGljZXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3BJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW4odmVydGljZXMpLCBob2xlcywgMylcbiAgICAgIC5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXQpO1xuXG4gICAgY29uc3Qgc2lkZUluZGljZXMgPSB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuICAgICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG5cbiAgICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaCguLi5kcmF3UmVjdGFuZ2xlKGkpKTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gW3RvcEluZGljZXMsIHNpZGVJbmRpY2VzXTtcblxuICAgIGZ1bmN0aW9uIGRyYXdSZWN0YW5nbGUoaSkge1xuICAgICAgcmV0dXJuIHF1YWQubWFwKHYgPT4gaSArIHZbMF0gKyBzdHJpZGUgKiB2WzFdICsgb2Zmc2V0KTtcbiAgICB9XG4gIH1cbn1cblxuRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NC5sYXllck5hbWUgPSAnRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCc7XG5FeHRydWRlZENob3JvcGxldGhMYXllcjY0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuLypcbiAqIGhlbHBlcnNcbiAqL1xuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGlmIChwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIGNvbnN0IGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5cbiAgY29uc3QgbG9uMSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxWzBdO1xuICBjb25zdCBsb24yID0gZGVncmVlczJyYWRpYW5zICogcDJbMF07XG4gIGNvbnN0IGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMVsxXTtcbiAgY29uc3QgbGF0MiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyWzFdO1xuXG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgY29uc3QgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuXG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG5cbi8vIGNvdW50IG51bWJlciBvZiB2ZXJ0aWNlcyBpbiBnZW9qc29uIHBvbHlnb25cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApO1xufVxuIl19

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* fragment shader for the building-layer */
/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME building-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6ImV4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBmcmFnbWVudCBzaGFkZXIgZm9yIHRoZSBidWlsZGluZy1sYXllciAqL1xuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGJ1aWxkaW5nLWxheWVyLWZyYWdtZW50LXNoYWRlclxuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG59XG5gO1xuIl19

/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("#define SHADER_NAME extruded-choropleths-layer-vertex-shader\n\nattribute vec4 positions;\nattribute vec2 heights;\nattribute vec3 normals;\nattribute vec4 colors;\n\nuniform float opacity;\nuniform float elevation;\n\nuniform vec3 uAmbientColor;\nuniform float uPointLightAmbientCoefficient;\nuniform vec3 uPointLightLocation;\nuniform vec3 uPointLightColor;\nuniform float uPointLightAttenuation;\n\nuniform vec3 uMaterialSpecularColor;\nuniform float uMaterialShininess;\n\nvarying vec4 vColor;\n\nvec3 applyLighting(vec3 position_modelspace, vec3 normal_modelspace, vec3 color) {\n\n  vec3 pointLightLocation_modelspace = vec3(project_position(uPointLightLocation));\n  vec3 lightDirection = normalize(pointLightLocation_modelspace - position_modelspace);\n\n  vec3 ambient = uPointLightAmbientCoefficient * color / 255.0 * uAmbientColor / 255.0;\n\n  float diffuseCoefficient = max(dot(normal_modelspace, lightDirection), 0.0);\n  vec3 diffuse = diffuseCoefficient * uPointLightColor / 255. * color / 255.;\n\n  return ambient + uPointLightAttenuation * diffuse;\n}\n\nvoid main(void) {\n  vec2 projected_xy[2];\n  project_position_fp64(positions, projected_xy);\n  vec2 scaled_height = mul_fp64(heights, vec2(projectionPixelsPerUnit.x * elevation, 0.0));\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_xy[0];\n  vertex_pos_modelspace[1] = projected_xy[1];\n  vertex_pos_modelspace[2] = sum_fp64(scaled_height, vec2(1.0, 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec3 color = applyLighting(\n  \tvec3(\n  \t  vertex_pos_modelspace[0].x,\n  \t  vertex_pos_modelspace[1].x,\n  \t  vertex_pos_modelspace[2].x),\n  \tnormals,\n  \tcolors.rgb\n  );\n  vColor = vec4(color, opacity);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgZXh0cnVkZWQtY2hvcm9wbGV0aHMtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMiBoZWlnaHRzO1xuYXR0cmlidXRlIHZlYzMgbm9ybWFscztcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9ycztcblxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb247XG5cbnVuaWZvcm0gdmVjMyB1QW1iaWVudENvbG9yO1xudW5pZm9ybSBmbG9hdCB1UG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudDtcbnVuaWZvcm0gdmVjMyB1UG9pbnRMaWdodExvY2F0aW9uO1xudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0Q29sb3I7XG51bmlmb3JtIGZsb2F0IHVQb2ludExpZ2h0QXR0ZW51YXRpb247XG5cbnVuaWZvcm0gdmVjMyB1TWF0ZXJpYWxTcGVjdWxhckNvbG9yO1xudW5pZm9ybSBmbG9hdCB1TWF0ZXJpYWxTaGluaW5lc3M7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnZlYzMgYXBwbHlMaWdodGluZyh2ZWMzIHBvc2l0aW9uX21vZGVsc3BhY2UsIHZlYzMgbm9ybWFsX21vZGVsc3BhY2UsIHZlYzMgY29sb3IpIHtcblxuICB2ZWMzIHBvaW50TGlnaHRMb2NhdGlvbl9tb2RlbHNwYWNlID0gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHVQb2ludExpZ2h0TG9jYXRpb24pKTtcbiAgdmVjMyBsaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZShwb2ludExpZ2h0TG9jYXRpb25fbW9kZWxzcGFjZSAtIHBvc2l0aW9uX21vZGVsc3BhY2UpO1xuXG4gIHZlYzMgYW1iaWVudCA9IHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50ICogY29sb3IgLyAyNTUuMCAqIHVBbWJpZW50Q29sb3IgLyAyNTUuMDtcblxuICBmbG9hdCBkaWZmdXNlQ29lZmZpY2llbnQgPSBtYXgoZG90KG5vcm1hbF9tb2RlbHNwYWNlLCBsaWdodERpcmVjdGlvbiksIDAuMCk7XG4gIHZlYzMgZGlmZnVzZSA9IGRpZmZ1c2VDb2VmZmljaWVudCAqIHVQb2ludExpZ2h0Q29sb3IgLyAyNTUuICogY29sb3IgLyAyNTUuO1xuXG4gIHJldHVybiBhbWJpZW50ICsgdVBvaW50TGlnaHRBdHRlbnVhdGlvbiAqIGRpZmZ1c2U7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzIgcHJvamVjdGVkX3h5WzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQocG9zaXRpb25zLCBwcm9qZWN0ZWRfeHkpO1xuICB2ZWMyIHNjYWxlZF9oZWlnaHQgPSBtdWxfZnA2NChoZWlnaHRzLCB2ZWMyKHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnggKiBlbGV2YXRpb24sIDAuMCkpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBwcm9qZWN0ZWRfeHlbMF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHByb2plY3RlZF94eVsxXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQoc2NhbGVkX2hlaWdodCwgdmVjMigxLjAsIDAuMCkpO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWMzIGNvbG9yID0gYXBwbHlMaWdodGluZyhcbiAgXHR2ZWMzKFxuICBcdCAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdLngsXG4gIFx0ICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0ueCxcbiAgXHQgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXS54KSxcbiAgXHRub3JtYWxzLFxuICBcdGNvbG9ycy5yZ2JcbiAgKTtcbiAgdkNvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XG59XG5gO1xuIl19

/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(43);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



var CompositeLayer = function (_Layer) {
  _inherits(CompositeLayer, _Layer);

  function CompositeLayer(props) {
    _classCallCheck(this, CompositeLayer);

    return _possibleConstructorReturn(this, (CompositeLayer.__proto__ || Object.getPrototypeOf(CompositeLayer)).call(this, props));
  }

  _createClass(CompositeLayer, [{
    key: 'initializeState',


    // initializeState is usually not needed for composite layers
    // Provide empty definition to disable check for missing definition
    value: function initializeState() {}

    // No-op for the invalidateAttribute function as the composite
    // layer has no AttributeManager

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {}

    // called to augment the info object that is bubbled up from a sublayer
    // override Layer.getPickingInfo() because decoding / setting uniform do
    // not apply to a composite layer.
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref) {
      var info = _ref.info;

      return info;
    }

    // Implement to generate sublayers

  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      return null;
    }
  }, {
    key: 'isComposite',
    get: function get() {
      return true;
    }
  }]);

  return CompositeLayer;
}(__WEBPACK_IMPORTED_MODULE_0__layer__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (CompositeLayer);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9zaXRlLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiQ29tcG9zaXRlTGF5ZXIiLCJwcm9wcyIsImluZm8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsS0FBUCxNQUFrQixTQUFsQjs7SUFFcUJDLGM7OztBQUNuQiwwQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLDJIQUNYQSxLQURXO0FBRWxCOzs7Ozs7QUFNRDtBQUNBO3NDQUNrQixDQUNqQjs7QUFFRDtBQUNBOzs7OzBDQUNzQixDQUNyQjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7Ozt5Q0FDdUI7QUFBQSxVQUFQQyxJQUFPLFFBQVBBLElBQU87O0FBQ3JCLGFBQU9BLElBQVA7QUFDRDs7QUFFRDs7OzttQ0FDZTtBQUNiLGFBQU8sSUFBUDtBQUNEOzs7d0JBekJpQjtBQUNoQixhQUFPLElBQVA7QUFDRDs7OztFQVB5Q0gsSzs7ZUFBdkJDLGMiLCJmaWxlIjoiY29tcG9zaXRlLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9zaXRlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgZ2V0IGlzQ29tcG9zaXRlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZVN0YXRlIGlzIHVzdWFsbHkgbm90IG5lZWRlZCBmb3IgY29tcG9zaXRlIGxheWVyc1xuICAvLyBQcm92aWRlIGVtcHR5IGRlZmluaXRpb24gdG8gZGlzYWJsZSBjaGVjayBmb3IgbWlzc2luZyBkZWZpbml0aW9uXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIE5vLW9wIGZvciB0aGUgaW52YWxpZGF0ZUF0dHJpYnV0ZSBmdW5jdGlvbiBhcyB0aGUgY29tcG9zaXRlXG4gIC8vIGxheWVyIGhhcyBubyBBdHRyaWJ1dGVNYW5hZ2VyXG4gIGludmFsaWRhdGVBdHRyaWJ1dGUoKSB7XG4gIH1cblxuICAvLyBjYWxsZWQgdG8gYXVnbWVudCB0aGUgaW5mbyBvYmplY3QgdGhhdCBpcyBidWJibGVkIHVwIGZyb20gYSBzdWJsYXllclxuICAvLyBvdmVycmlkZSBMYXllci5nZXRQaWNraW5nSW5mbygpIGJlY2F1c2UgZGVjb2RpbmcgLyBzZXR0aW5nIHVuaWZvcm0gZG9cbiAgLy8gbm90IGFwcGx5IHRvIGEgY29tcG9zaXRlIGxheWVyLlxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSkge1xuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50IHRvIGdlbmVyYXRlIHN1YmxheWVyc1xuICByZW5kZXJMYXllcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = drawLayers;
/* harmony export (immutable) */ __webpack_exports__["b"] = pickLayers;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(7);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */




// Note: corresponding touch events, once supported, should be included here as well.
var MOTION_EVENTS = ['dragmove', 'dragend'];
var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].log(3, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (!layer.isComposite && layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__["a" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  __WEBPACK_IMPORTED_MODULE_2__utils__["a" /* log */].log(3, 'RENDER PASS ' + pass + ': ' + renderCount++ + '\n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      radius = _ref2.radius,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var pickedColor = void 0;
  var pickedLayer = void 0;
  var pickedObjectIndex = void 0;
  var affectedLayers = [];

  if (MOTION_EVENTS.indexOf(mode) !== -1) {
    // "Motion events" are those that track the motion of an interaction
    // after its initiation. In this case, these subsequent events
    // should be bound to the object that was first picked,
    // e.g. to enable dragging behaviors.
    // Therefore, the picking process does not run for these events.
    var layerId = lastPickedInfo.layerId;

    pickedLayer = layers.find(function (layer) {
      return layer.props.id === layerId;
    });
    if (pickedLayer) {
      pickedColor = lastPickedInfo.color;
      pickedObjectIndex = lastPickedInfo.index;
      affectedLayers.push(pickedLayer);
    }
  } else {
    // For all other events, run picking process normally.
    var pickInfo = pickFromBuffer(gl, {
      layers: layers,
      pickingFBO: pickingFBO,
      deviceX: deviceX,
      deviceY: deviceY,
      deviceRadius: deviceRadius
    });

    pickedColor = pickInfo.pickedColor;
    pickedLayer = pickInfo.pickedLayer;
    pickedObjectIndex = pickInfo.pickedObjectIndex;
    affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      // only invoke onHover events if picked object has changed
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;
      var pickedLayerId = pickedLayer && pickedLayer.props.id;

      // proceed only if picked object changed
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          // We cannot store a ref to lastPickedLayer in the context because
          // the state of an outdated layer is no longer valid
          // and the props may have changed
          var lastPickedLayer = layers.find(function (layer) {
            return layer.props.id === lastPickedLayerId;
          });
          if (lastPickedLayer) {
            // Let leave event fire before enter event
            affectedLayers.unshift(lastPickedLayer);
          }
        }

        // Update layer manager context
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
      }
    }
  }

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // The onClick and onHover functions are provided by the user
    // and out of control by deck.gl. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, calls to functions like onClick and onHover need to be done
    // at the end of the function. NO operation relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'dragstart':
        handled = info.layer.props.onDragStart(info);break;
      case 'dragmove':
        handled = info.layer.props.onDragMove(info);break;
      case 'dragend':
        handled = info.layer.props.onDragEnd(info);break;
      case 'dragcancel':
        handled = info.layer.props.onDragCancel(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function pickFromBuffer(gl, _ref3) {
  var layers = _ref3.layers,
      pickingFBO = _ref3.pickingFBO,
      deviceX = _ref3.deviceX,
      deviceY = _ref3.deviceY,
      deviceRadius = _ref3.deviceRadius;


  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  // TODO - just return glContextWithState once luma updates
  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__["h" /* glContextWithState */])(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: x, y: y, w: width, h: height }
  }, function () {

    // Clear the frame buffer
    gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["h" /* getBlendMode */])(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__["a" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColors = new Uint8Array(width * height * 4);
    gl.readPixels(x, y, width, height, __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].RGBA, __WEBPACK_IMPORTED_MODULE_0_luma_gl__["c" /* GL */].UNSIGNED_BYTE, pickedColors);

    // restore blend mode
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["i" /* setBlendMode */])(gl, oldBlendMode);

    // Traverse all pixels in picking results and find the one closest to the supplied
    // [deviceX, deviceY]
    var minSquareDistanceToCenter = deviceRadius * deviceRadius;
    var closestResultToCenter = null;
    var i = 0;

    for (var row = 0; row < height; row++) {
      for (var col = 0; col < width; col++) {
        // Decode picked layer from color
        var pickedLayerIndex = pickedColors[i + 3] - 1;

        if (pickedLayerIndex >= 0) {
          var dx = col + x - deviceX;
          var dy = row + y - deviceY;
          var d2 = dx * dx + dy * dy;

          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;

            // Decode picked object index from color
            var pickedColor = pickedColors.slice(i, i + 4);
            var pickedLayer = layers[pickedLayerIndex];
            var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
            closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
          }
        }
        i += 4;
      }
    }

    return closestResultToCenter || {
      pickedColor: EMPTY_PIXEL,
      pickedLayer: null,
      pickedObjectIndex: -1
    };
  });
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref4) {
  var layer = _ref4.layer,
      info = _ref4.info,
      mode = _ref4.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJHTCIsImdsQ29udGV4dFdpdGhTdGF0ZSIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwibG9nIiwiZ2V0QmxlbmRNb2RlIiwic2V0QmxlbmRNb2RlIiwiTU9USU9OX0VWRU5UUyIsIkVNUFRZX1BJWEVMIiwiVWludDhBcnJheSIsInJlbmRlckNvdW50IiwiZHJhd0xheWVycyIsImxheWVycyIsInBhc3MiLCJsZW5ndGgiLCJ2aXNpYmxlQ291bnQiLCJmb3JFYWNoIiwibGF5ZXIiLCJsYXllckluZGV4IiwiaXNDb21wb3NpdGUiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsInBpY2tMYXllcnMiLCJnbCIsInBpY2tpbmdGQk8iLCJ4IiwieSIsInJhZGl1cyIsIm1vZGUiLCJsYXN0UGlja2VkSW5mbyIsInBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlWCIsIk1hdGgiLCJyb3VuZCIsImRldmljZVkiLCJjYW52YXMiLCJoZWlnaHQiLCJkZXZpY2VSYWRpdXMiLCJwaWNrZWRDb2xvciIsInBpY2tlZExheWVyIiwicGlja2VkT2JqZWN0SW5kZXgiLCJhZmZlY3RlZExheWVycyIsImluZGV4T2YiLCJsYXllcklkIiwiZmluZCIsImlkIiwiY29sb3IiLCJpbmRleCIsInB1c2giLCJwaWNrSW5mbyIsInBpY2tGcm9tQnVmZmVyIiwibGFzdFBpY2tlZE9iamVjdEluZGV4IiwibGFzdFBpY2tlZExheWVySWQiLCJwaWNrZWRMYXllcklkIiwibGFzdFBpY2tlZExheWVyIiwidW5zaGlmdCIsImJhc2VJbmZvIiwiY3JlYXRlSW5mbyIsImRldmljZVBpeGVsIiwiaW5mb3MiLCJNYXAiLCJ1bmhhbmRsZWRQaWNrSW5mb3MiLCJpbmZvIiwicGlja2VkIiwiZ2V0TGF5ZXJQaWNraW5nSW5mbyIsInNldCIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25EcmFnU3RhcnQiLCJvbkRyYWdNb3ZlIiwib25EcmFnRW5kIiwib25EcmFnQ2FuY2VsIiwib25Ib3ZlciIsIkVycm9yIiwibWF4Iiwid2lkdGgiLCJtaW4iLCJmcmFtZUJ1ZmZlciIsImZyYW1lYnVmZmVyIiwic2Npc3NvclRlc3QiLCJ3IiwiaCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJvbGRCbGVuZE1vZGUiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuY1NlcGFyYXRlIiwiT05FIiwiWkVSTyIsIkNPTlNUQU5UX0FMUEhBIiwiYmxlbmRFcXVhdGlvbiIsIkZVTkNfQUREIiwicGlja2FibGUiLCJibGVuZENvbG9yIiwicGlja2VkQ29sb3JzIiwicmVhZFBpeGVscyIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwibWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlciIsImNsb3Nlc3RSZXN1bHRUb0NlbnRlciIsImkiLCJyb3ciLCJjb2wiLCJwaWNrZWRMYXllckluZGV4IiwiZHgiLCJkeSIsImQyIiwic2xpY2UiLCJkZWNvZGVQaWNraW5nQ29sb3IiLCJwaXhlbCIsImxuZ0xhdCIsInVucHJvamVjdCIsInNvdXJjZUxheWVyIiwicGlja0xheWVyIiwicGFyZW50TGF5ZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUUEsRUFBUixFQUFZQyxrQkFBWixRQUFxQyxTQUFyQztBQUNBLFNBQVFDLHVCQUFSLFFBQXNDLHFCQUF0QztBQUNBLFNBQVFDLEdBQVIsRUFBYUMsWUFBYixFQUEyQkMsWUFBM0IsUUFBOEMsU0FBOUM7O0FBRUE7QUFD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QUEyQkMsb0NBQTNCLEVBQXhCO0FBQ0Q7QUFDRjtBQUNEOEQsYUFBSyxDQUFMO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPRCx5QkFBeUI7QUFDOUIvRCxtQkFBYXhDLFdBRGlCO0FBRTlCeUMsbUJBQWEsSUFGaUI7QUFHOUJDLHlCQUFtQixDQUFDO0FBSFUsS0FBaEM7QUFLRCxHQTVFTSxDQUFQO0FBNkVEO0FBQ0Q7O0FBRUEsU0FBU2lCLFVBQVQsQ0FBb0JzRCxLQUFwQixFQUEyQjVGLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0EsU0FBTztBQUNMMkIsV0FBT2hELFdBREY7QUFFTGlELFdBQU8sQ0FBQyxDQUZIO0FBR0xnQixZQUFRLEtBSEg7QUFJTHhDLE9BQUd3RixNQUFNLENBQU4sQ0FKRTtBQUtMdkYsT0FBR3VGLE1BQU0sQ0FBTixDQUxFO0FBTUxBLGdCQU5LO0FBT0xDLFlBQVE3RixTQUFTOEYsU0FBVCxDQUFtQkYsS0FBbkI7QUFQSCxHQUFQO0FBU0Q7O0FBRUQ7QUFDQSxTQUFTL0MsbUJBQVQsUUFBa0Q7QUFBQSxNQUFwQnpELEtBQW9CLFNBQXBCQSxLQUFvQjtBQUFBLE1BQWJ1RCxJQUFhLFNBQWJBLElBQWE7QUFBQSxNQUFQcEMsSUFBTyxTQUFQQSxJQUFPOztBQUNoRCxTQUFPbkIsU0FBU3VELElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTW9ELGNBQWNwRCxLQUFLdkQsS0FBTCxJQUFjQSxLQUFsQztBQUNBdUQsU0FBS3ZELEtBQUwsR0FBYUEsS0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBdUQsV0FBT3ZELE1BQU00RyxTQUFOLENBQWdCLEVBQUNyRCxVQUFELEVBQU9wQyxVQUFQLEVBQWF3Rix3QkFBYixFQUFoQixDQUFQO0FBQ0EzRyxZQUFRQSxNQUFNNkcsV0FBZDtBQUNEO0FBQ0QsU0FBT3RELElBQVA7QUFDRCIsImZpbGUiOiJkcmF3LWFuZC1waWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7R0wsIGdsQ29udGV4dFdpdGhTdGF0ZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2dldFVuaWZvcm1zRnJvbVZpZXdwb3J0fSBmcm9tICcuL3ZpZXdwb3J0LXVuaWZvcm1zJztcbmltcG9ydCB7bG9nLCBnZXRCbGVuZE1vZGUsIHNldEJsZW5kTW9kZX0gZnJvbSAnLi91dGlscyc7XG5cbi8vIE5vdGU6IGNvcnJlc3BvbmRpbmcgdG91Y2ggZXZlbnRzLCBvbmNlIHN1cHBvcnRlZCwgc2hvdWxkIGJlIGluY2x1ZGVkIGhlcmUgYXMgd2VsbC5cbmNvbnN0IE1PVElPTl9FVkVOVFMgPSBbXG4gICdkcmFnbW92ZScsXG4gICdkcmFnZW5kJ1xuXTtcbmNvbnN0IEVNUFRZX1BJWEVMID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG5sZXQgcmVuZGVyQ291bnQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0xheWVycyh7bGF5ZXJzLCBwYXNzfSkge1xuICBsb2cubG9nKDMsIGBEUkFXSU5HICR7bGF5ZXJzLmxlbmd0aH0gbGF5ZXJzYCk7XG5cbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxldCB2aXNpYmxlQ291bnQgPSAwO1xuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgaWYgKCFsYXllci5pc0NvbXBvc2l0ZSAmJiBsYXllci5wcm9wcy52aXNpYmxlKSB7XG4gICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMCwgcGlja2luZ0VuYWJsZWQ6IDB9LFxuICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLFxuICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIHZpc2libGVDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nLmxvZygzLCBgUkVOREVSIFBBU1MgJHtwYXNzfTogJHtyZW5kZXJDb3VudCsrfVxuICAgICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlLCAke2xheWVycy5sZW5ndGh9IHRvdGFsYCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgeCxcbiAgeSxcbiAgcmFkaXVzLFxuICB2aWV3cG9ydCxcbiAgbW9kZSxcbiAgbGFzdFBpY2tlZEluZm9cbn0pIHtcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBkZXZpY2VYID0gTWF0aC5yb3VuZCh4ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVkgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVJhZGl1cyA9IE1hdGgucm91bmQocmFkaXVzICogcGl4ZWxSYXRpbyk7XG5cbiAgbGV0IHBpY2tlZENvbG9yO1xuICBsZXQgcGlja2VkTGF5ZXI7XG4gIGxldCBwaWNrZWRPYmplY3RJbmRleDtcbiAgbGV0IGFmZmVjdGVkTGF5ZXJzID0gW107XG5cbiAgaWYgKE1PVElPTl9FVkVOVFMuaW5kZXhPZihtb2RlKSAhPT0gLTEpIHtcbiAgICAvLyBcIk1vdGlvbiBldmVudHNcIiBhcmUgdGhvc2UgdGhhdCB0cmFjayB0aGUgbW90aW9uIG9mIGFuIGludGVyYWN0aW9uXG4gICAgLy8gYWZ0ZXIgaXRzIGluaXRpYXRpb24uIEluIHRoaXMgY2FzZSwgdGhlc2Ugc3Vic2VxdWVudCBldmVudHNcbiAgICAvLyBzaG91bGQgYmUgYm91bmQgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBmaXJzdCBwaWNrZWQsXG4gICAgLy8gZS5nLiB0byBlbmFibGUgZHJhZ2dpbmcgYmVoYXZpb3JzLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIHBpY2tpbmcgcHJvY2VzcyBkb2VzIG5vdCBydW4gZm9yIHRoZXNlIGV2ZW50cy5cbiAgICBjb25zdCB7bGF5ZXJJZH0gPSBsYXN0UGlja2VkSW5mbztcbiAgICBwaWNrZWRMYXllciA9IGxheWVycy5maW5kKGxheWVyID0+IGxheWVyLnByb3BzLmlkID09PSBsYXllcklkKTtcbiAgICBpZiAocGlja2VkTGF5ZXIpIHtcbiAgICAgIHBpY2tlZENvbG9yID0gbGFzdFBpY2tlZEluZm8uY29sb3I7XG4gICAgICBwaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgICAgYWZmZWN0ZWRMYXllcnMucHVzaChwaWNrZWRMYXllcik7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIGFsbCBvdGhlciBldmVudHMsIHJ1biBwaWNraW5nIHByb2Nlc3Mgbm9ybWFsbHkuXG4gICAgY29uc3QgcGlja0luZm8gPSBwaWNrRnJvbUJ1ZmZlcihnbCwge1xuICAgICAgbGF5ZXJzLFxuICAgICAgcGlja2luZ0ZCTyxcbiAgICAgIGRldmljZVgsXG4gICAgICBkZXZpY2VZLFxuICAgICAgZGV2aWNlUmFkaXVzXG4gICAgfSk7XG5cbiAgICBwaWNrZWRDb2xvciA9IHBpY2tJbmZvLnBpY2tlZENvbG9yO1xuICAgIHBpY2tlZExheWVyID0gcGlja0luZm8ucGlja2VkTGF5ZXI7XG4gICAgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrSW5mby5waWNrZWRPYmplY3RJbmRleDtcbiAgICBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuICAgICAgY29uc3QgcGlja2VkTGF5ZXJJZCA9IHBpY2tlZExheWVyICYmIHBpY2tlZExheWVyLnByb3BzLmlkO1xuXG4gICAgICAvLyBwcm9jZWVkIG9ubHkgaWYgcGlja2VkIG9iamVjdCBjaGFuZ2VkXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQgfHwgcGlja2VkT2JqZWN0SW5kZXggIT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgICAvLyBXZSBjYW5ub3Qgc3RvcmUgYSByZWYgdG8gbGFzdFBpY2tlZExheWVyIGluIHRoZSBjb250ZXh0IGJlY2F1c2VcbiAgICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVyID0gbGF5ZXJzLmZpbmQobGF5ZXIgPT4gbGF5ZXIucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgICAvLyBMZXQgbGVhdmUgZXZlbnQgZmlyZSBiZWZvcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgICBsYXN0UGlja2VkSW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJhc2VJbmZvID0gY3JlYXRlSW5mbyhbeCwgeV0sIHZpZXdwb3J0KTtcbiAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gIC8vIFVzZSBhIE1hcCB0byBzdG9yZSBhbGwgcGlja2luZyBpbmZvcy5cbiAgLy8gVGhlIGZvbGxvd2luZyB0d28gZm9yRWFjaCBsb29wcyBhcmUgdGhlIHJlc3VsdCBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy80NDNcbiAgLy8gUGxlYXNlIGJlIHZlcnkgY2FyZWZ1bCB3aGVuIGNoYW5naW5nIHRoaXMgcGF0dGVyblxuICBjb25zdCBpbmZvcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG5cbiAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgbGV0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSW5mbyk7XG5cbiAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICBpbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe2xheWVyLCBpbmZvLCBtb2RlfSk7XG5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGNvcHkgb2YgaW5mbyBmb3JcbiAgICAvLyBvbmUgY29tcG9zaXRlIGxheWVyXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm9zLnNldChpbmZvLmxheWVyLmlkLCBpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAvLyBUaGUgb25DbGljayBhbmQgb25Ib3ZlciBmdW5jdGlvbnMgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gYW5kIG91dCBvZiBjb250cm9sIGJ5IGRlY2suZ2wuIEl0J3MgdmVyeSBtdWNoIHBvc3NpYmxlIHRoYXRcbiAgICAvLyB0aGUgdXNlciBjYWxscyBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBpbiB0aGVzZSBmdW5jdGlvbiwgc3VjaCBhc1xuICAgIC8vIFJlYWN0Q29tcG9uZW50LnNldFN0YXRlKCkuIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIHNvbWV0aW1lcyBpbmR1Y2VcbiAgICAvLyBhIHJlLXJlbmRlciBhbmQgcmUtZ2VuZXJhdGlvbiBvZiBwcm9wcyBvZiBkZWNrLmdsIGFuZCBpdHMgbGF5ZXJzLFxuICAgIC8vIHdoaWNoIGludmFsaWRhdGVzIGFsbCBsYXllcnMgY3VycmVudGx5IHBhc3NlZCB0byB0aGlzIHZlcnkgZnVuY3Rpb24uXG5cbiAgICAvLyBUaGVyZWZvcmUsIGNhbGxzIHRvIGZ1bmN0aW9ucyBsaWtlIG9uQ2xpY2sgYW5kIG9uSG92ZXIgbmVlZCB0byBiZSBkb25lXG4gICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24uIE5PIG9wZXJhdGlvbiByZWxpZXMgb24gdGhlIHN0YXRlcyBvZiBjdXJyZW50XG4gICAgLy8gbGF5ZXJzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyBjb2RlLlxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25DbGljayhpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnZHJhZ3N0YXJ0JzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25EcmFnU3RhcnQoaW5mbyk7IGJyZWFrO1xuICAgIGNhc2UgJ2RyYWdtb3ZlJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25EcmFnTW92ZShpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnZHJhZ2VuZCc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uRHJhZ0VuZChpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnZHJhZ2NhbmNlbCc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uRHJhZ0NhbmNlbChpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnaG92ZXInOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1bmhhbmRsZWRQaWNrSW5mb3M7XG59XG5cbi8qKlxuICogUGljayBhdCBhIHNwZWNpZmllZCBwaXhlbCB3aXRoIGEgdG9sZXJhbmNlIHJhZGl1c1xuICogUmV0dXJucyB0aGUgY2xvc2VzdCBvYmplY3QgdG8gdGhlIHBpeGVsIGluIHNoYXBlIGB7cGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH1gXG4gKi9cbmZ1bmN0aW9uIHBpY2tGcm9tQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgZGV2aWNlWCxcbiAgZGV2aWNlWSxcbiAgZGV2aWNlUmFkaXVzXG59KSB7XG5cbiAgLy8gQ3JlYXRlIGEgYm94IG9mIHNpemUgYHJhZGl1cyAqIDIgKyAxYCBjZW50ZXJlZCBhdCBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgY29uc3QgeCA9IE1hdGgubWF4KDAsIGRldmljZVggLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB5ID0gTWF0aC5tYXgoMCwgZGV2aWNlWSAtIGRldmljZVJhZGl1cyk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5taW4ocGlja2luZ0ZCTy53aWR0aCwgZGV2aWNlWCArIGRldmljZVJhZGl1cykgLSB4ICsgMTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4ocGlja2luZ0ZCTy5oZWlnaHQsIGRldmljZVkgKyBkZXZpY2VSYWRpdXMpIC0geSArIDE7XG5cbiAgLy8gVE9ETyAtIGp1c3QgcmV0dXJuIGdsQ29udGV4dFdpdGhTdGF0ZSBvbmNlIGx1bWEgdXBkYXRlc1xuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIC8vIE5vdGUgdGhhdCB0aGUgY2FsbGJhY2sgaGVyZSBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgcmV0dXJuIGdsQ29udGV4dFdpdGhTdGF0ZShnbCwge1xuICAgIGZyYW1lQnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB7eCwgeSwgdzogd2lkdGgsIGg6IGhlaWdodH1cbiAgfSwgKCkgPT4ge1xuXG4gICAgLy8gQ2xlYXIgdGhlIGZyYW1lIGJ1ZmZlclxuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAvLyBTYXZlIGN1cnJlbnQgYmxlbmQgc2V0dGluZ3NcbiAgICBjb25zdCBvbGRCbGVuZE1vZGUgPSBnZXRCbGVuZE1vZGUoZ2wpO1xuICAgIC8vIFNldCBibGVuZCBtb2RlIGZvciBwaWNraW5nXG4gICAgLy8gYWx3YXlzIG92ZXJ3cml0ZSBleGlzdGluZyBwaXhlbCB3aXRoIFtyLGcsYixsYXllckluZGV4XVxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5aRVJPLCBnbC5DT05TVEFOVF9BTFBIQSwgZ2wuWkVSTyk7XG4gICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHBpY2thYmxlIGxheWVycyBpbiBwaWNraW5nIGNvbG9yc1xuICAgIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgICAgaWYgKCFsYXllci5pc0NvbXBvc2l0ZSAmJiBsYXllci5wcm9wcy52aXNpYmxlICYmIGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG5cbiAgICAgICAgLy8gRW5jb2RlIGxheWVySW5kZXggd2l0aCBhbHBoYVxuICAgICAgICBnbC5ibGVuZENvbG9yKDAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTUpO1xuXG4gICAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDF9LFxuICAgICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgIGNvbnN0IHBpY2tlZENvbG9ycyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBHTC5SR0JBLCBHTC5VTlNJR05FRF9CWVRFLCBwaWNrZWRDb2xvcnMpO1xuXG4gICAgLy8gcmVzdG9yZSBibGVuZCBtb2RlXG4gICAgc2V0QmxlbmRNb2RlKGdsLCBvbGRCbGVuZE1vZGUpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGZpbmQgdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZFxuICAgIC8vIFtkZXZpY2VYLCBkZXZpY2VZXVxuICAgIGxldCBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZGV2aWNlUmFkaXVzICogZGV2aWNlUmFkaXVzO1xuICAgIGxldCBjbG9zZXN0UmVzdWx0VG9DZW50ZXIgPSBudWxsO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHdpZHRoOyBjb2wrKykge1xuICAgICAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICAgICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgICAgICBjb25zdCBkeCA9IGNvbCArIHggLSBkZXZpY2VYO1xuICAgICAgICAgIGNvbnN0IGR5ID0gcm93ICsgeSAtIGRldmljZVk7XG4gICAgICAgICAgY29uc3QgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgIGlmIChkMiA8PSBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyKSB7XG4gICAgICAgICAgICBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZDI7XG5cbiAgICAgICAgICAgIC8vIERlY29kZSBwaWNrZWQgb2JqZWN0IGluZGV4IGZyb20gY29sb3JcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZENvbG9yID0gcGlja2VkQ29sb3JzLnNsaWNlKGksIGkgKyA0KTtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpO1xuICAgICAgICAgICAgY2xvc2VzdFJlc3VsdFRvQ2VudGVyID0ge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpICs9IDQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RSZXN1bHRUb0NlbnRlciB8fCB7XG4gICAgICBwaWNrZWRDb2xvcjogRU1QVFlfUElYRUwsXG4gICAgICBwaWNrZWRMYXllcjogbnVsbCxcbiAgICAgIHBpY2tlZE9iamVjdEluZGV4OiAtMVxuICAgIH07XG4gIH0pO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBsbmdMYXQ6IHZpZXdwb3J0LnVucHJvamVjdChwaXhlbClcbiAgfTtcbn1cblxuLy8gV2FsayB1cCB0aGUgbGF5ZXIgY29tcG9zaXRlIGNoYWluIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuZnVuY3Rpb24gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KSB7XG4gIHdoaWxlIChsYXllciAmJiBpbmZvKSB7XG4gICAgLy8gRm9yIGEgY29tcG9zaXRlIGxheWVyLCBzb3VyY2VMYXllciB3aWxsIHBvaW50IHRvIHRoZSBzdWJsYXllclxuICAgIC8vIHdoZXJlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20uXG4gICAgLy8gSXQgcHJvdmlkZXMgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRlIGxheWVyJ3NcbiAgICAvLyBnZXRQaWNraW5nSW5mbygpIG1ldGhvZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbiAgICBjb25zdCBzb3VyY2VMYXllciA9IGluZm8ubGF5ZXIgfHwgbGF5ZXI7XG4gICAgaW5mby5sYXllciA9IGxheWVyO1xuICAgIC8vIGxheWVyLnBpY2tMYXllcigpIGZ1bmN0aW9uIHJlcXVpcmVzIGEgbm9uLW51bGwgYGBgbGF5ZXIuc3RhdGVgYGBcbiAgICAvLyBvYmplY3QgdG8gZnVudGlvbiBwcm9wZXJseS4gU28gdGhlIGxheWVyIHJlZmVyZWNlZCBoZXJlXG4gICAgLy8gbXVzdCBiZSB0aGUgXCJjdXJyZW50XCIgbGF5ZXIsIG5vdCBhbiBcIm91dC1kYXRlZFwiIC8gXCJpbnZhbGlkYXRlZFwiIGxheWVyXG4gICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZSwgc291cmNlTGF5ZXJ9KTtcbiAgICBsYXllciA9IGxheWVyLnBhcmVudExheWVyO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuIl19

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_globals__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json__ = __webpack_require__(211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__package_json__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




// Version detection
// TODO - this imports a rather large JSON file, we only need one field


var STARTUP_MESSAGE = 'set deck.log.priority=2 to trace attribute updates';

if (__WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck && __WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck.VERSION !== __WEBPACK_IMPORTED_MODULE_2__package_json__["version"]) {
  throw new Error('deck.gl - multiple versions detected: ' + __WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck.VERSION + ' vs ' + __WEBPACK_IMPORTED_MODULE_2__package_json__["version"]);
}

if (!__WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck) {
  /* global console */
  /* eslint-disable no-console */
  console.log('deck.gl ' + __WEBPACK_IMPORTED_MODULE_2__package_json__["version"] + ' - ' + STARTUP_MESSAGE);

  __WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck = __WEBPACK_IMPORTED_MODULE_0__utils_globals__["global"].deck || {
    VERSION: __WEBPACK_IMPORTED_MODULE_2__package_json__["version"],
    log: __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */]
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvaW5pdC5qcyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJsb2ciLCJ2ZXJzaW9uIiwiU1RBUlRVUF9NRVNTQUdFIiwiZGVjayIsIlZFUlNJT04iLCJFcnJvciIsImNvbnNvbGUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLE1BQVIsUUFBcUIsaUJBQXJCO0FBQ0EsT0FBT0MsR0FBUCxNQUFnQixhQUFoQjs7QUFFQTtBQUNBO0FBQ0EsU0FBUUMsT0FBUixRQUFzQixvQkFBdEI7O0FBRUEsSUFBTUMsa0JBQWtCLG9EQUF4Qjs7QUFFQSxJQUFJSCxPQUFPSSxJQUFQLElBQWVKLE9BQU9JLElBQVAsQ0FBWUMsT0FBWixLQUF3QkgsT0FBM0MsRUFBb0Q7QUFDbEQsUUFBTSxJQUFJSSxLQUFKLDRDQUFtRE4sT0FBT0ksSUFBUCxDQUFZQyxPQUEvRCxZQUE2RUgsT0FBN0UsQ0FBTjtBQUNEOztBQUVELElBQUksQ0FBQ0YsT0FBT0ksSUFBWixFQUFrQjtBQUNoQjtBQUNBO0FBQ0FHLFVBQVFOLEdBQVIsY0FBdUJDLE9BQXZCLFdBQW9DQyxlQUFwQzs7QUFFQUgsU0FBT0ksSUFBUCxHQUFjSixPQUFPSSxJQUFQLElBQWU7QUFDM0JDLGFBQVNILE9BRGtCO0FBRTNCRDtBQUYyQixHQUE3QjtBQUlEIiwiZmlsZSI6ImluaXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtnbG9iYWx9IGZyb20gJy4vdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvbG9nJztcblxuLy8gVmVyc2lvbiBkZXRlY3Rpb25cbi8vIFRPRE8gLSB0aGlzIGltcG9ydHMgYSByYXRoZXIgbGFyZ2UgSlNPTiBmaWxlLCB3ZSBvbmx5IG5lZWQgb25lIGZpZWxkXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5cbmNvbnN0IFNUQVJUVVBfTUVTU0FHRSA9ICdzZXQgZGVjay5sb2cucHJpb3JpdHk9MiB0byB0cmFjZSBhdHRyaWJ1dGUgdXBkYXRlcyc7XG5cbmlmIChnbG9iYWwuZGVjayAmJiBnbG9iYWwuZGVjay5WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XG4gIHRocm93IG5ldyBFcnJvcihgZGVjay5nbCAtIG11bHRpcGxlIHZlcnNpb25zIGRldGVjdGVkOiAke2dsb2JhbC5kZWNrLlZFUlNJT059IHZzICR7dmVyc2lvbn1gKTtcbn1cblxuaWYgKCFnbG9iYWwuZGVjaykge1xuICAvKiBnbG9iYWwgY29uc29sZSAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGNvbnNvbGUubG9nKGBkZWNrLmdsICR7dmVyc2lvbn0gLSAke1NUQVJUVVBfTUVTU0FHRX1gKTtcblxuICBnbG9iYWwuZGVjayA9IGdsb2JhbC5kZWNrIHx8IHtcbiAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgIGxvZ1xuICB9O1xufVxuIl19

/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__draw_and_pick__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__viewports__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__debug_seer_integration__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_luma_gl__ = __webpack_require__(5);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// IMLEMENTATION NOTES: Why new layers are created on every render
//
// The key here is to understand the declarative / functional
// programming nature of "reactive" applications.
//
// - In a reactive application, the entire "UI tree"
//   is re-rendered every time something in the application changes.
//
// - The UI framework (such as React or deck.gl) then diffs the rendered
//   tree of UI elements (React Elements or deck.gl Layers) against the
//   previously tree and makes optimized changes (to the DOM or to WebGL state).
//
// - Deck.gl layers are not based on React.
//   But it should be possible to wrap deck.gl layers in React components to
//   enable use of JSX.
//
// The deck.gl model that for the app creates a new set of on layers on every
// render.
// Internally, the new layers are efficiently matched against existing layers
// using layer ids.
//
// All calculated state (programs, attributes etc) are stored in a state object
// and this state object is moved forward to the match layer on every render
// cycle.  The new layer ends up with the state of the old layer (and the
// props of the new layer), while the old layer is simply discarded for
// garbage collecion.
//
/* eslint-disable no-try-catch */










var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 3;

var LayerManager = function () {
  function LayerManager(_ref) {
    var _this = this;

    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    this.prevLayers = [];
    this.layers = [];
    // Tracks if any layers were drawn last update
    // Needed to ensure that screen is cleared when no layers are shown
    this.screenCleared = false;
    this.oldContext = {};
    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      lastPickedInfo: {
        index: -1,
        layerId: null
      },
      shaderCache: new __WEBPACK_IMPORTED_MODULE_7_luma_gl__["f" /* experimental */].ShaderCache({ gl: gl })
    };

    Object.seal(this.context);

    /**
     * Set an override on the specified property and update the layers
     */
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__debug_seer_integration__["a" /* layerEditListener */])(function (payload) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__debug_seer_integration__["b" /* setOverride */])(payload.itemKey, payload.valuePath, payload.value);
      var newLayers = _this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      _this.updateLayers({ newLayers: newLayers });
    });
  }

  _createClass(LayerManager, [{
    key: 'setViewport',
    value: function setViewport(viewport) {
      __WEBPACK_IMPORTED_MODULE_2_assert___default()(viewport instanceof __WEBPACK_IMPORTED_MODULE_5__viewports__["b" /* Viewport */], 'Invalid viewport');

      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */])(4, viewport);
      }

      return this;
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref2) {
      var newLayers = _ref2.newLayers;

      /* eslint-disable */
      __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref3) {
      var pass = _ref3.pass;

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__["a" /* drawLayers */])({ layers: this.layers, pass: pass });

      return this;
    }
  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          mode = _ref4.mode,
          _ref4$radius = _ref4.radius,
          radius = _ref4$radius === undefined ? 0 : _ref4$radius;
      var _context = this.context,
          gl = _context.gl,
          uniforms = _context.uniforms;

      // Set up a frame buffer if needed

      if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {
        this.context.pickingFBO = new __WEBPACK_IMPORTED_MODULE_7_luma_gl__["g" /* FramebufferObject */](gl, {
          width: gl.canvas.width,
          height: gl.canvas.height
        });
      }
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__["b" /* pickLayers */])(gl, {
        x: x,
        y: y,
        radius: radius,
        layers: this.layers,
        mode: mode,
        viewport: this.context.viewport,
        pickingFBO: this.context.pickingFBO,
        lastPickedInfo: this.context.lastPickedInfo
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = false;

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else {
        if (this.screenCleared === true) {
          this.screenCleared = false;
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    // PRIVATE METHODS

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref6) {
      var oldLayers = _ref6.oldLayers,
          newLayers = _ref6.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var oldLayer = _step3.value;

          if (oldLayerMap[oldLayer.id]) {
            __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'Multipe old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref7) {
      var _this2 = this;

      var newLayers = _ref7.newLayers,
          oldLayerMap = _ref7.oldLayerMap,
          generatedLayers = _ref7.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step4.value;

          newLayer.context = _this2.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'Multipe new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {

              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__debug_seer_integration__["c" /* logLayer */])(newLayer);

              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */])(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '=>', newLayer);
              _this2._transferLayerState(oldLayer, newLayer);
              _this2._updateLayer(newLayer);
            } else {
              _this2._initializeNewLayer(newLayer);
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var sublayers = newLayer.isComposite ? newLayer.renderLayers() : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this2._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      __WEBPACK_IMPORTED_MODULE_2_assert___default()(state, 'deck.gl sanity check - Matching layer has no state');
      __WEBPACK_IMPORTED_MODULE_2_assert___default()(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');

      // Move state
      newLayer.state = state;
      newLayer.lifecycle = __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* LIFECYCLE */].MATCHED;
      state.layer = newLayer;

      // Update model layer reference
      if (state.model) {
        state.model.userData.layer = newLayer;
      }
      // Keep a temporary ref to the old props, for prop comparison
      newLayer.oldProps = props;
      // oldLayer.state = null;
      oldLayer.lifecycle = __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* LIFECYCLE */].OUTDATED;
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;

          if (layer.lifecycle !== __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* LIFECYCLE */].OUTDATED) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */])(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {
          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });
          layer.lifecycle = __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* LIFECYCLE */].INITIALIZED;
        } catch (err) {
          __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */])(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          __WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */].once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = __WEBPACK_IMPORTED_MODULE_4__constants__["b" /* LIFECYCLE */].FINALIZED;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* log */])(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }
  }]);

  return LayerManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (LayerManager);


function layerName(layer) {
  if (layer instanceof __WEBPACK_IMPORTED_MODULE_0__layer__["a" /* default */]) {
    return '' + layer;
  }
  return !layer ? 'null layer' : 'invalid layer';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImxvZyIsImFzc2VydCIsImRyYXdMYXllcnMiLCJwaWNrTGF5ZXJzIiwiTElGRUNZQ0xFIiwiVmlld3BvcnQiLCJzZXRPdmVycmlkZSIsImxheWVyRWRpdExpc3RlbmVyIiwibG9nTGF5ZXIiLCJleHBlcmltZW50YWwiLCJGcmFtZWJ1ZmZlck9iamVjdCIsIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwiTGF5ZXJNYW5hZ2VyIiwiZ2wiLCJwcmV2TGF5ZXJzIiwibGF5ZXJzIiwic2NyZWVuQ2xlYXJlZCIsIm9sZENvbnRleHQiLCJjb250ZXh0IiwidW5pZm9ybXMiLCJ2aWV3cG9ydCIsInZpZXdwb3J0Q2hhbmdlZCIsInBpY2tpbmdGQk8iLCJsYXN0UGlja2VkSW5mbyIsImluZGV4IiwibGF5ZXJJZCIsInNoYWRlckNhY2hlIiwiU2hhZGVyQ2FjaGUiLCJPYmplY3QiLCJzZWFsIiwicGF5bG9hZCIsIml0ZW1LZXkiLCJ2YWx1ZVBhdGgiLCJ2YWx1ZSIsIm5ld0xheWVycyIsIm1hcCIsImxheWVyIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInVwZGF0ZUxheWVycyIsImFzc2lnbiIsImZpbHRlciIsIm5ld0xheWVyIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwicGFzcyIsIngiLCJ5IiwibW9kZSIsInJhZGl1cyIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiY2xlYXJSZWRyYXdGbGFncyIsInJlZHJhdyIsImxlbmd0aCIsImdldE5lZWRzUmVkcmF3Iiwib2xkTGF5ZXJNYXAiLCJvbGRMYXllciIsImlkIiwib25jZSIsImxheWVyTmFtZSIsIl9tYXRjaFN1YmxheWVycyIsImVycm9yMiIsIl9maW5hbGl6ZU9sZExheWVycyIsImZpcnN0RXJyb3IiLCJfdHJhbnNmZXJMYXllclN0YXRlIiwiX3VwZGF0ZUxheWVyIiwiX2luaXRpYWxpemVOZXdMYXllciIsInB1c2giLCJzdWJsYXllcnMiLCJpc0NvbXBvc2l0ZSIsInJlbmRlckxheWVycyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwYXJlbnRMYXllciIsImVyciIsInN0YXRlIiwibGlmZWN5Y2xlIiwiTUFUQ0hFRCIsIm1vZGVsIiwidXNlckRhdGEiLCJvbGRQcm9wcyIsIk9VVERBVEVEIiwiX2ZpbmFsaXplTGF5ZXIiLCJpbml0aWFsaXplTGF5ZXIiLCJjaGFuZ2VGbGFncyIsImRpZmZQcm9wcyIsIklOSVRJQUxJWkVEIiwidXBkYXRlTGF5ZXIiLCJmaW5hbGl6ZUxheWVyIiwiRklOQUxJWkVEIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPQSxLQUFQLE1BQWtCLFNBQWxCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixTQUFsQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxTQUFRQyx5QkFBUixFQUFvQkMsVUFBcEIsUUFBcUMsaUJBQXJDO0FBQ0EsU0FBUUMsU0FBUixRQUF3QixhQUF4QjtBQUNBLFNBQVFDLFFBQVIsUUFBdUIsYUFBdkI7QUFDQSxTQUFRQyxXQUFSLEVBQXFCQyxpQkFBckIsRUFBd0NDLFFBQXhDLFFBQXVELDJCQUF2RDtBQUNBLFNBQVFDLFlBQVIsUUFBMkIsU0FBM0I7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyxTQUFoQzs7QUFFQSxJQUFNQyx5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LGlCQUFpQnRDLEtBQXJCLEVBQTRCO0FBQzFCLGdCQUFVc0MsS0FBVjtBQUNEO0FBQ0QsU0FBTyxDQUFDQSxLQUFELEdBQVMsWUFBVCxHQUF3QixlQUEvQjtBQUNEIiwiZmlsZSI6ImxheWVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gSU1MRU1FTlRBVElPTiBOT1RFUzogV2h5IG5ldyBsYXllcnMgYXJlIGNyZWF0ZWQgb24gZXZlcnkgcmVuZGVyXG4vL1xuLy8gVGhlIGtleSBoZXJlIGlzIHRvIHVuZGVyc3RhbmQgdGhlIGRlY2xhcmF0aXZlIC8gZnVuY3Rpb25hbFxuLy8gcHJvZ3JhbW1pbmcgbmF0dXJlIG9mIFwicmVhY3RpdmVcIiBhcHBsaWNhdGlvbnMuXG4vL1xuLy8gLSBJbiBhIHJlYWN0aXZlIGFwcGxpY2F0aW9uLCB0aGUgZW50aXJlIFwiVUkgdHJlZVwiXG4vLyAgIGlzIHJlLXJlbmRlcmVkIGV2ZXJ5IHRpbWUgc29tZXRoaW5nIGluIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxuLy9cbi8vIC0gVGhlIFVJIGZyYW1ld29yayAoc3VjaCBhcyBSZWFjdCBvciBkZWNrLmdsKSB0aGVuIGRpZmZzIHRoZSByZW5kZXJlZFxuLy8gICB0cmVlIG9mIFVJIGVsZW1lbnRzIChSZWFjdCBFbGVtZW50cyBvciBkZWNrLmdsIExheWVycykgYWdhaW5zdCB0aGVcbi8vICAgcHJldmlvdXNseSB0cmVlIGFuZCBtYWtlcyBvcHRpbWl6ZWQgY2hhbmdlcyAodG8gdGhlIERPTSBvciB0byBXZWJHTCBzdGF0ZSkuXG4vL1xuLy8gLSBEZWNrLmdsIGxheWVycyBhcmUgbm90IGJhc2VkIG9uIFJlYWN0LlxuLy8gICBCdXQgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHdyYXAgZGVjay5nbCBsYXllcnMgaW4gUmVhY3QgY29tcG9uZW50cyB0b1xuLy8gICBlbmFibGUgdXNlIG9mIEpTWC5cbi8vXG4vLyBUaGUgZGVjay5nbCBtb2RlbCB0aGF0IGZvciB0aGUgYXBwIGNyZWF0ZXMgYSBuZXcgc2V0IG9mIG9uIGxheWVycyBvbiBldmVyeVxuLy8gcmVuZGVyLlxuLy8gSW50ZXJuYWxseSwgdGhlIG5ldyBsYXllcnMgYXJlIGVmZmljaWVudGx5IG1hdGNoZWQgYWdhaW5zdCBleGlzdGluZyBsYXllcnNcbi8vIHVzaW5nIGxheWVyIGlkcy5cbi8vXG4vLyBBbGwgY2FsY3VsYXRlZCBzdGF0ZSAocHJvZ3JhbXMsIGF0dHJpYnV0ZXMgZXRjKSBhcmUgc3RvcmVkIGluIGEgc3RhdGUgb2JqZWN0XG4vLyBhbmQgdGhpcyBzdGF0ZSBvYmplY3QgaXMgbW92ZWQgZm9yd2FyZCB0byB0aGUgbWF0Y2ggbGF5ZXIgb24gZXZlcnkgcmVuZGVyXG4vLyBjeWNsZS4gIFRoZSBuZXcgbGF5ZXIgZW5kcyB1cCB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgb2xkIGxheWVyIChhbmQgdGhlXG4vLyBwcm9wcyBvZiB0aGUgbmV3IGxheWVyKSwgd2hpbGUgdGhlIG9sZCBsYXllciBpcyBzaW1wbHkgZGlzY2FyZGVkIGZvclxuLy8gZ2FyYmFnZSBjb2xsZWNpb24uXG4vL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdHJ5LWNhdGNoICovXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge2RyYXdMYXllcnMsIHBpY2tMYXllcnN9IGZyb20gJy4vZHJhdy1hbmQtcGljayc7XG5pbXBvcnQge0xJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuaW1wb3J0IHtzZXRPdmVycmlkZSwgbGF5ZXJFZGl0TGlzdGVuZXIsIGxvZ0xheWVyfSBmcm9tICcuLi9kZWJ1Zy9zZWVyLWludGVncmF0aW9uJztcbmltcG9ydCB7ZXhwZXJpbWVudGFsfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7RnJhbWVidWZmZXJPYmplY3R9IGZyb20gJ2x1bWEuZ2wnO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFID0gMjtcbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IgPSAzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllck1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7Z2x9KSB7XG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gW107XG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAvLyBUcmFja3MgaWYgYW55IGxheWVycyB3ZXJlIGRyYXduIGxhc3QgdXBkYXRlXG4gICAgLy8gTmVlZGVkIHRvIGVuc3VyZSB0aGF0IHNjcmVlbiBpcyBjbGVhcmVkIHdoZW4gbm8gbGF5ZXJzIGFyZSBzaG93blxuICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgIHRoaXMub2xkQ29udGV4dCA9IHt9O1xuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgIGdsLFxuICAgICAgdW5pZm9ybXM6IHt9LFxuICAgICAgdmlld3BvcnQ6IG51bGwsXG4gICAgICB2aWV3cG9ydENoYW5nZWQ6IHRydWUsXG4gICAgICBwaWNraW5nRkJPOiBudWxsLFxuICAgICAgbGFzdFBpY2tlZEluZm86IHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBsYXllcklkOiBudWxsXG4gICAgICB9LFxuICAgICAgc2hhZGVyQ2FjaGU6IG5ldyBleHBlcmltZW50YWwuU2hhZGVyQ2FjaGUoe2dsfSlcbiAgICB9O1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcy5jb250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBvdmVycmlkZSBvbiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGFuZCB1cGRhdGUgdGhlIGxheWVyc1xuICAgICAqL1xuICAgIGxheWVyRWRpdExpc3RlbmVyKHBheWxvYWQgPT4ge1xuICAgICAgc2V0T3ZlcnJpZGUocGF5bG9hZC5pdGVtS2V5LCBwYXlsb2FkLnZhbHVlUGF0aCwgcGF5bG9hZC52YWx1ZSk7XG4gICAgICBjb25zdCBuZXdMYXllcnMgPSB0aGlzLmxheWVycy5tYXAobGF5ZXIgPT4gbmV3IGxheWVyLmNvbnN0cnVjdG9yKGxheWVyLnByb3BzKSk7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgLy8gVE9ETyAtIHZpZXdwb3J0IGNoYW5nZSBkZXRlY3Rpb24gYnJlYWtzIE1FVEVSX09GRlNFVFMgbW9kZVxuICAgIC8vIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIC8vIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKG9sZFZpZXdwb3J0KTtcblxuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkQ29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRleHQudW5pZm9ybXMgPSB7fTtcbiAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVMYXllcnMoe25ld0xheWVyc30pIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICAnTGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBsYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMucHJldkxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIGNvbnN0IHtlcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfSA9IHRoaXMuX3VwZGF0ZUxheWVycyh7XG4gICAgICBvbGRMYXllcnM6IHRoaXMucHJldkxheWVycyxcbiAgICAgIG5ld0xheWVyc1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgLy8gVGhyb3cgZmlyc3QgZXJyb3IgZm91bmQsIGlmIGFueVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhd0xheWVycyh7cGFzc30pIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIGRyYXdMYXllcnMoe2xheWVyczogdGhpcy5sYXllcnMsIHBhc3N9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGlja0xheWVyKHt4LCB5LCBtb2RlLCByYWRpdXMgPSAwfSkge1xuICAgIGNvbnN0IHtnbCwgdW5pZm9ybXN9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgLy8gU2V0IHVwIGEgZnJhbWUgYnVmZmVyIGlmIG5lZWRlZFxuICAgIGlmICh0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9PT0gbnVsbCB8fFxuICAgICAgZ2wuY2FudmFzLndpZHRoICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy53aWR0aCB8fFxuICAgICAgZ2wuY2FudmFzLmhlaWdodCAhPT0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8uaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9IG5ldyBGcmFtZWJ1ZmZlck9iamVjdChnbCwge1xuICAgICAgICB3aWR0aDogZ2wuY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGlja0xheWVycyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByYWRpdXMsXG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgbW9kZSxcbiAgICAgIHZpZXdwb3J0OiB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB0aGlzLmNvbnRleHQubGFzdFBpY2tlZEluZm9cbiAgICB9KTtcbiAgfVxuXG4gIG5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dC52aWV3cG9ydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpcyBjbGVhcmVkIG9uY2Ugd2hlbiBsYXllciBsaXN0IGJlY29tZXMgZW1wdHlcbiAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSBmYWxzZSkge1xuICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuc2NyZWVuQ2xlYXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIF91cGRhdGVMYXllcnMoe29sZExheWVycywgbmV3TGF5ZXJzfSkge1xuICAgIC8vIENyZWF0ZSBvbGQgbGF5ZXIgbWFwXG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9sZExheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKG9sZExheWVyTWFwW29sZExheWVyLmlkXSkge1xuICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBvbGQgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShvbGRMYXllcil9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMYXllck1hcFtvbGRMYXllci5pZF0gPSBvbGRMYXllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSBhcnJheSBmb3IgZ2VuZXJhdGVkIGxheWVyc1xuICAgIGNvbnN0IGdlbmVyYXRlZExheWVycyA9IFtdO1xuXG4gICAgLy8gTWF0Y2ggc3VibGF5ZXJzXG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICBuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IGVycm9yMiA9IHRoaXMuX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycyk7XG4gICAgY29uc3QgZmlyc3RFcnJvciA9IGVycm9yIHx8IGVycm9yMjtcbiAgICByZXR1cm4ge2Vycm9yOiBmaXJzdEVycm9yLCBnZW5lcmF0ZWRMYXllcnN9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfbWF0Y2hTdWJsYXllcnMoe25ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc30pIHtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gMS4gZ2l2ZW4gYSBuZXcgY29taW5nIGxheWVyLCBmaW5kIGl0cyBtYXRjaGluZyBsYXllclxuICAgICAgICBjb25zdCBvbGRMYXllciA9IG9sZExheWVyTWFwW25ld0xheWVyLmlkXTtcbiAgICAgICAgb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdID0gbnVsbDtcblxuICAgICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHRyYW5zZmVyIHN0YXRlIGF0IHRoaXMgc3RhZ2UuIFdlIG11c3Qgbm90IGdlbmVyYXRlIGV4Y2VwdGlvbnNcbiAgICAgICAgLy8gdW50aWwgYWxsIGxheWVycycgc3RhdGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgIGlmIChvbGRMYXllcikge1xuXG4gICAgICAgICAgbG9nTGF5ZXIobmV3TGF5ZXIpO1xuXG4gICAgICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsXG4gICAgICAgICAgICBgbWF0Y2hlZCAke2xheWVyTmFtZShuZXdMYXllcil9YCwgb2xkTGF5ZXIsICc9PicsIG5ld0xheWVyKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKTtcbiAgICAgICAgICB0aGlzLl91cGRhdGVMYXllcihuZXdMYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5ld0xheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0ZWRMYXllcnMucHVzaChuZXdMYXllcik7XG5cbiAgICAgICAgLy8gQ2FsbCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG4gICAgICAgIGxldCBzdWJsYXllcnMgPSBuZXdMYXllci5pc0NvbXBvc2l0ZSA/IG5ld0xheWVyLnJlbmRlckxheWVycygpIDogbnVsbDtcbiAgICAgICAgLy8gRW5kIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcblxuICAgICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgICAgc3VibGF5ZXJzID0gQXJyYXkuaXNBcnJheShzdWJsYXllcnMpID8gc3VibGF5ZXJzIDogW3N1YmxheWVyc107XG5cbiAgICAgICAgICAvLyBwb3B1bGF0ZSByZWZlcmVuY2UgdG8gcGFyZW50IGxheWVyXG4gICAgICAgICAgc3VibGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgICAgbGF5ZXIucGFyZW50TGF5ZXIgPSBuZXdMYXllcjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgICAgICAgIG5ld0xheWVyczogc3VibGF5ZXJzLFxuICAgICAgICAgICAgb2xkTGF5ZXJNYXAsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMYXllcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIG1hdGNoaW5nIG9mICR7bGF5ZXJOYW1lKG5ld0xheWVyKX0gJHtlcnJ9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpIHtcbiAgICBjb25zdCB7c3RhdGUsIHByb3BzfSA9IG9sZExheWVyO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXNzZXJ0KHN0YXRlLCAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBoYXMgbm8gc3RhdGUnKTtcbiAgICBhc3NlcnQob2xkTGF5ZXIgIT09IG5ld0xheWVyLCAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBpcyBzYW1lJyk7XG5cbiAgICAvLyBNb3ZlIHN0YXRlXG4gICAgbmV3TGF5ZXIuc3RhdGUgPSBzdGF0ZTtcbiAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICBzdGF0ZS5sYXllciA9IG5ld0xheWVyO1xuXG4gICAgLy8gVXBkYXRlIG1vZGVsIGxheWVyIHJlZmVyZW5jZVxuICAgIGlmIChzdGF0ZS5tb2RlbCkge1xuICAgICAgc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBuZXdMYXllcjtcbiAgICB9XG4gICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgIG5ld0xheWVyLm9sZFByb3BzID0gcHJvcHM7XG4gICAgLy8gb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5PVVREQVRFRDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gTWF0Y2hlZCBsYXllcnMgaGF2ZSBsaWZlY3ljbGUgc3RhdGUgXCJvdXRkYXRlZFwiXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5saWZlY3ljbGUgIT09IExJRkVDWUNMRS5PVVREQVRFRCkge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF9pbml0aWFsaXplTmV3TGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgIGlmICghbGF5ZXIuc3RhdGUpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmluaXRpYWxpemVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHM6IHt9LFxuICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuSU5JVElBTElaRUQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX0gJHtlcnJ9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiYWNrIHBvaW50ZXIgKHVzZWQgaW4gcGlja2luZylcbiAgICAgIGlmIChsYXllci5zdGF0ZSkge1xuICAgICAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuICAgICAgICAvLyBTYXZlIGxheWVyIG9uIG1vZGVsIGZvciBwaWNraW5nIHB1cnBvc2VzXG4gICAgICAgIC8vIFRPRE8gLSBzdG9yZSBvbiBtb2RlbC51c2VyRGF0YSByYXRoZXIgdGhhbiBkaXJlY3RseSBvbiBtb2RlbFxuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnN0YXRlICYmIGxheWVyLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfdXBkYXRlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzfSA9IGxheWVyO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci51cGRhdGVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgdXBkYXRlIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsIGB1cGRhdGluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEZpbmFsaXplcyBhIHNpbmdsZSBsYXllclxuICBfZmluYWxpemVMYXllcihsYXllcikge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgY29uc3Qge3N0YXRlfSA9IGxheWVyO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIuZmluYWxpemVMYXllcigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyLnN0YXRlID0gbnVsbDtcbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5GSU5BTElaRUQ7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF5ZXJOYW1lKGxheWVyKSB7XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgcmV0dXJuIGAke2xheWVyfWA7XG4gIH1cbiAgcmV0dXJuICFsYXllciA/ICdudWxsIGxheWVyJyA6ICdpbnZhbGlkIGxheWVyJztcbn1cbiJdfQ==

/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getBlendMode;
/* harmony export (immutable) */ __webpack_exports__["b"] = setBlendMode;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// get current blending settings
function getBlendMode(gl) {
  return {
    enabled: gl.getParameter(gl.BLEND),
    equationRGB: gl.getParameter(gl.BLEND_EQUATION_RGB),
    equationAlpha: gl.getParameter(gl.BLEND_EQUATION_ALPHA),
    srcRGB: gl.getParameter(gl.BLEND_SRC_RGB),
    dstRGB: gl.getParameter(gl.BLEND_DST_RGB),
    srcAlpha: gl.getParameter(gl.BLEND_SRC_ALPHA),
    dstAlpha: gl.getParameter(gl.BLEND_DST_ALPHA)
  };
}

// apply blending settings
function setBlendMode(gl, settings) {
  if (settings.enabled) {
    gl.enable(gl.BLEND);
  } else {
    gl.disable(gl.BLEND);
  }
  gl.blendEquationSeparate(settings.equationRGB, settings.equationAlpha);
  gl.blendFuncSeparate(settings.srcRGB, settings.dstRGB, settings.srcAlpha, settings.dstAlpha);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvYmxlbmQuanMiXSwibmFtZXMiOlsiZ2V0QmxlbmRNb2RlIiwiZ2wiLCJlbmFibGVkIiwiZ2V0UGFyYW1ldGVyIiwiQkxFTkQiLCJlcXVhdGlvblJHQiIsIkJMRU5EX0VRVUFUSU9OX1JHQiIsImVxdWF0aW9uQWxwaGEiLCJCTEVORF9FUVVBVElPTl9BTFBIQSIsInNyY1JHQiIsIkJMRU5EX1NSQ19SR0IiLCJkc3RSR0IiLCJCTEVORF9EU1RfUkdCIiwic3JjQWxwaGEiLCJCTEVORF9TUkNfQUxQSEEiLCJkc3RBbHBoYSIsIkJMRU5EX0RTVF9BTFBIQSIsInNldEJsZW5kTW9kZSIsInNldHRpbmdzIiwiZW5hYmxlIiwiZGlzYWJsZSIsImJsZW5kRXF1YXRpb25TZXBhcmF0ZSIsImJsZW5kRnVuY1NlcGFyYXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sU0FBU0EsWUFBVCxDQUFzQkMsRUFBdEIsRUFBMEI7QUFDL0IsU0FBTztBQUNMQyxhQUFTRCxHQUFHRSxZQUFILENBQWdCRixHQUFHRyxLQUFuQixDQURKO0FBRUxDLGlCQUFhSixHQUFHRSxZQUFILENBQWdCRixHQUFHSyxrQkFBbkIsQ0FGUjtBQUdMQyxtQkFBZU4sR0FBR0UsWUFBSCxDQUFnQkYsR0FBR08sb0JBQW5CLENBSFY7QUFJTEMsWUFBUVIsR0FBR0UsWUFBSCxDQUFnQkYsR0FBR1MsYUFBbkIsQ0FKSDtBQUtMQyxZQUFRVixHQUFHRSxZQUFILENBQWdCRixHQUFHVyxhQUFuQixDQUxIO0FBTUxDLGNBQVVaLEdBQUdFLFlBQUgsQ0FBZ0JGLEdBQUdhLGVBQW5CLENBTkw7QUFPTEMsY0FBVWQsR0FBR0UsWUFBSCxDQUFnQkYsR0FBR2UsZUFBbkI7QUFQTCxHQUFQO0FBU0Q7O0FBRUQ7QUFDQSxPQUFPLFNBQVNDLFlBQVQsQ0FBc0JoQixFQUF0QixFQUEwQmlCLFFBQTFCLEVBQW9DO0FBQ3pDLE1BQUlBLFNBQVNoQixPQUFiLEVBQXNCO0FBQ3BCRCxPQUFHa0IsTUFBSCxDQUFVbEIsR0FBR0csS0FBYjtBQUNELEdBRkQsTUFFTztBQUNMSCxPQUFHbUIsT0FBSCxDQUFXbkIsR0FBR0csS0FBZDtBQUNEO0FBQ0RILEtBQUdvQixxQkFBSCxDQUF5QkgsU0FBU2IsV0FBbEMsRUFBK0NhLFNBQVNYLGFBQXhEO0FBQ0FOLEtBQUdxQixpQkFBSCxDQUFxQkosU0FBU1QsTUFBOUIsRUFBc0NTLFNBQVNQLE1BQS9DLEVBQXVETyxTQUFTTCxRQUFoRSxFQUEwRUssU0FBU0gsUUFBbkY7QUFDRCIsImZpbGUiOiJibGVuZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBnZXQgY3VycmVudCBibGVuZGluZyBzZXR0aW5nc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJsZW5kTW9kZShnbCkge1xuICByZXR1cm4ge1xuICAgIGVuYWJsZWQ6IGdsLmdldFBhcmFtZXRlcihnbC5CTEVORCksXG4gICAgZXF1YXRpb25SR0I6IGdsLmdldFBhcmFtZXRlcihnbC5CTEVORF9FUVVBVElPTl9SR0IpLFxuICAgIGVxdWF0aW9uQWxwaGE6IGdsLmdldFBhcmFtZXRlcihnbC5CTEVORF9FUVVBVElPTl9BTFBIQSksXG4gICAgc3JjUkdCOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfU1JDX1JHQiksXG4gICAgZHN0UkdCOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRFNUX1JHQiksXG4gICAgc3JjQWxwaGE6IGdsLmdldFBhcmFtZXRlcihnbC5CTEVORF9TUkNfQUxQSEEpLFxuICAgIGRzdEFscGhhOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRFNUX0FMUEhBKVxuICB9O1xufVxuXG4vLyBhcHBseSBibGVuZGluZyBzZXR0aW5nc1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJsZW5kTW9kZShnbCwgc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICB9IGVsc2Uge1xuICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICB9XG4gIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShzZXR0aW5ncy5lcXVhdGlvblJHQiwgc2V0dGluZ3MuZXF1YXRpb25BbHBoYSk7XG4gIGdsLmJsZW5kRnVuY1NlcGFyYXRlKHNldHRpbmdzLnNyY1JHQiwgc2V0dGluZ3MuZHN0UkdCLCBzZXR0aW5ncy5zcmNBbHBoYSwgc2V0dGluZ3MuZHN0QWxwaGEpO1xufVxuIl19

/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export parseColor */
/* unused harmony export parseHexColor */
/* unused harmony export setOpacity */
/* unused harmony export applyOpacity */
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Parse array or string color
function parseColor(color) {
  if (Array.isArray(color)) {
    if (color.length === 3) {
      return [color[0], color[1], color[2], 255];
    }
    return color;
  }
  if (typeof color === 'string') {
    return parseHexColor(color);
  }
  return null;
}

// Parse a hex color
function parseHexColor(color) {
  var array = new Uint8ClampedArray(4);
  if (color.length === 7) {
    var value = parseInt(color.substring(1), 16);
    array[0] = value / 65536;
    array[1] = value / 256 % 256;
    array[2] = value % 256;
    array[3] = 255;
  } else if (color.length === 9) {
    var _value = parseInt(color.substring(1), 16);
    array[0] = _value / 16777216;
    array[1] = _value / 65536 % 256;
    array[2] = _value / 256 % 256;
    array[3] = _value % 256;
  }
  return array;
}

function setOpacity(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 127;

  return [color[0], color[1], color[2], opacity];
}

function applyOpacity(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 127;

  return [color[0], color[1], color[2], opacity];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvY29sb3IuanMiXSwibmFtZXMiOlsicGFyc2VDb2xvciIsImNvbG9yIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwicGFyc2VIZXhDb2xvciIsImFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJ2YWx1ZSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwic2V0T3BhY2l0eSIsIm9wYWNpdHkiLCJhcHBseU9wYWNpdHkiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxTQUFTQSxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtBQUNoQyxNQUFJQyxNQUFNQyxPQUFOLENBQWNGLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixRQUFJQSxNQUFNRyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGFBQU8sQ0FBQ0gsTUFBTSxDQUFOLENBQUQsRUFBV0EsTUFBTSxDQUFOLENBQVgsRUFBcUJBLE1BQU0sQ0FBTixDQUFyQixFQUErQixHQUEvQixDQUFQO0FBQ0Q7QUFDRCxXQUFPQSxLQUFQO0FBQ0Q7QUFDRCxNQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBT0ksY0FBY0osS0FBZCxDQUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLE9BQU8sU0FBU0ksYUFBVCxDQUF1QkosS0FBdkIsRUFBOEI7QUFDbkMsTUFBTUssUUFBUSxJQUFJQyxpQkFBSixDQUFzQixDQUF0QixDQUFkO0FBQ0EsTUFBSU4sTUFBTUcsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixRQUFNSSxRQUFRQyxTQUFTUixNQUFNUyxTQUFOLENBQWdCLENBQWhCLENBQVQsRUFBNkIsRUFBN0IsQ0FBZDtBQUNBSixVQUFNLENBQU4sSUFBV0UsUUFBUSxLQUFuQjtBQUNBRixVQUFNLENBQU4sSUFBWUUsUUFBUSxHQUFULEdBQWdCLEdBQTNCO0FBQ0FGLFVBQU0sQ0FBTixJQUFXRSxRQUFRLEdBQW5CO0FBQ0FGLFVBQU0sQ0FBTixJQUFXLEdBQVg7QUFDRCxHQU5ELE1BTU8sSUFBSUwsTUFBTUcsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUM3QixRQUFNSSxTQUFRQyxTQUFTUixNQUFNUyxTQUFOLENBQWdCLENBQWhCLENBQVQsRUFBNkIsRUFBN0IsQ0FBZDtBQUNBSixVQUFNLENBQU4sSUFBV0UsU0FBUSxRQUFuQjtBQUNBRixVQUFNLENBQU4sSUFBWUUsU0FBUSxLQUFULEdBQWtCLEdBQTdCO0FBQ0FGLFVBQU0sQ0FBTixJQUFZRSxTQUFRLEdBQVQsR0FBZ0IsR0FBM0I7QUFDQUYsVUFBTSxDQUFOLElBQVdFLFNBQVEsR0FBbkI7QUFDRDtBQUNELFNBQU9GLEtBQVA7QUFDRDs7QUFFRCxPQUFPLFNBQVNLLFVBQVQsQ0FBb0JWLEtBQXBCLEVBQTBDO0FBQUEsTUFBZlcsT0FBZSx1RUFBTCxHQUFLOztBQUMvQyxTQUFPLENBQUNYLE1BQU0sQ0FBTixDQUFELEVBQVdBLE1BQU0sQ0FBTixDQUFYLEVBQXFCQSxNQUFNLENBQU4sQ0FBckIsRUFBK0JXLE9BQS9CLENBQVA7QUFDRDs7QUFFRCxPQUFPLFNBQVNDLFlBQVQsQ0FBc0JaLEtBQXRCLEVBQTRDO0FBQUEsTUFBZlcsT0FBZSx1RUFBTCxHQUFLOztBQUNqRCxTQUFPLENBQUNYLE1BQU0sQ0FBTixDQUFELEVBQVdBLE1BQU0sQ0FBTixDQUFYLEVBQXFCQSxNQUFNLENBQU4sQ0FBckIsRUFBK0JXLE9BQS9CLENBQVA7QUFDRCIsImZpbGUiOiJjb2xvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBQYXJzZSBhcnJheSBvciBzdHJpbmcgY29sb3JcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgMjU1XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlSGV4Q29sb3IoY29sb3IpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBQYXJzZSBhIGhleCBjb2xvclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSGV4Q29sb3IoY29sb3IpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCk7XG4gIGlmIChjb2xvci5sZW5ndGggPT09IDcpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cmluZygxKSwgMTYpO1xuICAgIGFycmF5WzBdID0gdmFsdWUgLyA2NTUzNjtcbiAgICBhcnJheVsxXSA9ICh2YWx1ZSAvIDI1NikgJSAyNTY7XG4gICAgYXJyYXlbMl0gPSB2YWx1ZSAlIDI1NjtcbiAgICBhcnJheVszXSA9IDI1NTtcbiAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cmluZygxKSwgMTYpO1xuICAgIGFycmF5WzBdID0gdmFsdWUgLyAxNjc3NzIxNjtcbiAgICBhcnJheVsxXSA9ICh2YWx1ZSAvIDY1NTM2KSAlIDI1NjtcbiAgICBhcnJheVsyXSA9ICh2YWx1ZSAvIDI1NikgJSAyNTY7XG4gICAgYXJyYXlbM10gPSB2YWx1ZSAlIDI1NjtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGNvbG9yLCBvcGFjaXR5ID0gMTI3KSB7XG4gIHJldHVybiBbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU9wYWNpdHkoY29sb3IsIG9wYWNpdHkgPSAxMjcpIHtcbiAgcmV0dXJuIFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5XTtcbn1cblxuIl19

/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export compareArrays */
/* unused harmony export checkArray */
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
function compareArrays(array1, array2) {

  var length = Math.min(array1.length, array2.length);
  for (var i = 0; i < length; ++i) {
    if (array1[i] !== array2[i]) {
      return "Arrays are different in element " + i + ": " + array1[i] + " vs " + array2[i];
    }
  }

  if (array1.length !== array2.length) {
    return "Arrays have different length " + array1.length + " vs " + array2.length;
  }

  return null;
}

function checkArray(array) {
  for (var i = 0; i < array.length; ++i) {
    if (!Number.isFinite(array[i])) {
      throw new Error("Array has invalid element " + i + ": " + array[i]);
    }
  }
  return null;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvY29tcGFyZS1hcnJheXMuanMiXSwibmFtZXMiOlsiY29tcGFyZUFycmF5cyIsImFycmF5MSIsImFycmF5MiIsImxlbmd0aCIsIk1hdGgiLCJtaW4iLCJpIiwiY2hlY2tBcnJheSIsImFycmF5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVNBLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxNQUEvQixFQUF1Qzs7QUFFNUMsTUFBTUMsU0FBU0MsS0FBS0MsR0FBTCxDQUFTSixPQUFPRSxNQUFoQixFQUF3QkQsT0FBT0MsTUFBL0IsQ0FBZjtBQUNBLE9BQUssSUFBSUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSCxNQUFwQixFQUE0QixFQUFFRyxDQUE5QixFQUFpQztBQUMvQixRQUFJTCxPQUFPSyxDQUFQLE1BQWNKLE9BQU9JLENBQVAsQ0FBbEIsRUFBNkI7QUFDM0Isa0RBQTBDQSxDQUExQyxVQUFnREwsT0FBT0ssQ0FBUCxDQUFoRCxZQUFnRUosT0FBT0ksQ0FBUCxDQUFoRTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUwsT0FBT0UsTUFBUCxLQUFrQkQsT0FBT0MsTUFBN0IsRUFBcUM7QUFDbkMsNkNBQXVDRixPQUFPRSxNQUE5QyxZQUEyREQsT0FBT0MsTUFBbEU7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxPQUFPLFNBQVNJLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCO0FBQ2hDLE9BQUssSUFBSUYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRSxNQUFNTCxNQUExQixFQUFrQyxFQUFFRyxDQUFwQyxFQUF1QztBQUNyQyxRQUFJLENBQUNHLE9BQU9DLFFBQVAsQ0FBZ0JGLE1BQU1GLENBQU4sQ0FBaEIsQ0FBTCxFQUFnQztBQUM5QixZQUFNLElBQUlLLEtBQUosZ0NBQXVDTCxDQUF2QyxVQUE2Q0UsTUFBTUYsQ0FBTixDQUE3QyxDQUFOO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNEIiwiZmlsZSI6ImNvbXBhcmUtYXJyYXlzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5Mikge1xuXG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XG4gICAgICByZXR1cm4gYEFycmF5cyBhcmUgZGlmZmVyZW50IGluIGVsZW1lbnQgJHtpfTogJHthcnJheTFbaV19IHZzICR7YXJyYXkyW2ldfWA7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYEFycmF5cyBoYXZlIGRpZmZlcmVudCBsZW5ndGggJHthcnJheTEubGVuZ3RofSB2cyAke2FycmF5Mi5sZW5ndGh9YDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBcnJheShhcnJheSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJyYXlbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFycmF5IGhhcyBpbnZhbGlkIGVsZW1lbnQgJHtpfTogJHthcnJheVtpXX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4iXX0=

/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = compareProps;
/* unused harmony export areEqualShallow */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
 * @returns {null|String} - null when values of all keys are strictly equal.
 *   if unequal, returns a string explaining what changed.
 */
/* eslint-disable max-statements, complexity */
function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      oldProps = _ref.oldProps,
      newProps = _ref.newProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps;

  __WEBPACK_IMPORTED_MODULE_0_assert___default()(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  if (oldProps === newProps) {
    return null;
  }

  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {
    return 'old props is not an object';
  }
  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {
    return 'new props is not an object';
  }

  // Test if new props different from old props
  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!newProps.hasOwnProperty(key)) {
        return 'prop ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';
      } else if (oldProps[key] !== newProps[key]) {
        return 'prop ' + key + ' changed: ' + oldProps[key] + ' -> ' + newProps[key];
      }
    }
  }

  // Test if any new props have been added
  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!oldProps.hasOwnProperty(_key)) {
        return 'prop ' + _key + ' added: (undefined) -> ' + newProps[_key];
      }
    }
  }

  return null;
}
/* eslint-enable max-statements, complexity */

// Shallow compare
/* eslint-disable complexity */
function areEqualShallow(a, b) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$ignore = _ref2.ignore,
      ignore = _ref2$ignore === undefined ? {} : _ref2$ignore;

  if (a === b) {
    return true;
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || a === null || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== 'object' || b === null) {
    return false;
  }

  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }

  for (var key in a) {
    if (!(key in ignore) && (!(key in b) || a[key] !== b[key])) {
      return false;
    }
  }
  for (var _key2 in b) {
    if (!(_key2 in ignore) && !(_key2 in a)) {
      return false;
    }
  }
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvY29tcGFyZS1vYmplY3RzLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsImNvbXBhcmVQcm9wcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJpZ25vcmVQcm9wcyIsInVuZGVmaW5lZCIsImtleSIsImhhc093blByb3BlcnR5IiwiYXJlRXF1YWxTaGFsbG93IiwiYSIsImIiLCJpZ25vcmUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0EsT0FBTyxTQUFTQyxZQUFULEdBQW1FO0FBQUEsaUZBQUosRUFBSTtBQUFBLE1BQTVDQyxRQUE0QyxRQUE1Q0EsUUFBNEM7QUFBQSxNQUFsQ0MsUUFBa0MsUUFBbENBLFFBQWtDO0FBQUEsOEJBQXhCQyxXQUF3QjtBQUFBLE1BQXhCQSxXQUF3QixvQ0FBVixFQUFVOztBQUN4RUosU0FBT0UsYUFBYUcsU0FBYixJQUEwQkYsYUFBYUUsU0FBOUMsRUFBeUQsbUJBQXpEOztBQUVBLE1BQUlILGFBQWFDLFFBQWpCLEVBQTJCO0FBQ3pCLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUksUUFBT0QsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwQixJQUFnQ0EsYUFBYSxJQUFqRCxFQUF1RDtBQUNyRCxXQUFPLDRCQUFQO0FBQ0Q7QUFDRCxNQUFJLFFBQU9DLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBcEIsSUFBZ0NBLGFBQWEsSUFBakQsRUFBdUQ7QUFDckQsV0FBTyw0QkFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBSyxJQUFNRyxHQUFYLElBQWtCSixRQUFsQixFQUE0QjtBQUMxQixRQUFJLEVBQUVJLE9BQU9GLFdBQVQsQ0FBSixFQUEyQjtBQUN6QixVQUFJLENBQUNELFNBQVNJLGNBQVQsQ0FBd0JELEdBQXhCLENBQUwsRUFBbUM7QUFDakMseUJBQWVBLEdBQWYsa0JBQStCSixTQUFTSSxHQUFULENBQS9CO0FBQ0QsT0FGRCxNQUVPLElBQUlKLFNBQVNJLEdBQVQsTUFBa0JILFNBQVNHLEdBQVQsQ0FBdEIsRUFBcUM7QUFDMUMseUJBQWVBLEdBQWYsa0JBQStCSixTQUFTSSxHQUFULENBQS9CLFlBQW1ESCxTQUFTRyxHQUFULENBQW5EO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsT0FBSyxJQUFNQSxJQUFYLElBQWtCSCxRQUFsQixFQUE0QjtBQUMxQixRQUFJLEVBQUVHLFFBQU9GLFdBQVQsQ0FBSixFQUEyQjtBQUN6QixVQUFJLENBQUNGLFNBQVNLLGNBQVQsQ0FBd0JELElBQXhCLENBQUwsRUFBbUM7QUFDakMseUJBQWVBLElBQWYsK0JBQTRDSCxTQUFTRyxJQUFULENBQTVDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLE9BQU8sU0FBU0UsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQW1EO0FBQUEsa0ZBQUosRUFBSTtBQUFBLDJCQUFuQkMsTUFBbUI7QUFBQSxNQUFuQkEsTUFBbUIsZ0NBQVYsRUFBVTs7QUFFeEQsTUFBSUYsTUFBTUMsQ0FBVixFQUFhO0FBQ1gsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSSxRQUFPRCxDQUFQLHlDQUFPQSxDQUFQLE9BQWEsUUFBYixJQUF5QkEsTUFBTSxJQUEvQixJQUNGLFFBQU9DLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQURYLElBQ3VCQSxNQUFNLElBRGpDLEVBQ3VDO0FBQ3JDLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUlFLE9BQU9DLElBQVAsQ0FBWUosQ0FBWixFQUFlSyxNQUFmLEtBQTBCRixPQUFPQyxJQUFQLENBQVlILENBQVosRUFBZUksTUFBN0MsRUFBcUQ7QUFDbkQsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsT0FBSyxJQUFNUixHQUFYLElBQWtCRyxDQUFsQixFQUFxQjtBQUNuQixRQUFJLEVBQUVILE9BQU9LLE1BQVQsTUFBcUIsRUFBRUwsT0FBT0ksQ0FBVCxLQUFlRCxFQUFFSCxHQUFGLE1BQVdJLEVBQUVKLEdBQUYsQ0FBL0MsQ0FBSixFQUE0RDtBQUMxRCxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsT0FBSyxJQUFNQSxLQUFYLElBQWtCSSxDQUFsQixFQUFxQjtBQUNuQixRQUFJLEVBQUVKLFNBQU9LLE1BQVQsS0FBcUIsRUFBRUwsU0FBT0csQ0FBVCxDQUF6QixFQUF1QztBQUNyQyxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0QiLCJmaWxlIjoiY29tcGFyZS1vYmplY3RzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQub2xkUHJvcHMgLSBvYmplY3Qgd2l0aCBvbGQga2V5L3ZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lm5ld1Byb3BzIC0gb2JqZWN0IHdpdGggbmV3IGtleS92YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdC5pZ25vcmVQcm9wcz17fSAtIG9iamVjdCwga2V5cyB0aGF0IHNob3VsZCBub3QgYmUgY29tcGFyZWRcbiAqIEByZXR1cm5zIHtudWxsfFN0cmluZ30gLSBudWxsIHdoZW4gdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqICAgaWYgdW5lcXVhbCwgcmV0dXJucyBhIHN0cmluZyBleHBsYWluaW5nIHdoYXQgY2hhbmdlZC5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlUHJvcHMoe29sZFByb3BzLCBuZXdQcm9wcywgaWdub3JlUHJvcHMgPSB7fX0gPSB7fSkge1xuICBhc3NlcnQob2xkUHJvcHMgIT09IHVuZGVmaW5lZCAmJiBuZXdQcm9wcyAhPT0gdW5kZWZpbmVkLCAnY29tcGFyZVByb3BzIGFyZ3MnKTtcblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIG9sZFByb3BzICE9PSAnb2JqZWN0JyB8fCBvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnb2xkIHByb3BzIGlzIG5vdCBhbiBvYmplY3QnO1xuICB9XG4gIGlmICh0eXBlb2YgbmV3UHJvcHMgIT09ICdvYmplY3QnIHx8IG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICduZXcgcHJvcHMgaXMgbm90IGFuIG9iamVjdCc7XG4gIH1cblxuICAvLyBUZXN0IGlmIG5ldyBwcm9wcyBkaWZmZXJlbnQgZnJvbSBvbGQgcHJvcHNcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7a2V5fSBkcm9wcGVkOiAke29sZFByb3BzW2tleV19IC0+ICh1bmRlZmluZWQpYDtcbiAgICAgIH0gZWxzZSBpZiAob2xkUHJvcHNba2V5XSAhPT0gbmV3UHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gYHByb3AgJHtrZXl9IGNoYW5nZWQ6ICR7b2xkUHJvcHNba2V5XX0gLT4gJHtuZXdQcm9wc1trZXldfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGVzdCBpZiBhbnkgbmV3IHByb3BzIGhhdmUgYmVlbiBhZGRlZFxuICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmVQcm9wcykpIHtcbiAgICAgIGlmICghb2xkUHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gYHByb3AgJHtrZXl9IGFkZGVkOiAodW5kZWZpbmVkKSAtPiAke25ld1Byb3BzW2tleV19YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cblxuLy8gU2hhbGxvdyBjb21wYXJlXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWxTaGFsbG93KGEsIGIsIHtpZ25vcmUgPSB7fX0gPSB7fSkge1xuXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IGEgPT09IG51bGwgfHxcbiAgICB0eXBlb2YgYiAhPT0gJ29iamVjdCcgfHwgYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlKSAmJiAoIShrZXkgaW4gYikgfHwgYVtrZXldICE9PSBiW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGIpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlKSAmJiAoIShrZXkgaW4gYSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl19

/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = flatten;
/* unused harmony export countVertices */
/* harmony export (immutable) */ __webpack_exports__["b"] = flattenVertices;
/* harmony export (immutable) */ __webpack_exports__["c"] = fillArray;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Flattens a nested array into a single level array
 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
 * @param {Array} array The array to flatten.
 * @return {Array} Returns the new flattened array.
 */
function flatten(array) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var index = -1;
  while (++index < array.length) {
    var value = array[index];
    if (Array.isArray(value)) {
      flatten(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}

function countVertices(nestedArray) {
  var count = 0;
  var index = -1;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      count += countVertices(value);
    } else {
      count++;
    }
  }
  return count;
}

// Flattens nested array of vertices, padding third coordinate as needed
function flattenVertices(nestedArray) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$result = _ref.result,
      result = _ref$result === undefined ? [] : _ref$result,
      _ref$dimensions = _ref.dimensions,
      dimensions = _ref$dimensions === undefined ? 3 : _ref$dimensions;

  var index = -1;
  var vertexLength = 0;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, { result: result, dimensions: dimensions });
    } else {
      if (vertexLength < dimensions) {
        // eslint-disable-line
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

// Uses copyWithin to significantly speed up typed array value filling
function fillArray(_ref2) {
  var target = _ref2.target,
      source = _ref2.source,
      _ref2$start = _ref2.start,
      start = _ref2$start === undefined ? 0 : _ref2$start,
      _ref2$count = _ref2.count,
      count = _ref2$count === undefined ? 1 : _ref2$count;

  var total = count * source.length;
  var copied = 0;
  for (var i = 0; i < source.length; ++i) {
    target[start + copied++] = source[i];
  }

  while (copied < total) {
    // If we have copied less than half, copy everything we got
    // else copy remaining in one operation
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

// Flattens nested array of vertices, padding third coordinate as needed
/*
export function flattenTypedVertices(nestedArray, {
  result = [],
  Type = Float32Array,
  start = 0,
  dimensions = 3
} = {}) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      start = flattenTypedVertices(value, {result, start, dimensions});
    } else {
      if (vertexLength < dimensions) { // eslint-disable-line
        result[start++] = value;
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result[start++] = 0;
  }
  return start;
}
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZmxhdHRlbi5qcyJdLCJuYW1lcyI6WyJmbGF0dGVuIiwiYXJyYXkiLCJyZXN1bHQiLCJpbmRleCIsImxlbmd0aCIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsImNvdW50VmVydGljZXMiLCJuZXN0ZWRBcnJheSIsImNvdW50IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmbGF0dGVuVmVydGljZXMiLCJkaW1lbnNpb25zIiwidmVydGV4TGVuZ3RoIiwiZmlsbEFycmF5IiwidGFyZ2V0Iiwic291cmNlIiwic3RhcnQiLCJ0b3RhbCIsImNvcGllZCIsImkiLCJjb3B5V2l0aGluIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUEsT0FBTyxTQUFTQSxPQUFULENBQWlCQyxLQUFqQixFQUFxQztBQUFBLE1BQWJDLE1BQWEsdUVBQUosRUFBSTs7QUFDMUMsTUFBSUMsUUFBUSxDQUFDLENBQWI7QUFDQSxTQUFPLEVBQUVBLEtBQUYsR0FBVUYsTUFBTUcsTUFBdkIsRUFBK0I7QUFDN0IsUUFBTUMsUUFBUUosTUFBTUUsS0FBTixDQUFkO0FBQ0EsUUFBSUcsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUosRUFBMEI7QUFDeEJMLGNBQVFLLEtBQVIsRUFBZUgsTUFBZjtBQUNELEtBRkQsTUFFTztBQUNMQSxhQUFPTSxJQUFQLENBQVlILEtBQVo7QUFDRDtBQUNGO0FBQ0QsU0FBT0gsTUFBUDtBQUNEOztBQUVELE9BQU8sU0FBU08sYUFBVCxDQUF1QkMsV0FBdkIsRUFBb0M7QUFDekMsTUFBSUMsUUFBUSxDQUFaO0FBQ0EsTUFBSVIsUUFBUSxDQUFDLENBQWI7QUFDQSxTQUFPLEVBQUVBLEtBQUYsR0FBVU8sWUFBWU4sTUFBN0IsRUFBcUM7QUFDbkMsUUFBTUMsUUFBUUssWUFBWVAsS0FBWixDQUFkO0FBQ0EsUUFBSUcsTUFBTUMsT0FBTixDQUFjRixLQUFkLEtBQXdCTyxZQUFZQyxNQUFaLENBQW1CUixLQUFuQixDQUE1QixFQUF1RDtBQUNyRE0sZUFBU0YsY0FBY0osS0FBZCxDQUFUO0FBQ0QsS0FGRCxNQUVPO0FBQ0xNO0FBQ0Q7QUFDRjtBQUNELFNBQU9BLEtBQVA7QUFDRDs7QUFFRDtBQUNBLE9BQU8sU0FBU0csZUFBVCxDQUF5QkosV0FBekIsRUFBMEU7QUFBQSxpRkFBSixFQUFJO0FBQUEseUJBQW5DUixNQUFtQztBQUFBLE1BQW5DQSxNQUFtQywrQkFBMUIsRUFBMEI7QUFBQSw2QkFBdEJhLFVBQXNCO0FBQUEsTUFBdEJBLFVBQXNCLG1DQUFULENBQVM7O0FBQy9FLE1BQUlaLFFBQVEsQ0FBQyxDQUFiO0FBQ0EsTUFBSWEsZUFBZSxDQUFuQjtBQUNBLFNBQU8sRUFBRWIsS0FBRixHQUFVTyxZQUFZTixNQUE3QixFQUFxQztBQUNuQyxRQUFNQyxRQUFRSyxZQUFZUCxLQUFaLENBQWQ7QUFDQSxRQUFJRyxNQUFNQyxPQUFOLENBQWNGLEtBQWQsS0FBd0JPLFlBQVlDLE1BQVosQ0FBbUJSLEtBQW5CLENBQTVCLEVBQXVEO0FBQ3JEUyxzQkFBZ0JULEtBQWhCLEVBQXVCLEVBQUNILGNBQUQsRUFBU2Esc0JBQVQsRUFBdkI7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJQyxlQUFlRCxVQUFuQixFQUErQjtBQUFFO0FBQy9CYixlQUFPTSxJQUFQLENBQVlILEtBQVo7QUFDQVc7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBLE1BQUlBLGVBQWUsQ0FBZixJQUFvQkEsZUFBZUQsVUFBdkMsRUFBbUQ7QUFDakRiLFdBQU9NLElBQVAsQ0FBWSxDQUFaO0FBQ0Q7QUFDRCxTQUFPTixNQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFPLFNBQVNlLFNBQVQsUUFBMkQ7QUFBQSxNQUF2Q0MsTUFBdUMsU0FBdkNBLE1BQXVDO0FBQUEsTUFBL0JDLE1BQStCLFNBQS9CQSxNQUErQjtBQUFBLDBCQUF2QkMsS0FBdUI7QUFBQSxNQUF2QkEsS0FBdUIsK0JBQWYsQ0FBZTtBQUFBLDBCQUFaVCxLQUFZO0FBQUEsTUFBWkEsS0FBWSwrQkFBSixDQUFJOztBQUNoRSxNQUFNVSxRQUFRVixRQUFRUSxPQUFPZixNQUE3QjtBQUNBLE1BQUlrQixTQUFTLENBQWI7QUFDQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosT0FBT2YsTUFBM0IsRUFBbUMsRUFBRW1CLENBQXJDLEVBQXdDO0FBQ3RDTCxXQUFPRSxRQUFRRSxRQUFmLElBQTJCSCxPQUFPSSxDQUFQLENBQTNCO0FBQ0Q7O0FBRUQsU0FBT0QsU0FBU0QsS0FBaEIsRUFBdUI7QUFDckI7QUFDQTtBQUNBLFFBQUlDLFNBQVNELFFBQVFDLE1BQXJCLEVBQTZCO0FBQzNCSixhQUFPTSxVQUFQLENBQWtCSixRQUFRRSxNQUExQixFQUFrQ0YsS0FBbEMsRUFBeUNBLFFBQVFFLE1BQWpEO0FBQ0FBLGdCQUFVLENBQVY7QUFDRCxLQUhELE1BR087QUFDTEosYUFBT00sVUFBUCxDQUFrQkosUUFBUUUsTUFBMUIsRUFBa0NGLEtBQWxDLEVBQXlDQSxRQUFRQyxLQUFSLEdBQWdCQyxNQUF6RDtBQUNBQSxlQUFTRCxLQUFUO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPSCxNQUFQO0FBQ0Q7O0FBRUQ7QUFDQSIsImZpbGUiOiJmbGF0dGVuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qKlxuICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgaW50byBhIHNpbmdsZSBsZXZlbCBhcnJheVxuICogQGV4YW1wbGUgZmxhdHRlbihbWzEsIFsyXV0sIFszXSwgNF0pID0+IFsxLCAyLCAzLCA0XVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIHJlc3VsdCA9IFtdKSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZmxhdHRlbih2YWx1ZSwgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnRWZXJ0aWNlcyhuZXN0ZWRBcnJheSkge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBuZXN0ZWRBcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5lc3RlZEFycmF5W2luZGV4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgY291bnQgKz0gY291bnRWZXJ0aWNlcyh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gRmxhdHRlbnMgbmVzdGVkIGFycmF5IG9mIHZlcnRpY2VzLCBwYWRkaW5nIHRoaXJkIGNvb3JkaW5hdGUgYXMgbmVlZGVkXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblZlcnRpY2VzKG5lc3RlZEFycmF5LCB7cmVzdWx0ID0gW10sIGRpbWVuc2lvbnMgPSAzfSA9IHt9KSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgdmVydGV4TGVuZ3RoID0gMDtcbiAgd2hpbGUgKCsraW5kZXggPCBuZXN0ZWRBcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5lc3RlZEFycmF5W2luZGV4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgZmxhdHRlblZlcnRpY2VzKHZhbHVlLCB7cmVzdWx0LCBkaW1lbnNpb25zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB2ZXJ0ZXhMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWRkIGEgdGhpcmQgY29vcmRpbmF0ZSBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleExlbmd0aCA+IDAgJiYgdmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykge1xuICAgIHJlc3VsdC5wdXNoKDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFVzZXMgY29weVdpdGhpbiB0byBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHR5cGVkIGFycmF5IHZhbHVlIGZpbGxpbmdcbmV4cG9ydCBmdW5jdGlvbiBmaWxsQXJyYXkoe3RhcmdldCwgc291cmNlLCBzdGFydCA9IDAsIGNvdW50ID0gMX0pIHtcbiAgY29uc3QgdG90YWwgPSBjb3VudCAqIHNvdXJjZS5sZW5ndGg7XG4gIGxldCBjb3BpZWQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgIHRhcmdldFtzdGFydCArIGNvcGllZCsrXSA9IHNvdXJjZVtpXTtcbiAgfVxuXG4gIHdoaWxlIChjb3BpZWQgPCB0b3RhbCkge1xuICAgIC8vIElmIHdlIGhhdmUgY29waWVkIGxlc3MgdGhhbiBoYWxmLCBjb3B5IGV2ZXJ5dGhpbmcgd2UgZ290XG4gICAgLy8gZWxzZSBjb3B5IHJlbWFpbmluZyBpbiBvbmUgb3BlcmF0aW9uXG4gICAgaWYgKGNvcGllZCA8IHRvdGFsIC0gY29waWVkKSB7XG4gICAgICB0YXJnZXQuY29weVdpdGhpbihzdGFydCArIGNvcGllZCwgc3RhcnQsIHN0YXJ0ICsgY29waWVkKTtcbiAgICAgIGNvcGllZCAqPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuY29weVdpdGhpbihzdGFydCArIGNvcGllZCwgc3RhcnQsIHN0YXJ0ICsgdG90YWwgLSBjb3BpZWQpO1xuICAgICAgY29waWVkID0gdG90YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gRmxhdHRlbnMgbmVzdGVkIGFycmF5IG9mIHZlcnRpY2VzLCBwYWRkaW5nIHRoaXJkIGNvb3JkaW5hdGUgYXMgbmVlZGVkXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5UeXBlZFZlcnRpY2VzKG5lc3RlZEFycmF5LCB7XG4gIHJlc3VsdCA9IFtdLFxuICBUeXBlID0gRmxvYXQzMkFycmF5LFxuICBzdGFydCA9IDAsXG4gIGRpbWVuc2lvbnMgPSAzXG59ID0ge30pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCB2ZXJ0ZXhMZW5ndGggPSAwO1xuICB3aGlsZSAoKytpbmRleCA8IG5lc3RlZEFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBzdGFydCA9IGZsYXR0ZW5UeXBlZFZlcnRpY2VzKHZhbHVlLCB7cmVzdWx0LCBzdGFydCwgZGltZW5zaW9uc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJlc3VsdFtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgICB2ZXJ0ZXhMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWRkIGEgdGhpcmQgY29vcmRpbmF0ZSBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleExlbmd0aCA+IDAgJiYgdmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykge1xuICAgIHJlc3VsdFtzdGFydCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuKi9cbiJdfQ==

/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getUniformsFromViewport;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_matrix__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(27);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */

// import {Matrix4} from 'luma.gl';




function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix,
      viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;
  var modelViewMatrix = void 0;

  switch (projectionMode) {

    case __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* COORDINATE_SYSTEM */].IDENTITY:
    case __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* COORDINATE_SYSTEM */].LNGLAT:
      projectionCenter = ZERO_VECTOR;
      // modelViewMatrix = new Matrix4(viewMatrix);
      modelViewMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].copy([], viewMatrix);
      break;

    // TODO: make lighitng work for meter offset mode
    case __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* COORDINATE_SYSTEM */].METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["vec4"].transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // modelViewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      modelViewMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply([], viewMatrixUncentered || viewMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].invert([], modelViewMatrix) || modelViewMatrix;

  if (modelMatrix) {
    // Apply model matrix if supplied
    // modelViewMatrix.multiplyRight(modelMatrix);
    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply(modelViewMatrix, modelViewMatrix, modelMatrix);
  }

  // const modelViewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(modelViewMatrix);
  var modelViewProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__["mat4"].multiply([], projectionMatrix, modelViewMatrix);
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    modelViewMatrix: modelViewMatrix,
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* COORDINATE_SYSTEM */].LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  __WEBPACK_IMPORTED_MODULE_1_assert___default()(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewMatrix = _calculateMatrixAndOf.modelViewMatrix,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  __WEBPACK_IMPORTED_MODULE_1_assert___default()(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  __WEBPACK_IMPORTED_MODULE_1_assert___default()(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),
    modelViewMatrix: new Float32Array(modelViewMatrix),

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsibWF0NCIsInZlYzQiLCJhc3NlcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsImZwNjRpZnkiLCJhIiwiaGlQYXJ0IiwiTWF0aCIsImZyb3VuZCIsImxvUGFydCIsIlpFUk9fVkVDVE9SIiwiVkVDVE9SX1RPX1BPSU5UX01BVFJJWCIsImNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCIsInByb2plY3Rpb25Nb2RlIiwicG9zaXRpb25PcmlnaW4iLCJ2aWV3cG9ydCIsIm1vZGVsTWF0cml4Iiwidmlld01hdHJpeFVuY2VudGVyZWQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIm1vZGVsVmlld01hdHJpeCIsIklERU5USVRZIiwiTE5HTEFUIiwiY29weSIsIk1FVEVSX09GRlNFVFMiLCJwb3NpdGlvblBpeGVscyIsInByb2plY3RGbGF0IiwidHJhbnNmb3JtTWF0NCIsIm11bHRpcGx5IiwiRXJyb3IiLCJ2aWV3TWF0cml4SW52IiwiaW52ZXJ0IiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsImNhbWVyYVBvcyIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0Iiwic2NhbGUiLCJwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCIsImdldERpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJnbFByb2plY3Rpb25NYXRyaXgiLCJGbG9hdDMyQXJyYXkiLCJnbFByb2plY3Rpb25NYXRyaXhGUDY0IiwiaSIsImoiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwidmlld3BvcnRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZCIsInByb2plY3Rpb25GUDY0IiwicHJvamVjdGlvblNjYWxlIiwicHJvamVjdGlvblNjYWxlRlA2NCJdLCJtYXBwaW5ncyI6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Q0FBYixFQUFnQkEsSUFBSSxDQUFwQixFQUF1QixFQUFFQSxDQUF6QixFQUE0QjtBQUMxQixTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSSxDQUFwQixFQUF1QixFQUFFQSxDQUF6QixFQUE0QjtBQUFBLHFCQUl0QnpDLFFBQVE4QiwwQkFBMEJXLElBQUksQ0FBSixHQUFRRCxDQUFsQyxDQUFSLENBSnNCOztBQUFBOztBQUV4QkQsNkJBQXVCLENBQUNDLElBQUksQ0FBSixHQUFRQyxDQUFULElBQWMsQ0FBckMsQ0FGd0I7QUFHeEJGLDZCQUF1QixDQUFDQyxJQUFJLENBQUosR0FBUUMsQ0FBVCxJQUFjLENBQWQsR0FBa0IsQ0FBekMsQ0FId0I7QUFLM0I7QUFDRjs7QUFFRCxNQUFNQyxtQkFBb0JDLFVBQVVBLE9BQU9ELGdCQUFsQixJQUF1QyxDQUFoRTs7QUFFQSxTQUFPO0FBQ0w7QUFDQWpDLGtDQUZLO0FBR0xRLHNDQUhLOztBQUtMO0FBQ0FDLHFCQUFpQixJQUFJb0IsWUFBSixDQUFpQnBCLGVBQWpCLENBTlo7O0FBUUw7QUFDQTBCLGtCQUFjLENBQUNqQyxTQUFTa0MsS0FBVCxHQUFpQkgsZ0JBQWxCLEVBQW9DL0IsU0FBU21DLE1BQVQsR0FBa0JKLGdCQUF0RCxDQVRUO0FBVUxBLHNDQVZLOztBQVlMO0FBQ0EzQixzQkFBa0JzQixrQkFiYjtBQWNMVSxnQ0FBNEJWLGtCQWR2QjtBQWVMVyxvQkFBZ0JULHNCQWZYO0FBZ0JMTCxvREFoQks7O0FBa0JMO0FBQ0FlLHFCQUFpQnRDLFNBQVNzQixLQW5CckI7O0FBcUJMO0FBQ0FpQix5QkFBcUJsRCxRQUFRVyxTQUFTc0IsS0FBakIsQ0F0QmhCOztBQXdCTDtBQUNBRixlQUFXLElBQUlPLFlBQUosQ0FBaUJQLFNBQWpCOztBQXpCTixHQUFQO0FBNEJEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7bWF0NCwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4Jztcbi8vIGltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gaGlQYXJ0O1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5cbi8vIFRoZSBjb2RlIHRoYXQgdXRpbGl6ZXMgTWF0cml4NCBkb2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGFzIHRoZWlyIG1hdDQgY291bnRlcnBhcnRzLFxuLy8gaGFzIGxvd2VyIHBlcmZvcm1hbmNlIGJ1dCBwcm92aWRlcyBlcnJvciBjaGVja2luZy5cbi8vIFVuY29tbWVudCB3aGVuIGRlYnVnZ2luZ1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCB2aWV3UHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcblxuICBsZXQgcHJvamVjdGlvbkNlbnRlcjtcbiAgbGV0IG1vZGVsVmlld01hdHJpeDtcblxuICBzd2l0Y2ggKHByb2plY3Rpb25Nb2RlKSB7XG5cbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5JREVOVElUWTpcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IFpFUk9fVkVDVE9SO1xuICAgIC8vIG1vZGVsVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KHZpZXdNYXRyaXgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQuY29weShbXSwgdmlld01hdHJpeCk7XG4gICAgYnJlYWs7XG5cbiAgLy8gVE9ETzogbWFrZSBsaWdoaXRuZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLk1FVEVSX09GRlNFVFM6XG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAvLyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uKVxuICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gdmlld3BvcnQucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuICAgIC8vIHByb2plY3Rpb25DZW50ZXIgPSBuZXcgTWF0cml4NCh2aWV3UHJvamVjdGlvbk1hdHJpeClcbiAgICAvLyAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLFxuICAgICAgW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdLFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgLy8gbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAvLyAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXgsIFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1hdDQuaW52ZXJ0KFtdLCBtb2RlbFZpZXdNYXRyaXgpIHx8IG1vZGVsVmlld01hdHJpeDtcblxuICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAvLyBBcHBseSBtb2RlbCBtYXRyaXggaWYgc3VwcGxpZWRcbiAgICAvLyBtb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseShtb2RlbFZpZXdNYXRyaXgsIG1vZGVsVmlld01hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICB9XG5cbiAgLy8gY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpLm11bHRpcGx5UmlnaHQobW9kZWxWaWV3TWF0cml4KTtcbiAgY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIG1vZGVsVmlld01hdHJpeCk7XG4gIGNvbnN0IGNhbWVyYVBvcyA9IFt2aWV3TWF0cml4SW52WzEyXSwgdmlld01hdHJpeEludlsxM10sIHZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld01hdHJpeCxcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcbiAgICBtb2RlbFZpZXdNYXRyaXg6IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3TWF0cml4KSxcblxuICAgIC8vIFNjcmVlbiBzaXplXG4gICAgdmlld3BvcnRTaXplOiBbdmlld3BvcnQud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvLCB2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvXSxcbiAgICBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsXG5cbiAgICAvLyBEZXByZWNhdGVkP1xuICAgIHByb2plY3Rpb25TY2FsZUZQNjQ6IGZwNjRpZnkodmlld3BvcnQuc2NhbGUpLFxuXG4gICAgLy8gVGhpcyBpcyBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zXG4gICAgY2FtZXJhUG9zOiBuZXcgRmxvYXQzMkFycmF5KGNhbWVyYVBvcylcblxuICB9O1xufVxuIl19

/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__autobind__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(5);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */




/* global requestAnimationFrame, cancelAnimationFrame */

var DEFAULT_PIXEL_RATIO = typeof window !== 'undefined' && window.devicePixelRatio || 1;

var propTypes = {
  id: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,

  width: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  height: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number.isRequired,
  style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,

  pixelRatio: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,
  viewport: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired,
  events: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  gl: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  glOptions: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  debug: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,

  onInitializationFailed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onRendererInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
  onRenderFrame: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onMouseMove: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
};

var defaultProps = {
  style: {},
  gl: null,
  glOptions: { preserveDrawingBuffer: true },
  debug: false,
  pixelRatio: DEFAULT_PIXEL_RATIO,

  onInitializationFailed: function onInitializationFailed(error) {
    throw error;
  },
  onRendererInitialized: function onRendererInitialized() {},
  onRenderFrame: function onRenderFrame() {}
};

var WebGLRenderer = function (_React$Component) {
  _inherits(WebGLRenderer, _React$Component);

  /**
   * @classdesc
   * Small react component that uses Luma.GL to initialize a WebGL context.
   *
   * Returns a canvas, creates a basic WebGL context
   * sets up a renderloop, and registers some basic event handlers
   *
   * @class
   * @param {Object} props - see propTypes documentation
   */
  function WebGLRenderer(props) {
    _classCallCheck(this, WebGLRenderer);

    var _this = _possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, props));

    _this.state = {};
    _this._animationFrame = null;
    _this.gl = null;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__autobind__["a" /* default */])(_this);
    return _this;
  }

  _createClass(WebGLRenderer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var canvas = this.refs.overlay;
      this._initWebGL(canvas);
      this._animationLoop();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._cancelAnimationLoop();
    }

    /**
     * Initialize LumaGL library and through it WebGL
     * @param {string} canvas
     */

  }, {
    key: '_initWebGL',
    value: function _initWebGL(canvas) {
      var _props = this.props,
          debug = _props.debug,
          glOptions = _props.glOptions;

      // Create context if not supplied

      var gl = this.props.gl;
      if (!gl) {
        try {
          gl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_luma_gl__["e" /* createGLContext */])(Object.assign({ canvas: canvas, debug: debug }, glOptions));
        } catch (error) {
          this.props.onInitializationFailed(error);
          return;
        }
      }

      this.gl = gl;

      // Call callback last, in case it throws
      this.props.onRendererInitialized({ canvas: canvas, gl: gl });
    }

    /**
     * Main WebGL animation loop
     */

  }, {
    key: '_animationLoop',
    value: function _animationLoop() {
      this._renderFrame();
      // Keep registering ourselves for the next animation frame
      if (typeof window !== 'undefined') {
        this._animationFrame = requestAnimationFrame(this._animationLoop);
      }
    }
  }, {
    key: '_cancelAnimationLoop',
    value: function _cancelAnimationLoop() {
      if (this._animationFrame) {
        cancelAnimationFrame(this._animationFrame);
      }
    }

    // Updates WebGL viewport to latest props
    // for clean logging, only calls gl.viewport if props have changed

  }, {
    key: '_updateGLViewport',
    value: function _updateGLViewport() {
      var _props$viewport = this.props.viewport,
          x = _props$viewport.x,
          y = _props$viewport.y,
          w = _props$viewport.width,
          h = _props$viewport.height;
      var dpr = this.props.pixelRatio;
      var gl = this.gl;


      x = x * dpr;
      y = y * dpr;
      w = w * dpr;
      h = h * dpr;

      if (x !== this.x || y !== this.y || w !== this.w || h !== this.h) {
        gl.viewport(x, y, w, h);
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
      }
    }
  }, {
    key: '_renderFrame',
    value: function _renderFrame() {
      var _props$viewport2 = this.props.viewport,
          width = _props$viewport2.width,
          height = _props$viewport2.height;
      var gl = this.gl;

      // Check for reasons not to draw

      if (!gl || !(width > 0) || !(height > 0)) {
        return;
      }

      this._updateGLViewport();

      // Call render callback
      this.props.onRenderFrame({ gl: gl });

      this.props.onAfterRender(this.refs.overlay);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          id = _props2.id,
          width = _props2.width,
          height = _props2.height,
          pixelRatio = _props2.pixelRatio,
          style = _props2.style;

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])('canvas', {
        ref: 'overlay',
        key: 'overlay',
        id: id,
        width: width * pixelRatio,
        height: height * pixelRatio,
        style: Object.assign({}, style, { width: width, height: height })
      });
    }
  }]);

  return WebGLRenderer;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (WebGLRenderer);


WebGLRenderer.propTypes = propTypes;
WebGLRenderer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC93ZWJnbC1yZW5kZXJlci5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJQcm9wVHlwZXMiLCJhdXRvYmluZCIsImNyZWF0ZUdMQ29udGV4dCIsIkRFRkFVTFRfUElYRUxfUkFUSU8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwicHJvcFR5cGVzIiwiaWQiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwid2lkdGgiLCJudW1iZXIiLCJoZWlnaHQiLCJzdHlsZSIsIm9iamVjdCIsInBpeGVsUmF0aW8iLCJ2aWV3cG9ydCIsImV2ZW50cyIsImdsIiwiZ2xPcHRpb25zIiwiZGVidWciLCJib29sIiwib25Jbml0aWFsaXphdGlvbkZhaWxlZCIsImZ1bmMiLCJvblJlbmRlcmVySW5pdGlhbGl6ZWQiLCJvblJlbmRlckZyYW1lIiwib25Nb3VzZU1vdmUiLCJvbkNsaWNrIiwiZGVmYXVsdFByb3BzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiZXJyb3IiLCJXZWJHTFJlbmRlcmVyIiwicHJvcHMiLCJzdGF0ZSIsIl9hbmltYXRpb25GcmFtZSIsImNhbnZhcyIsInJlZnMiLCJvdmVybGF5IiwiX2luaXRXZWJHTCIsIl9hbmltYXRpb25Mb29wIiwiX2NhbmNlbEFuaW1hdGlvbkxvb3AiLCJPYmplY3QiLCJhc3NpZ24iLCJfcmVuZGVyRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIngiLCJ5IiwidyIsImgiLCJkcHIiLCJfdXBkYXRlR0xWaWV3cG9ydCIsIm9uQWZ0ZXJSZW5kZXIiLCJyZWYiLCJrZXkiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPQSxL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QUFPLEVBQUVSLFFBQVEsQ0FBVixDQUFQLElBQXVCLEVBQUVFLFNBQVMsQ0FBWCxDQUEzQixFQUEwQztBQUN4QztBQUNEOztBQUVELFdBQUt1QyxpQkFBTDs7QUFFQTtBQUNBLFdBQUtuQixLQUFMLENBQVdQLGFBQVgsQ0FBeUIsRUFBQ1AsTUFBRCxFQUF6Qjs7QUFFQSxXQUFLYyxLQUFMLENBQVdvQixhQUFYLENBQXlCLEtBQUtoQixJQUFMLENBQVVDLE9BQW5DO0FBRUQ7Ozs2QkFFUTtBQUFBLG9CQUN3QyxLQUFLTCxLQUQ3QztBQUFBLFVBQ0F6QixFQURBLFdBQ0FBLEVBREE7QUFBQSxVQUNJRyxLQURKLFdBQ0lBLEtBREo7QUFBQSxVQUNXRSxNQURYLFdBQ1dBLE1BRFg7QUFBQSxVQUNtQkcsVUFEbkIsV0FDbUJBLFVBRG5CO0FBQUEsVUFDK0JGLEtBRC9CLFdBQytCQSxLQUQvQjs7QUFFUCxhQUFPZCxjQUFjLFFBQWQsRUFBd0I7QUFDN0JzRCxhQUFLLFNBRHdCO0FBRTdCQyxhQUFLLFNBRndCO0FBRzdCL0MsY0FINkI7QUFJN0JHLGVBQU9BLFFBQVFLLFVBSmM7QUFLN0JILGdCQUFRQSxTQUFTRyxVQUxZO0FBTTdCRixlQUFPNEIsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0I3QixLQUFsQixFQUF5QixFQUFDSCxZQUFELEVBQVFFLGNBQVIsRUFBekI7QUFOc0IsT0FBeEIsQ0FBUDtBQVFEOzs7O0VBdkh3Q2QsTUFBTXlELFM7O2VBQTVCeEIsYTs7O0FBMEhyQkEsY0FBY3pCLFNBQWQsR0FBMEJBLFNBQTFCO0FBQ0F5QixjQUFjSCxZQUFkLEdBQTZCQSxZQUE3QiIsImZpbGUiOiJ3ZWJnbC1yZW5kZXJlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IHtjcmVhdGVHTENvbnRleHR9IGZyb20gJ2x1bWEuZ2wnO1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKi9cblxuY29uc3QgREVGQVVMVF9QSVhFTF9SQVRJTyA9XG4gICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICBwaXhlbFJhdGlvOiBQcm9wVHlwZXMubnVtYmVyLFxuICB2aWV3cG9ydDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBldmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBnbE9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRlYnVnOiBQcm9wVHlwZXMuYm9vbCxcblxuICBvbkluaXRpYWxpemF0aW9uRmFpbGVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25SZW5kZXJlckluaXRpYWxpemVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvblJlbmRlckZyYW1lOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHlsZToge30sXG4gIGdsOiBudWxsLFxuICBnbE9wdGlvbnM6IHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWV9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIHBpeGVsUmF0aW86IERFRkFVTFRfUElYRUxfUkFUSU8sXG5cbiAgb25Jbml0aWFsaXphdGlvbkZhaWxlZDogZXJyb3IgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9LFxuICBvblJlbmRlcmVySW5pdGlhbGl6ZWQ6ICgpID0+IHt9LFxuICBvblJlbmRlckZyYW1lOiAoKSA9PiB7fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFNtYWxsIHJlYWN0IGNvbXBvbmVudCB0aGF0IHVzZXMgTHVtYS5HTCB0byBpbml0aWFsaXplIGEgV2ViR0wgY29udGV4dC5cbiAgICpcbiAgICogUmV0dXJucyBhIGNhbnZhcywgY3JlYXRlcyBhIGJhc2ljIFdlYkdMIGNvbnRleHRcbiAgICogc2V0cyB1cCBhIHJlbmRlcmxvb3AsIGFuZCByZWdpc3RlcnMgc29tZSBiYXNpYyBldmVudCBoYW5kbGVyc1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gc2VlIHByb3BUeXBlcyBkb2N1bWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLm92ZXJsYXk7XG4gICAgdGhpcy5faW5pdFdlYkdMKGNhbnZhcyk7XG4gICAgdGhpcy5fYW5pbWF0aW9uTG9vcCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uTG9vcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgTHVtYUdMIGxpYnJhcnkgYW5kIHRocm91Z2ggaXQgV2ViR0xcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc1xuICAgKi9cbiAgX2luaXRXZWJHTChjYW52YXMpIHtcbiAgICBjb25zdCB7ZGVidWcsIGdsT3B0aW9uc30gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ3JlYXRlIGNvbnRleHQgaWYgbm90IHN1cHBsaWVkXG4gICAgbGV0IGdsID0gdGhpcy5wcm9wcy5nbDtcbiAgICBpZiAoIWdsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBnbCA9IGNyZWF0ZUdMQ29udGV4dChPYmplY3QuYXNzaWduKHtjYW52YXMsIGRlYnVnfSwgZ2xPcHRpb25zKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnByb3BzLm9uSW5pdGlhbGl6YXRpb25GYWlsZWQoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy8gQ2FsbCBjYWxsYmFjayBsYXN0LCBpbiBjYXNlIGl0IHRocm93c1xuICAgIHRoaXMucHJvcHMub25SZW5kZXJlckluaXRpYWxpemVkKHtjYW52YXMsIGdsfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBXZWJHTCBhbmltYXRpb24gbG9vcFxuICAgKi9cbiAgX2FuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5fcmVuZGVyRnJhbWUoKTtcbiAgICAvLyBLZWVwIHJlZ2lzdGVyaW5nIG91cnNlbHZlcyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25Mb29wKTtcbiAgICB9XG4gIH1cblxuICBfY2FuY2VsQW5pbWF0aW9uTG9vcCgpIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGVzIFdlYkdMIHZpZXdwb3J0IHRvIGxhdGVzdCBwcm9wc1xuICAvLyBmb3IgY2xlYW4gbG9nZ2luZywgb25seSBjYWxscyBnbC52aWV3cG9ydCBpZiBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgX3VwZGF0ZUdMVmlld3BvcnQoKSB7XG4gICAgbGV0IHt2aWV3cG9ydDoge3gsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGh9fSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3BpeGVsUmF0aW86IGRwcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzO1xuXG4gICAgeCA9IHggKiBkcHI7XG4gICAgeSA9IHkgKiBkcHI7XG4gICAgdyA9IHcgKiBkcHI7XG4gICAgaCA9IGggKiBkcHI7XG5cbiAgICBpZiAoeCAhPT0gdGhpcy54IHx8IHkgIT09IHRoaXMueSB8fCB3ICE9PSB0aGlzLncgfHwgaCAhPT0gdGhpcy5oKSB7XG4gICAgICBnbC52aWV3cG9ydCh4LCB5LCB3LCBoKTtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy53ID0gdztcbiAgICAgIHRoaXMuaCA9IGg7XG4gICAgfVxuICB9XG5cbiAgX3JlbmRlckZyYW1lKCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydDoge3dpZHRoLCBoZWlnaHR9fSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBmb3IgcmVhc29ucyBub3QgdG8gZHJhd1xuICAgIGlmICghZ2wgfHwgISh3aWR0aCA+IDApIHx8ICEoaGVpZ2h0ID4gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVHTFZpZXdwb3J0KCk7XG5cbiAgICAvLyBDYWxsIHJlbmRlciBjYWxsYmFja1xuICAgIHRoaXMucHJvcHMub25SZW5kZXJGcmFtZSh7Z2x9KTtcblxuICAgIHRoaXMucHJvcHMub25BZnRlclJlbmRlcih0aGlzLnJlZnMub3ZlcmxheSk7XG5cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7aWQsIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sIHN0eWxlfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogJ292ZXJsYXknLFxuICAgICAga2V5OiAnb3ZlcmxheScsXG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiB3aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICBoZWlnaHQ6IGhlaWdodCAqIHBpeGVsUmF0aW8sXG4gICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHt3aWR0aCwgaGVpZ2h0fSlcbiAgICB9KTtcbiAgfVxufVxuXG5XZWJHTFJlbmRlcmVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbldlYkdMUmVuZGVyZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export checkRendererVendor */
/* unused harmony export getPlatformShaderDefines */
/* harmony export (immutable) */ __webpack_exports__["a"] = assembleShaders;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(82);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


// Load shader chunks
// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';


function checkRendererVendor(debugInfo, gpuVendor) {
  var vendor = debugInfo.vendor,
      renderer = debugInfo.renderer;

  var result = void 0;
  switch (gpuVendor) {
    case 'nvidia':
      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
      break;
    case 'intel':
      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
      break;
    case 'amd':
      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
      break;
    default:
      result = false;
  }
  return result;
}

function getPlatformShaderDefines(gl) {
  /* eslint-disable */
  var platformDefines = '';
  var debugInfo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__["m" /* glGetDebugInfo */])(gl);

  if (checkRendererVendor(debugInfo, 'nvidia')) {
    platformDefines += '#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'intel')) {
    platformDefines += '#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n #define INTEL_TAN_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'amd')) {
    platformDefines += '#define AMD_GPU\n';
  } else {
    platformDefines += '#define DEFAULT_GPU\n';
  }

  return platformDefines;
}

function assembleShader(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts = opts,
      vs = _opts.vs,
      _opts$project = _opts.project,
      project = _opts$project === undefined ? true : _opts$project,
      _opts$project2 = _opts.project64,
      project64 = _opts$project2 === undefined ? false : _opts$project2;
  var _opts2 = opts,
      _opts2$fp = _opts2.fp64,
      fp64 = _opts2$fp === undefined ? false : _opts2$fp;

  if (project64 === true) {
    fp64 = true;
  }
  var source = getPlatformShaderDefines(gl) + '\n';
  opts = Object.assign({}, opts, { project: project, project64: project64, fp64: fp64 });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(__WEBPACK_IMPORTED_MODULE_1__shader_chunks__)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunkName = _step.value;

      if (opts[chunkName]) {
        source += __WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName].source + '\n';
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (opts.modules || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _chunkName = _step2.value;

      if (__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[_chunkName]) {
        source += __WEBPACK_IMPORTED_MODULE_1__shader_chunks__[_chunkName].source + '\n';
      } else {
        throw new Error('Shader module ' + _chunkName + ' not found');
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  source += vs;
  return source;
}

function assembleShaders(gl, opts) {
  var vsSource = assembleShader(gl, opts);
  var fsSource = opts.fs;

  // If shaderCache presents, output compiled shaders from luma.gl/shadeCache
  if (opts.shaderCache) {
    return {
      gl: gl,
      vs: opts.shaderCache.getVertexShader(gl, vsSource),
      fs: opts.shaderCache.getFragmentShader(gl, fsSource)
    };
  };
  // Otherwise just output shader source
  return {
    gl: gl,
    vs: vsSource,
    fs: fsSource
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvYXNzZW1ibGUtc2hhZGVycy5qcyJdLCJuYW1lcyI6WyJnbEdldERlYnVnSW5mbyIsIlNIQURFUl9DSFVOS1MiLCJjaGVja1JlbmRlcmVyVmVuZG9yIiwiZGVidWdJbmZvIiwiZ3B1VmVuZG9yIiwidmVuZG9yIiwicmVuZGVyZXIiLCJyZXN1bHQiLCJtYXRjaCIsImdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyIsImdsIiwicGxhdGZvcm1EZWZpbmVzIiwiYXNzZW1ibGVTaGFkZXIiLCJvcHRzIiwidnMiLCJwcm9qZWN0IiwicHJvamVjdDY0IiwiZnA2NCIsInNvdXJjZSIsIk9iamVjdCIsImFzc2lnbiIsImtleXMiLCJjaHVua05hbWUiLCJtb2R1bGVzIiwiRXJyb3IiLCJhc3NlbWJsZVNoYWRlcnMiLCJ2c1NvdXJjZSIsImZzU291cmNlIiwiZnMiLCJzaGFkZXJDYWNoZSIsImdldFZlcnRleFNoYWRlciIsImdldEZyYWdtZW50U2hhZGVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxjQUFSLFFBQTZCLFNBQTdCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBS0MsYUFBWixNQUErQixpQkFBL0I7O0FBRUEsT0FBTyxTQUFTQyxtQkFBVCxDQUE2QkMsU0FBN0IsRUFBd0NDLFNBQXhDLEVBQW1EO0FBQUEsTUFDakRDLE1BRGlELEdBQzdCRixTQUQ2QixDQUNqREUsTUFEaUQ7QUFBQSxNQUN6Q0MsUUFEeUMsR0FDN0JILFNBRDZCLENBQ3pDRyxRQUR5Qzs7QUFFeEQsTUFBSUMsZUFBSjtBQUNBLFVBQVFILFNBQVI7QUFDQSxTQUFLLFFBQUw7QUFDRUcsZUFBU0YsT0FBT0csS0FBUCxDQUFhLFNBQWIsS0FBMkJGLFNBQVNFLEtBQVQsQ0FBZSxTQUFmLENB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LFdBQVdkLEtBQUtlLEVBQXRCOztBQUVBO0FBQ0EsTUFBSWYsS0FBS2dCLFdBQVQsRUFBc0I7QUFDcEIsV0FBTztBQUNMbkIsWUFESztBQUVMSSxVQUFJRCxLQUFLZ0IsV0FBTCxDQUFpQkMsZUFBakIsQ0FBaUNwQixFQUFqQyxFQUFxQ2dCLFFBQXJDLENBRkM7QUFHTEUsVUFBSWYsS0FBS2dCLFdBQUwsQ0FBaUJFLGlCQUFqQixDQUFtQ3JCLEVBQW5DLEVBQXVDaUIsUUFBdkM7QUFIQyxLQUFQO0FBS0Q7QUFDRDtBQUNBLFNBQU87QUFDTGpCLFVBREs7QUFFTEksUUFBSVksUUFGQztBQUdMRSxRQUFJRDtBQUhDLEdBQVA7QUFLRCIsImZpbGUiOiJhc3NlbWJsZS1zaGFkZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Z2xHZXREZWJ1Z0luZm99IGZyb20gJ2x1bWEuZ2wnO1xuLy8gTG9hZCBzaGFkZXIgY2h1bmtzXG4vLyBpbXBvcnQgU0hBREVSX0NIVU5LUyBmcm9tICcuLi8uLi9kaXN0L3NoYWRlcmxpYi9zaGFkZXItY2h1bmtzJztcbmltcG9ydCAqIGFzIFNIQURFUl9DSFVOS1MgZnJvbSAnLi9zaGFkZXItY2h1bmtzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCBncHVWZW5kb3IpIHtcbiAgY29uc3Qge3ZlbmRvciwgcmVuZGVyZXJ9ID0gZGVidWdJbmZvO1xuICBsZXQgcmVzdWx0O1xuICBzd2l0Y2ggKGdwdVZlbmRvcikge1xuICBjYXNlICdudmlkaWEnOlxuICAgIHJlc3VsdCA9IHZlbmRvci5tYXRjaCgvTlZJRElBL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9OVklESUEvaSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2ludGVsJzpcbiAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0lOVEVML2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9JTlRFTC9pKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYW1kJzpcbiAgICByZXN1bHQgPVxuICAgICAgdmVuZG9yLm1hdGNoKC9BTUQvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0FNRC9pKSB8fFxuICAgICAgdmVuZG9yLm1hdGNoKC9BVEkvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0FUSS9pKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICByZXN1bHQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIGxldCBwbGF0Zm9ybURlZmluZXMgPSAnJztcbiAgY29uc3QgZGVidWdJbmZvID0gZ2xHZXREZWJ1Z0luZm8oZ2wpO1xuXG4gIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ252aWRpYScpKSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBOVklESUFfR1BVXG4jZGVmaW5lIE5WSURJQV9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXG5gO1xuICB9IGVsc2UgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnaW50ZWwnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgSU5URUxfR1BVXG4jZGVmaW5lIElOVEVMX0ZQNjRfV09SS0FST1VORCAxXG4jZGVmaW5lIE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EIDFcXG4gXFxcbiNkZWZpbmUgSU5URUxfVEFOX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2FtZCcpKSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBBTURfR1BVXG5gO1xuICB9IGVsc2Uge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgREVGQVVMVF9HUFVcbmA7XG4gIH1cblxuICByZXR1cm4gcGxhdGZvcm1EZWZpbmVzO1xufVxuXG5mdW5jdGlvbiBhc3NlbWJsZVNoYWRlcihnbCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHt2cywgcHJvamVjdCA9IHRydWUsIHByb2plY3Q2NCA9IGZhbHNlfSA9IG9wdHM7XG4gIGxldCB7ZnA2NCA9IGZhbHNlfSA9IG9wdHM7XG4gIGlmIChwcm9qZWN0NjQgPT09IHRydWUpIHtcbiAgICBmcDY0ID0gdHJ1ZTtcbiAgfVxuICBsZXQgc291cmNlID0gYCR7Z2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKX1cXG5gO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge3Byb2plY3QsIHByb2plY3Q2NCwgZnA2NH0pO1xuICBmb3IgKGNvbnN0IGNodW5rTmFtZSBvZiBPYmplY3Qua2V5cyhTSEFERVJfQ0hVTktTKSkge1xuICAgIGlmIChvcHRzW2NodW5rTmFtZV0pIHtcbiAgICAgIHNvdXJjZSArPSBgJHtTSEFERVJfQ0hVTktTW2NodW5rTmFtZV0uc291cmNlfVxcbmA7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgY2h1bmtOYW1lIG9mIG9wdHMubW9kdWxlcyB8fCBbXSkge1xuICAgIGlmIChTSEFERVJfQ0hVTktTW2NodW5rTmFtZV0pIHtcbiAgICAgIHNvdXJjZSArPSBgJHtTSEFERVJfQ0hVTktTW2NodW5rTmFtZV0uc291cmNlfVxcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2hhZGVyIG1vZHVsZSAke2NodW5rTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG4gIHNvdXJjZSArPSB2cztcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVycyhnbCwgb3B0cykge1xuICBjb25zdCB2c1NvdXJjZSA9IGFzc2VtYmxlU2hhZGVyKGdsLCBvcHRzKTtcbiAgY29uc3QgZnNTb3VyY2UgPSBvcHRzLmZzO1xuXG4gIC8vIElmIHNoYWRlckNhY2hlIHByZXNlbnRzLCBvdXRwdXQgY29tcGlsZWQgc2hhZGVycyBmcm9tIGx1bWEuZ2wvc2hhZGVDYWNoZVxuICBpZiAob3B0cy5zaGFkZXJDYWNoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBnbCxcbiAgICAgIHZzOiBvcHRzLnNoYWRlckNhY2hlLmdldFZlcnRleFNoYWRlcihnbCwgdnNTb3VyY2UpLFxuICAgICAgZnM6IG9wdHMuc2hhZGVyQ2FjaGUuZ2V0RnJhZ21lbnRTaGFkZXIoZ2wsIGZzU291cmNlKVxuICAgIH1cbiAgfTtcbiAgLy8gT3RoZXJ3aXNlIGp1c3Qgb3V0cHV0IHNoYWRlciBzb3VyY2VcbiAgcmV0dXJuIHtcbiAgICBnbCxcbiAgICB2czogdnNTb3VyY2UsXG4gICAgZnM6IGZzU291cmNlXG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fp64; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_fp64_glsl__ = __webpack_require__(200);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



var fp64 = {
  interface: 'fp64',
  source: __WEBPACK_IMPORTED_MODULE_0__math_fp64_glsl__["a" /* default */]
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvZnA2NC9pbmRleC5qcyJdLCJuYW1lcyI6WyJtYXRoRnA2NCIsImZwNjQiLCJpbnRlcmZhY2UiLCJzb3VyY2UiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVAsTUFBcUIsa0JBQXJCOztBQUVBLE9BQU8sSUFBTUMsT0FBTztBQUNsQkMsYUFBVyxNQURPO0FBRWxCQyxVQUFRSDtBQUZVLENBQWIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IG1hdGhGcDY0IGZyb20gJy4vbWF0aC1mcDY0Lmdsc2wnO1xuXG5leHBvcnQgY29uc3QgZnA2NCA9IHtcbiAgaW50ZXJmYWNlOiAnZnA2NCcsXG4gIHNvdXJjZTogbWF0aEZwNjRcbn07XG4iXX0=

/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("uniform float ONE;\n\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#else\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 quickTwoSum(float a, float b) {\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n  return vec2(sum, err);\n}\n#else\nvec2 quickTwoSum(float a, float b) {\n  float sum = a + b;\n  float err = b - (sum - a);\n  return vec2(sum, err);\n}\n#endif\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n\n/* The purpose of this workaround is to prevent compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' from.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be one only at the runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSum(float a, float b) {\n  float s = a + b;\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n  return vec2(s, err);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n/* Same thing as in twoSum() */\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSub(float a, float b) {\n  float s = a - b;\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n  return vec2(s, err);\n}\n#endif\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n  return vec2(prod, err);\n}\n#else\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n  return vec2(prod, err);\n}\n#endif\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n  prod.y += a.y * b.x;\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n  vec2 yn = a * xn;\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n  return sum_fp64(vec2(yn, 0.0), prod);\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvZnA2NC9tYXRoLWZwNjQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJtYXRoLWZwNjQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbnVuaWZvcm0gZmxvYXQgT05FO1xuXG5jb25zdCB2ZWMyIEVfRlA2NCA9IHZlYzIoMi43MTgyODE3NDU5MTA2NDQ1ZSswMCwgOC4yNTQ4NDAzNjY4MTcwMDdlLTA4KTtcbmNvbnN0IHZlYzIgTE9HMl9GUDY0ID0gdmVjMigwLjY5MzE0NzE4MjQ2NDU5OTZlKzAwLCAtMS45MDQ2NTQyMTIxMjU5MzM2ZS0wOSk7XG5jb25zdCB2ZWMyIFBJX0ZQNjQgPSB2ZWMyKDMuMTQxNTkyNzQxMDEyNTczMiwgLTguNzQyMjc4MDEyNjE4OTU0ZS04KTtcbmNvbnN0IHZlYzIgVFdPX1BJX0ZQNjQgPSB2ZWMyKDYuMjgzMTg1NDgyMDI1MTQ2NSwgLTEuNzQ4NDU1NjAyNTIzNzkwN2UtNyk7XG5jb25zdCB2ZWMyIFBJXzJfRlA2NCA9IHZlYzIoMS41NzA3OTYzNzA1MDYyODY2LCAtNC4zNzExMzkwMDYzMDk0NzdlLTgpO1xuY29uc3QgdmVjMiBQSV80X0ZQNjQgPSB2ZWMyKDAuNzg1Mzk4MTg1MjUzMTQzMywgLTIuMTg1NTY5NTAzMTU0NzM4NGUtOCk7XG5jb25zdCB2ZWMyIFBJXzE2X0ZQNjQgPSB2ZWMyKDAuMTk2MzQ5NTQ2MzEzMjg1ODMsIC01LjQ2MzkyMzc1Nzg4Njg0NmUtOSk7XG5jb25zdCB2ZWMyIFBJXzE2XzJfRlA2NCA9IHZlYzIoMC4zOTI2OTkwOTI2MjY1NzE2NiwgLTEuMDkyNzg0NzUxNTc3MzY5MmUtOCk7XG5jb25zdCB2ZWMyIFBJXzE2XzNfRlA2NCA9IHZlYzIoMC41ODkwNDg2MjQwMzg2OTYzLCAtMS40OTA2MTAwNzk4MTI4ODE4ZS05KTtcbmNvbnN0IHZlYzIgUElfMTgwX0ZQNjQgPSB2ZWMyKDAuMDE3NDUzMjkyMzg0NzQzNjksIDEuMzUxOTk2MDQ5ODM2NDkwMmUtMTApO1xuXG5jb25zdCB2ZWMyIFNJTl9UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuMTk1MDkwMzIzNjg2NTk5NzMsIC0xLjY3MDQ3MTQ4MzM2MTUyNDJlLTkpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfMV9GUDY0ID0gdmVjMigwLjM4MjY4MzQyNjE0MTczODksIDYuMjIzMzUwODkwMTc3NjdlLTkpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfMl9GUDY0ID0gdmVjMigwLjU1NTU3MDI0NDc4OTEyMzUsIC0xLjE3Njk1MjEzNTc1MDc1MjllLTgpO1xuY29uc3QgdmVjMiBTSU5fVEFCTEVfM19GUDY0ID0gdmVjMigwLjcwNzEwNjc2OTA4NDkzMDQsIDEuMjEwMTYxNzA0MTc5MzEzM2UtOCk7XG5cbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzBfRlA2NCA9IHZlYzIoMC45ODA3ODUyNTA2NjM3NTczLCAyLjk3Mzk0NzMxMDYzNjA0OTJlLTgpO1xuY29uc3QgdmVjMiBDT1NfVEFCTEVfMV9GUDY0ID0gdmVjMigwLjkyMzg3OTUwNDIwMzc5NjQsIDIuODMwNzQ5MDM1MTc2NDM4NmUtOCk7XG5jb25zdCB2ZWMyIENPU19UQUJMRV8yX0ZQNjQgPSB2ZWMyKDAuODMxNDY5NTk1NDMyMjgxNSwgMS42ODcwMjYzNzQxNTMwNzc4ZS04KTtcbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzNfRlA2NCA9IHZlYzIoMC43MDcxMDY3NjkwODQ5MzA0LCAxLjIxMDE2MTcxNTI4MTU0MzZlLTgpO1xuXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCA9IHZlYzIoMS42NjY2NjY3MTYzMzcyMDRlLTAxLCAtNC45NjcwNTM4NzkzMTIyODllLTA5KTsgLy8gMS8zIVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF80X0ZQNjQgPSB2ZWMyKDQuMTY2NjY2NzkwODQzMDFlLTAyLCAtMS4yNDE3NjM0Njk4MjgwNzIyZS0wOSk7IC8vIDEvNCFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0ID0gdmVjMig4LjMzMzMzMzc2Nzk1MDUzNWUtMDMsIC00LjM0NjE3MjAzMzM3NTk1ZS0xMCk7IC8vIDEvNSFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0ID0gdmVjMigxLjM4ODg4ODkyMjUxOTk4MTllLTAzLCAtMy4zNjMxMDk0NDM3MTAzMjE1ZS0xMSk7IC8vIDEvNiFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0ID0gdmVjMigxLjk4NDEyNzAxMTM4Mjk1MjNlLTA0LCAgLTIuNzI1NTk2ODc0OTMzNDU2ZS0xMik7IC8vIDEvNyFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfOF9GUDY0ID0gdmVjMigyLjQ4MDE1ODc2NDIyODY5MDRlLTA1LCAtMy40MDY5OTYwMjU5MDQxODRlLTEzKTsgLy8gMS84IVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQgPSB2ZWMyKDIuNzU1NzMxODg0NDYyODc1MzNlLTA2LCAzLjc5MzU3MTM5MzcwMzgxODZlLTE0KTsgLy8gMS85IVxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF8xMF9GUDY0ID0gdmVjMigyLjc1NTczMTk5ODE0OTcxM2UtMDcsIC03LjU3NTExMjM2Nzg2OTg3M2UtMTUpOyAvLyAxLzEwIVxuXG5mbG9hdCBuaW50KGZsb2F0IGQpIHtcbiAgICBpZiAoZCA9PSBmbG9vcihkKSkgcmV0dXJuIGQ7XG4gICAgcmV0dXJuIGZsb29yKGQgKyAwLjUpO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcbiAgZmxvYXQgdCA9IGEgKiBTUExJVDtcbiAgZmxvYXQgYV9oaSA9IHQgKiBPTkUgLSAodCAtIGEpO1xuICBmbG9hdCBhX2xvID0gYSAqIE9ORSAtIGFfaGk7XG4gIHJldHVybiB2ZWMyKGFfaGksIGFfbG8pO1xufVxuI2Vsc2VcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcbiAgZmxvYXQgdCA9IGEgKiBTUExJVDtcbiAgZmxvYXQgYV9oaSA9IHQgLSAodCAtIGEpO1xuICBmbG9hdCBhX2xvID0gYSAtIGFfaGk7XG4gIHJldHVybiB2ZWMyKGFfaGksIGFfbG8pO1xufVxuI2VuZGlmXG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgc3VtID0gKGEgKyBiKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gYiAtIChzdW0gLSBhKSAqIE9ORTtcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xufVxuI2Vsc2VcbnZlYzIgcXVpY2tUd29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzdW0gPSBhICsgYjtcbiAgZmxvYXQgZXJyID0gYiAtIChzdW0gLSBhKTtcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xufVxuI2VuZGlmXG5cbnZlYzIgbmludF9mcDY0KHZlYzIgYSkge1xuICAgIGZsb2F0IGhpID0gbmludChhLngpO1xuICAgIGZsb2F0IGxvO1xuICAgIHZlYzIgdG1wO1xuICAgIGlmIChoaSA9PSBhLngpIHtcbiAgICAgICAgbG8gPSBuaW50KGEueSk7XG4gICAgICAgIHRtcCA9IHF1aWNrVHdvU3VtKGhpLCBsbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSAwLjA7XG4gICAgICAgIGlmIChhYnMoaGkgLSBhLngpID09IDAuNSAmJiBhLnkgPCAwLjApIHtcbiAgICAgICAgICAgIGhpIC09IDEuMDtcbiAgICAgICAgfVxuICAgICAgICB0bXAgPSB2ZWMyKGhpLCBsbyk7XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG59XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG5cbi8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgd29ya2Fyb3VuZCBpcyB0byBwcmV2ZW50IGNvbXBpbGVycyBmcm9tXG5vcHRpbWl6aW5nIGF3YXkgbmVjZXNzYXJ5IGFyaXRobWV0aWMgb3BlcmF0aW9ucyBieSBzd2FwcGluZyB0aGVpciBzZXF1ZW5jZXNcbm9yIHRyYW5zZm9ybSB0aGUgZXF1YXRpb24gdG8gc29tZSAnZXF1aXZhbGVudCcgZnJvbS5cblxuVGhlIG1ldGhvZCBpcyB0byBtdWx0aXBseSBhbiBhcnRpZmljYWwgdmFyaWFibGUsIE9ORSwgd2hpY2ggd2lsbCBiZSBrbm93biB0b1xudGhlIGNvbXBpbGVyIHRvIGJlIG9uZSBvbmx5IGF0IHRoZSBydW50aW1lLiBUaGUgd2hvbGUgZXhwcmVzc2lvbiBpcyB0aGVuIHJlcHJlc2VudGVkXG5hcyBhIHBvbHlub21pYWwgd2l0aCByZXNwZWN0aXZlIHRvIE9ORS4gSW4gdGhlIGNvZWZmaWNpZW50cyBvZiBhbGwgdGVybXMsIG9ubHkgb25lIGFcbmFuZCBvbmUgYiBzaG91bGQgYXBwZWFyXG5cbmVyciA9IChhICsgYikgKiBPTkVeNiAtIGEgKiBPTkVeNSAtIChhICsgYikgKiBPTkVeNCArIGEgKiBPTkVeMyAtIGIgLSAoYSArIGIpICogT05FXjIgKyBhICogT05FXG4qL1xuXG52ZWMyIHR3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSAoYSArIGIpO1xuICBmbG9hdCB2ID0gKHMgKiBPTkUgLSBhKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpICogT05FKSAqIE9ORSAqIE9ORSAqIE9ORSArIChiIC0gdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gYSArIGI7XG4gIGZsb2F0IHYgPSBzIC0gYTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZW5kaWZcblxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbi8qIFNhbWUgdGhpbmcgYXMgaW4gdHdvU3VtKCkgKi9cbnZlYzIgdHdvU3ViKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcyA9IChhIC0gYik7XG4gIGZsb2F0IHYgPSAocyAqIE9ORSAtIGEpICogT05FO1xuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikgKiBPTkUpICogT05FICogT05FICogT05FIC0gKGIgKyB2KTtcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSBhIC0gYjtcbiAgZmxvYXQgdiA9IHMgLSBhO1xuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikpIC0gKGIgKyB2KTtcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIHR3b1Byb2QoZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBwcm9kID0gYSAqIGI7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG4gIHZlYzIgYl9mcDY0ID0gc3BsaXQoYik7XG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBiX2ZwNjQueCAtIHByb2QpICsgYV9mcDY0LnggKiBiX2ZwNjQueSArXG4gICAgYV9mcDY0LnkgKiBiX2ZwNjQueCkgKyBhX2ZwNjQueSAqIGJfZnA2NC55O1xuICByZXR1cm4gdmVjMihwcm9kLCBlcnIpO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xuICBmbG9hdCBwcm9kID0gYSAqIGE7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG5cbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKiBPTkUgKyAyLjAgKiBhX2ZwNjQueCAqXG4gICAgYV9mcDY0LnkgKiBPTkUgKiBPTkUpICsgYV9mcDY0LnkgKiBhX2ZwNjQueSAqIE9ORSAqIE9ORSAqIE9ORTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHR3b1NxcihmbG9hdCBhKSB7XG4gIGZsb2F0IHByb2QgPSBhICogYTtcbiAgdmVjMiBhX2ZwNjQgPSBzcGxpdChhKTtcblxuICBmbG9hdCBlcnIgPSAoKGFfZnA2NC54ICogYV9mcDY0LnggLSBwcm9kKSArIDIuMCAqIGFfZnA2NC54ICogYV9mcDY0LnkpICsgYV9mcDY0LnkgKiBhX2ZwNjQueTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIHN1bV9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIHZlYzIgcywgdDtcbiAgcyA9IHR3b1N1bShhLngsIGIueCk7XG4gIHQgPSB0d29TdW0oYS55LCBiLnkpO1xuICBzLnkgKz0gdC54O1xuICBzID0gcXVpY2tUd29TdW0ocy54LCBzLnkpO1xuICBzLnkgKz0gdC55O1xuICBzID0gcXVpY2tUd29TdW0ocy54LCBzLnkpO1xuICByZXR1cm4gcztcbn1cblxudmVjMiBzdWJfZnA2NCh2ZWMyIGEsIHZlYzIgYikge1xuICB2ZWMyIHMsIHQ7XG4gIHMgPSB0d29TdWIoYS54LCBiLngpO1xuICB0ID0gdHdvU3ViKGEueSwgYi55KTtcbiAgcy55ICs9IHQueDtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcy55ICs9IHQueTtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgbXVsX2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZChhLngsIGIueCk7XG4gIC8vIHkgY29tcG9uZW50IGlzIGZvciB0aGUgZXJyb3JcbiAgcHJvZC55ICs9IGEueCAqIGIueTtcbiAgcHJvZC55ICs9IGEueSAqIGIueDtcbiAgcHJvZCA9IHF1aWNrVHdvU3VtKHByb2QueCwgcHJvZC55KTtcbiAgcmV0dXJuIHByb2Q7XG59XG5cbnZlYzIgZGl2X2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgZmxvYXQgeG4gPSAxLjAgLyBiLng7XG4gIHZlYzIgeW4gPSBhICogeG47XG4gIGZsb2F0IGRpZmYgPSAoc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoYiwgeW4pKSkueDtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZCh4biwgZGlmZik7XG4gIHJldHVybiBzdW1fZnA2NCh5biwgcHJvZCk7XG59XG5cbnZlYzIgc3FydF9mcDY0KHZlYzIgYSkge1xuXG4gIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgaWYgKGEueCA8IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuXG4gIGZsb2F0IHggPSAxLjAgLyBzcXJ0KGEueCk7XG4gIGZsb2F0IHluID0gYS54ICogeDtcbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxuICB2ZWMyIHluX3NxciA9IHR3b1Nxcih5bikgKiBPTkU7XG4jZWxzZVxuICB2ZWMyIHluX3NxciA9IHR3b1Nxcih5bik7XG4jZW5kaWZcbiAgZmxvYXQgZGlmZiA9IHN1Yl9mcDY0KGEsIHluX3NxcikueDtcbiAgdmVjMiBwcm9kID0gdHdvUHJvZCh4ICogMC41LCBkaWZmKTtcbiAgcmV0dXJuIHN1bV9mcDY0KHZlYzIoeW4sIDAuMCksIHByb2QpO1xufVxuXG4vKiBrX3Bvd2VyIGNvbnRyb2xzIGhvdyBtdWNoIHJhbmdlIHJlZHVjdGlvbiB3ZSB3b3VsZCBsaWtlIHRvIGhhdmVcblJhbmdlIHJlZHVjdGlvbiB1c2VzIHRoZSBmb2xsb3dpbmcgbWV0aG9kOlxuYXNzdW1lIGEgPSBrX3Bvd2VyICogciArIG0gKiBsb2coMiksIGsgYW5kIG0gYmVpbmcgaW50ZWdlcnMuXG5TZXQga19wb3dlciA9IDQgKHdlIGNhbiBjaG9vc2Ugb3RoZXIgayB0byB0cmFkZSBhY2N1cmFjeSB3aXRoIHBlcmZvcm1hbmNlLlxud2Ugb25seSBuZWVkIHRvIGNhbGN1bGF0ZSBleHAocikgYW5kIHVzaW5nIGV4cChhKSA9IDJebSAqIGV4cChyKV5rX3Bvd2VyO1xuKi9cblxudmVjMiBleHBfZnA2NCh2ZWMyIGEpIHtcbiAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlc2UgdHdvIG51bWJlcnMgbWF0Y2hcbiAgLy8gYXMgYml0LXdpc2Ugc2hpZnQgaXMgbm90IGF2YWlsYWJsZSBpbiBHTFNMIDEuMFxuICBjb25zdCBpbnQga19wb3dlciA9IDQ7XG4gIGNvbnN0IGZsb2F0IGsgPSAxNi4wO1xuXG4gIGNvbnN0IGZsb2F0IGludl9rID0gMS4wIC8gaztcblxuICBpZiAoYS54IDw9IC04OC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIGlmIChhLnggPj0gODguMCkgcmV0dXJuIHZlYzIoMS4wIC8gMC4wLCAxLjAgLyAwLjApO1xuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gdmVjMigxLjAsIDAuMCk7XG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiBFX0ZQNjQ7XG5cbiAgZmxvYXQgbSA9IGZsb29yKGEueCAvIExPRzJfRlA2NC54ICsgMC41KTtcbiAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoTE9HMl9GUDY0LCB2ZWMyKG0sIDAuMCkpKSAqIGludl9rO1xuICB2ZWMyIHMsIHQsIHA7XG5cbiAgcCA9IG11bF9mcDY0KHIsIHIpO1xuICBzID0gc3VtX2ZwNjQociwgcCAqIDAuNSk7XG4gIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCk7XG5cbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuICBwID0gbXVsX2ZwNjQocCwgcik7XG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF80X0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0KTtcblxuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG4gIC8vIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgLy8gdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCk7XG5cbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuICAvLyBwID0gbXVsX2ZwNjQocCwgcik7XG4gIC8vIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF83X0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHMgPSBleHAocikgLSAxOyBidXQgYWZ0ZXIgZm9sbG93aW5nIDQgcmVjdXJzaW9ucywgd2Ugd2lsbCBnZXQgZXhwKHIpIF4gNTEyIC0gMS5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBrX3Bvd2VyOyBpKyspIHtcbiAgICBzID0gc3VtX2ZwNjQocyAqIDIuMCwgbXVsX2ZwNjQocywgcykpO1xuICB9XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxuICBzID0gc3VtX2ZwNjQocywgdmVjMihPTkUsIDAuMCkpO1xuI2Vsc2VcbiAgcyA9IHN1bV9mcDY0KHMsIHZlYzIoMS4wLCAwLjApKTtcbiNlbmRpZlxuXG4gIHJldHVybiBzICogcG93KDIuMCwgbSk7XG4vLyAgIHJldHVybiByO1xufVxuXG52ZWMyIGxvZ19mcDY0KHZlYzIgYSlcbntcbiAgaWYgKGEueCA9PSAxLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICBpZiAoYS54IDw9IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICB2ZWMyIHggPSB2ZWMyKGxvZyhhLngpLCAwLjApO1xuICB2ZWMyIHM7XG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgcyA9IHZlYzIoT05FLCAwLjApO1xuI2Vsc2VcbiAgcyA9IHZlYzIoMS4wLCAwLjApO1xuI2VuZGlmXG5cbiAgeCA9IHN1Yl9mcDY0KHN1bV9mcDY0KHgsIG11bF9mcDY0KGEsIGV4cF9mcDY0KC14KSkpLCBzKTtcbiAgcmV0dXJuIHg7XG59XG5cbnZlYzIgc2luX3RheWxvcl9mcDY0KHZlYzIgYSkge1xuICB2ZWMyIHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgfVxuXG4gIHggPSAtbXVsX2ZwNjQoYSwgYSk7XG4gIHMgPSBhO1xuICByID0gYTtcblxuICByID0gbXVsX2ZwNjQociwgeCk7XG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNV9GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIC8qIGtlZXAgdGhlIGZvbGxvd2luZyBjb21tZW50ZWQgY29kZSBpbiBjYXNlIHdlIG5lZWQgdGhlbVxuICBmb3IgZXh0cmEgYWNjdXJhY3kgZnJvbSB0aGUgVGF5bG9yIGV4cGFuc2lvbiovXG5cbiAgLy8gciA9IG11bF9mcDY0KHIsIHgpO1xuICAvLyB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzlfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByZXR1cm4gcztcbn1cblxudmVjMiBjb3NfdGF5bG9yX2ZwNjQodmVjMiBhKSB7XG4gIHZlYzIgciwgcywgdCwgeDtcblxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICB9XG5cbiAgeCA9IC1tdWxfZnA2NChhLCBhKTtcbiAgciA9IHg7XG4gIHMgPSBzdW1fZnA2NCh2ZWMyKDEuMCwgMC4wKSwgciAqIDAuNSk7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvKiBrZWVwIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cbiAgZm9yIGV4dHJhIGFjY3VyYWN5IGZyb20gdGhlIFRheWxvciBleHBhbnNpb24qL1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzhfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8xMF9GUDY0KTtcbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHJldHVybiBzO1xufVxuXG52b2lkIHNpbmNvc190YXlsb3JfZnA2NCh2ZWMyIGEsIG91dCB2ZWMyIHNpbl90LCBvdXQgdmVjMiBjb3NfdCkge1xuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgc2luX3QgPSB2ZWMyKDAuMCwgMC4wKTtcbiAgICBjb3NfdCA9IHZlYzIoMS4wLCAwLjApO1xuICB9XG5cbiAgc2luX3QgPSBzaW5fdGF5bG9yX2ZwNjQoYSk7XG4gIGNvc190ID0gc3FydF9mcDY0KHN1Yl9mcDY0KHZlYzIoMS4wLCAwLjApLCBtdWxfZnA2NChzaW5fdCwgc2luX3QpKSk7XG59XG5cbnZlYzIgc2luX2ZwNjQodmVjMiBhKSB7XG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH1cblxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGsgPSBpbnQocSk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC1zaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICBpZiAoYWJzX2sgPiA0KSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XG4gICAgfVxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4gICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZWxzZVxuICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZW5kaWZcblxuICAgIHZlYzIgc2luX3QsIGNvc190O1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG5cblxuICAgIHZlYzIgcmVzdWx0ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIGNvc190KSwgbXVsX2ZwNjQodSwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZlYzIgY29zX2ZwNjQodmVjMiBhKSB7XG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigxLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH1cblxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGsgPSBpbnQocSk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb3NfdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gLXNpbl90YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC1jb3NfdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICBpZiAoYWJzX2sgPiA0KSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XG4gICAgfVxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4gICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZWxzZVxuICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICB9XG4jZW5kaWZcblxuICAgIHZlYzIgc2luX3QsIGNvc190O1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG4gICAgdmVjMiByZXN1bHQgPSB2ZWMyKDAuMCwgMC4wKTtcbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgY29zX3QpLCBtdWxfZnA2NCh1LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiB0YW5fZnA2NCh2ZWMyIGEpIHtcbiAgICB2ZWMyIHNpbl9hO1xuICAgIHZlYzIgY29zX2E7XG5cbiAgICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgICB9XG5cbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXG4gICAgdmVjMiB6ID0gbmludF9mcDY0KGRpdl9mcDY0KGEsIFRXT19QSV9GUDY0KSk7XG4gICAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoVFdPX1BJX0ZQNjQsIHopKTtcblxuICAgIHZlYzIgdDtcbiAgICBmbG9hdCBxID0gZmxvb3Ioci54IC8gUElfMl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBqID0gaW50KHEpO1xuXG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcblxuICAgIC8vIFdlIGp1c3QgY2FuJ3QgZ2V0IFBJLzE2ICogMy4wIHZlcnkgYWNjdXJhdGVseS5cbiAgICAvLyBzbyBsZXQncyBqdXN0IHN0b3JlIGl0XG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICB2ZWMyIHMsIGM7XG4gICAgc2luY29zX3RheWxvcl9mcDY0KHQsIHNpbl90LCBjb3NfdCk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIHMgPSBzaW5fdDtcbiAgICAgICAgYyA9IGNvc190O1xuICAgIH0gZWxzZSB7XG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgICAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgICAgIH1cbiNlbHNlXG4gICAgICAgIGlmIChhYnNfayA9PSAxKSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xuICAgICAgICB9XG4jZW5kaWZcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICBzID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICAgICAgYyA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgICAgICBjID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBzaW5fYSA9IHM7XG4gICAgICAgIGNvc19hID0gYztcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBzaW5fYSA9IGM7XG4gICAgICAgIGNvc19hID0gLXM7XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIHNpbl9hID0gLWM7XG4gICAgICAgIGNvc19hID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5fYSA9IC1zO1xuICAgICAgICBjb3NfYSA9IC1jO1xuICAgIH1cbiAgICByZXR1cm4gZGl2X2ZwNjQoc2luX2EsIGNvc19hKTtcbn1cblxudmVjMiByYWRpYW5zX2ZwNjQodmVjMiBkZWdyZWUpIHtcbiAgcmV0dXJuIG11bF9mcDY0KGRlZ3JlZSwgUElfMTgwX0ZQNjQpO1xufVxuXG52ZWMyIG1peF9mcDY0KHZlYzIgYSwgdmVjMiBiLCBmbG9hdCB4KSB7XG4gIHZlYzIgcmFuZ2UgPSBzdWJfZnA2NChiLCBhKTtcbiAgcmV0dXJuIHN1bV9mcDY0KGEsIG11bF9mcDY0KHJhbmdlLCB2ZWMyKHgsIDAuMCkpKTtcbn1cblxuLy8gVmVjdG9yIGZ1bmN0aW9uc1xuLy8gdmVjMiBmdW5jdGlvbnNcbnZvaWQgdmVjMl9zdW1fZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBzdW1fZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gc3VtX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9zdWJfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBzdWJfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gc3ViX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9tdWxfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9kaXZfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICAgIG91dF92YWxbMF0gPSBkaXZfZnA2NChhWzBdLCBiWzBdKTtcbiAgICBvdXRfdmFsWzFdID0gZGl2X2ZwNjQoYVsxXSwgYlsxXSk7XG59XG5cbnZvaWQgdmVjMl9taXhfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSwgZmxvYXQgYSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuICB2ZWMyIHJhbmdlWzJdO1xuICB2ZWMyX3N1Yl9mcDY0KHksIHgsIHJhbmdlKTtcbiAgdmVjMiBwb3J0aW9uWzJdO1xuICBwb3J0aW9uWzBdID0gcmFuZ2VbMF0gKiBhO1xuICBwb3J0aW9uWzFdID0gcmFuZ2VbMV0gKiBhO1xuICB2ZWMyX3N1bV9mcDY0KHgsIHBvcnRpb24sIG91dF92YWwpO1xufVxuXG52ZWMyIHZlYzJfbGVuZ3RoX2ZwNjQodmVjMiB4WzJdKSB7XG4gIHJldHVybiBzcXJ0X2ZwNjQoc3VtX2ZwNjQobXVsX2ZwNjQoeFswXSwgeFswXSksIG11bF9mcDY0KHhbMV0sIHhbMV0pKSk7XG59XG5cbnZvaWQgdmVjMl9ub3JtYWxpemVfZnA2NCh2ZWMyIHhbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgdmVjMiBsZW5ndGggPSB2ZWMyX2xlbmd0aF9mcDY0KHgpO1xuICB2ZWMyIGxlbmd0aF92ZWMyWzJdO1xuICBsZW5ndGhfdmVjMlswXSA9IGxlbmd0aDtcbiAgbGVuZ3RoX3ZlYzJbMV0gPSBsZW5ndGg7XG5cbiAgdmVjMl9kaXZfZnA2NCh4LCBsZW5ndGhfdmVjMiwgb3V0X3ZhbCk7XG59XG5cbnZlYzIgdmVjMl9kaXN0YW5jZV9mcDY0KHZlYzIgeFsyXSwgdmVjMiB5WzJdKSB7XG4gIHZlYzIgZGlmZlsyXTtcbiAgdmVjMl9zdWJfZnA2NCh4LCB5LCBkaWZmKTtcbiAgcmV0dXJuIHZlYzJfbGVuZ3RoX2ZwNjQoZGlmZik7XG59XG5cbnZlYzIgdmVjMl9kb3RfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSkge1xuICB2ZWMyIHZbMl07XG5cbiAgdlswXSA9IG11bF9mcDY0KGFbMF0sIGJbMF0pO1xuICB2WzFdID0gbXVsX2ZwNjQoYVsxXSwgYlsxXSk7XG5cbiAgcmV0dXJuIHN1bV9mcDY0KHZbMF0sIHZbMV0pO1xufVxuXG4vLyB2ZWMzIGZ1bmN0aW9uc1xudm9pZCB2ZWMzX3N1Yl9mcDY0KHZlYzIgYVszXSwgdmVjMiBiWzNdLCBvdXQgdmVjMiBvdXRfdmFsWzNdKSB7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgb3V0X3ZhbFtpXSA9IHN1bV9mcDY0KGFbaV0sIGJbaV0pO1xuICB9XG59XG5cbnZvaWQgdmVjM19zdW1fZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52ZWMyIHZlYzNfbGVuZ3RoX2ZwNjQodmVjMiB4WzNdKSB7XG4gIHJldHVybiBzcXJ0X2ZwNjQoc3VtX2ZwNjQoc3VtX2ZwNjQobXVsX2ZwNjQoeFswXSwgeFswXSksIG11bF9mcDY0KHhbMV0sIHhbMV0pKSxcbiAgICBtdWxfZnA2NCh4WzJdLCB4WzJdKSkpO1xufVxuXG52ZWMyIHZlYzNfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbM10sIHZlYzIgeVszXSkge1xuICB2ZWMyIGRpZmZbM107XG4gIHZlYzNfc3ViX2ZwNjQoeCwgeSwgZGlmZik7XG4gIHJldHVybiB2ZWMzX2xlbmd0aF9mcDY0KGRpZmYpO1xufVxuXG4vLyB2ZWM0IGZ1bmN0aW9uc1xudm9pZCB2ZWM0X2ZwNjQodmVjNCBhLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XG4gIG91dF92YWxbMF0ueCA9IGFbMF07XG4gIG91dF92YWxbMF0ueSA9IDAuMDtcblxuICBvdXRfdmFsWzFdLnggPSBhWzFdO1xuICBvdXRfdmFsWzFdLnkgPSAwLjA7XG5cbiAgb3V0X3ZhbFsyXS54ID0gYVsyXTtcbiAgb3V0X3ZhbFsyXS55ID0gMC4wO1xuXG4gIG91dF92YWxbM10ueCA9IGFbM107XG4gIG91dF92YWxbM10ueSA9IDAuMDtcbn1cblxudm9pZCB2ZWM0X3NjYWxhcl9tdWxfZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYiwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoYVswXSwgYik7XG4gIG91dF92YWxbMV0gPSBtdWxfZnA2NChhWzFdLCBiKTtcbiAgb3V0X3ZhbFsyXSA9IG11bF9mcDY0KGFbMl0sIGIpO1xuICBvdXRfdmFsWzNdID0gbXVsX2ZwNjQoYVszXSwgYik7XG59XG5cbnZvaWQgdmVjNF9zdW1fZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYls0XSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52b2lkIHZlYzRfZG90X2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWwpIHtcbiAgdmVjMiB2WzRdO1xuXG4gIHZbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgdlsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xuICB2WzJdID0gbXVsX2ZwNjQoYVsyXSwgYlsyXSk7XG4gIHZbM10gPSBtdWxfZnA2NChhWzNdLCBiWzNdKTtcblxuICBvdXRfdmFsID0gc3VtX2ZwNjQoc3VtX2ZwNjQodlswXSwgdlsxXSksIHN1bV9mcDY0KHZbMl0sIHZbM10pKTtcbn1cblxudm9pZCBtYXQ0X3ZlYzRfbXVsX2ZwNjQodmVjMiBiWzE2XSwgdmVjMiBhWzRdLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XG4gIHZlYzIgdG1wWzRdO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKVxuICB7XG4gICAgZm9yIChpbnQgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgdG1wW2pdID0gYltqICsgaSAqIDRdO1xuICAgIH1cbiAgICB2ZWM0X2RvdF9mcDY0KGEsIHRtcCwgb3V0X3ZhbFtpXSk7XG4gIH1cbn1cbmA7XG4iXX0=

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return lighting; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lighting_glsl__ = __webpack_require__(202);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



var lighting = {
  interface: 'lighting',
  source: __WEBPACK_IMPORTED_MODULE_0__lighting_glsl__["a" /* default */]
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvbGlnaHRpbmcvaW5kZXguanMiXSwibmFtZXMiOlsibGlnaHRpbmdTaGFkZXIiLCJsaWdodGluZyIsImludGVyZmFjZSIsInNvdXJjZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsY0FBUCxNQUEyQixpQkFBM0I7O0FBRUEsT0FBTyxJQUFNQyxXQUFXO0FBQ3RCQyxhQUFXLFVBRFc7QUFFdEJDLFVBQVFIO0FBRmMsQ0FBakIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IGxpZ2h0aW5nU2hhZGVyIGZyb20gJy4vbGlnaHRpbmcuZ2xzbCc7XG5cbmV4cG9ydCBjb25zdCBsaWdodGluZyA9IHtcbiAgaW50ZXJmYWNlOiAnbGlnaHRpbmcnLFxuICBzb3VyY2U6IGxpZ2h0aW5nU2hhZGVyXG59O1xuIl19

/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// lighting

/* harmony default export */ __webpack_exports__["a"] = ("#define NUM_OF_LIGHTS 2\nuniform vec3 cameraPos;\nuniform vec3 lightsPosition[16];\nuniform vec2 lightsStrength[16];\nuniform float ambientRatio;\nuniform float diffuseRatio;\nuniform float specularRatio;\n\nfloat getLightWeight(vec3 position_worldspace_vec3, vec3 normals_worldspace) {\n  float lightWeight = 0.0;\n\n  vec3 normals_worldspace_vec3 = normals_worldspace.xzy;\n\n  vec3 camera_pos_worldspace = cameraPos;\n  vec3 view_direction = normalize(camera_pos_worldspace - position_worldspace_vec3);\n\n  for (int i = 0; i < NUM_OF_LIGHTS; i++) {\n    vec3 light_position_worldspace = project_position(lightsPosition[i]);\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace_vec3);\n\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normals_worldspace_vec3);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normals_worldspace_vec3, halfway_direction), 0.0);\n      specular = pow(specular_angle, 32.0);\n    }\n    lambertian = max(lambertian, 0.0);\n    lightWeight += (ambientRatio + lambertian * diffuseRatio + specular * specularRatio) *\n      lightsStrength[i].x;\n\n  }\n\n  return lightWeight;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvbGlnaHRpbmcvbGlnaHRpbmcuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiJsaWdodGluZy5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIGxpZ2h0aW5nXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBOVU1fT0ZfTElHSFRTIDJcbnVuaWZvcm0gdmVjMyBjYW1lcmFQb3M7XG51bmlmb3JtIHZlYzMgbGlnaHRzUG9zaXRpb25bMTZdO1xudW5pZm9ybSB2ZWMyIGxpZ2h0c1N0cmVuZ3RoWzE2XTtcbnVuaWZvcm0gZmxvYXQgYW1iaWVudFJhdGlvO1xudW5pZm9ybSBmbG9hdCBkaWZmdXNlUmF0aW87XG51bmlmb3JtIGZsb2F0IHNwZWN1bGFyUmF0aW87XG5cbmZsb2F0IGdldExpZ2h0V2VpZ2h0KHZlYzMgcG9zaXRpb25fd29ybGRzcGFjZV92ZWMzLCB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZSkge1xuICBmbG9hdCBsaWdodFdlaWdodCA9IDAuMDtcblxuICB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZV92ZWMzID0gbm9ybWFsc193b3JsZHNwYWNlLnh6eTtcblxuICB2ZWMzIGNhbWVyYV9wb3Nfd29ybGRzcGFjZSA9IGNhbWVyYVBvcztcbiAgdmVjMyB2aWV3X2RpcmVjdGlvbiA9IG5vcm1hbGl6ZShjYW1lcmFfcG9zX3dvcmxkc3BhY2UgLSBwb3NpdGlvbl93b3JsZHNwYWNlX3ZlYzMpO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgTlVNX09GX0xJR0hUUzsgaSsrKSB7XG4gICAgdmVjMyBsaWdodF9wb3NpdGlvbl93b3JsZHNwYWNlID0gcHJvamVjdF9wb3NpdGlvbihsaWdodHNQb3NpdGlvbltpXSk7XG4gICAgdmVjMyBsaWdodF9kaXJlY3Rpb24gPSBub3JtYWxpemUobGlnaHRfcG9zaXRpb25fd29ybGRzcGFjZSAtIHBvc2l0aW9uX3dvcmxkc3BhY2VfdmVjMyk7XG5cbiAgICB2ZWMzIGhhbGZ3YXlfZGlyZWN0aW9uID0gbm9ybWFsaXplKGxpZ2h0X2RpcmVjdGlvbiArIHZpZXdfZGlyZWN0aW9uKTtcbiAgICBmbG9hdCBsYW1iZXJ0aWFuID0gZG90KGxpZ2h0X2RpcmVjdGlvbiwgbm9ybWFsc193b3JsZHNwYWNlX3ZlYzMpO1xuICAgIGZsb2F0IHNwZWN1bGFyID0gMC4wO1xuICAgIGlmIChsYW1iZXJ0aWFuID4gMC4wKSB7XG4gICAgICBmbG9hdCBzcGVjdWxhcl9hbmdsZSA9IG1heChkb3Qobm9ybWFsc193b3JsZHNwYWNlX3ZlYzMsIGhhbGZ3YXlfZGlyZWN0aW9uKSwgMC4wKTtcbiAgICAgIHNwZWN1bGFyID0gcG93KHNwZWN1bGFyX2FuZ2xlLCAzMi4wKTtcbiAgICB9XG4gICAgbGFtYmVydGlhbiA9IG1heChsYW1iZXJ0aWFuLCAwLjApO1xuICAgIGxpZ2h0V2VpZ2h0ICs9IChhbWJpZW50UmF0aW8gKyBsYW1iZXJ0aWFuICogZGlmZnVzZVJhdGlvICsgc3BlY3VsYXIgKiBzcGVjdWxhclJhdGlvKSAqXG4gICAgICBsaWdodHNTdHJlbmd0aFtpXS54O1xuXG4gIH1cblxuICByZXR1cm4gbGlnaHRXZWlnaHQ7XG59XG5gO1xuIl19

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return project64; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__project64_glsl__ = __webpack_require__(204);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



var project64 = {
  interface: 'project64',
  source: __WEBPACK_IMPORTED_MODULE_0__project64_glsl__["a" /* default */]
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdDY0L2luZGV4LmpzIl0sIm5hbWVzIjpbInByb2plY3Q2NFNoYWRlciIsInByb2plY3Q2NCIsImludGVyZmFjZSIsInNvdXJjZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBUCxNQUE0QixrQkFBNUI7O0FBRUEsT0FBTyxJQUFNQyxZQUFZO0FBQ3ZCQyxhQUFXLFdBRFk7QUFFdkJDLFVBQVFIO0FBRmUsQ0FBbEIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHByb2plY3Q2NFNoYWRlciBmcm9tICcuL3Byb2plY3Q2NC5nbHNsJztcblxuZXhwb3J0IGNvbnN0IHByb2plY3Q2NCA9IHtcbiAgaW50ZXJmYWNlOiAncHJvamVjdDY0JyxcbiAgc291cmNlOiBwcm9qZWN0NjRTaGFkZXJcbn07XG4iXX0=

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 projectionScaleFP64;\nuniform vec2 projectionFP64[16];\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sub_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], projectionScaleFP64);\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], projectionScaleFP64);\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\n\n  return;\n}\n\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(projectionFP64, vertex_pos_modelspace, vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdDY0L3Byb2plY3Q2NC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InByb2plY3Q2NC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuXG5jb25zdCB2ZWMyIFdPUkxEX1NDQUxFX0ZQNjQgPSB2ZWMyKDgxLjQ4NzMyNzU3NTY4MzYsIDAuMDAwMDAzMjg3MzY2ODIzMjAxNDA5Nyk7XG5cbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uU2NhbGVGUDY0O1xudW5pZm9ybSB2ZWMyIHByb2plY3Rpb25GUDY0WzE2XTtcblxuLy8gbG9uZ2l0dWRlOiBsbmdsYXRfZnA2NC54eTsgbGF0aXR1ZGU6IGxuZ2xhdF9mcDY0Lnp3XG52b2lkIG1lcmNhdG9yUHJvamVjdF9mcDY0KHZlYzQgbG5nbGF0X2ZwNjQsIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcblxuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORClcbiAgb3V0X3ZhbFswXSA9IHN1bV9mcDY0KHJhZGlhbnNfZnA2NChsbmdsYXRfZnA2NC54eSksIFBJX0ZQNjQgKiBPTkUpO1xuI2Vsc2VcbiAgb3V0X3ZhbFswXSA9IHN1bV9mcDY0KHJhZGlhbnNfZnA2NChsbmdsYXRfZnA2NC54eSksIFBJX0ZQNjQpO1xuI2VuZGlmXG4gIG91dF92YWxbMV0gPSBzdWJfZnA2NChQSV9GUDY0LFxuICAgIGxvZ19mcDY0KHRhbl9mcDY0KHN1bV9mcDY0KFBJXzRfRlA2NCwgcmFkaWFuc19mcDY0KGxuZ2xhdF9mcDY0Lnp3KSAvIDIuMCkpKSk7XG4gIHJldHVybjtcbn1cblxudm9pZCBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQodmVjNCBwb3NpdGlvbl9mcDY0LCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XG5cbiAgdmVjMiBwb3NfZnA2NFsyXTtcbiAgbWVyY2F0b3JQcm9qZWN0X2ZwNjQocG9zaXRpb25fZnA2NCwgcG9zX2ZwNjQpO1xuICB2ZWMyIHhfZnA2NCA9IG11bF9mcDY0KHBvc19mcDY0WzBdLCBwcm9qZWN0aW9uU2NhbGVGUDY0KTtcbiAgdmVjMiB5X2ZwNjQgPSBtdWxfZnA2NChwb3NfZnA2NFsxXSwgcHJvamVjdGlvblNjYWxlRlA2NCk7XG4gIG91dF92YWxbMF0gPSBtdWxfZnA2NCh4X2ZwNjQsIFdPUkxEX1NDQUxFX0ZQNjQpO1xuICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoeV9mcDY0LCBXT1JMRF9TQ0FMRV9GUDY0KTtcblxuICByZXR1cm47XG59XG5cbnZlYzQgcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XSkge1xuICB2ZWMyIHZlcnRleF9wb3NfY2xpcHNwYWNlWzRdO1xuICBtYXQ0X3ZlYzRfbXVsX2ZwNjQocHJvamVjdGlvbkZQNjQsIHZlcnRleF9wb3NfbW9kZWxzcGFjZSwgdmVydGV4X3Bvc19jbGlwc3BhY2UpO1xuICByZXR1cm4gdmVjNChcbiAgICB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZVswXS54LFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzFdLngsXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbMl0ueCxcbiAgICB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZVszXS54XG4gICAgKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return project; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__project_glsl__ = __webpack_require__(206);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



var project = {
  interface: 'project',
  source: __WEBPACK_IMPORTED_MODULE_0__project_glsl__["a" /* default */]
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9pbmRleC5qcyJdLCJuYW1lcyI6WyJwcm9qZWN0U2hhZGVyIiwicHJvamVjdCIsImludGVyZmFjZSIsInNvdXJjZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsYUFBUCxNQUEwQixnQkFBMUI7O0FBRUEsT0FBTyxJQUFNQyxVQUFVO0FBQ3JCQyxhQUFXLFNBRFU7QUFFckJDLFVBQVFIO0FBRmEsQ0FBaEIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHByb2plY3RTaGFkZXIgZnJvbSAnLi9wcm9qZWN0Lmdsc2wnO1xuXG5leHBvcnQgY29uc3QgcHJvamVjdCA9IHtcbiAgaW50ZXJmYWNlOiAncHJvamVjdCcsXG4gIHNvdXJjZTogcHJvamVjdFNoYWRlclxufTtcbiJdfQ==

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["a"] = ("const float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 projectionMatrixUncentered;\n\n#ifdef INTEL_TAN_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef INTEL_TAN_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n\n//\n// Scaling offsets\n//\n\nfloat project_scale(float meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return meters * projectionPixelsPerUnit.x;\n  }\n}\n\nvec2 project_scale(vec2 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec2(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec3 project_scale(vec3 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec3(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec4 project_scale(vec4 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec4(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x,\n      meters.w\n    );\n  }\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec2 project_position(vec2 position) {\n  if (projectionMode == PROJECT_IDENTITY) {\n    return position;\n  }\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return position;\n    return project_scale(position);\n  }\n  // Covers projectionMode == PROJECT_MERCATOR\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\n}\n\nvec3 project_position(vec3 position) {\n  return vec3(project_position(position.xy), project_scale(position.z));\n}\n\nvec4 project_position(vec4 position) {\n  return vec4(project_position(position.xyz), position.w);\n}\n\n//\n\nvec4 project_to_viewspace(vec4 position) {\n  return modelViewMatrix * position;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position = position * projectionPixelsPerUnit.x;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoicHJvamVjdC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNjtcbmNvbnN0IGZsb2F0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKFBJICogMi4wKTtcblxuLy8gcmVmOiBsaWIvY29uc3RhbnRzLmpzXG5jb25zdCBmbG9hdCBQUk9KRUNUX0lERU5USVRZID0gMC47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SID0gMS47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMgPSAyLjtcblxudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uTW9kZTtcbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvblNjYWxlO1xudW5pZm9ybSB2ZWM0IHByb2plY3Rpb25DZW50ZXI7XG51bmlmb3JtIHZlYzMgcHJvamVjdGlvblBpeGVsc1BlclVuaXQ7XG5cbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDtcblxuI2lmZGVmIElOVEVMX1RBTl9XT1JLQVJPVU5EXG5cbi8vIEFsbCB0aGVzZSBmdW5jdGlvbnMgYXJlIGZvciBzdWJzdGl0dXRpbmcgdGFuKCkgZnVuY3Rpb24gZnJvbSBJbnRlbCBHUFUgb25seVxuY29uc3QgZmxvYXQgVFdPX1BJID0gNi4yODMxODU0ODIwMjUxNDY1O1xuY29uc3QgZmxvYXQgUElfMiA9IDEuNTcwNzk2MzcwNTA2Mjg2NjtcbmNvbnN0IGZsb2F0IFBJXzE2ID0gMC4xOTYzNDk1NDYzMTMyODU4O1xuXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMCA9IDAuMTk1MDkwMzIzNjg2NTk5NzM7XG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMSA9IDAuMzgyNjgzNDI2MTQxNzM4OTtcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8yID0gMC41NTU1NzAyNDQ3ODkxMjM1O1xuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XG5cbmNvbnN0IGZsb2F0IENPU19UQUJMRV8wID0gMC45ODA3ODUyNTA2NjM3NTczO1xuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzEgPSAwLjkyMzg3OTUwNDIwMzc5NjQ7XG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMiA9IDAuODMxNDY5NTk1NDMyMjgxNTtcbmNvbnN0IGZsb2F0IENPU19UQUJMRV8zID0gMC43MDcxMDY3NjkwODQ5MzA0O1xuXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF8zID0gMS42NjY2NjY3MTYzMzcyMDRlLTAxOyAvLyAxLzMhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF81ID0gOC4zMzMzMzM3Njc5NTA1MzVlLTAzOyAvLyAxLzUhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF83ID0gMS45ODQxMjcwMTEzODI5NTIzZS0wNDsgLy8gMS83IVxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfOSA9IDIuNzU1NzMxODg0NDYyODc1MzNlLTA2OyAvLyAxLzkhXG5cbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XG4gIGZsb2F0IHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEgPT0gMC4wKSB7XG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuXG4gIHggPSAtYSAqIGE7XG4gIHMgPSBhO1xuICByID0gYTtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcbiAgcyA9IHMgKyB0O1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF81O1xuICBzID0gcyArIHQ7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzc7XG4gIHMgPSBzICsgdDtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcbiAgcyA9IHMgKyB0O1xuXG4gIHJldHVybiBzO1xufVxuXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xuICBpZiAoYSA9PSAwLjApIHtcbiAgICBzaW5fdCA9IDAuMDtcbiAgICBjb3NfdCA9IDEuMDtcbiAgfVxuICBzaW5fdCA9IHNpbl90YXlsb3JfZnAzMihhKTtcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xufVxuXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xuICAgIGZsb2F0IHNpbl9hO1xuICAgIGZsb2F0IGNvc19hO1xuXG4gICAgaWYgKGEgPT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIGZsb2F0IHogPSBmbG9vcihhIC8gVFdPX1BJKTtcbiAgICBmbG9hdCByID0gYSAtIFRXT19QSSAqIHo7XG5cbiAgICBmbG9hdCB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyIC8gUElfMiArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiAwLjAgLyAwLjA7XG4gICAgfVxuXG4gICAgdCA9IHIgLSBQSV8yICogcTtcblxuICAgIHEgPSBmbG9vcih0IC8gUElfMTYgKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcblxuICAgIGlmIChhYnNfayA+IDQpIHtcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdCAtIFBJXzE2ICogcTtcbiAgICB9XG5cbiAgICBmbG9hdCB1ID0gMC4wO1xuICAgIGZsb2F0IHYgPSAwLjA7XG5cbiAgICBmbG9hdCBzaW5fdCwgY29zX3Q7XG4gICAgZmxvYXQgcywgYztcbiAgICBzaW5jb3NfdGF5bG9yX2ZwMzIodCwgc2luX3QsIGNvc190KTtcblxuICAgIGlmIChrID09IDApIHtcbiAgICAgICAgcyA9IHNpbl90O1xuICAgICAgICBjID0gY29zX3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzA7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMTtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMTtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzM7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICBzID0gdSAqIHNpbl90ICsgdiAqIGNvc190O1xuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCAtIHYgKiBzaW5fdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgLSB2ICogY29zX3Q7XG4gICAgICAgICAgICBjID0gdSAqIGNvc190ICsgdiAqIHNpbl90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBzaW5fYSA9IHM7XG4gICAgICAgIGNvc19hID0gYztcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBzaW5fYSA9IGM7XG4gICAgICAgIGNvc19hID0gLXM7XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIHNpbl9hID0gLWM7XG4gICAgICAgIGNvc19hID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5fYSA9IC1zO1xuICAgICAgICBjb3NfYSA9IC1jO1xuICAgIH1cbiAgICByZXR1cm4gc2luX2EgLyBjb3NfYTtcbn1cbiNlbmRpZlxuXG5mbG9hdCB0YW5fZnAzMihmbG9hdCBhKSB7XG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcbiNlbHNlXG4gIHJldHVybiB0YW4oYSk7XG4jZW5kaWZcbn1cblxuLy9cbi8vIFNjYWxpbmcgb2Zmc2V0c1xuLy9cblxuZmxvYXQgcHJvamVjdF9zY2FsZShmbG9hdCBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1ldGVycyAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbn1cblxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2ZWMyKFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XG4gICAgKTtcbiAgfVxufVxuXG52ZWMzIHByb2plY3Rfc2NhbGUodmVjMyBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlYzMoXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueSAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcbiAgICApO1xuICB9XG59XG5cbnZlYzQgcHJvamVjdF9zY2FsZSh2ZWM0IG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmVjNChcbiAgICAgIG1ldGVycy54ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy53XG4gICAgKTtcbiAgfVxufVxuXG4vL1xuLy8gUHJvamVjdGluZyBwb3NpdGlvbnNcbi8vXG5cbi8vIG5vbi1saW5lYXIgcHJvamVjdGlvbjogbG5nbGF0cyA9PiB1bml0IHRpbGUgWzAtMSwgMC0xXVxudmVjMiBwcm9qZWN0X21lcmNhdG9yXyh2ZWMyIGxuZ2xhdCkge1xuICByZXR1cm4gdmVjMihcbiAgICByYWRpYW5zKGxuZ2xhdC54KSArIFBJLFxuICAgIFBJIC0gbG9nKHRhbl9mcDMyKFBJICogMC4yNSArIHJhZGlhbnMobG5nbGF0LnkpICogMC41KSlcbiAgKTtcbn1cblxudmVjMiBwcm9qZWN0X3Bvc2l0aW9uKHZlYzIgcG9zaXRpb24pIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfSURFTlRJVFkpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG4gIH1cbiAgLy8gQ292ZXJzIHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JcbiAgcmV0dXJuIHByb2plY3RfbWVyY2F0b3JfKHBvc2l0aW9uKSAqIFdPUkxEX1NDQUxFICogcHJvamVjdGlvblNjYWxlO1xufVxuXG52ZWMzIHByb2plY3RfcG9zaXRpb24odmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uLnh5KSwgcHJvamVjdF9zY2FsZShwb3NpdGlvbi56KSk7XG59XG5cbnZlYzQgcHJvamVjdF9wb3NpdGlvbih2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiB2ZWM0KHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24ueHl6KSwgcG9zaXRpb24udyk7XG59XG5cbi8vXG5cbnZlYzQgcHJvamVjdF90b192aWV3c3BhY2UodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gbW9kZWxWaWV3TWF0cml4ICogcG9zaXRpb247XG59XG5cbnZlYzQgcHJvamVjdF90b19jbGlwc3BhY2UodmVjNCBwb3NpdGlvbikge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXggKiBwb3NpdGlvbiArIHByb2plY3Rpb25DZW50ZXI7XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmZsb2F0IHNjYWxlKGZsb2F0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBzY2FsZSh2ZWMyIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMyBzY2FsZSh2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjNCBzY2FsZSh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBwcmVwcm9qZWN0KHZlYzIgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWMzIHByZXByb2plY3QodmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzQgcHJlcHJvamVjdCh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjNCBwcm9qZWN0KHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uKTtcbn1cbmA7XG4iXX0=

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_EVENT_CLASSES", function() { return BASIC_EVENT_CLASSES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_EVENT_ALIASES", function() { return BASIC_EVENT_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENT_RECOGNIZER_MAP", function() { return EVENT_RECOGNIZER_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RECOGNIZERS", function() { return RECOGNIZERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GESTURE_EVENT_ALIASES", function() { return GESTURE_EVENT_ALIASES; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hammerjs__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hammerjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hammerjs__);


/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */
/* eslint-disable */
var BASIC_EVENT_CLASSES = {
  down: ['pointerdown', 'touchstart', 'mousedown'],
  move: ['pointermove', 'touchmove', 'mousemove'],
  up: ['pointerup', 'touchend', 'mouseup']
};
/* eslint-enable */

var BASIC_EVENT_ALIASES = {
  pointerdown: BASIC_EVENT_CLASSES.down,
  pointermove: BASIC_EVENT_CLASSES.move,
  pointerup: BASIC_EVENT_CLASSES.up,
  touchstart: BASIC_EVENT_CLASSES.down,
  touchmove: BASIC_EVENT_CLASSES.move,
  touchend: BASIC_EVENT_CLASSES.up,
  mousedown: BASIC_EVENT_CLASSES.down,
  mousemove: BASIC_EVENT_CLASSES.move,
  mouseup: BASIC_EVENT_CLASSES.up
};

/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */
var EVENT_RECOGNIZER_MAP = {
  click: 'tap',
  tap: 'tap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};

var RECOGNIZERS = [[__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Rotate"], { enable: false }], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Pinch"], { enable: false }, ['rotate']], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Pan"], { threshold: 10, enable: false }], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Swipe"], { enable: false }], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Press"], { enable: false }], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Tap"], { event: 'doubletap', taps: 2, enable: false }], [__WEBPACK_IMPORTED_MODULE_0_hammerjs__["Tap"], { enable: false }]];

/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */
var GESTURE_EVENT_ALIASES = {
  click: 'tap'
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvY29uc3RhbnRzLmpzIl0sIm5hbWVzIjpbIlRhcCIsIlByZXNzIiwiUGluY2giLCJSb3RhdGUiLCJQYW4iLCJTd2lwZSIsIkJBU0lDX0VWRU5UX0NMQVNTRVMiLCJkb3duIiwibW92ZSIsInVwIiwiQkFTSUNfRVZFTlRfQUxJQVNFUyIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwiRVZFTlRfUkVDT0dOSVpFUl9NQVAiLCJjbGljayIsInRhcCIsImRvdWJsZXRhcCIsInByZXNzIiwicGluY2giLCJwaW5jaGluIiwicGluY2hvdXQiLCJwaW5jaHN0YXJ0IiwicGluY2htb3ZlIiwicGluY2hlbmQiLCJwaW5jaGNhbmNlbCIsInJvdGF0ZSIsInJvdGF0ZXN0YXJ0Iiwicm90YXRlbW92ZSIsInJvdGF0ZWVuZCIsInJvdGF0ZWNhbmNlbCIsInBhbiIsInBhbnN0YXJ0IiwicGFubW92ZSIsInBhbnVwIiwicGFuZG93biIsInBhbmxlZnQiLCJwYW5yaWdodCIsInBhbmVuZCIsInBhbmNhbmNlbCIsInN3aXBlIiwic3dpcGVsZWZ0Iiwic3dpcGVyaWdodCIsInN3aXBldXAiLCJzd2lwZWRvd24iLCJSRUNPR05JWkVSUyIsImVuYWJsZSIsInRocmVzaG9sZCIsImV2ZW50IiwidGFwcyIsIkdFU1RVUkVfRVZFTlRfQUxJQVNFUyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FDRUEsR0FERixFQUVFQyxLQUZGLEVBR0VDLEtBSEYsRUFJRUMsTUFKRixFQUtFQyxHQUxGLEVBTUVDLEtBTkYsUUFPTyxVQVBQOztBQVNBOzs7Ozs7O0FBT0E7QUFDQSxPQUFPLElBQU1DLHNCQUFzQjtBQUNqQ0MsUUFBTSxDQUFDLGFBQUQsRUFBZ0IsWUFBaEIsRUFBOEIsV0FBOUIsQ0FEMkI7QUFFakNDLFFBQU0sQ0FBQyxhQUFELEVBQWdCLFdBQWhCLEVBQThCLFdBQTlCLENBRjJCO0FBR2pDQyxNQUFNLENBQUMsV0FBRCxFQUFnQixVQUFoQixFQUE4QixTQUE5QjtBQUgyQixDQUE1QjtBQUtQOztBQUVBLE9BQU8sSUFBTUMsc0JBQXNCO0FBQ2pDQyxlQUFhTCxvQkFBb0JDLElBREE7QUFFakNLLGVBQWFOLG9CQUFvQkUsSUFGQTtBQUdqQ0ssYUFBV1Asb0JBQW9CRyxFQUhFO0FBSWpDSyxjQUFZUixvQkFBb0JDLElBSkM7QUFLakNRLGFBQVdULG9CQUFvQkUsSUFMRTtBQU1qQ1EsWUFBVVYsb0JBQW9CRyxFQU5HO0FBT2pDUSxhQUFXWCxvQkFBb0JDLElBUEU7QUFRakNXLGFBQVdaLG9CQUFvQkUsSUFSRTtBQVNqQ1csV0FBU2Isb0JBQW9CRztBQVRJLENBQTVCOztBQVlQOzs7Ozs7QUFNQSxPQUFPLElBQU1XLHVCQUF1QjtBQUNsQ0MsU0FBTyxLQUQyQjtBQUVsQ0MsT0FBSyxLQUY2QjtBQUdsQ0MsYUFBVyxXQUh1QjtBQUlsQ0MsU0FBTyxPQUoyQjtBQUtsQ0MsU0FBTyxPQUwyQjtBQU1sQ0MsV0FBUyxPQU55QjtBQU9sQ0MsWUFBVSxPQVB3QjtBQVFsQ0MsY0FBWSxPQVJzQjtBQVNsQ0MsYUFBVyxPQVR1QjtBQVVsQ0MsWUFBVSxPQVZ3QjtBQVdsQ0MsZUFBYSxPQVhxQjtBQVlsQ0MsVUFBUSxRQVowQjtBQWFsQ0MsZUFBYSxRQWJxQjtBQWNsQ0MsY0FBWSxRQWRzQjtBQWVsQ0MsYUFBVyxRQWZ1QjtBQWdCbENDLGdCQUFjLFFBaEJvQjtBQWlCbENDLE9BQUssS0FqQjZCO0FBa0JsQ0MsWUFBVSxLQWxCd0I7QUFtQmxDQyxXQUFTLEtBbkJ5QjtBQW9CbENDLFNBQU8sS0FwQjJCO0FBcUJsQ0MsV0FBUyxLQXJCeUI7QUFzQmxDQyxXQUFTLEtBdEJ5QjtBQXVCbENDLFlBQVUsS0F2QndCO0FBd0JsQ0MsVUFBUSxLQXhCMEI7QUF5QmxDQyxhQUFXLEtBekJ1QjtBQTBCbENDLFNBQU8sT0ExQjJCO0FBMkJsQ0MsYUFBVyxPQTNCdUI7QUE0QmxDQyxjQUFZLE9BNUJzQjtBQTZCbENDLFdBQVMsT0E3QnlCO0FBOEJsQ0MsYUFBVztBQTlCdUIsQ0FBN0I7O0FBaUNQLE9BQU8sSUFBTUMsY0FBYyxDQUN6QixDQUFDaEQsTUFBRCxFQUFTLEVBQUNpRCxRQUFRLEtBQVQsRUFBVCxDQUR5QixFQUV6QixDQUFDbEQsS0FBRCxFQUFRLEVBQUNrRCxRQUFRLEtBQVQsRUFBUixFQUF5QixDQUFDLFFBQUQsQ0FBekIsQ0FGeUIsRUFHekIsQ0FBQ2hELEdBQUQsRUFBTSxFQUFDaUQsV0FBVyxFQUFaLEVBQWdCRCxRQUFRLEtBQXhCLEVBQU4sQ0FIeUIsRUFJekIsQ0FBQy9DLEtBQUQsRUFBUSxFQUFDK0MsUUFBUSxLQUFULEVBQVIsQ0FKeUIsRUFLekIsQ0FBQ25ELEtBQUQsRUFBUSxFQUFDbUQsUUFBUSxLQUFULEVBQVIsQ0FMeUIsRUFNekIsQ0FBQ3BELEdBQUQsRUFBTSxFQUFDc0QsT0FBTyxXQUFSLEVBQXFCQyxNQUFNLENBQTNCLEVBQThCSCxRQUFRLEtBQXRDLEVBQU4sQ0FOeUIsRUFPekIsQ0FBQ3BELEdBQUQsRUFBTSxFQUFDb0QsUUFBUSxLQUFULEVBQU4sQ0FQeUIsQ0FBcEI7O0FBVVA7Ozs7O0FBS0EsT0FBTyxJQUFNSSx3QkFBd0I7QUFDbkNuQyxTQUFPO0FBRDRCLENBQTlCIiwiZmlsZSI6ImNvbnN0YW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFRhcCxcbiAgUHJlc3MsXG4gIFBpbmNoLFxuICBSb3RhdGUsXG4gIFBhbixcbiAgU3dpcGVcbn0gZnJvbSAnaGFtbWVyanMnO1xuXG4vKipcbiAqIE9ubHkgb25lIHNldCBvZiBiYXNpYyBpbnB1dCBldmVudHMgd2lsbCBiZSBmaXJlZCBieSBIYW1tZXIuanM6XG4gKiBlaXRoZXIgcG9pbnRlciwgdG91Y2gsIG9yIG1vdXNlLCBkZXBlbmRpbmcgb24gc3lzdGVtIHN1cHBvcnQuXG4gKiBJbiBvcmRlciB0byBlbmFibGUgYW4gYXBwbGljYXRpb24gdG8gYmUgYWdub3N0aWMgb2Ygc3lzdGVtIHN1cHBvcnQsXG4gKiBhbGlhcyBiYXNpYyBpbnB1dCBldmVudHMgaW50byBcImNsYXNzZXNcIiBvZiBldmVudHM6IGRvd24sIG1vdmUsIGFuZCB1cC5cbiAqIFNlZSBgX29uQmFzaWNJbnB1dCgpYCBmb3IgdXNhZ2Ugb2YgdGhlc2UgYWxpYXNlcy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBjb25zdCBCQVNJQ19FVkVOVF9DTEFTU0VTID0ge1xuICBkb3duOiBbJ3BvaW50ZXJkb3duJywgJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10sXG4gIG1vdmU6IFsncG9pbnRlcm1vdmUnLCAndG91Y2htb3ZlJywgICdtb3VzZW1vdmUnXSxcbiAgdXA6ICAgWydwb2ludGVydXAnLCAgICd0b3VjaGVuZCcsICAgJ21vdXNldXAnXVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuZXhwb3J0IGNvbnN0IEJBU0lDX0VWRU5UX0FMSUFTRVMgPSB7XG4gIHBvaW50ZXJkb3duOiBCQVNJQ19FVkVOVF9DTEFTU0VTLmRvd24sXG4gIHBvaW50ZXJtb3ZlOiBCQVNJQ19FVkVOVF9DTEFTU0VTLm1vdmUsXG4gIHBvaW50ZXJ1cDogQkFTSUNfRVZFTlRfQ0xBU1NFUy51cCxcbiAgdG91Y2hzdGFydDogQkFTSUNfRVZFTlRfQ0xBU1NFUy5kb3duLFxuICB0b3VjaG1vdmU6IEJBU0lDX0VWRU5UX0NMQVNTRVMubW92ZSxcbiAgdG91Y2hlbmQ6IEJBU0lDX0VWRU5UX0NMQVNTRVMudXAsXG4gIG1vdXNlZG93bjogQkFTSUNfRVZFTlRfQ0xBU1NFUy5kb3duLFxuICBtb3VzZW1vdmU6IEJBU0lDX0VWRU5UX0NMQVNTRVMubW92ZSxcbiAgbW91c2V1cDogQkFTSUNfRVZFTlRfQ0xBU1NFUy51cFxufTtcblxuLyoqXG4gKiBcIkdlc3R1cmFsXCIgZXZlbnRzIGFyZSB0aG9zZSB0aGF0IGhhdmUgc2VtYW50aWMgbWVhbmluZyBiZXlvbmQgdGhlIGJhc2ljIGlucHV0IGV2ZW50LFxuICogZS5nLiBhIGNsaWNrIG9yIHRhcCBpcyBhIHNlcXVlbmNlIG9mIGBkb3duYCBhbmQgYHVwYCBldmVudHMgd2l0aCBubyBgbW92ZWAgZXZlbnQgaW4gYmV0d2Vlbi5cbiAqIEhhbW1lci5qcyBoYW5kbGVzIHRoZXNlIHdpdGggaXRzIFJlY29nbml6ZXIgc3lzdGVtO1xuICogdGhpcyBibG9jayBtYXBzIGV2ZW50IG5hbWVzIHRvIHRoZSBSZWNvZ25pemVycyByZXF1aXJlZCB0byBkZXRlY3QgdGhlIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IEVWRU5UX1JFQ09HTklaRVJfTUFQID0ge1xuICBjbGljazogJ3RhcCcsXG4gIHRhcDogJ3RhcCcsXG4gIGRvdWJsZXRhcDogJ2RvdWJsZXRhcCcsXG4gIHByZXNzOiAncHJlc3MnLFxuICBwaW5jaDogJ3BpbmNoJyxcbiAgcGluY2hpbjogJ3BpbmNoJyxcbiAgcGluY2hvdXQ6ICdwaW5jaCcsXG4gIHBpbmNoc3RhcnQ6ICdwaW5jaCcsXG4gIHBpbmNobW92ZTogJ3BpbmNoJyxcbiAgcGluY2hlbmQ6ICdwaW5jaCcsXG4gIHBpbmNoY2FuY2VsOiAncGluY2gnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByb3RhdGVzdGFydDogJ3JvdGF0ZScsXG4gIHJvdGF0ZW1vdmU6ICdyb3RhdGUnLFxuICByb3RhdGVlbmQ6ICdyb3RhdGUnLFxuICByb3RhdGVjYW5jZWw6ICdyb3RhdGUnLFxuICBwYW46ICdwYW4nLFxuICBwYW5zdGFydDogJ3BhbicsXG4gIHBhbm1vdmU6ICdwYW4nLFxuICBwYW51cDogJ3BhbicsXG4gIHBhbmRvd246ICdwYW4nLFxuICBwYW5sZWZ0OiAncGFuJyxcbiAgcGFucmlnaHQ6ICdwYW4nLFxuICBwYW5lbmQ6ICdwYW4nLFxuICBwYW5jYW5jZWw6ICdwYW4nLFxuICBzd2lwZTogJ3N3aXBlJyxcbiAgc3dpcGVsZWZ0OiAnc3dpcGUnLFxuICBzd2lwZXJpZ2h0OiAnc3dpcGUnLFxuICBzd2lwZXVwOiAnc3dpcGUnLFxuICBzd2lwZWRvd246ICdzd2lwZSdcbn07XG5cbmV4cG9ydCBjb25zdCBSRUNPR05JWkVSUyA9IFtcbiAgW1JvdGF0ZSwge2VuYWJsZTogZmFsc2V9XSxcbiAgW1BpbmNoLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICBbUGFuLCB7dGhyZXNob2xkOiAxMCwgZW5hYmxlOiBmYWxzZX1dLFxuICBbU3dpcGUsIHtlbmFibGU6IGZhbHNlfV0sXG4gIFtQcmVzcywge2VuYWJsZTogZmFsc2V9XSxcbiAgW1RhcCwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMiwgZW5hYmxlOiBmYWxzZX1dLFxuICBbVGFwLCB7ZW5hYmxlOiBmYWxzZX1dXG5dO1xuXG4vKipcbiAqIE1hcCBnZXN0dXJhbCBldmVudHMgdHlwaWNhbGx5IHByb3ZpZGVkIGJ5IGJyb3dzZXJzXG4gKiB0aGF0IGFyZSBub3QgcmVwb3J0ZWQgaW4gJ2hhbW1lci5pbnB1dCcgZXZlbnRzXG4gKiB0byBjb3JyZXNwb25kaW5nIEhhbW1lci5qcyBnZXN0dXJlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEdFU1RVUkVfRVZFTlRfQUxJQVNFUyA9IHtcbiAgY2xpY2s6ICd0YXAnXG59O1xuIl19

/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wheel_input__ = __webpack_require__(210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__move_input__ = __webpack_require__(209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__controllers_globals__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__controllers_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__controllers_globals__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





// Hammer.js directly references `document` and `window`,
// which means that importing it in environments without
// those objects throws errors. Therefore, instead of
// directly `import`ing 'hammerjs' and './constants'
// (which imports Hammer.js) we conditionally require it
// depending on support for those globals.
function ManagerMock(m) {
  var noop = function noop() {};
  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop
  };
}

var Manager = __WEBPACK_IMPORTED_MODULE_2__controllers_globals__["isBrowser"] ? __webpack_require__(89).Manager : ManagerMock;

var _ref = __WEBPACK_IMPORTED_MODULE_2__controllers_globals__["isBrowser"] ? __webpack_require__(207) : {},
    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,
    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,
    RECOGNIZERS = _ref.RECOGNIZERS,
    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;

/**
 * Single API for subscribing to events about both
 * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
 * and gestural input (e.g. 'click', 'tap', 'panstart').
 * Delegates event registration and handling to Hammer.js.
 * @param {DOM Element} element         DOM element on which event handlers will be registered.
 * @param {Object} options              Options for instantiation
 * @param {Object} options.events       Map of {event name: handler} to register on init.
 * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register.
 *                                      Not yet implemented.
 */


var EventManager = function () {
  function EventManager(element, options) {
    _classCallCheck(this, EventManager);

    // TODO: support overriding default RECOGNIZERS by passing
    // recognizers / configs, keyed to event name.

    this._onBasicInput = this._onBasicInput.bind(this);
    this.manager = new Manager(element, { recognizers: RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.aliasedEventHandlers = {};

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new __WEBPACK_IMPORTED_MODULE_0__wheel_input__["a" /* default */](element, this._onOtherEvent);
    this.moveInput = new __WEBPACK_IMPORTED_MODULE_1__move_input__["a" /* default */](element, this._onOtherEvent);

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  _createClass(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.manager.destroy();
    }

    /**
     * Register an event handler function to be called on `event`.
     * @param {string|Object} event   An event name (String) or map of event names to handlers.
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'on',
    value: function on(event, handler) {
      if (typeof event === 'string') {
        // Special handling for gestural events.
        var recognizerEvent = EVENT_RECOGNIZER_MAP[event];
        if (recognizerEvent) {
          // Enable recognizer for this event.
          this.manager.get(recognizerEvent).set({ enable: true });

          // Alias to a recognized gesture as necessary.
          var eventAlias = GESTURE_EVENT_ALIASES[event];
          if (eventAlias && !this.aliasedEventHandlers[event]) {
            var aliasedEventHandler = this._aliasEventHandler(event);
            this.manager.on(eventAlias, aliasedEventHandler);
            // TODO: multiple handlers for the same aliased event will override one another.
            // This should be an array of aliased handlers instead.
            this.aliasedEventHandlers[event] = aliasedEventHandler;
          }
        }

        // Register event handler.
        this.manager.on(event, handler);
      } else {
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this.on(eventName, event[eventName]);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        // Clean up aliased gesture handler as necessary.
        var recognizerEvent = EVENT_RECOGNIZER_MAP[event];
        if (recognizerEvent) {
          var eventAlias = GESTURE_EVENT_ALIASES[event];
          if (eventAlias && this.aliasedEventHandlers[event]) {
            this.manager.off(eventAlias, this.aliasedEventHandlers[event]);
            delete this.aliasedEventHandlers[event];
          }
        }

        // Deregister event handler.
        this.manager.off(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this.off(eventName, event[eventName]);
        }
      }
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var _this = this;

      var srcEvent = event.srcEvent;

      var eventAliases = BASIC_EVENT_ALIASES[srcEvent.type];
      if (eventAliases) {
        // fire all events aliased to srcEvent.type
        eventAliases.forEach(function (alias) {
          var emitEvent = Object.assign({}, event, { type: alias });
          _this.manager.emit(alias, emitEvent);
        });
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      var type = event.srcEvent.type;

      this.manager.emit(type, event);
    }

    /**
     * Alias one event name to another,
     * to support events supported by Hammer.js under a different name.
     * See constants.GESTURE_EVENT_ALIASES.
     */

  }, {
    key: '_aliasEventHandler',
    value: function _aliasEventHandler(eventAlias) {
      var _this2 = this;

      return function (event) {
        return _this2.manager.emit(eventAlias, event);
      };
    }
  }]);

  return EventManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (EventManager);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvZXZlbnQtbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJXaGVlbElucHV0IiwiTW92ZUlucHV0IiwiaXNCcm93c2VyIiwiTWFuYWdlck1vY2siLCJtIiwibm9vcCIsIm9uIiwib2ZmIiwiZGVzdHJveSIsImVtaXQiLCJNYW5hZ2VyIiwicmVxdWlyZSIsIkJBU0lDX0VWRU5UX0FMSUFTRVMiLCJFVkVOVF9SRUNPR05JWkVSX01BUCIsIlJFQ09HTklaRVJTIiwiR0VTVFVSRV9FVkVOVF9BTElBU0VTIiwiRXZlbnRNYW5hZ2VyIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJfb25CYXNpY0lucHV0IiwiYmluZCIsIm1hbmFnZXIiLCJyZWNvZ25pemVycyIsImFsaWFzZWRFdmVudEhhbmRsZXJzIiwiX29uT3RoZXJFdmVudCIsIndoZWVsSW5wdXQiLCJtb3ZlSW5wdXQiLCJldmVudHMiLCJldmVudCIsImhhbmRsZXIiLCJyZWNvZ25pemVyRXZlbnQiLCJnZXQiLCJzZXQiLCJlbmFibGUiLCJldmVudEFsaWFzIiwiYWxpYXNlZEV2ZW50SGFuZGxlciIsIl9hbGlhc0V2ZW50SGFuZGxlciIsImV2ZW50TmFtZSIsInNyY0V2ZW50IiwiZXZlbnRBbGlhc2VzIiwidHlwZSIsImZvckVhY2giLCJlbWl0RXZlbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJhbGlhcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU9BLFVBQVAsTUFBdUIsZUFBdkI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLGNBQXRCO0FBQ0EsU0FBUUMsU0FBUixRQUF3QiwyQkFBeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsV0FBVCxDQUFxQkMsQ0FBckIsRUFBd0I7QUFDdEIsTUFBTUMsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjtBQUNBLFNBQU87QUFDTEMsUUFBSUQsSUFEQztBQUVMRSxTQUFLRixJQUZBO0FBR0xHLGFBQVNI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QUFPO0FBQUEsZUFBUyxPQUFLYixPQUFMLENBQWFaLElBQWIsQ0FBa0J5QixVQUFsQixFQUE4Qk4sS0FBOUIsQ0FBVDtBQUFBLE9BQVA7QUFDRDs7Ozs7O2VBL0hrQlosWSIsImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdoZWVsSW5wdXQgZnJvbSAnLi93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vbW92ZS1pbnB1dCc7XG5pbXBvcnQge2lzQnJvd3Nlcn0gZnJvbSAnLi4vLi4vY29udHJvbGxlcnMvZ2xvYmFscyc7XG5cbi8vIEhhbW1lci5qcyBkaXJlY3RseSByZWZlcmVuY2VzIGBkb2N1bWVudGAgYW5kIGB3aW5kb3dgLFxuLy8gd2hpY2ggbWVhbnMgdGhhdCBpbXBvcnRpbmcgaXQgaW4gZW52aXJvbm1lbnRzIHdpdGhvdXRcbi8vIHRob3NlIG9iamVjdHMgdGhyb3dzIGVycm9ycy4gVGhlcmVmb3JlLCBpbnN0ZWFkIG9mXG4vLyBkaXJlY3RseSBgaW1wb3J0YGluZyAnaGFtbWVyanMnIGFuZCAnLi9jb25zdGFudHMnXG4vLyAod2hpY2ggaW1wb3J0cyBIYW1tZXIuanMpIHdlIGNvbmRpdGlvbmFsbHkgcmVxdWlyZSBpdFxuLy8gZGVwZW5kaW5nIG9uIHN1cHBvcnQgZm9yIHRob3NlIGdsb2JhbHMuXG5mdW5jdGlvbiBNYW5hZ2VyTW9jayhtKSB7XG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgcmV0dXJuIHtcbiAgICBvbjogbm9vcCxcbiAgICBvZmY6IG5vb3AsXG4gICAgZGVzdHJveTogbm9vcCxcbiAgICBlbWl0OiBub29wXG4gIH07XG59XG5cbmNvbnN0IE1hbmFnZXIgPSBpc0Jyb3dzZXIgPyByZXF1aXJlKCdoYW1tZXJqcycpLk1hbmFnZXIgOiBNYW5hZ2VyTW9jaztcbmNvbnN0IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUyxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVAsXG4gIFJFQ09HTklaRVJTLFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVNcbn0gPSBpc0Jyb3dzZXIgPyByZXF1aXJlKCcuL2NvbnN0YW50cycpIDoge307XG5cbi8qKlxuICogU2luZ2xlIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gZXZlbnRzIGFib3V0IGJvdGhcbiAqIGJhc2ljIGlucHV0IGV2ZW50cyAoZS5nLiAnbW91c2Vtb3ZlJywgJ3RvdWNoc3RhcnQnLCAnd2hlZWwnKVxuICogYW5kIGdlc3R1cmFsIGlucHV0IChlLmcuICdjbGljaycsICd0YXAnLCAncGFuc3RhcnQnKS5cbiAqIERlbGVnYXRlcyBldmVudCByZWdpc3RyYXRpb24gYW5kIGhhbmRsaW5nIHRvIEhhbW1lci5qcy5cbiAqIEBwYXJhbSB7RE9NIEVsZW1lbnR9IGVsZW1lbnQgICAgICAgICBET00gZWxlbWVudCBvbiB3aGljaCBldmVudCBoYW5kbGVycyB3aWxsIGJlIHJlZ2lzdGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgaW5zdGFudGlhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXZlbnRzICAgICAgIE1hcCBvZiB7ZXZlbnQgbmFtZTogaGFuZGxlcn0gdG8gcmVnaXN0ZXIgb24gaW5pdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnJlY29nbml6ZXJzICBHZXN0dXJlIHJlY29nbml6ZXJzIGZyb20gSGFtbWVyLmpzIHRvIHJlZ2lzdGVyLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBzdXBwb3J0IG92ZXJyaWRpbmcgZGVmYXVsdCBSRUNPR05JWkVSUyBieSBwYXNzaW5nXG4gICAgLy8gcmVjb2duaXplcnMgLyBjb25maWdzLCBrZXllZCB0byBldmVudCBuYW1lLlxuXG4gICAgdGhpcy5fb25CYXNpY0lucHV0ID0gdGhpcy5fb25CYXNpY0lucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbmV3IE1hbmFnZXIoZWxlbWVudCwge3JlY29nbml6ZXJzOiBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICB0aGlzLmFsaWFzZWRFdmVudEhhbmRsZXJzID0ge307XG5cbiAgICAvLyBIYW5kbGUgZXZlbnRzIG5vdCBoYW5kbGVkIGJ5IEhhbW1lci5qczpcbiAgICAvLyAtIG1vdXNlIHdoZWVsXG4gICAgLy8gLSBwb2ludGVyL3RvdWNoL21vdXNlIG1vdmVcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLndoZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQpO1xuICAgIHRoaXMubW92ZUlucHV0ID0gbmV3IE1vdmVJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYWxsIHBhc3NlZCBldmVudHMuXG4gICAgY29uc3Qge2V2ZW50c30gPSBvcHRpb25zO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIHRoaXMub24oZXZlbnRzKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBldmVudCAgIEFuIGV2ZW50IG5hbWUgKFN0cmluZykgb3IgbWFwIG9mIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgZ2VzdHVyYWwgZXZlbnRzLlxuICAgICAgY29uc3QgcmVjb2duaXplckV2ZW50ID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRdO1xuICAgICAgaWYgKHJlY29nbml6ZXJFdmVudCkge1xuICAgICAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmdldChyZWNvZ25pemVyRXZlbnQpLnNldCh7ZW5hYmxlOiB0cnVlfSk7XG5cbiAgICAgICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgICAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XTtcbiAgICAgICAgaWYgKGV2ZW50QWxpYXMgJiYgIXRoaXMuYWxpYXNlZEV2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgY29uc3QgYWxpYXNlZEV2ZW50SGFuZGxlciA9IHRoaXMuX2FsaWFzRXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB0aGlzLm1hbmFnZXIub24oZXZlbnRBbGlhcywgYWxpYXNlZEV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgLy8gVE9ETzogbXVsdGlwbGUgaGFuZGxlcnMgZm9yIHRoZSBzYW1lIGFsaWFzZWQgZXZlbnQgd2lsbCBvdmVycmlkZSBvbmUgYW5vdGhlci5cbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBhbGlhc2VkIGhhbmRsZXJzIGluc3RlYWQuXG4gICAgICAgICAgdGhpcy5hbGlhc2VkRXZlbnRIYW5kbGVyc1tldmVudF0gPSBhbGlhc2VkRXZlbnRIYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXIuXG4gICAgICB0aGlzLm1hbmFnZXIub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHByZXZpb3VzbHktcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDbGVhbiB1cCBhbGlhc2VkIGdlc3R1cmUgaGFuZGxlciBhcyBuZWNlc3NhcnkuXG4gICAgICBjb25zdCByZWNvZ25pemVyRXZlbnQgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudF07XG4gICAgICBpZiAocmVjb2duaXplckV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdO1xuICAgICAgICBpZiAoZXZlbnRBbGlhcyAmJiB0aGlzLmFsaWFzZWRFdmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIHRoaXMubWFuYWdlci5vZmYoZXZlbnRBbGlhcywgdGhpcy5hbGlhc2VkRXZlbnRIYW5kbGVyc1tldmVudF0pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFsaWFzZWRFdmVudEhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZXJlZ2lzdGVyIGV2ZW50IGhhbmRsZXIuXG4gICAgICB0aGlzLm1hbmFnZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb2ZmKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgZXZlbnRBbGlhc2VzID0gQkFTSUNfRVZFTlRfQUxJQVNFU1tzcmNFdmVudC50eXBlXTtcbiAgICBpZiAoZXZlbnRBbGlhc2VzKSB7XG4gICAgICAvLyBmaXJlIGFsbCBldmVudHMgYWxpYXNlZCB0byBzcmNFdmVudC50eXBlXG4gICAgICBldmVudEFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgIGNvbnN0IGVtaXRFdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7dHlwZTogYWxpYXN9KTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGVtaXRFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAqL1xuICBfb25PdGhlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge3NyY0V2ZW50OiB7dHlwZX19ID0gZXZlbnQ7XG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQodHlwZSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIG9uZSBldmVudCBuYW1lIHRvIGFub3RoZXIsXG4gICAqIHRvIHN1cHBvcnQgZXZlbnRzIHN1cHBvcnRlZCBieSBIYW1tZXIuanMgdW5kZXIgYSBkaWZmZXJlbnQgbmFtZS5cbiAgICogU2VlIGNvbnN0YW50cy5HRVNUVVJFX0VWRU5UX0FMSUFTRVMuXG4gICAqL1xuICBfYWxpYXNFdmVudEhhbmRsZXIoZXZlbnRBbGlhcykge1xuICAgIHJldHVybiBldmVudCA9PiB0aGlzLm1hbmFnZXIuZW1pdChldmVudEFsaWFzLCBldmVudCk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOVE_EVENTS = ['pointermove', 'touchmove', 'mousemove'];

/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MOVE_EVENTS;

    _classCallCheck(this, MoveInput);

    this.element = element;
    this.callback = callback;
    this.events = events;

    this.handler = this.handler.bind(this);
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handler);
    });
  }

  _createClass(MoveInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handler);
      });
    }
  }, {
    key: 'handler',
    value: function handler(event) {
      this.callback({
        srcEvent: event,
        target: this.element
      });
    }
  }]);

  return MoveInput;
}();

/* harmony default export */ __webpack_exports__["a"] = (MoveInput);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvbW92ZS1pbnB1dC5qcyJdLCJuYW1lcyI6WyJNT1ZFX0VWRU5UUyIsIk1vdmVJbnB1dCIsImVsZW1lbnQiLCJjYWxsYmFjayIsImV2ZW50cyIsImhhbmRsZXIiLCJiaW5kIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzcmNFdmVudCIsInRhcmdldCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQU1BLGNBQWMsQ0FBQyxhQUFELEVBQWdCLFdBQWhCLEVBQTZCLFdBQTdCLENBQXBCOztBQUVBOzs7Ozs7Ozs7SUFRcUJDLFM7QUFFbkIscUJBQVlDLE9BQVosRUFBcUJDLFFBQXJCLEVBQXFEO0FBQUE7O0FBQUEsUUFBdEJDLE1BQXNCLHVFQUFiSixXQUFhOztBQUFBOztBQUNuRCxTQUFLRSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLE1BQUwsR0FBY0EsTUFBZDs7QUFFQSxTQUFLQyxPQUFMLEdBQWUsS0FBS0EsT0FBTCxDQUFhQyxJQUFiLENBQWtCLElBQWxCLENBQWY7QUFDQSxTQUFLRixNQUFMLENBQVlHLE9BQVosQ0FBb0I7QUFBQSxhQUFTTCxRQUFRTSxnQkFBUixDQUF5QkMsS0FBekIsRUFBZ0MsTUFBS0osT0FBckMsQ0FBVDtBQUFBLEtBQXBCO0FBQ0Q7Ozs7OEJBRVM7QUFBQTs7QUFDUixXQUFLRCxNQUFMLENBQVlHLE9BQVosQ0FBb0I7QUFBQSxlQUFTLE9BQUtMLE9BQUwsQ0FBYVEsbUJBQWIsQ0FBaUNELEtBQWpDLEVBQXdDLE9BQUtKLE9BQTdDLENBQVQ7QUFBQSxPQUFwQjtBQUNEOzs7NEJBRU9JLEssRUFBTztBQUNiLFdBQUtOLFFBQUwsQ0FBYztBQUNaUSxrQkFBVUYsS0FERTtBQUVaRyxnQkFBUSxLQUFLVjtBQUZELE9BQWQ7QUFJRDs7Ozs7O2VBcEJrQkQsUyIsImZpbGUiOiJtb3ZlLWlucHV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTU9WRV9FVkVOVFMgPSBbJ3BvaW50ZXJtb3ZlJywgJ3RvdWNobW92ZScsICdtb3VzZW1vdmUnXTtcblxuLyoqXG4gKiBIYW1tZXIuanMgc3dhbGxvd3MgJ21vdmUnIGV2ZW50cyAoZm9yIHBvaW50ZXIvdG91Y2gvbW91c2UpXG4gKiB3aGVuIHRoZSBwb2ludGVyIGlzIG5vdCBkb3duLiBUaGlzIGNsYXNzIHNldHMgdXAgYSBoYW5kbGVyXG4gKiBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIGV2ZW50cyB0byB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3VsZCBiZSBleHRlbmRlZCB0byBtb3JlIGludGVsbGlnZW50bHkgaGFuZGxlXG4gKiBtb3ZlIGV2ZW50cyBhY3Jvc3MgaW5wdXQgdHlwZXMsIGUuZy4gc3RvcmluZyBtdWx0aXBsZSBzaW11bHRhbmVvdXNcbiAqIHBvaW50ZXIvdG91Y2ggZXZlbnRzLCBjYWxjdWxhdGluZyBzcGVlZC9kaXJlY3Rpb24sIGV0Yy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92ZUlucHV0IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgZXZlbnRzID0gTU9WRV9FVkVOVFMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcblxuICAgIHRoaXMuaGFuZGxlciA9IHRoaXMuaGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXIpKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVyKSk7XG4gIH1cblxuICBoYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICB0YXJnZXQ6IHRoaXMuZWxlbWVudFxuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__lib_utils_globals__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var ua = typeof __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.navigator !== 'undefined' ? __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

var WHEEL_EVENTS = [
// Chrome, Safari
'wheel',
// IE
'mousewheel',
// legacy Firefox
'DOMMouseScroll'];

// Constants for normalizing input delta
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var TRACKPAD_MAX_DELTA = 4;
var TRACKPAD_MAX_DELTA_PER_TIME = 200;
// Slow down zoom if shift key is held for more precise zooming
var SHIFT_MULTIPLIER = 0.25;

var WheelInput = function () {
  function WheelInput(element, callback) {
    var _this = this;

    _classCallCheck(this, WheelInput);

    this.element = element;
    this.callback = callback;

    this.handler = this.handler.bind(this);

    WHEEL_EVENTS.forEach(function (eventName) {
      return element.addEventListener(eventName, _this.handler);
    });

    this.time = 0;
    this.wheelPosition = null;
    this.type = null;
    this.timeout = null;
    this.lastValue = 0;
  }

  _createClass(WheelInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      var element = this.element;

      WHEEL_EVENTS.forEach(function (eventName) {
        return element.removeEventListener(eventName, _this2.handler);
      });
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: 'handler',
    value: function handler(event) {

      event.preventDefault();
      var value = event.deltaY;
      // Firefox doubles the values on retina screens...
      if (firefox && event.deltaMode === __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.WheelEvent.DOM_DELTA_PIXEL) {
        value /= __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.devicePixelRatio;
      }
      if (event.deltaMode === __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.WheelEvent.DOM_DELTA_LINE) {
        value *= WHEEL_DELTA_PER_LINE;
      }

      var type = this.type,
          timeout = this.timeout,
          lastValue = this.lastValue,
          time = this.time;


      var now = (__WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.performance || Date).now();
      var timeDelta = now - (time || 0);

      this.wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };
      time = now;

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event,
        // and delay it by up to 40ms.
        timeout = __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.setTimeout(function setTimeout() {
          this._onWheel(event, -lastValue, this.wheelPosition);
          type = 'wheel';
        }.bind(this), 40);
      } else if (!type) {
        // This is a repeating event, but we don't know the type of event just yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          __WEBPACK_IMPORTED_MODULE_0__lib_utils_globals___default.a.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      // Only fire the callback if we actually know
      // what type of scrolling device the user uses.
      if (type) {
        this._onWheel(event, -value, this.wheelPosition);
      }
    }
  }, {
    key: '_onWheel',
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        target: this.element
      });
    }
  }]);

  return WheelInput;
}();

/* harmony default export */ __webpack_exports__["a"] = (WheelInput);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvd2hlZWwtaW5wdXQuanMiXSwibmFtZXMiOlsid2luZG93IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsImZpcmVmb3giLCJpbmRleE9mIiwiV0hFRUxfRVZFTlRTIiwiV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSIiwiV0hFRUxfREVMVEFfUEVSX0xJTkUiLCJUUkFDS1BBRF9NQVhfREVMVEEiLCJUUkFDS1BBRF9NQVhfREVMVEFfUEVSX1RJTUUiLCJTSElGVF9NVUxUSVBMSUVSIiwiV2hlZWxJbnB1dCIsImVsZW1lbnQiLCJjYWxsYmFjayIsImhhbmRsZXIiLCJiaW5kIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJ0aW1lIiwid2hlZWxQb3NpdGlvbiIsInR5cGUiLCJ0aW1lb3V0IiwibGFzdFZhbHVlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJ2YWx1ZSIsImRlbHRhWSIsImRlbHRhTW9kZSIsIldoZWVsRXZlbnQiLCJET01fREVMVEFfUElYRUwiLCJkZXZpY2VQaXhlbFJhdGlvIiwiRE9NX0RFTFRBX0xJTkUiLCJub3ciLCJwZXJmb3JtYW5jZSIsIkRhdGUiLCJ0aW1lRGVsdGEiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwiTWF0aCIsImZsb29yIiwiYWJzIiwic2V0VGltZW91dCIsIl9vbldoZWVsIiwiY2xlYXJUaW1lb3V0Iiwic2hpZnRLZXkiLCJzcmNFdmVudCIsImRlbHRhIiwicG9zaXRpb24iLCJjZW50ZXIiLCJ0YXJnZXQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPQSxNQUFQLE1BQW1CLHlCQUFuQjs7QUFFQSxJQUFNQyxLQUFLLE9BQU9ELE9BQU9FLFNBQWQsS0FBNEIsV0FBNUIsR0FDVEYsT0FBT0UsU0FBUCxDQUFpQkMsU0FBakIsQ0FBMkJDLFdBQTNCLEVBRFMsR0FD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LGtCQUFVeEIsT0FBTytDLFVBQVAsQ0FBa0IsU0FBU0EsVUFBVCxHQUFzQjtBQUNoRCxlQUFLQyxRQUFMLENBQWNyQixLQUFkLEVBQXFCLENBQUNGLFNBQXRCLEVBQWlDLEtBQUtILGFBQXRDO0FBQ0FDLGlCQUFPLE9BQVA7QUFDRCxTQUgyQixDQUcxQk4sSUFIMEIsQ0FHckIsSUFIcUIsQ0FBbEIsRUFHSSxFQUhKLENBQVY7QUFJRCxPQVZNLE1BVUEsSUFBSSxDQUFDTSxJQUFMLEVBQVc7QUFDaEI7QUFDQTtBQUNBO0FBQ0FBLGVBQU9xQixLQUFLRSxHQUFMLENBQVNQLFlBQVlWLEtBQXJCLElBQThCbEIsMkJBQTlCLEdBQTRELFVBQTVELEdBQXlFLE9BQWhGOztBQUVBO0FBQ0E7QUFDQSxZQUFJYSxPQUFKLEVBQWE7QUFDWHhCLGlCQUFPaUQsWUFBUCxDQUFvQnpCLE9BQXBCO0FBQ0FBLG9CQUFVLElBQVY7QUFDQUssbUJBQVNKLFNBQVQ7QUFDRDtBQUNGOztBQUVELFVBQUlFLE1BQU11QixRQUFOLElBQWtCckIsS0FBdEIsRUFBNkI7QUFDM0JBLGdCQUFRQSxRQUFRakIsZ0JBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUlXLElBQUosRUFBVTtBQUNSLGFBQUt5QixRQUFMLENBQWNyQixLQUFkLEVBQXFCLENBQUNFLEtBQXRCLEVBQTZCLEtBQUtQLGFBQWxDO0FBQ0Q7QUFDRjs7OzZCQUVRNkIsUSxFQUFVQyxLLEVBQU9DLFEsRUFBVTtBQUNsQyxXQUFLdEMsUUFBTCxDQUFjO0FBQ1p1QyxnQkFBUUQsUUFESTtBQUVaRCxvQkFGWTtBQUdaRCwwQkFIWTtBQUlaSSxnQkFBUSxLQUFLekM7QUFKRCxPQUFkO0FBTUQ7Ozs7OztlQXRHa0JELFUiLCJmaWxlIjoid2hlZWwtaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgd2luZG93IGZyb20gJy4uLy4uL2xpYi91dGlscy9nbG9iYWxzJztcblxuY29uc3QgdWEgPSB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgP1xuICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG5jb25zdCBmaXJlZm94ID0gdWEuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcblxuY29uc3QgV0hFRUxfRVZFTlRTID0gW1xuICAvLyBDaHJvbWUsIFNhZmFyaVxuICAnd2hlZWwnLFxuICAvLyBJRVxuICAnbW91c2V3aGVlbCcsXG4gIC8vIGxlZ2FjeSBGaXJlZm94XG4gICdET01Nb3VzZVNjcm9sbCdcbl07XG5cbi8vIENvbnN0YW50cyBmb3Igbm9ybWFsaXppbmcgaW5wdXQgZGVsdGFcbmNvbnN0IFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiA9IDQuMDAwMjQ0MTQwNjI1O1xuY29uc3QgV0hFRUxfREVMVEFfUEVSX0xJTkUgPSA0MDtcbmNvbnN0IFRSQUNLUEFEX01BWF9ERUxUQSA9IDQ7XG5jb25zdCBUUkFDS1BBRF9NQVhfREVMVEFfUEVSX1RJTUUgPSAyMDA7XG4vLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbmNvbnN0IFNISUZUX01VTFRJUExJRVIgPSAwLjI1O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaGVlbElucHV0IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5oYW5kbGVyID0gdGhpcy5oYW5kbGVyLmJpbmQodGhpcyk7XG5cbiAgICBXSEVFTF9FVkVOVFMuZm9yRWFjaChldmVudE5hbWUgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVyKSk7XG5cbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMud2hlZWxQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMubGFzdFZhbHVlID0gMDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qge2VsZW1lbnR9ID0gdGhpcztcbiAgICBXSEVFTF9FVkVOVFMuZm9yRWFjaChldmVudE5hbWUgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVyKSk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBoYW5kbGVyKGV2ZW50KSB7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCB2YWx1ZSA9IGV2ZW50LmRlbHRhWTtcbiAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxuICAgIGlmIChmaXJlZm94ICYmIGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICB2YWx1ZSAvPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgIHZhbHVlICo9IFdIRUVMX0RFTFRBX1BFUl9MSU5FO1xuICAgIH1cblxuICAgIGxldCB7XG4gICAgICB0eXBlLFxuICAgICAgdGltZW91dCxcbiAgICAgIGxhc3RWYWx1ZSxcbiAgICAgIHRpbWVcbiAgICB9ID0gdGhpcztcblxuICAgIGNvbnN0IG5vdyA9ICh3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG4gICAgY29uc3QgdGltZURlbHRhID0gbm93IC0gKHRpbWUgfHwgMCk7XG5cbiAgICB0aGlzLndoZWVsUG9zaXRpb24gPSB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgIH07XG4gICAgdGltZSA9IG5vdztcblxuICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAlIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiA9PT0gMCkge1xuICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAgdHlwZSA9ICd3aGVlbCc7XG4gICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gMCAmJiBNYXRoLmFicyh2YWx1ZSkgPCBUUkFDS1BBRF9NQVhfREVMVEEpIHtcbiAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSB0cmFja3BhZCBldmVudCBiZWNhdXNlIGl0IGlzIHNvIHNtYWxsLlxuICAgICAgdHlwZSA9ICd0cmFja3BhZCc7XG4gICAgfSBlbHNlIGlmICh0aW1lRGVsdGEgPiA0MDApIHtcbiAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgbmV3IHNjcm9sbCBhY3Rpb24uXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gU3RhcnQgYSB0aW1lb3V0IGluIGNhc2UgdGhpcyB3YXMgYSBzaW5ndWxhciBldmVudCxcbiAgICAgIC8vIGFuZCBkZWxheSBpdCBieSB1cCB0byA0MG1zLlxuICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIHRoaXMuX29uV2hlZWwoZXZlbnQsIC1sYXN0VmFsdWUsIHRoaXMud2hlZWxQb3NpdGlvbik7XG4gICAgICAgIHR5cGUgPSAnd2hlZWwnO1xuICAgICAgfS5iaW5kKHRoaXMpLCA0MCk7XG4gICAgfSBlbHNlIGlmICghdHlwZSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHJlcGVhdGluZyBldmVudCwgYnV0IHdlIGRvbid0IGtub3cgdGhlIHR5cGUgb2YgZXZlbnQganVzdCB5ZXQuXG4gICAgICAvLyBJZiB0aGUgZGVsdGEgcGVyIHRpbWUgaXMgc21hbGwsIHdlIGFzc3VtZSBpdCdzIGEgZmFzdCB0cmFja3BhZDtcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgdHlwZSA9IE1hdGguYWJzKHRpbWVEZWx0YSAqIHZhbHVlKSA8IFRSQUNLUEFEX01BWF9ERUxUQV9QRVJfVElNRSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFsdWUgKz0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAqIFNISUZUX01VTFRJUExJRVI7XG4gICAgfVxuXG4gICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93XG4gICAgLy8gd2hhdCB0eXBlIG9mIHNjcm9sbGluZyBkZXZpY2UgdGhlIHVzZXIgdXNlcy5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdGhpcy5fb25XaGVlbChldmVudCwgLXZhbHVlLCB0aGlzLndoZWVsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIF9vbldoZWVsKHNyY0V2ZW50LCBkZWx0YSwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICBkZWx0YSxcbiAgICAgIHNyY0V2ZW50LFxuICAgICAgdGFyZ2V0OiB0aGlzLmVsZW1lbnRcbiAgICB9KTtcbiAgfVxufVxuIl19

/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = {
	"_args": [
		[
			{
				"raw": "deck.gl",
				"scope": null,
				"escapedName": "deck.gl",
				"name": "deck.gl",
				"rawSpec": "",
				"spec": "latest",
				"type": "tag"
			},
			"D:\\tomcat7\\webapps\\echartsMapbox"
		]
	],
	"_from": "deck.gl@latest",
	"_id": "deck.gl@4.1.0-alpha.7",
	"_inCache": true,
	"_location": "/deck.gl",
	"_nodeVersion": "7.10.0",
	"_npmOperationalInternal": {
		"host": "s3://npm-registry-packages",
		"tmp": "tmp/deck.gl-4.1.0-alpha.7.tgz_1495661998512_0.24267960339784622"
	},
	"_npmUser": {
		"name": "apercu",
		"email": "bgronon@gmail.com"
	},
	"_npmVersion": "4.2.0",
	"_phantomChildren": {},
	"_requested": {
		"raw": "deck.gl",
		"scope": null,
		"escapedName": "deck.gl",
		"name": "deck.gl",
		"rawSpec": "",
		"spec": "latest",
		"type": "tag"
	},
	"_requiredBy": [
		"#USER",
		"/"
	],
	"_resolved": "https://registry.npmjs.org/deck.gl/-/deck.gl-4.1.0-alpha.7.tgz",
	"_shasum": "ecd5e6647d8ec0473fa9fc41b6d547e937726b7b",
	"_shrinkwrap": null,
	"_spec": "deck.gl",
	"_where": "D:\\tomcat7\\webapps\\echartsMapbox",
	"babel": {
		"presets": [
			[
				"es2015",
				{
					"modules": false
				}
			]
		],
		"env": {
			"test": {
				"plugins": [
					"istanbul"
				]
			}
		}
	},
	"bugs": {
		"url": "https://github.com/uber/deck.gl/issues"
	},
	"dependencies": {
		"d3-hexbin": "^0.2.1",
		"earcut": "^2.0.6",
		"gl-matrix": "^2.3.2",
		"hammerjs": "^2.0.8",
		"lodash.flattendeep": "^4.4.0",
		"prop-types": "^15.5.8",
		"seer": "^0.1.0"
	},
	"description": "A suite of 3D-enabled data visualization overlays, suitable for react-map-gl",
	"devDependencies": {
		"babel-cli": "^6.22.2",
		"babel-core": "^6.22.1",
		"babel-loader": "^6.2.10",
		"babel-plugin-istanbul": "^4.1.1",
		"babel-plugin-transform-es2015-modules-commonjs": "^6.22.0",
		"babel-polyfill": "^6.20.0",
		"babel-preset-es2015": "^6.4.3",
		"benchmark": "^2.1.3",
		"brfs-babel": "^1.0.0",
		"buble": "^0.15.1",
		"buble-loader": "^0.4.0",
		"colorbrewer": "^1.0.0",
		"coveralls": "^2.13.0",
		"eslint": "^3.0.0",
		"eslint-config-uber-es2015": "^3.0.0",
		"eslint-config-uber-jsx": "^3.0.0",
		"eslint-plugin-react": "~6.7.0",
		"faucet": "0.0.1",
		"file-loader": "^0.10.1",
		"gl": "^4.0.3",
		"immutable": "^3.8.1",
		"jsdom": "^9.11.0",
		"luma.gl": "4.0.0-alpha.5",
		"module-alias": "^2.0.0",
		"nyc": "^10.2.0",
		"path-exists-cli": "^1.0.0",
		"pre-commit": "^1.2.2",
		"raw-loader": "^0.5.1",
		"react": "^15.4.0",
		"react-addons-test-utils": "^15.4.2",
		"react-dom": "^15.4.0",
		"reify": "^0.4.4",
		"spy": "^1.0.0",
		"tap-browser-color": "^0.1.2",
		"tape": "^4.5.1",
		"tape-catch": "^1.0.4",
		"transform-loader": "^0.2.3",
		"uglify-js": "^2.6.1",
		"url-loader": "^0.5.7",
		"webpack": "^2.4.0",
		"webpack-dev-server": "^2.4.0"
	},
	"directories": {},
	"dist": {
		"shasum": "ecd5e6647d8ec0473fa9fc41b6d547e937726b7b",
		"tarball": "https://registry.npmjs.org/deck.gl/-/deck.gl-4.1.0-alpha.7.tgz"
	},
	"files": [
		"dist",
		"dist-es6",
		"src"
	],
	"gitHead": "a24e1b834d162680e6555b3bb0e7aaef5fb318a8",
	"homepage": "https://github.com/uber/deck.gl#readme",
	"keywords": [
		"webgl",
		"visualization",
		"overlay",
		"layer"
	],
	"license": "MIT",
	"main": "dist/index.js",
	"maintainers": [
		{
			"name": "apercu",
			"email": "bgronon@gmail.com"
		}
	],
	"module": "dist-es6/index.js",
	"name": "deck.gl",
	"nyc": {
		"sourceMap": false,
		"instrument": false,
		"include": [
			"src/**/*.js"
		],
		"exclude": [
			"test/**/*.js",
			"src/layers/deprecated"
		]
	},
	"optionalDependencies": {},
	"peerDependencies": {
		"luma.gl": ">=3.x",
		"react": "0.14.x - 15.x",
		"react-dom": "0.14.x - 15.x"
	},
	"readme": "ERROR: No README data found!",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/uber/deck.gl.git"
	},
	"scripts": {
		"bench": "node test/bench/node.js",
		"bench-browser": "webpack-dev-server --config webpack.config.bench-browser.js --progress --hot --open --port 3011",
		"build": "npm run build-clean && npm run build-es6 && npm run build-es5 && webpack -d --display-modules",
		"build-buble": "buble dist-es6 -o dist --no modules --y dangerousForOf --objectAssign",
		"build-clean": "rm -fr dist dist-es6 && mkdir -p dist dist-es6",
		"build-es5": "rm -fr dist && babel src --out-dir dist --plugins=static-fs,transform-es2015-modules-commonjs --source-maps inline",
		"build-es6": "rm -fr dist-es6 && babel src --out-dir dist-es6 --plugins=static-fs --source-maps inline",
		"cover": "NODE_ENV=test nyc --reporter html --reporter cobertura --reporter=lcov npm run test-cover",
		"lint": "eslint src test examples && npm run lint-yarn",
		"lint-yarn": "! grep -q unpm.u yarn.lock",
		"publish-beta": "npm run build && npm run test && npm run test-dist && npm publish --tag beta",
		"publish-prod": "npm run build && npm run test && npm run test-dist && npm publish",
		"start": "(cd examples/layer-browser && (path-exists node_modules || npm i) && npm run start-local)",
		"test": "npm run lint && npm run build && npm run test-node",
		"test-browser": "webpack-dev-server --config webpack.config.test-browser.js --progress --hot --open --port 3010",
		"test-cover": "NODE_ENV=test tape -r babel-register test/node.js && nyc report",
		"test-dist": "node test/node-dist.js",
		"test-fp64": "(cd test/fp64-test && webpack-dev-server --config webpack.config.test-fp64.js --progress --hot --open)",
		"test-node": "node test/node.js",
		"test-rendering": "(cd test/rendering-test && webpack-dev-server --config webpack.config.test-rendering.js --progress --hot --open)"
	},
	"version": "4.1.0-alpha.7"
};

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);
var mat3 = __webpack_require__(86);
var vec3 = __webpack_require__(87);
var vec4 = __webpack_require__(88);

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(15);

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return addModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return removeModel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_seer__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_seer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_seer__);


var models = {};

/**
 * Add a model to our cache indexed by id
 */
var addModel = function addModel(model) {
  if (models[model.id]) {
    return;
  }
  models[model.id] = model;
};

/**
 * Remove a previously set model from the cache
 */
var removeModel = function removeModel(id) {
  delete models[id];
};

/**
 * Recursively traverse an object given a path of properties and set the given value
 */
var recursiveSet = function recursiveSet(obj, path, value) {
  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

/**
 * Listen for luma.gl edit events
 */
__WEBPACK_IMPORTED_MODULE_0_seer___default.a.listenFor('luma.gl', function (payload) {
  var model = models[payload.itemKey];
  if (!model || payload.type !== 'edit') {
    return;
  }

  var uniforms = model.getUniforms();
  recursiveSet(uniforms, payload.valuePath, payload.value);
  model.setUniforms(uniforms);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWJ1Zy9zZWVyLWludGVncmF0aW9uLmpzIl0sIm5hbWVzIjpbInNlZXIiLCJtb2RlbHMiLCJhZGRNb2RlbCIsIm1vZGVsIiwiaWQiLCJyZW1vdmVNb2RlbCIsInJlY3Vyc2l2ZVNldCIsIm9iaiIsInBhdGgiLCJ2YWx1ZSIsImxlbmd0aCIsInNsaWNlIiwibGlzdGVuRm9yIiwicGF5bG9hZCIsIml0ZW1LZXkiLCJ0eXBlIiwidW5pZm9ybXMiLCJnZXRVbmlmb3JtcyIsInZhbHVlUGF0aCIsInNldFVuaWZvcm1zIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxJQUFQLE1BQWlCLE1BQWpCOztBQUVBLElBQU1DLFNBQVMsRUFBZjs7QUFFQTs7O0FBR0EsT0FBTyxJQUFNQyxXQUFXLFNBQVhBLFFBQVcsUUFBUztBQUMvQixNQUFJRCxPQUFPRSxNQUFNQyxFQUFiLENBQUosRUFBc0I7QUFDcEI7QUFDRDtBQUNESCxTQUFPRSxNQUFNQyxFQUFiLElBQW1CRCxLQUFuQjtBQUNELENBTE07O0FBT1A7OztBQUdBLE9BQU8sSUFBTUUsY0FBYyxTQUFkQSxXQUFjLEtBQU07QUFDL0IsU0FBT0osT0FBT0csRUFBUCxDQUFQO0FBQ0QsQ0FGTTs7QUFJUDs7O0FBR0EsSUFBTUUsZUFBZSxTQUFmQSxZQUFlLENBQUNDLEdBQUQsRUFBTUMsSUFBTixFQUFZQyxLQUFaLEVBQXNCO0FBQ3pDLE1BQUlELEtBQUtFLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQkosaUJBQWFDLElBQUlDLEtBQUssQ0FBTCxDQUFKLENBQWIsRUFBMkJBLEtBQUtHLEtBQUwsQ0FBVyxDQUFYLENBQTNCLEVBQTBDRixLQUExQztBQUNELEdBRkQsTUFFTztBQUNMRixRQUFJQyxLQUFLLENBQUwsQ0FBSixJQUFlQyxLQUFmO0FBQ0Q7QUFDRixDQU5EOztBQVFBOzs7QUFHQVQsS0FBS1ksU0FBTCxDQUFlLFNBQWYsRUFBMEIsbUJBQVc7QUFDbkMsTUFBTVQsUUFBUUYsT0FBT1ksUUFBUUMsT0FBZixDQUFkO0FBQ0EsTUFBSSxDQUFDWCxLQUFELElBQVVVLFFBQVFFLElBQVIsS0FBaUIsTUFBL0IsRUFBdUM7QUFDckM7QUFDRDs7QUFFRCxNQUFNQyxXQUFXYixNQUFNYyxXQUFOLEVBQWpCO0FBQ0FYLGVBQWFVLFFBQWIsRUFBdUJILFFBQVFLLFNBQS9CLEVBQTBDTCxRQUFRSixLQUFsRDtBQUNBTixRQUFNZ0IsV0FBTixDQUFrQkgsUUFBbEI7QUFDRCxDQVREIiwiZmlsZSI6InNlZXItaW50ZWdyYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2VlciBmcm9tICdzZWVyJztcblxuY29uc3QgbW9kZWxzID0ge307XG5cbi8qKlxuICogQWRkIGEgbW9kZWwgdG8gb3VyIGNhY2hlIGluZGV4ZWQgYnkgaWRcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZE1vZGVsID0gbW9kZWwgPT4ge1xuICBpZiAobW9kZWxzW21vZGVsLmlkXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtb2RlbHNbbW9kZWwuaWRdID0gbW9kZWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHByZXZpb3VzbHkgc2V0IG1vZGVsIGZyb20gdGhlIGNhY2hlXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVNb2RlbCA9IGlkID0+IHtcbiAgZGVsZXRlIG1vZGVsc1tpZF07XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCBnaXZlbiBhIHBhdGggb2YgcHJvcGVydGllcyBhbmQgc2V0IHRoZSBnaXZlbiB2YWx1ZVxuICovXG5jb25zdCByZWN1cnNpdmVTZXQgPSAob2JqLCBwYXRoLCB2YWx1ZSkgPT4ge1xuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgcmVjdXJzaXZlU2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RlbiBmb3IgbHVtYS5nbCBlZGl0IGV2ZW50c1xuICovXG5zZWVyLmxpc3RlbkZvcignbHVtYS5nbCcsIHBheWxvYWQgPT4ge1xuICBjb25zdCBtb2RlbCA9IG1vZGVsc1twYXlsb2FkLml0ZW1LZXldO1xuICBpZiAoIW1vZGVsIHx8IHBheWxvYWQudHlwZSAhPT0gJ2VkaXQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdW5pZm9ybXMgPSBtb2RlbC5nZXRVbmlmb3JtcygpO1xuICByZWN1cnNpdmVTZXQodW5pZm9ybXMsIHBheWxvYWQudmFsdWVQYXRoLCBwYXlsb2FkLnZhbHVlKTtcbiAgbW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xufSk7XG4iXX0=

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Timer based animation
// TODO clean up linting
/* eslint-disable */
/* global setTimeout */


var _utils = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Queue = [];

var Fx = function () {
  function Fx() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Fx);

    this.opt = (0, _utils.merge)({
      delay: 0,
      duration: 1000,
      transition: function transition(x) {
        return x;
      },
      onCompute: _utils.noop,
      onComplete: _utils.noop
    }, options);
  }

  _createClass(Fx, [{
    key: 'start',
    value: function start(options) {
      this.opt = (0, _utils.merge)(this.opt, options || {});
      this.time = Date.now();
      this.animating = true;
      Queue.push(this);
    }

    // perform a step in the animation

  }, {
    key: 'step',
    value: function step() {
      // if not animating, then return
      if (!this.animating) {
        return;
      }
      var currentTime = Date.now(),
          time = this.time,
          opt = this.opt,
          delay = opt.delay,
          duration = opt.duration,
          delta = 0;
      // hold animation for the delay
      if (currentTime < time + delay) {
        opt.onCompute.call(this, delta);
        return;
      }
      // if in our time window, then execute animation
      if (currentTime < time + delay + duration) {
        delta = opt.transition((currentTime - time - delay) / duration);
        opt.onCompute.call(this, delta);
      } else {
        this.animating = false;
        opt.onCompute.call(this, 1);
        opt.onComplete.call(this);
      }
    }
  }], [{
    key: 'compute',
    value: function compute(from, to, delta) {
      return from + (to - from) * delta;
    }
  }]);

  return Fx;
}();

exports.default = Fx;


Fx.Queue = Queue;

// Easing equations
Fx.Transition = {
  linear: function linear(p) {
    return p;
  }
};

var Trans = Fx.Transition;

Fx.prototype.time = null;

function makeTrans(transition, params) {
  params = (0, _utils.splat)(params);
  return Object.assign(transition, {
    easeIn: function easeIn(pos) {
      return transition(pos, params);
    },
    easeOut: function easeOut(pos) {
      return 1 - transition(1 - pos, params);
    },
    easeInOut: function easeInOut(pos) {
      return pos <= 0.5 ? transition(2 * pos, params) / 2 : (2 - transition(2 * (1 - pos), params)) / 2;
    }
  });
}

var transitions = {
  Pow: function Pow(p, x) {
    return Math.pow(p, x[0] || 6);
  },
  Expo: function Expo(p) {
    return Math.pow(2, 8 * (p - 1));
  },
  Circ: function Circ(p) {
    return 1 - Math.sin(Math.acos(p));
  },
  Sine: function Sine(p) {
    return 1 - Math.sin((1 - p) * Math.PI / 2);
  },
  Back: function Back(p, x) {
    x = x[0] || 1.618;
    return Math.pow(p, 2) * ((x + 1) * p - x);
  },
  Bounce: function Bounce(p) {
    var value;
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
      if (p >= (7 - 4 * a) / 11) {
        value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
        break;
      }
    }
    return value;
  },
  Elastic: function Elastic(p, x) {
    return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x[0] || 1) / 3);
  }
};

for (var t in transitions) {
  Trans[t] = makeTrans(transitions[t]);
}

['Quad', 'Cubic', 'Quart', 'Quint'].forEach(function (elem, i) {
  Trans[elem] = makeTrans(function (p) {
    return Math.pow(p, [i + 2]);
  });
});

// animationTime - function branching

// rye: TODO- refactor global definition when we define the two
//           (browserify/<script>) build paths.
var global;
try {
  global = window;
} catch (e) {
  global = null;
}

var checkFxQueue = function checkFxQueue() {
  var oldQueue = Queue;
  Queue = [];
  if (oldQueue.length) {
    for (var i = 0, l = oldQueue.length, fx; i < l; i++) {
      fx = oldQueue[i];
      fx.step();
      if (fx.animating) {
        Queue.push(fx);
      }
    }
    Fx.Queue = Queue;
  }
};

if (global) {
  var found = false;
  ['webkitAnimationTime', 'mozAnimationTime', 'animationTime', 'webkitAnimationStartTime', 'mozAnimationStartTime', 'animationStartTime'].forEach(function (impl) {
    if (impl in global) {
      Fx.animationTime = function () {
        return global[impl];
      };
      found = true;
    }
  });
  if (!found) {
    Fx.animationTime = Date.now;
  }
  // requestAnimationFrame - function branching
  found = false;
  ['webkitRequestAnimationFrame', 'mozRequestAnimationFrame', 'requestAnimationFrame'].forEach(function (impl) {
    if (impl in global) {
      Fx.requestAnimationFrame = function (callback) {
        global[impl](function () {
          checkFxQueue();
          callback();
        });
      };
      found = true;
    }
  });
  if (!found) {
    Fx.requestAnimationFrame = function (callback) {
      setTimeout(function () {
        checkFxQueue();
        callback();
      }, 1000 / 60);
    };
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZXByZWNhdGVkL2Z4LmpzIl0sIm5hbWVzIjpbIlF1ZXVlIiwiRngiLCJvcHRpb25zIiwib3B0IiwiZGVsYXkiLCJkdXJhdGlvbiIsInRyYW5zaXRpb24iLCJ4Iiwib25Db21wdXRlIiwib25Db21wbGV0ZSIsInRpbWUiLCJEYXRlIiwibm93IiwiYW5pbWF0aW5nIiwicHVzaCIsImN1cnJlbnRUaW1lIiwiZGVsdGEiLCJjYWxsIiwiZnJvbSIsInRvIiwiVHJhbnNpdGlvbiIsImxpbmVhciIsInAiLCJUcmFucyIsInByb3RvdHlwZSIsIm1ha2VUcmFucyIsInBhcmFtcyIsIk9iamVjdCIsImFzc2lnbiIsImVhc2VJbiIsInBvcyIsImVhc2VPdXQiLCJlYXNlSW5PdXQiLCJ0cmFuc2l0aW9ucyIsIlBvdyIsIk1hdGgiLCJwb3ciLCJFeHBvIiwiQ2lyYyIsInNpbiIsImFjb3MiLCJTaW5lIiwiUEkiLCJCYWNrIiwiQm91bmNlIiwidmFsdWUiLCJhIiwiYiIsIkVsYXN0aWMiLCJjb3MiLCJ0IiwiZm9yRWFjaCIsImVsZW0iLCJpIiwiZ2xvYmFsIiwid2luZG93IiwiZSIsImNoZWNrRnhRdWV1ZSIsIm9sZFF1ZXVlIiwibGVuZ3RoIiwibCIsImZ4Iiwic3RlcCIsImZvdW5kIiwiaW1wbCIsImFuaW1hdGlvblRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiXSwibWFwcGluZ3MiOiI7Ozs7OztxakJBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7O0FBRUEsSUFBSUEsUUFBUSxFQUFaOztJQUVxQkMsRTtBQUNuQixnQkFBMEI7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3hCLFNBQUtDLEdBQUwsR0FBVyxrQkFBTTtBQUNmQyxhQUFPLENBRFE7QUFFZkMsZ0JBQVUsSUFGSztBQUdmQyxrQkFBWTtBQUFBLGVBQUtDLENBQUw7QUFBQSxPQUhHO0FBSWZDLDRCQUplO0FBS2ZDO0FB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bnQiOlsiLy8gVGltZXIgYmFzZWQgYW5pbWF0aW9uXG4vLyBUT0RPIGNsZWFuIHVwIGxpbnRpbmdcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBnbG9iYWwgc2V0VGltZW91dCAqL1xuaW1wb3J0IHttZXJnZSwgbm9vcCwgc3BsYXR9IGZyb20gJy4uL3V0aWxzJztcblxudmFyIFF1ZXVlID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHQgPSBtZXJnZSh7XG4gICAgICBkZWxheTogMCxcbiAgICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgICAgdHJhbnNpdGlvbjogeCA9PiB4LFxuICAgICAgb25Db21wdXRlOiBub29wLFxuICAgICAgb25Db21wbGV0ZTogbm9vcFxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhcnQob3B0aW9ucykge1xuICAgIHRoaXMub3B0ID0gbWVyZ2UodGhpcy5vcHQsIG9wdGlvbnMgfHwge30pO1xuICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgIFF1ZXVlLnB1c2godGhpcyk7XG4gIH1cblxuICAvLyBwZXJmb3JtIGEgc3RlcCBpbiB0aGUgYW5pbWF0aW9uXG4gIHN0ZXAoKSB7XG4gICAgLy8gaWYgbm90IGFuaW1hdGluZywgdGhlbiByZXR1cm5cbiAgICBpZiAoIXRoaXMuYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCksXG4gICAgICB0aW1lID0gdGhpcy50aW1lLFxuICAgICAgb3B0ID0gdGhpcy5vcHQsXG4gICAgICBkZWxheSA9IG9wdC5kZWxheSxcbiAgICAgIGR1cmF0aW9uID0gb3B0LmR1cmF0aW9uLFxuICAgICAgZGVsdGEgPSAwO1xuICAgIC8vIGhvbGQgYW5pbWF0aW9uIGZvciB0aGUgZGVsYXlcbiAgICBpZiAoY3VycmVudFRpbWUgPCB0aW1lICsgZGVsYXkpIHtcbiAgICAgIG9wdC5vbkNvbXB1dGUuY2FsbCh0aGlzLCBkZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIGluIG91ciB0aW1lIHdpbmRvdywgdGhlbiBleGVjdXRlIGFuaW1hdGlvblxuICAgIGlmIChjdXJyZW50VGltZSA8IHRpbWUgKyBkZWxheSArIGR1cmF0aW9uKSB7XG4gICAgICBkZWx0YSA9IG9wdC50cmFuc2l0aW9uKChjdXJyZW50VGltZSAtIHRpbWUgLSBkZWxheSkgLyBkdXJhdGlvbik7XG4gICAgICBvcHQub25Db21wdXRlLmNhbGwodGhpcywgZGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgb3B0Lm9uQ29tcHV0ZS5jYWxsKHRoaXMsIDEpO1xuICAgICAgb3B0Lm9uQ29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY29tcHV0ZShmcm9tLCB0bywgZGVsdGEpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZGVsdGE7XG4gIH1cbn1cblxuRnguUXVldWUgPSBRdWV1ZTtcblxuLy8gRWFzaW5nIGVxdWF0aW9uc1xuRnguVHJhbnNpdGlvbiA9IHtcbiAgbGluZWFyKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxudmFyIFRyYW5zID0gRnguVHJhbnNpdGlvbjtcblxuRngucHJvdG90eXBlLnRpbWUgPSBudWxsO1xuXG5mdW5jdGlvbiBtYWtlVHJhbnModHJhbnNpdGlvbiwgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHNwbGF0KHBhcmFtcyk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRyYW5zaXRpb24sIHtcbiAgICBlYXNlSW4ocG9zKSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbihwb3MsIHBhcmFtcyk7XG4gICAgfSxcbiAgICBlYXNlT3V0KHBvcykge1xuICAgICAgcmV0dXJuIDEgLSB0cmFuc2l0aW9uKDEgLSBwb3MsIHBhcmFtcyk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXQocG9zKSB7XG4gICAgICByZXR1cm4gKHBvcyA8PSAwLjUpID8gdHJhbnNpdGlvbigyICogcG9zLCBwYXJhbXMpIC8gMiA6XG4gICAgICAgICgyIC0gdHJhbnNpdGlvbigyICogKDEgLSBwb3MpLCBwYXJhbXMpKSAvIDI7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHRyYW5zaXRpb25zID0ge1xuXG4gIFBvdyhwLCB4KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHAsIHhbMF0gfHwgNik7XG4gIH0sXG5cbiAgRXhwbyhwKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIDggKiAocCAtIDEpKTtcbiAgfSxcblxuICBDaXJjKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc2luKE1hdGguYWNvcyhwKSk7XG4gIH0sXG5cbiAgU2luZShwKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNpbigoMSAtIHApICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIEJhY2socCwgeCkge1xuICAgIHggPSB4WzBdIHx8IDEuNjE4O1xuICAgIHJldHVybiBNYXRoLnBvdyhwLCAyKSAqICgoeCArIDEpICogcCAtIHgpO1xuICB9LFxuXG4gIEJvdW5jZShwKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGZvciAobGV0IGEgPSAwLCBiID0gMTsgMTsgYSArPSBiLCBiIC89IDIpIHtcbiAgICAgIGlmIChwID49ICg3IC0gNCAqIGEpIC8gMTEpIHtcbiAgICAgICAgdmFsdWUgPSBiICogYiAtIE1hdGgucG93KCgxMSAtIDYgKiBhIC0gMTEgKiBwKSAvIDQsIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIEVsYXN0aWMocCwgeCkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqIC0tcCkgKiBNYXRoLmNvcygyMCAqIHAgKiBNYXRoLlBJICogKHhbMF0gfHwgMSkgLyAzKTtcbiAgfVxuXG59O1xuXG5mb3IgKGNvbnN0IHQgaW4gdHJhbnNpdGlvbnMpIHtcbiAgVHJhbnNbdF0gPSBtYWtlVHJhbnModHJhbnNpdGlvbnNbdF0pO1xufVxuXG5bJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnXS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW0sIGkpIHtcbiAgVHJhbnNbZWxlbV0gPSBtYWtlVHJhbnMoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhwLCBbXG4gICAgICBpICsgMlxuICAgIF0pO1xuICB9KTtcbn0pO1xuXG4vLyBhbmltYXRpb25UaW1lIC0gZnVuY3Rpb24gYnJhbmNoaW5nXG5cbi8vIHJ5ZTogVE9ETy0gcmVmYWN0b3IgZ2xvYmFsIGRlZmluaXRpb24gd2hlbiB3ZSBkZWZpbmUgdGhlIHR3b1xuLy8gICAgICAgICAgIChicm93c2VyaWZ5LzxzY3JpcHQ+KSBidWlsZCBwYXRocy5cbnZhciBnbG9iYWw7XG50cnkge1xuICBnbG9iYWwgPSB3aW5kb3c7XG59IGNhdGNoIChlKSB7XG4gIGdsb2JhbCA9IG51bGw7XG59XG5cbnZhciBjaGVja0Z4UXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9sZFF1ZXVlID0gUXVldWU7XG4gIFF1ZXVlID0gW107XG4gIGlmIChvbGRRdWV1ZS5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9sZFF1ZXVlLmxlbmd0aCwgZng7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZ4ID0gb2xkUXVldWVbaV07XG4gICAgICBmeC5zdGVwKCk7XG4gICAgICBpZiAoZnguYW5pbWF0aW5nKSB7XG4gICAgICAgIFF1ZXVlLnB1c2goZngpO1xuICAgICAgfVxuICAgIH1cbiAgICBGeC5RdWV1ZSA9IFF1ZXVlO1xuICB9XG59O1xuXG5pZiAoZ2xvYmFsKSB7XG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuICBbJ3dlYmtpdEFuaW1hdGlvblRpbWUnLCAnbW96QW5pbWF0aW9uVGltZScsICdhbmltYXRpb25UaW1lJyxcbiAgICd3ZWJraXRBbmltYXRpb25TdGFydFRpbWUnLCAnbW96QW5pbWF0aW9uU3RhcnRUaW1lJywgJ2FuaW1hdGlvblN0YXJ0VGltZSddXG4gICAgLmZvckVhY2goaW1wbCA9PiB7XG4gICAgICBpZiAoaW1wbCBpbiBnbG9iYWwpIHtcbiAgICAgICAgRnguYW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnbG9iYWxbaW1wbF07XG4gICAgICAgIH07XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIEZ4LmFuaW1hdGlvblRpbWUgPSBEYXRlLm5vdztcbiAgfVxuICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLSBmdW5jdGlvbiBicmFuY2hpbmdcbiAgZm91bmQgPSBmYWxzZTtcbiAgWyd3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCAnbW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGltcGwpIHtcbiAgICAgIGlmIChpbXBsIGluIGdsb2JhbCkge1xuICAgICAgICBGeC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGdsb2JhbFtpbXBsXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNoZWNrRnhRdWV1ZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgRngucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNoZWNrRnhRdWV1ZSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICB9O1xuICB9XG59XG4iXX0=

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _object3d = __webpack_require__(50);

Object.defineProperty(exports, 'Object3D', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_object3d).default;
  }
});

var _group = __webpack_require__(49);

Object.defineProperty(exports, 'Group', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_group).default;
  }
});

var _scene = __webpack_require__(220);

Object.defineProperty(exports, 'Scene', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scene).default;
  }
});

var _pick = __webpack_require__(92);

Object.defineProperty(exports, 'pickModels', {
  enumerable: true,
  get: function get() {
    return _pick.pickModels;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NjZW5lZ3JhcGgvaW5kZXguanMiXSwibmFtZXMiOlsiZGVmYXVsdCIsInBpY2tNb2RlbHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzZDQUFRQSxPOzs7Ozs7Ozs7MENBQ0FBLE87Ozs7Ozs7OzswQ0FDQUEsTzs7Ozs7Ozs7O2lCQUNBQyxVIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHtkZWZhdWx0IGFzIE9iamVjdDNEfSBmcm9tICcuL29iamVjdC0zZCc7XG5leHBvcnQge2RlZmF1bHQgYXMgR3JvdXB9IGZyb20gJy4vZ3JvdXAnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNjZW5lfSBmcm9tICcuL3NjZW5lJztcbmV4cG9ydCB7cGlja01vZGVsc30gZnJvbSAnLi9waWNrJztcbiJdfQ==

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(51);

var _utils = __webpack_require__(4);

var _group = __webpack_require__(49);

var _group2 = _interopRequireDefault(_group);

var _pick = __webpack_require__(92);

var _assert = __webpack_require__(0);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Scene Object management and rendering
/* eslint-disable max-statements, no-try-catch */


var INVALID_ARGUMENT = 'LumaGL.Scene invalid argument';

var DEFAULT_SCENE_OPTS = {
  lights: {
    enable: false,
    // ambient light
    ambient: { r: 0.2, g: 0.2, b: 0.2 },
    // directional light
    directional: {
      direction: { x: 1, y: 1, z: 1 },
      color: { r: 0, g: 0, b: 0 }
    }
    // point light
    // points: []
  },
  effects: {
    fog: false
    // { near, far, color }
  },
  clearColor: true,
  clearDepth: true,
  backgroundColor: { r: 0, g: 0, b: 0, a: 1 },
  backgroundDepth: 1
};

// Scene class

var Scene = function (_Group) {
  _inherits(Scene, _Group);

  function Scene(gl, opts) {
    _classCallCheck(this, Scene);

    (0, _assert2.default)(gl, INVALID_ARGUMENT);

    opts = (0, _utils.merge)(DEFAULT_SCENE_OPTS, opts);

    var _this = _possibleConstructorReturn(this, (Scene.__proto__ || Object.getPrototypeOf(Scene)).call(this, opts));

    _this.gl = gl;
    _this.config = opts;
    _this.needsRedraw = false;
    Object.seal(_this);
    return _this;
  }

  _createClass(Scene, [{
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = redraw;
      return this;
    }
  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearRedrawFlags = _ref.clearRedrawFlags,
          clearRedrawFlags = _ref$clearRedrawFlags === undefined ? false : _ref$clearRedrawFlags;

      var redraw = false;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      this.traverse(function (model) {
        redraw = redraw || model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      });
      return redraw;
    }
  }, {
    key: 'clear',
    value: function clear() {
      var gl = this.gl;

      if (this.config.clearColor) {
        var bg = this.config.backgroundColor;
        gl.clearColor(bg.r, bg.g, bg.b, bg.a);
      }
      if (this.config.clearDepth) {
        gl.clearDepth(this.config.backgroundDepth);
      }
      if (this.config.clearColor && this.config.clearDepth) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      } else if (this.config.clearColor) {
        gl.clear(gl.COLOR_BUFFER_BIT);
      } else if (this.config.clearDepth) {
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      return this;
    }

    // Renders all objects in the scene.

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.clear();
      // Go through each model and render it.
      this.traverse(function (model) {
        if (model.display) {
          _this2.renderObject({ model: model, uniforms: uniforms });
        }
      });
      return this;
    }
  }, {
    key: 'renderObject',
    value: function renderObject(_ref2) {
      var model = _ref2.model,
          uniforms = _ref2.uniforms;

      // Setup lighting and scene effects like fog, etc.
      uniforms = Object.assign({}, this.getSceneUniforms(), uniforms);
      model.render(uniforms);
      return this;
    }
  }, {
    key: 'pickModels',
    value: function pickModels() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var x = opts.x,
          y = opts.y,
          _opts$uniforms = opts.uniforms,
          uniforms = _opts$uniforms === undefined ? {} : _opts$uniforms;

      return (0, _pick.pickModels)(this.gl, Object.assign({
        group: this,
        x: x, y: y,
        uniforms: uniforms
      }, opts));
    }

    // Setup the lighting system: ambient, directional, point lights.

  }, {
    key: 'getSceneUniforms',
    value: function getSceneUniforms() {
      // Setup Lighting
      var _config$lights = this.config.lights,
          enable = _config$lights.enable,
          ambient = _config$lights.ambient,
          directional = _config$lights.directional,
          points = _config$lights.points;

      // Set light uniforms. Ambient and directional lights.

      return Object.assign({}, this.getEffectsUniforms(), { enableLights: enable }, enable && ambient ? this.getAmbientUniforms(ambient) : {}, enable && directional ? this.getDirectionalUniforms(directional) : {}, enable && points ? this.getPointUniforms(points) : {});
    }
  }, {
    key: 'getAmbientUniforms',
    value: function getAmbientUniforms(ambient) {
      return {
        ambientColor: [ambient.r, ambient.g, ambient.b]
      };
    }
  }, {
    key: 'getDirectionalUniforms',
    value: function getDirectionalUniforms(directional) {
      var color = directional.color,
          direction = directional.direction;

      // Normalize lighting direction vector

      var dir = new _math.Vector3(direction.x, direction.y, direction.z).normalize().scale(-1, -1, -1);

      return {
        directionalColor: [color.r, color.g, color.b],
        lightingDirection: [dir.x, dir.y, dir.z]
      };
    }
  }, {
    key: 'getPointUniforms',
    value: function getPointUniforms(points) {
      points = points instanceof Array ? points : [points];
      var numberPoints = points.length;
      var uniforms = { numberPoints: numberPoints };

      var pointLocations = [];
      var pointColors = [];
      var enableSpecular = [];
      var pointSpecularColors = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var position = point.position,
              color = point.color,
              diffuse = point.diffuse,
              specular = point.specular;

          var pointColor = color || diffuse;

          pointLocations.push(position.x, position.y, position.z);
          pointColors.push(pointColor.r, pointColor.g, pointColor.b);

          // Add specular color
          enableSpecular.push(Number(Boolean(specular)));
          if (specular) {
            pointSpecularColors.push(specular.r, specular.g, specular.b);
          } else {
            pointSpecularColors.push(0, 0, 0);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (pointLocations.length) {
        Object.assign(uniforms, {
          pointLocation: pointLocations,
          pointColor: pointColors,
          enableSpecular: enableSpecular,
          pointSpecularColor: pointSpecularColors
        });
      }

      return uniforms;
    }

    // Setup effects like fog, etc.

  }, {
    key: 'getEffectsUniforms',
    value: function getEffectsUniforms() {
      var fog = this.config.effects.fog;


      if (fog) {
        var _fog$color = fog.color,
            color = _fog$color === undefined ? { r: 0.5, g: 0.5, b: 0.5 } : _fog$color;

        return {
          hasFog: true,
          fogNear: fog.near,
          fogFar: fog.far,
          fogColor: [color.r, color.g, color.b]
        };
      }
      return { hasFog: false };
    }
  }]);

  return Scene;
}(_group2.default);

exports.default = Scene;


Scene.MAX_TEXTURES = 4;
Scene.MAX_POINT_LIGHTS = 4;
Scene.PICKING_RES = 4;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NjZW5lZ3JhcGgvc2NlbmUuanMiXSwibmFtZXMiOlsiSU5WQUxJRF9BUkdVTUVOVCIsIkRFRkFVTFRfU0NFTkVfT1BUUyIsImxpZ2h0cyIsImVuYWJsZSIsImFtYmllbnQiLCJyIiwiZyIsImIiLCJkaXJlY3Rpb25hbCIsImRpcmVjdGlvbiIsIngiLCJ5IiwieiIsImNvbG9yIiwiZWZmZWN0cyIsImZvZyIsImNsZWFyQ29sb3IiLCJjbGVhckRlcHRoIiwiYmFja2dyb3VuZENvbG9yIiwiYSIsImJhY2tncm91bmREZXB0aCIsIlNjZW5lIiwiZ2wiLCJvcHRzIiwiY29uZmlnIiwibmVlZHNSZWRyYXciLCJPYmplY3QiLCJzZWFsIiwicmVkcmF3IiwiY2xlYXJSZWRyYXdGbGFncyIsInRyYXZlcnNlIiwibW9kZWwiLCJnZXROZWVkc1JlZHJhdyIsImJnIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsInVuaWZvcm1zIiwiZGlzcGxheSIsInJlbmRlck9iamVjdCIsImFzc2lnbiIsImdldFNjZW5lVW5pZm9ybXMiLCJyZW5kZXIiLCJncm91cCIsInBvaW50cyIsImdldEVmZmVjdHNVbmlmb3JtcyIsImVuYWJsZUxpZ2h0cyIsImdldEFtYmllbnRVbmlmb3JtcyIsImdldERpcmVjdGlvbmFsVW5pZm9ybXMiLCJnZXRQb2ludFVuaWZvcm1zIiwiYW1iaWVudENvbG9yIiwiZGlyIiwibm9ybWFsaXplIiwic2NhbGUiLCJkaXJlY3Rpb25hbENvbG9yIiwibGlnaHRpbmdEaXJlY3Rpb24iLCJBcnJheSIsIm51bWJlclBvaW50cyIsImxlbmd0aCIsInBvaW50TG9jYXRpb25zIiwicG9pbnRDb2xvcnMiLCJlbmFibGVTcGVjdWxhciIsInBvaW50U3BlY3VsYXJDb2xvcnMiLCJwb2ludCIsInBvc2l0aW9uIiwiZGlmZnVzZSIsInNwZWN1bGFyIiwicG9pbnRDb2xvciIsInB1c2giLCJOdW1iZXIiLCJCb29sZWFuIiwicG9pbnRMb2NhdGlvbiIsInBvaW50U3BlY3VsYXJDb2xvciIsImhhc0ZvZyIsImZvZ05lYXIiLCJuZWFyIiwiZm9nRmFyIiwiZmFyIiwiZm9nQ29sb3IiLCJNQVhfVEVYVFVSRVMiLCJNQVhfUE9JTlRfTElHSFRTIiwiUElDS0lOR19SRVMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OzsrZUFOQTtBQUNBOzs7QUFPQSxJQUFNQSxtQkFBbUIsK0JBQXpCOztBQUVBLElBQU1DLHFCQUFxQjtBQUN6QkMsVUFBUTtBQUNOQyxZQUFRLEtBREY7QUFFTjtBQUNBQyxhQUFTLEVBQUNDLEdBQUcsR0FBSixFQUFTQyxHQUFHLEdBQVosRUFBaUJDLEdBQUcsR0FBcEIsRUFISDtBQUlOO0FBQ0FDLGlCQUFhO0FBQ1hDLGlCQUFXLEVBQUNDLEdBQUcsQ0FBSixFQUFPQyxHQUFHLENBQVYsRUFBYUMsR0FBRyxDQUFoQixFQURBO0FBRVhDLGFBQU8sRUFBQ1IsR0FBRyxDQUFKLEVBQU9DLEdBQUcsQ0FBVixFQUFhQyxHQUFHLENBQWhCO0FBRkk7QUFJYjtBQUNBO0FBVk0sR0FEaUI7QUFhekJPLFdBQVM7QUFDUEMsU0FBSztBQUNMO0FBRk8sR0FiZ0I7QUFpQnpCQyxjQUFZLElBakJhO0FBa0J6QkMsY0FBWSxJQWxCYTtBQW1CekJDLG1CQUFpQixFQUFDYixHQUFHLENBQUosRUFBT0MsR0FBRyxDQUFWLEVBQWFDLEdBQUcsQ0FBaEIsRUFBbUJZLEdBQUcsQ0FBdEIsRUFuQlE7QUFvQnpCQyxtQkFBaUI7QUFwQlEsQ0FBM0I7O0FBdUJBOztJQUNxQkMsSzs7O0FBRW5CLGlCQUFZQyxFQUFaLEVBQWdCQyxJQUFoQixFQUFzQjtBQUFBOztBQUNwQiwwQkFBT0QsRUFBUCxFQUFXdEIsZ0JBQVg7O0FBRUF1QixXQUFPLGtCQUFNdEIsa0JBQU4sRUFBMEJzQixJQUExQixDQUFQOztBQUhvQiw4R0FLZEEsSUFMYzs7QUFPcEIsVUFBS0QsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsVUFBS0UsTUFBTCxHQUFjRCxJQUFkO0FBQ0EsVUFBS0UsV0FBTCxHQUFtQixLQUFuQjtBQUNBQyxXQUFPQyxJQUFQO0FBVm9CO0FBV3JCOzs7O3FDQUU2QjtBQUFBLFVBQWZDLE1BQWUsdUVBQU4sSUFBTTs7QUFDNUIsV0FBS0gsV0FBTCxHQUFtQkcsTUFBbkI7QUFDQSxhQUFPLElBQVA7QUFDRDs7O3FDQUUrQztBQUFBLHFGQUFKLEVBQUk7QUFBQSx1Q0FBaENDLGdCQUFnQztBQUFBLFVBQWhDQSxnQkFBZ0MseUNBQWIsS0FBYTs7QUFDOUMsVUFBSUQsU0FBUyxLQUFiO0FBQ0FBLGVBQVNBLFVBQVUsS0FBS0gsV0FBeEI7QUFDQSxXQUFLQSxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsSUFBb0IsQ0FBQ0ksZ0JBQXhDO0FBQ0EsV0FBS0MsUUFBTCxDQUFjLGlCQUFTO0FBQ3JCRixpQkFBU0EsVUFBVUcsTUFBTUMsY0FBTixDQUFxQixFQUFDSCxrQ0FBRCxFQUFyQixDQUFuQjtBQUNELE9BRkQ7QUFHQSxhQUFPRCxNQUFQO0FBQ0Q7Ozs0QkFFTztBQUFBLFVBQ0NOLEVBREQsR0FDTyxJQURQLENBQ0NBLEVBREQ7O0FBRU4sVUFBSSxLQUFLRSxNQUFMLENBQVlSLFVBQWhCLEVBQTRCO0FBQzFCLFlBQU1pQixLQUFLLEtBQUtULE1BQUwsQ0FBWU4sZUFBdkI7QUFDQUksV0FBR04sVUFBSCxDQUFjaUIsR0FBRzVCLENBQWpCLEVBQW9CNEIsR0FBRzNCLENBQXZCLEVBQTBCMkIsR0FBRzFCLENBQTdCLEVBQWdDMEIsR0FBR2QsQ0FBbkM7QUFDRDtBQUNELFVBQUksS0FBS0ssTUFBTCxDQUFZUCxVQUFoQixFQUE0QjtBQUMxQkssV0FBR0wsVUFBSCxDQUFjLEtBQUtPLE1BQUwsQ0FBWUosZUFBMUI7QUFDRDtBQUNELFVBQUksS0FBS0ksTUFBTCxDQUFZUixVQUFaLElBQTBCLEtBQUtRLE1BQUwsQ0FBWVAsVUFBMUMsRUFBc0Q7QUFDcERLLFdBQUdZLEtBQUgsQ0FBU1osR0FBR2EsZ0JBQUgsR0FBc0JiLEdBQUdjLGdCQUFsQztBQUNELE9BRkQsTUFFTyxJQUFJLEtBQUtaLE1BQUwsQ0FBWVIsVUFBaEIsRUFBNEI7QUFDakNNLFdBQUdZLEtBQUgsQ0FBU1osR0FBR2EsZ0JBQVo7QUFDRCxPQUZNLE1BRUEsSUFBSSxLQUFLWCxNQUFMLENBQVlQLFVBQWhCLEVBQTRCO0FBQ2pDSyxXQUFHWSxLQUFILENBQVNaLEdBQUdjLGdCQUFaO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs2QkFDc0I7QUFBQTs7QUFBQSxVQUFmQyxRQUFlLHVFQUFKLEVBQUk7O0FBQ3BCLFdBQUtILEtBQUw7QUFDQTtBQUNBLFdBQUtKLFFBQUwsQ0FBYyxpQkFBUztBQUNyQixZQUFJQyxNQUFNTyxPQUFWLEVBQW1CO0FBQ2pCLGlCQUFLQyxZQUFMLENBQWtCLEVBQUNSLFlBQUQsRUFBUU0sa0JBQVIsRUFBbEI7QUFDRDtBQUNGLE9BSkQ7QUFLQSxhQUFPLElBQVA7QUFDRDs7O3dDQUUrQjtBQUFBLFVBQWxCTixLQUFrQixTQUFsQkEsS0FBa0I7QUFBQSxVQUFYTSxRQUFXLFNBQVhBLFFBQVc7O0FBQzlCO0FBQ0FBLGlCQUFXWCxPQUFPYyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLQyxnQkFBTCxFQUFsQixFQUEyQ0osUUFBM0MsQ0FBWDtBQUNBTixZQUFNVyxNQUFOLENBQWFMLFFBQWI7QUFDQSxhQUFPLElBQVA7QUFDRDs7O2lDQUVxQjtBQUFBLFVBQVhkLElBQVcsdUVBQUosRUFBSTtBQUFBLFVBQ2JiLENBRGEsR0FDVWEsSUFEVixDQUNiYixDQURhO0FBQUEsVUFDVkMsQ0FEVSxHQUNVWSxJQURWLENBQ1ZaLENBRFU7QUFBQSwyQkFDVVksSUFEVixDQUNQYyxRQURPO0FBQUEsVUFDUEEsUUFETyxrQ0FDSSxFQURKOztBQUVwQixhQUFPLHNCQUFXLEtBQUtmLEVBQWhCLEVBQW9CSSxPQUFPYyxNQUFQLENBQWM7QUFDdkNHLGVBQU8sSUFEZ0M7QUFFdkNqQyxZQUZ1QyxFQUVwQ0MsSUFGb0M7QUFHdkMwQjtBQUh1QyxPQUFkLEVBSXhCZCxJQUp3QixDQUFwQixDQUFQO0FBS0Q7O0FBRUQ7Ozs7dUNBQ21CO0FBQ2pCO0FBRGlCLDJCQUU4QixLQUFLQyxNQUFMLENBQVl0QixNQUYxQztBQUFBLFVBRVZDLE1BRlUsa0JBRVZBLE1BRlU7QUFBQSxVQUVGQyxPQUZFLGtCQUVGQSxPQUZFO0FBQUEsVUFFT0ksV0FGUCxrQkFFT0EsV0FGUDtBQUFBLFVBRW9Cb0MsTUFGcEIsa0JBRW9CQSxNQUZwQjs7QUFJakI7O0FBQ0EsYUFBT2xCLE9BQU9jLE1BQVAsQ0FBYyxFQUFkLEVBQ0wsS0FBS0ssa0JBQUwsRUFESyxFQUVMLEVBQUNDLGNBQWMzQyxNQUFmLEVBRkssRUFHSkEsVUFBVUMsT0FBVixHQUFvQixLQUFLMkMsa0JBQUwsQ0FBd0IzQyxPQUF4QixDQUFwQixHQUF1RCxFQUhuRCxFQUlKRCxVQUFVSyxXQUFWLEdBQXdCLEtBQUt3QyxzQkFBTCxDQUE0QnhDLFdBQTVCLENBQXhCLEdBQW1FLEVBSi9ELEVBS0pMLFVBQVV5QyxNQUFWLEdBQW1CLEtBQUtLLGdCQUFMLENBQXNCTCxNQUF0QixDQUFuQixHQUFtRCxFQUwvQyxDQUFQO0FBT0Q7Ozt1Q0FFa0J4QyxPLEVBQVM7QUFDMUIsYUFBTztBQUNMOEMsc0JBQWMsQ0FBQzlDLFFBQVFDLENBQVQsRUFBWUQsUUFBUUUsQ0FBcEIsRUFBdUJGLFFBQVFHLENBQS9CO0FBRFQsT0FBUDtBQUdEOzs7MkNBRXNCQyxXLEVBQWE7QUFBQSxVQUMzQkssS0FEMkIsR0FDUEwsV0FETyxDQUMzQkssS0FEMkI7QUFBQSxVQUNwQkosU0FEb0IsR0FDUEQsV0FETyxDQUNwQkMsU0FEb0I7O0FBR2xDOztBQUNBLFVBQU0wQyxNQUFNLGtCQUFZMUMsVUFBVUMsQ0FBdEIsRUFBeUJELFVBQVVFLENBQW5DLEVBQXNDRixVQUFVRyxDQUFoRCxFQUNUd0MsU0FEUyxHQUVUQyxLQUZTLENBRUgsQ0FBQyxDQUZFLEVBRUMsQ0FBQyxDQUZGLEVBRUssQ0FBQyxDQUZOLENBQVo7O0FBSUEsYUFBTztBQUNMQywwQkFBa0IsQ0FBQ3pDLE1BQU1SLENBQVAsRUFBVVEsTUFBTVAsQ0FBaEIsRUFBbUJPLE1BQU1OLENBQXpCLENBRGI7QUFFTGdELDJCQUFtQixDQUFDSixJQUFJekMsQ0FBTCxFQUFReUMsSUFBSXhDLENBQVosRUFBZXdDLElBQUl2QyxDQUFuQjtBQUZkLE9BQVA7QUFJRDs7O3FDQUVnQmdDLE0sRUFBUTtBQUN2QkEsZUFBU0Esa0JBQWtCWSxLQUFsQixHQUEwQlosTUFBMUIsR0FBbUMsQ0FBQ0EsTUFBRCxDQUE1QztBQUNBLFVBQU1hLGVBQWViLE9BQU9jLE1BQTVCO0FBQ0EsVUFBTXJCLFdBQVcsRUFBQ29CLDBCQUFELEVBQWpCOztBQUVBLFVBQU1FLGlCQUFpQixFQUF2QjtBQUNBLFVBQU1DLGNBQWMsRUFBcEI7QUFDQSxVQUFNQyxpQkFBaUIsRUFBdkI7QUFDQSxVQUFNQyxzQkFBc0IsRUFBNUI7QUFSdUI7QUFBQTtBQUFBOztBQUFBO0FBU3ZCLDZCQUFvQmxCLE1BQXBCLDhIQUE0QjtBQUFBLGNBQWpCbUIsS0FBaUI7QUFBQSxjQUNuQkMsUUFEbUIsR0FDbUJELEtBRG5CLENBQ25CQyxRQURtQjtBQUFBLGNBQ1RuRCxLQURTLEdBQ21Ca0QsS0FEbkIsQ0FDVGxELEtBRFM7QUFBQSxjQUNGb0QsT0FERSxHQUNtQkYsS0FEbkIsQ0FDRkUsT0FERTtBQUFBLGNBQ09DLFFBRFAsR0FDbUJILEtBRG5CLENBQ09HLFFBRFA7O0FBRTFCLGNBQU1DLGFBQWF0RCxTQUFTb0QsT0FBNUI7O0FBRUFOLHlCQUFlUyxJQUFmLENBQW9CSixTQUFTdEQsQ0FBN0IsRUFBZ0NzRCxTQUFTckQsQ0FBekMsRUFBNENxRCxTQUFTcEQsQ0FBckQ7QUFDQWdELHNCQUFZUSxJQUFaLENBQWlCRCxXQUFXOUQsQ0FBNUIsRUFBK0I4RCxXQUFXN0QsQ0FBMUMsRUFBNkM2RCxXQUFXNUQsQ0FBeEQ7O0FBRUE7QUFDQXNELHlCQUFlTyxJQUFmLENBQW9CQyxPQUFPQyxRQUFRSixRQUFSLENBQVAsQ0FBcEI7QUFDQSxjQUFJQSxRQUFKLEVBQWM7QUFDWkosZ0NBQW9CTSxJQUFwQixDQUF5QkYsU0FBUzdELENBQWxDLEVBQXFDNkQsU0FBUzVELENBQTlDLEVBQWlENEQsU0FBUzNELENBQTFEO0FBQ0QsV0FGRCxNQUVPO0FBQ0x1RCxnQ0FBb0JNLElBQXBCLENBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CO0FBQ0Q7QUFDRjtBQXZCc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF5QnZCLFVBQUlULGVBQWVELE1BQW5CLEVBQTJCO0FBQ3pCaEMsZUFBT2MsTUFBUCxDQUFjSCxRQUFkLEVBQXdCO0FBQ3RCa0MseUJBQWVaLGNBRE87QUFFdEJRLHNCQUFZUCxXQUZVO0FBR3RCQyx3Q0FIc0I7QUFJdEJXLDhCQUFvQlY7QUFKRSxTQUF4QjtBQU1EOztBQUVELGFBQU96QixRQUFQO0FBQ0Q7O0FBRUQ7Ozs7eUNBQ3FCO0FBQUEsVUFDWnRCLEdBRFksR0FDTCxLQUFLUyxNQUFMLENBQVlWLE9BRFAsQ0FDWkMsR0FEWTs7O0FBR25CLFVBQUlBLEdBQUosRUFBUztBQUFBLHlCQUNvQ0EsR0FEcEMsQ0FDQUYsS0FEQTtBQUFBLFlBQ0FBLEtBREEsOEJBQ1EsRUFBQ1IsR0FBRyxHQUFKLEVBQVNDLEdBQUcsR0FBWixFQUFpQkMsR0FBRyxHQUFwQixFQURSOztBQUVQLGVBQU87QUFDTGtFLGtCQUFRLElBREg7QUFFTEMsbUJBQVMzRCxJQUFJNEQsSUFGUjtBQUdMQyxrQkFBUTdELElBQUk4RCxHQUhQO0FBSUxDLG9CQUFVLENBQUNqRSxNQUFNUixDQUFQLEVBQVVRLE1BQU1QLENBQWhCLEVBQW1CTyxNQUFNTixDQUF6QjtBQUpMLFNBQVA7QUFNRDtBQUNELGFBQU8sRUFBQ2tFLFFBQVEsS0FBVCxFQUFQO0FBQ0Q7Ozs7OztrQkFuS2tCcEQsSzs7O0FBc0tyQkEsTUFBTTBELFlBQU4sR0FBcUIsQ0FBckI7QUFDQTFELE1BQU0yRCxnQkFBTixHQUF5QixDQUF6QjtBQUNBM0QsTUFBTTRELFdBQU4sR0FBb0IsQ0FBcEIiLCJmaWxlIjoic2NlbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTY2VuZSBPYmplY3QgbWFuYWdlbWVudCBhbmQgcmVuZGVyaW5nXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgbm8tdHJ5LWNhdGNoICovXG5pbXBvcnQge1ZlY3RvcjN9IGZyb20gJy4uLy4uL3BhY2thZ2VzL21hdGgnO1xuaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vZ3JvdXAnO1xuaW1wb3J0IHtwaWNrTW9kZWxzfSBmcm9tICcuL3BpY2snO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBJTlZBTElEX0FSR1VNRU5UID0gJ0x1bWFHTC5TY2VuZSBpbnZhbGlkIGFyZ3VtZW50JztcblxuY29uc3QgREVGQVVMVF9TQ0VORV9PUFRTID0ge1xuICBsaWdodHM6IHtcbiAgICBlbmFibGU6IGZhbHNlLFxuICAgIC8vIGFtYmllbnQgbGlnaHRcbiAgICBhbWJpZW50OiB7cjogMC4yLCBnOiAwLjIsIGI6IDAuMn0sXG4gICAgLy8gZGlyZWN0aW9uYWwgbGlnaHRcbiAgICBkaXJlY3Rpb25hbDoge1xuICAgICAgZGlyZWN0aW9uOiB7eDogMSwgeTogMSwgejogMX0sXG4gICAgICBjb2xvcjoge3I6IDAsIGc6IDAsIGI6IDB9XG4gICAgfVxuICAgIC8vIHBvaW50IGxpZ2h0XG4gICAgLy8gcG9pbnRzOiBbXVxuICB9LFxuICBlZmZlY3RzOiB7XG4gICAgZm9nOiBmYWxzZVxuICAgIC8vIHsgbmVhciwgZmFyLCBjb2xvciB9XG4gIH0sXG4gIGNsZWFyQ29sb3I6IHRydWUsXG4gIGNsZWFyRGVwdGg6IHRydWUsXG4gIGJhY2tncm91bmRDb2xvcjoge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9LFxuICBiYWNrZ3JvdW5kRGVwdGg6IDFcbn07XG5cbi8vIFNjZW5lIGNsYXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSBleHRlbmRzIEdyb3VwIHtcblxuICBjb25zdHJ1Y3RvcihnbCwgb3B0cykge1xuICAgIGFzc2VydChnbCwgSU5WQUxJRF9BUkdVTUVOVCk7XG5cbiAgICBvcHRzID0gbWVyZ2UoREVGQVVMVF9TQ0VORV9PUFRTLCBvcHRzKTtcblxuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuY29uZmlnID0gb3B0cztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHJlZHJhdztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgdGhpcy50cmF2ZXJzZShtb2RlbCA9PiB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbW9kZWwuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNsZWFyQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJnID0gdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZ2wuY2xlYXJDb2xvcihiZy5yLCBiZy5nLCBiZy5iLCBiZy5hKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmNsZWFyRGVwdGgpIHtcbiAgICAgIGdsLmNsZWFyRGVwdGgodGhpcy5jb25maWcuYmFja2dyb3VuZERlcHRoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmNsZWFyQ29sb3IgJiYgdGhpcy5jb25maWcuY2xlYXJEZXB0aCkge1xuICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuY2xlYXJDb2xvcikge1xuICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5jbGVhckRlcHRoKSB7XG4gICAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBSZW5kZXJzIGFsbCBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAgcmVuZGVyKHVuaWZvcm1zID0ge30pIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIG1vZGVsIGFuZCByZW5kZXIgaXQuXG4gICAgdGhpcy50cmF2ZXJzZShtb2RlbCA9PiB7XG4gICAgICBpZiAobW9kZWwuZGlzcGxheSkge1xuICAgICAgICB0aGlzLnJlbmRlck9iamVjdCh7bW9kZWwsIHVuaWZvcm1zfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW5kZXJPYmplY3Qoe21vZGVsLCB1bmlmb3Jtc30pIHtcbiAgICAvLyBTZXR1cCBsaWdodGluZyBhbmQgc2NlbmUgZWZmZWN0cyBsaWtlIGZvZywgZXRjLlxuICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTY2VuZVVuaWZvcm1zKCksIHVuaWZvcm1zKTtcbiAgICBtb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGlja01vZGVscyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7eCwgeSwgdW5pZm9ybXMgPSB7fX0gPSBvcHRzO1xuICAgIHJldHVybiBwaWNrTW9kZWxzKHRoaXMuZ2wsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgZ3JvdXA6IHRoaXMsXG4gICAgICB4LCB5LFxuICAgICAgdW5pZm9ybXNcbiAgICB9LCBvcHRzKSk7XG4gIH1cblxuICAvLyBTZXR1cCB0aGUgbGlnaHRpbmcgc3lzdGVtOiBhbWJpZW50LCBkaXJlY3Rpb25hbCwgcG9pbnQgbGlnaHRzLlxuICBnZXRTY2VuZVVuaWZvcm1zKCkge1xuICAgIC8vIFNldHVwIExpZ2h0aW5nXG4gICAgY29uc3Qge2VuYWJsZSwgYW1iaWVudCwgZGlyZWN0aW9uYWwsIHBvaW50c30gPSB0aGlzLmNvbmZpZy5saWdodHM7XG5cbiAgICAvLyBTZXQgbGlnaHQgdW5pZm9ybXMuIEFtYmllbnQgYW5kIGRpcmVjdGlvbmFsIGxpZ2h0cy5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIHRoaXMuZ2V0RWZmZWN0c1VuaWZvcm1zKCksXG4gICAgICB7ZW5hYmxlTGlnaHRzOiBlbmFibGV9LFxuICAgICAgKGVuYWJsZSAmJiBhbWJpZW50ID8gdGhpcy5nZXRBbWJpZW50VW5pZm9ybXMoYW1iaWVudCkgOiB7fSksXG4gICAgICAoZW5hYmxlICYmIGRpcmVjdGlvbmFsID8gdGhpcy5nZXREaXJlY3Rpb25hbFVuaWZvcm1zKGRpcmVjdGlvbmFsKSA6IHt9KSxcbiAgICAgIChlbmFibGUgJiYgcG9pbnRzID8gdGhpcy5nZXRQb2ludFVuaWZvcm1zKHBvaW50cykgOiB7fSlcbiAgICApO1xuICB9XG5cbiAgZ2V0QW1iaWVudFVuaWZvcm1zKGFtYmllbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW1iaWVudENvbG9yOiBbYW1iaWVudC5yLCBhbWJpZW50LmcsIGFtYmllbnQuYl1cbiAgICB9O1xuICB9XG5cbiAgZ2V0RGlyZWN0aW9uYWxVbmlmb3JtcyhkaXJlY3Rpb25hbCkge1xuICAgIGNvbnN0IHtjb2xvciwgZGlyZWN0aW9ufSA9IGRpcmVjdGlvbmFsO1xuXG4gICAgLy8gTm9ybWFsaXplIGxpZ2h0aW5nIGRpcmVjdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBkaXIgPSBuZXcgVmVjdG9yMyhkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnksIGRpcmVjdGlvbi56KVxuICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAuc2NhbGUoLTEsIC0xLCAtMSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uYWxDb2xvcjogW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdLFxuICAgICAgbGlnaHRpbmdEaXJlY3Rpb246IFtkaXIueCwgZGlyLnksIGRpci56XVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludFVuaWZvcm1zKHBvaW50cykge1xuICAgIHBvaW50cyA9IHBvaW50cyBpbnN0YW5jZW9mIEFycmF5ID8gcG9pbnRzIDogW3BvaW50c107XG4gICAgY29uc3QgbnVtYmVyUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtudW1iZXJQb2ludHN9O1xuXG4gICAgY29uc3QgcG9pbnRMb2NhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBwb2ludENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGVuYWJsZVNwZWN1bGFyID0gW107XG4gICAgY29uc3QgcG9pbnRTcGVjdWxhckNvbG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIGNvbG9yLCBkaWZmdXNlLCBzcGVjdWxhcn0gPSBwb2ludDtcbiAgICAgIGNvbnN0IHBvaW50Q29sb3IgPSBjb2xvciB8fCBkaWZmdXNlO1xuXG4gICAgICBwb2ludExvY2F0aW9ucy5wdXNoKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgcG9pbnRDb2xvcnMucHVzaChwb2ludENvbG9yLnIsIHBvaW50Q29sb3IuZywgcG9pbnRDb2xvci5iKTtcblxuICAgICAgLy8gQWRkIHNwZWN1bGFyIGNvbG9yXG4gICAgICBlbmFibGVTcGVjdWxhci5wdXNoKE51bWJlcihCb29sZWFuKHNwZWN1bGFyKSkpO1xuICAgICAgaWYgKHNwZWN1bGFyKSB7XG4gICAgICAgIHBvaW50U3BlY3VsYXJDb2xvcnMucHVzaChzcGVjdWxhci5yLCBzcGVjdWxhci5nLCBzcGVjdWxhci5iKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50U3BlY3VsYXJDb2xvcnMucHVzaCgwLCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9pbnRMb2NhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCB7XG4gICAgICAgIHBvaW50TG9jYXRpb246IHBvaW50TG9jYXRpb25zLFxuICAgICAgICBwb2ludENvbG9yOiBwb2ludENvbG9ycyxcbiAgICAgICAgZW5hYmxlU3BlY3VsYXIsXG4gICAgICAgIHBvaW50U3BlY3VsYXJDb2xvcjogcG9pbnRTcGVjdWxhckNvbG9yc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xuICB9XG5cbiAgLy8gU2V0dXAgZWZmZWN0cyBsaWtlIGZvZywgZXRjLlxuICBnZXRFZmZlY3RzVW5pZm9ybXMoKSB7XG4gICAgY29uc3Qge2ZvZ30gPSB0aGlzLmNvbmZpZy5lZmZlY3RzO1xuXG4gICAgaWYgKGZvZykge1xuICAgICAgY29uc3Qge2NvbG9yID0ge3I6IDAuNSwgZzogMC41LCBiOiAwLjV9fSA9IGZvZztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc0ZvZzogdHJ1ZSxcbiAgICAgICAgZm9nTmVhcjogZm9nLm5lYXIsXG4gICAgICAgIGZvZ0ZhcjogZm9nLmZhcixcbiAgICAgICAgZm9nQ29sb3I6IFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtoYXNGb2c6IGZhbHNlfTtcbiAgfVxufVxuXG5TY2VuZS5NQVhfVEVYVFVSRVMgPSA0O1xuU2NlbmUuTUFYX1BPSU5UX0xJR0hUUyA9IDQ7XG5TY2VuZS5QSUNLSU5HX1JFUyA9IDQ7XG4iXX0=

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = "#define SHADER_NAME luma-default-fragment\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// varyings\nvarying vec4 vColor;\nvarying vec4 vPickingColor;\nvarying vec2 vTexCoord;\nvarying vec3 lightWeighting;\nvarying vec3 vReflection;\nvarying vec4 vNormal;\n\n// texture configs\nuniform bool hasTexture1;\nuniform sampler2D sampler1;\nuniform bool hasTextureCube1;\nuniform samplerCube samplerCube1;\n\n// picking configs\nuniform bool enablePicking;\nuniform bool hasPickingColors;\nuniform vec3 pickColor;\n\n// reflection / refraction configs\nuniform float reflection;\nuniform float refraction;\n\n// fog configuration\nuniform bool hasFog;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main(){\n  // set color from texture\n  if (!hasTexture1) {\n    gl_FragColor = vec4(vColor.rgb * lightWeighting, vColor.a);\n  } else {\n    gl_FragColor =\n      vec4(texture2D(sampler1, vec2(vTexCoord.s, vTexCoord.t)).rgb *\n      lightWeighting, 1.0);\n  }\n\n  // has cube texture then apply reflection\n  // if (hasTextureCube1) {\n  //   vec3 nReflection = normalize(vReflection);\n  //   vec3 reflectionValue;\n  //   if (refraction > 0.0) {\n  //    reflectionValue = refract(nReflection, vNormal.xyz, refraction);\n  //   } else {\n  //    reflectionValue = -reflect(nReflection, vNormal.xyz);\n  //   }\n\n  //   // TODO(nico): check whether this is right.\n  //   vec4 cubeColor = textureCube(samplerCube1,\n  //       vec3(-reflectionValue.x, -reflectionValue.y, reflectionValue.z));\n  //   gl_FragColor = vec4(mix(gl_FragColor.xyz, cubeColor.xyz, reflection), 1.0);\n  // }\n\n  // set picking\n  if (enablePicking) {\n    if (hasPickingColors) {\n      gl_FragColor = vPickingColor;\n    } else {\n      gl_FragColor = vec4(pickColor, 1.0);\n    }\n  }\n\n  // handle fog\n  // if (hasFog) {\n  //   float depth = gl_FragCoord.z / gl_FragCoord.w;\n  //   float fogFactor = smoothstep(fogNear, fogFar, depth);\n  //   gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);\n  // }\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJkZWZhdWx0LWZyYWdtZW50Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6W119

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  hasTexture1: false,
  hasTextureCube1: false,

  enableLights: false,
  useReflection: false,

  // picking configs
  enablePicking: false,
  hasPickingColors: false,

  // fog configuration
  hasFog: false
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkL3NoYWRlcmxpYi9kZWZhdWx0LXVuaWZvcm1zLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJoYXNUZXh0dXJlMSIsImhhc1RleHR1cmVDdWJlMSIsImVuYWJsZUxpZ2h0cyIsInVzZVJlZmxlY3Rpb24iLCJlbmFibGVQaWNraW5nIiwiaGFzUGlja2luZ0NvbG9ycyIsImhhc0ZvZyJdLCJtYXBwaW5ncyI6Ijs7QUFBQUEsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxlQUFhLEtBREU7QUFFZkMsbUJBQWlCLEtBRkY7O0FBSWZDLGdCQUFjLEtBSkM7QUFLZkMsaUJBQWUsS0FMQTs7QUFPZjtBQUNBQyxpQkFBZSxLQVJBO0FBU2ZDLG9CQUFrQixLQVRIOztBQVdmO0FBQ0FDLFVBQVE7QUFaTyxDQUFqQiIsImZpbGUiOiJkZWZhdWx0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc1RleHR1cmUxOiBmYWxzZSxcbiAgaGFzVGV4dHVyZUN1YmUxOiBmYWxzZSxcblxuICBlbmFibGVMaWdodHM6IGZhbHNlLFxuICB1c2VSZWZsZWN0aW9uOiBmYWxzZSxcblxuICAvLyBwaWNraW5nIGNvbmZpZ3NcbiAgZW5hYmxlUGlja2luZzogZmFsc2UsXG4gIGhhc1BpY2tpbmdDb2xvcnM6IGZhbHNlLFxuXG4gIC8vIGZvZyBjb25maWd1cmF0aW9uXG4gIGhhc0ZvZzogZmFsc2Vcbn07XG4iXX0=

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = "#define SHADER_NAME luma-default-vertex\n\n#define LIGHT_MAX 4\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec4 pickingColors;\nattribute vec2 texCoords;\n\n// camera and object matrices\nuniform mat4 viewMatrix;\nuniform mat4 viewInverseMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\n\n// objectMatrix * viewMatrix = worldMatrix\nuniform mat4 worldMatrix;\nuniform mat4 worldInverseMatrix;\nuniform mat4 worldInverseTransposeMatrix;\nuniform mat4 objectMatrix;\nuniform vec3 cameraPosition;\n\n// lighting configuration\nuniform bool enableLights;\nuniform vec3 ambientColor;\nuniform vec3 directionalColor;\nuniform vec3 lightingDirection;\n\n// point lights configuration\nuniform vec3 pointLocation[LIGHT_MAX];\nuniform vec3 pointColor[LIGHT_MAX];\nuniform int numberPoints;\n\n// reflection / refraction configuration\nuniform bool useReflection;\n\n// varyings\nvarying vec3 vReflection;\nvarying vec4 vColor;\nvarying vec4 vPickingColor;\nvarying vec2 vTexCoord;\nvarying vec4 vNormal;\nvarying vec3 lightWeighting;\n\nvoid main(void) {\n  vec4 mvPosition = worldMatrix * vec4(positions, 1.0);\n  vec4 transformedNormal = worldInverseTransposeMatrix * vec4(normals, 1.0);\n\n  // lighting code\n  if(!enableLights) {\n    lightWeighting = vec3(1.0, 1.0, 1.0);\n  } else {\n    vec3 plightDirection;\n    vec3 pointWeight = vec3(0.0, 0.0, 0.0);\n    float directionalLightWeighting =\n      max(dot(transformedNormal.xyz, lightingDirection), 0.0);\n    for (int i = 0; i < LIGHT_MAX; i++) {\n      if (i < numberPoints) {\n        plightDirection = normalize(\n          (viewMatrix * vec4(pointLocation[i], 1.0)).xyz - mvPosition.xyz);\n         pointWeight += max(\n          dot(transformedNormal.xyz, plightDirection), 0.0) * pointColor[i];\n       } else {\n         break;\n       }\n     }\n\n    lightWeighting = ambientColor +\n      (directionalColor * directionalLightWeighting) + pointWeight;\n  }\n\n  // refraction / reflection code\n  if (useReflection) {\n    vReflection =\n      (viewInverseMatrix[3] - (worldMatrix * vec4(positions, 1.0))).xyz;\n  } else {\n    vReflection = vec3(1.0, 1.0, 1.0);\n  }\n\n  // pass results to varyings\n  vColor = colors;\n  vPickingColor = pickingColors;\n  vTexCoord = texCoords;\n  vNormal = transformedNormal;\n  gl_Position = projectionMatrix * worldMatrix * vec4(positions, 1.0);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJkZWZhdWx0LXZlcnRleC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOltdfQ==

/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("// fog configuration\nuniform bool fog_uEnable;\nuniform vec3 fog_uColor;\nuniform float fog_uNear;\nuniform float fog_uFar;\n\n/*\n * Applies linear fog to a color\n * param - unfogged color\n * return - fogged color\n */\nvec4 fog_filterColor(vec4 color) {\n  if (fog_uEnable) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep(fog_uNear, fog_uFar, depth);\n    return mix(color, vec4(fog_uColor, gl_FragColor.w), fogFactor);\n  } else {\n  \treturn color;\n  }\n}\n\n// Other fog shaders, exponential etc, see\n// http://in2gpu.com/2014/07/22/create-fog-shader/\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvZm9nL2ZvZy1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImZvZy1mcmFnbWVudC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgYFxcXG4vLyBmb2cgY29uZmlndXJhdGlvblxudW5pZm9ybSBib29sIGZvZ191RW5hYmxlO1xudW5pZm9ybSB2ZWMzIGZvZ191Q29sb3I7XG51bmlmb3JtIGZsb2F0IGZvZ191TmVhcjtcbnVuaWZvcm0gZmxvYXQgZm9nX3VGYXI7XG5cbi8qXG4gKiBBcHBsaWVzIGxpbmVhciBmb2cgdG8gYSBjb2xvclxuICogcGFyYW0gLSB1bmZvZ2dlZCBjb2xvclxuICogcmV0dXJuIC0gZm9nZ2VkIGNvbG9yXG4gKi9cbnZlYzQgZm9nX2ZpbHRlckNvbG9yKHZlYzQgY29sb3IpIHtcbiAgaWYgKGZvZ191RW5hYmxlKSB7XG4gICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xuICAgIGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoZm9nX3VOZWFyLCBmb2dfdUZhciwgZGVwdGgpO1xuICAgIHJldHVybiBtaXgoY29sb3IsIHZlYzQoZm9nX3VDb2xvciwgZ2xfRnJhZ0NvbG9yLncpLCBmb2dGYWN0b3IpO1xuICB9IGVsc2Uge1xuICBcdHJldHVybiBjb2xvcjtcbiAgfVxufVxuXG4vLyBPdGhlciBmb2cgc2hhZGVycywgZXhwb25lbnRpYWwgZXRjLCBzZWVcbi8vIGh0dHA6Ly9pbjJncHUuY29tLzIwMTQvMDcvMjIvY3JlYXRlLWZvZy1zaGFkZXIvXG5gO1xuIl19

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return vertexShader; });
/* harmony export (immutable) */ __webpack_exports__["getUniforms"] = getUniforms;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fog_fragment_glsl__ = __webpack_require__(224);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentShader", function() { return __WEBPACK_IMPORTED_MODULE_0__fog_fragment_glsl__["a"]; });
var name = 'fog';
var vertexShader = '';


/* eslint-disable camelcase */
function getUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$fogEnable = _ref.fogEnable,
      fogEnable = _ref$fogEnable === undefined ? false : _ref$fogEnable,
      _ref$fogColor = _ref.fogColor,
      fogColor = _ref$fogColor === undefined ? [0.5, 0.5, 0.5] : _ref$fogColor,
      _ref$fogNear = _ref.fogNear,
      fogNear = _ref$fogNear === undefined ? 1 : _ref$fogNear,
      _ref$fogFar = _ref.fogFar,
      fogFar = _ref$fogFar === undefined ? 100 : _ref$fogFar;

  return {
    fog_uEnable: fogEnable,
    fog_uColor: fogColor,
    fog_uNear: fogNear,
    fog_uFar: fogFar
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvZm9nL2luZGV4LmpzIl0sIm5hbWVzIjpbIm5hbWUiLCJ2ZXJ0ZXhTaGFkZXIiLCJkZWZhdWx0IiwiZnJhZ21lbnRTaGFkZXIiLCJnZXRVbmlmb3JtcyIsImZvZ0VuYWJsZSIsImZvZ0NvbG9yIiwiZm9nTmVhciIsImZvZ0ZhciIsImZvZ191RW5hYmxlIiwiZm9nX3VDb2xvciIsImZvZ191TmVhciIsImZvZ191RmFyIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLElBQU1BLE9BQU8sS0FBYjtBQUNQLE9BQU8sSUFBTUMsZUFBZSxFQUFyQjtBQUNQLFNBQVFDLFdBQVdDLGNBQW5CLFFBQXdDLHFCQUF4Qzs7QUFFQTtBQUNBLE9BQU8sU0FBU0MsV0FBVCxHQUtDO0FBQUEsaUZBQUosRUFBSTtBQUFBLDRCQUpOQyxTQUlNO0FBQUEsTUFKTkEsU0FJTSxrQ0FKTSxLQUlOO0FBQUEsMkJBSE5DLFFBR007QUFBQSxNQUhOQSxRQUdNLGlDQUhLLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBR0w7QUFBQSwwQkFGTkMsT0FFTTtBQUFBLE1BRk5BLE9BRU0sZ0NBRkksQ0FFSjtBQUFBLHlCQUROQyxNQUNNO0FBQUEsTUFETkEsTUFDTSwrQkFERyxHQUNIOztBQUNOLFNBQU87QUFDTEMsaUJBQWFKLFNBRFI7QUFFTEssZ0JBQVlKLFFBRlA7QUFHTEssZUFBV0osT0FITjtBQUlMSyxjQUFVSjtBQUpMLEdBQVA7QUFNRCIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBuYW1lID0gJ2ZvZyc7XG5leHBvcnQgY29uc3QgdmVydGV4U2hhZGVyID0gJyc7XG5leHBvcnQge2RlZmF1bHQgYXMgZnJhZ21lbnRTaGFkZXJ9IGZyb20gJy4vZm9nLWZyYWdtZW50Lmdsc2wnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtcyh7XG4gIGZvZ0VuYWJsZSA9IGZhbHNlLFxuICBmb2dDb2xvciA9IFswLjUsIDAuNSwgMC41XSxcbiAgZm9nTmVhciA9IDEsXG4gIGZvZ0ZhciA9IDEwMFxufSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgZm9nX3VFbmFibGU6IGZvZ0VuYWJsZSxcbiAgICBmb2dfdUNvbG9yOiBmb2dDb2xvcixcbiAgICBmb2dfdU5lYXI6IGZvZ05lYXIsXG4gICAgZm9nX3VGYXI6IGZvZ0ZhclxuICB9O1xufVxuIl19

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_fp64__ = __webpack_require__(94);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return __WEBPACK_IMPORTED_MODULE_0__math_fp64__["default"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fp64ify", function() { return __WEBPACK_IMPORTED_MODULE_0__math_fp64__["b"]; });
var name = 'fp64';


// JS Utilities

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvZnA2NC9pbmRleC5qcyJdLCJuYW1lcyI6WyJuYW1lIiwiZGVmYXVsdCIsInZlcnRleFNoYWRlciJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxJQUFNQSxPQUFPLE1BQWI7QUFDUCxTQUFRQyxXQUFXQyxZQUFuQixRQUFzQyxhQUF0Qzs7QUFFQTtBQUNBLGNBQWMsYUFBZCIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBuYW1lID0gJ2ZwNjQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcnRleFNoYWRlcn0gZnJvbSAnLi9tYXRoLWZwNjQnO1xuXG4vLyBKUyBVdGlsaXRpZXNcbmV4cG9ydCAqIGZyb20gJy4vbWF0aC1mcDY0JztcbiJdfQ==

/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_tools__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fp64__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__fog__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__picking__ = __webpack_require__(231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__material__ = __webpack_require__(228);






// import * as lighting from './lighting';


__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__shader_tools__["a" /* registerShaderModules */])([__WEBPACK_IMPORTED_MODULE_1__fp64__, __WEBPACK_IMPORTED_MODULE_2__fog__, __WEBPACK_IMPORTED_MODULE_3__picking__,
// lighting,
__WEBPACK_IMPORTED_MODULE_4__material__]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvaW5kZXguanMiXSwibmFtZXMiOlsicmVnaXN0ZXJTaGFkZXJNb2R1bGVzIiwiZnA2NCIsImZvZyIsInBpY2tpbmciLCJtYXRlcmlhbCJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEscUJBQVIsUUFBb0MsaUJBQXBDOztBQUVBLE9BQU8sS0FBS0MsSUFBWixNQUFzQixRQUF0Qjs7QUFFQSxPQUFPLEtBQUtDLEdBQVosTUFBcUIsT0FBckI7QUFDQSxPQUFPLEtBQUtDLE9BQVosTUFBeUIsV0FBekI7QUFDQTtBQUNBLE9BQU8sS0FBS0MsUUFBWixNQUEwQixZQUExQjs7QUFFQUosc0JBQXNCLENBQ3BCQyxJQURvQixFQUVwQkMsR0FGb0IsRUFHcEJDLE9BSG9CO0FBSXBCO0FBQ0FDLFFBTG9CLENBQXRCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtyZWdpc3RlclNoYWRlck1vZHVsZXN9IGZyb20gJy4uL3NoYWRlci10b29scyc7XG5cbmltcG9ydCAqIGFzIGZwNjQgZnJvbSAnLi9mcDY0JztcblxuaW1wb3J0ICogYXMgZm9nIGZyb20gJy4vZm9nJztcbmltcG9ydCAqIGFzIHBpY2tpbmcgZnJvbSAnLi9waWNraW5nJztcbi8vIGltcG9ydCAqIGFzIGxpZ2h0aW5nIGZyb20gJy4vbGlnaHRpbmcnO1xuaW1wb3J0ICogYXMgbWF0ZXJpYWwgZnJvbSAnLi9tYXRlcmlhbCc7XG5cbnJlZ2lzdGVyU2hhZGVyTW9kdWxlcyhbXG4gIGZwNjQsXG4gIGZvZyxcbiAgcGlja2luZyxcbiAgLy8gbGlnaHRpbmcsXG4gIG1hdGVyaWFsXG5dKTtcbiJdfQ==

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (immutable) */ __webpack_exports__["getUniforms"] = getUniforms;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__material_vertex_glsl__ = __webpack_require__(230);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return __WEBPACK_IMPORTED_MODULE_0__material_vertex_glsl__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_fragment_glsl__ = __webpack_require__(229);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentShader", function() { return __WEBPACK_IMPORTED_MODULE_1__material_fragment_glsl__["a"]; });
var name = 'material';



/* eslint-disable camelcase */
function getUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$enable = _ref.enable,
      enable = _ref$enable === undefined ? true : _ref$enable;

  return {
    picking_enable: enable
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvbWF0ZXJpYWwvaW5kZXguanMiXSwibmFtZXMiOlsibmFtZSIsImRlZmF1bHQiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsImdldFVuaWZvcm1zIiwiZW5hYmxlIiwicGlja2luZ19lbmFibGUiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sSUFBTUEsT0FBTyxVQUFiO0FBQ1AsU0FBUUMsV0FBV0MsWUFBbkIsUUFBc0Msd0JBQXRDO0FBQ0EsU0FBUUQsV0FBV0UsY0FBbkIsUUFBd0MsMEJBQXhDOztBQUVBO0FBQ0EsT0FBTyxTQUFTQyxXQUFULEdBRUM7QUFBQSxpRkFBSixFQUFJO0FBQUEseUJBRE5DLE1BQ007QUFBQSxNQUROQSxNQUNNLCtCQURHLElBQ0g7O0FBQ04sU0FBTztBQUNMQyxvQkFBZ0JEO0FBRFgsR0FBUDtBQUdEIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG5hbWUgPSAnbWF0ZXJpYWwnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcnRleFNoYWRlcn0gZnJvbSAnLi9tYXRlcmlhbC12ZXJ0ZXguZ2xzbCc7XG5leHBvcnQge2RlZmF1bHQgYXMgZnJhZ21lbnRTaGFkZXJ9IGZyb20gJy4vbWF0ZXJpYWwtZnJhZ21lbnQuZ2xzbCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaWZvcm1zKHtcbiAgZW5hYmxlID0gdHJ1ZVxufSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgcGlja2luZ19lbmFibGU6IGVuYWJsZVxuICB9O1xufVxuIl19

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("uniform vec3 material_uAmbientColor;\nuniform vec3 material_uDiffuseColor;\nuniform vec3 material_uSpecularColor;\nuniform vec3 material_uEmissiveColor;\n\n// reflection / refraction configs\nuniform float material_uReflection;\nuniform float material_uRefraction;\n\nuniform bool material_enableDiffuseMap;\nuniform bool material_enableSpecularMap;\nuniform bool material_enableEnvironmentMap;\n\nuniform sampler2D material_diffuseMap;\nuniform sampler2D material_specularMap;\nuniform samplerCube material_environmentMap;\n\nvarying vec2 material_vDiffuseTextureCoordinate;\nvarying vec2 material_vSpecularTextureCoordinate;\n\n// Get shininess from uniform or specular map\nfloat material_getShininess() {\n  float shininess = material_uShininess;\n  if (material_enableSpecularMap) {\n    shininess = texture2D(sampler2, vec2(vTexCoord1.s, vTexCoord1.t)).r * 255.0;\n  }\n\n  if (shininessVal > 255.0) {\n    shininessVal = shininess;\n  }\n\n  return shininess;\n}\n\n// If we have a standard (diffuse) texture, set color to texture\nvec4 material_filterColor_diffuseMap(vec4 color) {\n  if (material_enableDiffuseTexture) {\n    color = texture2D(material_uDiffuseTexture, material_vDiffuseTextureCoordinate);\n  }\n  return color;\n}\n\n// Environment map - cube texture\nvec4 material_filterColor_environmentMap(color)\n  if (material_enableEnvironmentMap) {\n    vec3 nReflection = normalize(material_vReflection);\n    vec3 reflectionValue;\n    if (material_uRefraction > 0.0) {\n     reflectionValue = refract(nReflection, material_vNormal, material_uRefraction);\n    } else {\n     reflectionValue = -reflect(nReflection, material_vNormal);\n    }\n\n    vec4 cubeColor = textureCube(material_uEnvironmentMap,\n      vec3(-reflectionValue.x, -reflectionValue.y, reflectionValue.z));\n    color = vec4(mix(color.rgb, cubeColor.rgb, reflection), color.a);\n  }\n  return color;\n}\n\nvec4 material_filterColor(vec4 color) {\n  color = material_filterColor_diffuseMap(color);\n  color = material_filterColor_environmentMap(color);\n  return color;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvbWF0ZXJpYWwvbWF0ZXJpYWwtZnJhZ21lbnQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJtYXRlcmlhbC1mcmFnbWVudC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgYFxcXG51bmlmb3JtIHZlYzMgbWF0ZXJpYWxfdUFtYmllbnRDb2xvcjtcbnVuaWZvcm0gdmVjMyBtYXRlcmlhbF91RGlmZnVzZUNvbG9yO1xudW5pZm9ybSB2ZWMzIG1hdGVyaWFsX3VTcGVjdWxhckNvbG9yO1xudW5pZm9ybSB2ZWMzIG1hdGVyaWFsX3VFbWlzc2l2ZUNvbG9yO1xuXG4vLyByZWZsZWN0aW9uIC8gcmVmcmFjdGlvbiBjb25maWdzXG51bmlmb3JtIGZsb2F0IG1hdGVyaWFsX3VSZWZsZWN0aW9uO1xudW5pZm9ybSBmbG9hdCBtYXRlcmlhbF91UmVmcmFjdGlvbjtcblxudW5pZm9ybSBib29sIG1hdGVyaWFsX2VuYWJsZURpZmZ1c2VNYXA7XG51bmlmb3JtIGJvb2wgbWF0ZXJpYWxfZW5hYmxlU3BlY3VsYXJNYXA7XG51bmlmb3JtIGJvb2wgbWF0ZXJpYWxfZW5hYmxlRW52aXJvbm1lbnRNYXA7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGVyaWFsX2RpZmZ1c2VNYXA7XG51bmlmb3JtIHNhbXBsZXIyRCBtYXRlcmlhbF9zcGVjdWxhck1hcDtcbnVuaWZvcm0gc2FtcGxlckN1YmUgbWF0ZXJpYWxfZW52aXJvbm1lbnRNYXA7XG5cbnZhcnlpbmcgdmVjMiBtYXRlcmlhbF92RGlmZnVzZVRleHR1cmVDb29yZGluYXRlO1xudmFyeWluZyB2ZWMyIG1hdGVyaWFsX3ZTcGVjdWxhclRleHR1cmVDb29yZGluYXRlO1xuXG4vLyBHZXQgc2hpbmluZXNzIGZyb20gdW5pZm9ybSBvciBzcGVjdWxhciBtYXBcbmZsb2F0IG1hdGVyaWFsX2dldFNoaW5pbmVzcygpIHtcbiAgZmxvYXQgc2hpbmluZXNzID0gbWF0ZXJpYWxfdVNoaW5pbmVzcztcbiAgaWYgKG1hdGVyaWFsX2VuYWJsZVNwZWN1bGFyTWFwKSB7XG4gICAgc2hpbmluZXNzID0gdGV4dHVyZTJEKHNhbXBsZXIyLCB2ZWMyKHZUZXhDb29yZDEucywgdlRleENvb3JkMS50KSkuciAqIDI1NS4wO1xuICB9XG5cbiAgaWYgKHNoaW5pbmVzc1ZhbCA+IDI1NS4wKSB7XG4gICAgc2hpbmluZXNzVmFsID0gc2hpbmluZXNzO1xuICB9XG5cbiAgcmV0dXJuIHNoaW5pbmVzcztcbn1cblxuLy8gSWYgd2UgaGF2ZSBhIHN0YW5kYXJkIChkaWZmdXNlKSB0ZXh0dXJlLCBzZXQgY29sb3IgdG8gdGV4dHVyZVxudmVjNCBtYXRlcmlhbF9maWx0ZXJDb2xvcl9kaWZmdXNlTWFwKHZlYzQgY29sb3IpIHtcbiAgaWYgKG1hdGVyaWFsX2VuYWJsZURpZmZ1c2VUZXh0dXJlKSB7XG4gICAgY29sb3IgPSB0ZXh0dXJlMkQobWF0ZXJpYWxfdURpZmZ1c2VUZXh0dXJlLCBtYXRlcmlhbF92RGlmZnVzZVRleHR1cmVDb29yZGluYXRlKTtcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cbi8vIEVudmlyb25tZW50IG1hcCAtIGN1YmUgdGV4dHVyZVxudmVjNCBtYXRlcmlhbF9maWx0ZXJDb2xvcl9lbnZpcm9ubWVudE1hcChjb2xvcilcbiAgaWYgKG1hdGVyaWFsX2VuYWJsZUVudmlyb25tZW50TWFwKSB7XG4gICAgdmVjMyBuUmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShtYXRlcmlhbF92UmVmbGVjdGlvbik7XG4gICAgdmVjMyByZWZsZWN0aW9uVmFsdWU7XG4gICAgaWYgKG1hdGVyaWFsX3VSZWZyYWN0aW9uID4gMC4wKSB7XG4gICAgIHJlZmxlY3Rpb25WYWx1ZSA9IHJlZnJhY3QoblJlZmxlY3Rpb24sIG1hdGVyaWFsX3ZOb3JtYWwsIG1hdGVyaWFsX3VSZWZyYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICByZWZsZWN0aW9uVmFsdWUgPSAtcmVmbGVjdChuUmVmbGVjdGlvbiwgbWF0ZXJpYWxfdk5vcm1hbCk7XG4gICAgfVxuXG4gICAgdmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZShtYXRlcmlhbF91RW52aXJvbm1lbnRNYXAsXG4gICAgICB2ZWMzKC1yZWZsZWN0aW9uVmFsdWUueCwgLXJlZmxlY3Rpb25WYWx1ZS55LCByZWZsZWN0aW9uVmFsdWUueikpO1xuICAgIGNvbG9yID0gdmVjNChtaXgoY29sb3IucmdiLCBjdWJlQ29sb3IucmdiLCByZWZsZWN0aW9uKSwgY29sb3IuYSk7XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG52ZWM0IG1hdGVyaWFsX2ZpbHRlckNvbG9yKHZlYzQgY29sb3IpIHtcbiAgY29sb3IgPSBtYXRlcmlhbF9maWx0ZXJDb2xvcl9kaWZmdXNlTWFwKGNvbG9yKTtcbiAgY29sb3IgPSBtYXRlcmlhbF9maWx0ZXJDb2xvcl9lbnZpcm9ubWVudE1hcChjb2xvcik7XG4gIHJldHVybiBjb2xvcjtcbn1cbmA7XG4iXX0=

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("/* Set the UV coordinate from attributes */\nvoid material_setUVs(diffuseUV, specularUV) {\n  material_vDiffuseUV = diffuseUV;\n  material_vSpecularUV = specularUV;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvbWF0ZXJpYWwvbWF0ZXJpYWwtdmVydGV4Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoibWF0ZXJpYWwtdmVydGV4Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBgXFxcbi8qIFNldCB0aGUgVVYgY29vcmRpbmF0ZSBmcm9tIGF0dHJpYnV0ZXMgKi9cbnZvaWQgbWF0ZXJpYWxfc2V0VVZzKGRpZmZ1c2VVViwgc3BlY3VsYXJVVikge1xuICBtYXRlcmlhbF92RGlmZnVzZVVWID0gZGlmZnVzZVVWO1xuICBtYXRlcmlhbF92U3BlY3VsYXJVViA9IHNwZWN1bGFyVVY7XG59XG5gO1xuIl19

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (immutable) */ __webpack_exports__["getUniforms"] = getUniforms;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__picking_vertex_glsl__ = __webpack_require__(233);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return __WEBPACK_IMPORTED_MODULE_0__picking_vertex_glsl__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__picking_fragment_glsl__ = __webpack_require__(232);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentShader", function() { return __WEBPACK_IMPORTED_MODULE_1__picking_fragment_glsl__["a"]; });
var name = 'picking';



/* eslint-disable camelcase */
function getUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$enable = _ref.enable,
      enable = _ref$enable === undefined ? true : _ref$enable;

  return {
    picking_enable: enable
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvcGlja2luZy9pbmRleC5qcyJdLCJuYW1lcyI6WyJuYW1lIiwiZGVmYXVsdCIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiZ2V0VW5pZm9ybXMiLCJlbmFibGUiLCJwaWNraW5nX2VuYWJsZSJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxJQUFNQSxPQUFPLFNBQWI7QUFDUCxTQUFRQyxXQUFXQyxZQUFuQixRQUFzQyx1QkFBdEM7QUFDQSxTQUFRRCxXQUFXRSxjQUFuQixRQUF3Qyx5QkFBeEM7O0FBRUE7QUFDQSxPQUFPLFNBQVNDLFdBQVQsR0FBMkM7QUFBQSxpRkFBSixFQUFJO0FBQUEseUJBQXJCQyxNQUFxQjtBQUFBLE1BQXJCQSxNQUFxQiwrQkFBWixJQUFZOztBQUNoRCxTQUFPO0FBQ0xDLG9CQUFnQkQ7QUFEWCxHQUFQO0FBR0QiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbmFtZSA9ICdwaWNraW5nJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJ0ZXhTaGFkZXJ9IGZyb20gJy4vcGlja2luZy12ZXJ0ZXguZ2xzbCc7XG5leHBvcnQge2RlZmF1bHQgYXMgZnJhZ21lbnRTaGFkZXJ9IGZyb20gJy4vcGlja2luZy1mcmFnbWVudC5nbHNsJztcblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pZm9ybXMoe2VuYWJsZSA9IHRydWV9ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBwaWNraW5nX2VuYWJsZTogZW5hYmxlXG4gIH07XG59XG4iXX0=

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("// picking configs\nuniform bool picking_uEnabled;\nvarying vec3 picking_vPickingColor;\n\n/*\n * Returns picking color if picking enabled\n * Note: Should be called last, picking color must not be modified.\n */\nvec4 picking_filterColor(vec4 color) {\n  // set picking\n  if (picking_uEnabled) {\n  \treturn picking_vPickingColor;\n  } else {\n  \treturn color;\n  }\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvcGlja2luZy9waWNraW5nLWZyYWdtZW50Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicGlja2luZy1mcmFnbWVudC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgYFxcXG4vLyBwaWNraW5nIGNvbmZpZ3NcbnVuaWZvcm0gYm9vbCBwaWNraW5nX3VFbmFibGVkO1xudmFyeWluZyB2ZWMzIHBpY2tpbmdfdlBpY2tpbmdDb2xvcjtcblxuLypcbiAqIFJldHVybnMgcGlja2luZyBjb2xvciBpZiBwaWNraW5nIGVuYWJsZWRcbiAqIE5vdGU6IFNob3VsZCBiZSBjYWxsZWQgbGFzdCwgcGlja2luZyBjb2xvciBtdXN0IG5vdCBiZSBtb2RpZmllZC5cbiAqL1xudmVjNCBwaWNraW5nX2ZpbHRlckNvbG9yKHZlYzQgY29sb3IpIHtcbiAgLy8gc2V0IHBpY2tpbmdcbiAgaWYgKHBpY2tpbmdfdUVuYWJsZWQpIHtcbiAgXHRyZXR1cm4gcGlja2luZ192UGlja2luZ0NvbG9yO1xuICB9IGVsc2Uge1xuICBcdHJldHVybiBjb2xvcjtcbiAgfVxufVxuYDtcbiJdfQ==

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("varying vec4 vColor;\nvarying vec4 picking_vColor;\n\n// Stores the picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  vPickingColor = pickingColors;\n}\n");
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLW1vZHVsZXMvcGlja2luZy9waWNraW5nLXZlcnRleC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InBpY2tpbmctdmVydGV4Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBgXFxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzQgcGlja2luZ192Q29sb3I7XG5cbi8vIFN0b3JlcyB0aGUgcGlja2luZyBjb2xvclxudm9pZCBwaWNraW5nX3NldFBpY2tpbmdDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xuICB2UGlja2luZ0NvbG9yID0gcGlja2luZ0NvbG9ycztcbn1cbmA7XG4iXX0=

/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export checkRendererVendor */
/* unused harmony export getPlatformShaderDefines */
/* harmony export (immutable) */ __webpack_exports__["a"] = assembleShaders;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__register_shaders__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);




var VERTEX_SHADER = 'vertexShader';
var FRAGMENT_SHADER = 'fragmentShader';

function checkRendererVendor(debugInfo, gpuVendor) {
  var vendor = debugInfo.vendor,
      renderer = debugInfo.renderer;

  var result = void 0;
  switch (gpuVendor) {
    case 'nvidia':
      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
      break;
    case 'intel':
      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
      break;
    case 'amd':
      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
      break;
    default:
      result = false;
  }
  return result;
}

function getPlatformShaderDefines(gl) {
  /* eslint-disable */
  var platformDefines = '';
  var debugInfo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__webgl__["glGetDebugInfo"])(gl);

  if (checkRendererVendor(debugInfo, 'nvidia')) {
    platformDefines += '#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'intel')) {
    platformDefines += '#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n #define INTEL_TAN_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'amd')) {
    platformDefines += '#define AMD_GPU\n';
  } else {
    platformDefines += '#define DEFAULT_GPU\n';
  }

  return platformDefines;
}

function assembleShader(gl, _ref) {
  var source = _ref.source,
      type = _ref.type,
      _ref$modules = _ref.modules,
      modules = _ref$modules === undefined ? [] : _ref$modules;

  __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof source === 'string', 'shader source must be a string');

  // Add platform defines
  var assembledSource = getPlatformShaderDefines(gl) + '\n';

  // Add dependent modules in resolved order
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var moduleName = _step.value;

      var shaderModule = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__register_shaders__["b" /* getShaderModule */])(moduleName);
      if (!shaderModule) {
        __WEBPACK_IMPORTED_MODULE_2_assert___default()(shaderModule, 'shader module is not defined');
      }
      var moduleSource = shaderModule[type];
      assembledSource += '// BEGIN SHADER MODULE ' + moduleName + '\n#define MODULE_' + moduleName.toUpperCase() + '\n' + moduleSource + '\n// END SHADER MODULE ' + moduleName;
    }

    // Add actual source of shader
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  assembledSource += source;

  return assembledSource;
}

/**
 * Apply set of modules
 */
function assembleShaders(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var vs = opts.vs,
      fs = opts.fs;

  var modules = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__register_shaders__["c" /* getShaderDependencies */])(opts.modules || []);
  return {
    gl: gl,
    vs: assembleShader(gl, Object.assign({}, opts, { source: vs, type: VERTEX_SHADER, modules: modules })),
    fs: assembleShader(gl, Object.assign({}, opts, { source: fs, type: FRAGMENT_SHADER, modules: modules }))
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLXRvb2xzL2Fzc2VtYmxlLXNoYWRlcnMuanMiXSwibmFtZXMiOlsiZ2V0U2hhZGVyRGVwZW5kZW5jaWVzIiwiZ2V0U2hhZGVyTW9kdWxlIiwiZ2xHZXREZWJ1Z0luZm8iLCJhc3NlcnQiLCJWRVJURVhfU0hBREVSIiwiRlJBR01FTlRfU0hBREVSIiwiY2hlY2tSZW5kZXJlclZlbmRvciIsImRlYnVnSW5mbyIsImdwdVZlbmRvciIsInZlbmRvciIsInJlbmRlcmVyIiwicmVzdWx0IiwibWF0Y2giLCJnZXRQbGF0Zm9ybVNoYWRlckRlZmluZXMiLCJnbCIsInBsYXRmb3JtRGVmaW5lcyIsImFzc2VtYmxlU2hhZGVyIiwic291cmNlIiwidHlwZSIsIm1vZHVsZXMiLCJhc3NlbWJsZWRTb3VyY2UiLCJtb2R1bGVOYW1lIiwic2hhZGVyTW9kdWxlIiwibW9kdWxlU291cmNlIiwidG9VcHBlckNhc2UiLCJhc3NlbWJsZVNoYWRlcnMiLCJvcHRzIiwidnMiLCJmcyIsIk9iamVjdCIsImFzc2lnbiJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEscUJBQVIsRUFBK0JDLGVBQS9CLFFBQXFELG9CQUFyRDtBQUNBLFNBQVFDLGNBQVIsUUFBNkIsYUFBN0I7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGdCQUFnQixjQUF0QjtBQUNBLElBQU1DLGtCQUFrQixnQkFBeEI7O0FBRUEsT0FBTyxTQUFTQyxtQkFBVCxDQUE2QkMsU0FBN0IsRUFBd0NDLFNBQXhDLEVBQW1EO0FBQUEsTUFDakRDLE1BRGlELEdBQzdCRixTQUQ2QixDQUNqREUsTUFEaUQ7QUFBQSxNQUN6Q0MsUUFEeUMsR0FDN0JILFNBRDZCLENBQ3pDRyxRQUR5Qzs7QUFFeEQsTUFBSUMsZUFBSjtBQUNBLFVBQVFILFNBQVI7QUFDQSxTQUFLLFFBQUw7QUFDRUcsZUFBU0YsT0FBT0csS0FBUCxDQUFhLFNBQWIsS0FBMkJGLFNBQVNF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QUFIQyxHQUFQO0FBS0QiLCJmaWxlIjoiYXNzZW1ibGUtc2hhZGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0U2hhZGVyRGVwZW5kZW5jaWVzLCBnZXRTaGFkZXJNb2R1bGV9IGZyb20gJy4vcmVnaXN0ZXItc2hhZGVycyc7XG5pbXBvcnQge2dsR2V0RGVidWdJbmZvfSBmcm9tICcuLi8uLi93ZWJnbCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IFZFUlRFWF9TSEFERVIgPSAndmVydGV4U2hhZGVyJztcbmNvbnN0IEZSQUdNRU5UX1NIQURFUiA9ICdmcmFnbWVudFNoYWRlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgZ3B1VmVuZG9yKSB7XG4gIGNvbnN0IHt2ZW5kb3IsIHJlbmRlcmVyfSA9IGRlYnVnSW5mbztcbiAgbGV0IHJlc3VsdDtcbiAgc3dpdGNoIChncHVWZW5kb3IpIHtcbiAgY2FzZSAnbnZpZGlhJzpcbiAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL05WSURJQS9pKSB8fCByZW5kZXJlci5tYXRjaCgvTlZJRElBL2kpO1xuICAgIGJyZWFrO1xuICBjYXNlICdpbnRlbCc6XG4gICAgcmVzdWx0ID0gdmVuZG9yLm1hdGNoKC9JTlRFTC9pKSB8fCByZW5kZXJlci5tYXRjaCgvSU5URUwvaSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FtZCc6XG4gICAgcmVzdWx0ID1cbiAgICAgIHZlbmRvci5tYXRjaCgvQU1EL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BTUQvaSkgfHxcbiAgICAgIHZlbmRvci5tYXRjaCgvQVRJL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BVEkvaSk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBsZXQgcGxhdGZvcm1EZWZpbmVzID0gJyc7XG4gIGNvbnN0IGRlYnVnSW5mbyA9IGdsR2V0RGVidWdJbmZvKGdsKTtcblxuICBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdudmlkaWEnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgTlZJRElBX0dQVVxuI2RlZmluZSBOVklESUFfRlA2NF9XT1JLQVJPVU5EIDFcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2ludGVsJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIElOVEVMX0dQVVxuI2RlZmluZSBJTlRFTF9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXFxuIFxcXG4jZGVmaW5lIElOVEVMX1RBTl9XT1JLQVJPVU5EIDFcbmA7XG4gIH0gZWxzZSBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdhbWQnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgQU1EX0dQVVxuYDtcbiAgfSBlbHNlIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIERFRkFVTFRfR1BVXG5gO1xuICB9XG5cbiAgcmV0dXJuIHBsYXRmb3JtRGVmaW5lcztcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXIoZ2wsIHtcbiAgc291cmNlLFxuICB0eXBlLFxuICBtb2R1bGVzID0gW11cbn0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnc2hhZGVyIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgLy8gQWRkIHBsYXRmb3JtIGRlZmluZXNcbiAgbGV0IGFzc2VtYmxlZFNvdXJjZSA9IGAke2dldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCl9XFxuYDtcblxuICAvLyBBZGQgZGVwZW5kZW50IG1vZHVsZXMgaW4gcmVzb2x2ZWQgb3JkZXJcbiAgZm9yIChjb25zdCBtb2R1bGVOYW1lIG9mIG1vZHVsZXMpIHtcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSBnZXRTaGFkZXJNb2R1bGUobW9kdWxlTmFtZSk7XG4gICAgaWYgKCFzaGFkZXJNb2R1bGUpIHtcbiAgICAgIGFzc2VydChzaGFkZXJNb2R1bGUsICdzaGFkZXIgbW9kdWxlIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZVNvdXJjZSA9IHNoYWRlck1vZHVsZVt0eXBlXTtcbiAgICBhc3NlbWJsZWRTb3VyY2UgKz0gYFxcXG4vLyBCRUdJTiBTSEFERVIgTU9EVUxFICR7bW9kdWxlTmFtZX1cbiNkZWZpbmUgTU9EVUxFXyR7bW9kdWxlTmFtZS50b1VwcGVyQ2FzZSgpfVxuJHttb2R1bGVTb3VyY2V9XG4vLyBFTkQgU0hBREVSIE1PRFVMRSAke21vZHVsZU5hbWV9YDtcbiAgfVxuXG4gIC8vIEFkZCBhY3R1YWwgc291cmNlIG9mIHNoYWRlclxuICBhc3NlbWJsZWRTb3VyY2UgKz0gc291cmNlO1xuXG4gIHJldHVybiBhc3NlbWJsZWRTb3VyY2U7XG59XG5cbi8qKlxuICogQXBwbHkgc2V0IG9mIG1vZHVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVycyhnbCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHt2cywgZnN9ID0gb3B0cztcbiAgY29uc3QgbW9kdWxlcyA9IGdldFNoYWRlckRlcGVuZGVuY2llcyhvcHRzLm1vZHVsZXMgfHwgW10pO1xuICByZXR1cm4ge1xuICAgIGdsLFxuICAgIHZzOiBhc3NlbWJsZVNoYWRlcihnbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge3NvdXJjZTogdnMsIHR5cGU6IFZFUlRFWF9TSEFERVIsIG1vZHVsZXN9KSksXG4gICAgZnM6IGFzc2VtYmxlU2hhZGVyKGdsLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7c291cmNlOiBmcywgdHlwZTogRlJBR01FTlRfU0hBREVSLCBtb2R1bGVzfSkpXG4gIH07XG59XG4iXX0=

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webgl__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var ERR_SOURCE = 'ShaderCache expects source strings';
var ERR_CONTEXT = 'ShaderCache does not support caching across multiple contexts';

var ShaderCache = function () {

  /**
   * A cache of compiled shaders, keyed by shader source strings.
   * Compilation of long shaders can be time consuming.
   * By using this class, the application can ensure that each shader
   * is only compiled once.
   */
  function ShaderCache() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        gl = _ref.gl;

    _classCallCheck(this, ShaderCache);

    this.gl = gl;
    this.vertexShaders = {};
    this.fragmentShaders = {};
  }

  /**
   * Deletes shader references
   * @return {ShaderCache} - returns this for chaining
   */


  _createClass(ShaderCache, [{
    key: 'delete',
    value: function _delete() {
      // TODO - requires reference counting to avoid deleting shaders in use
      return this;
    }

    /**
     * Returns a compiled `VertexShader` object corresponding to the supplied
     * GLSL source code string, if possible from cache.
     *
     * @param {WebGLRenderingContext} gl - gl context
     * @param {String} source - Source code for shader
     * @return {VertexShader} - a compiled vertex shader
     */

  }, {
    key: 'getVertexShader',
    value: function getVertexShader(gl, source) {
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(typeof source === 'string', ERR_SOURCE);

      var shader = this.vertexShaders[source];
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(!shader || shader.gl === gl, ERR_CONTEXT);

      if (!shader) {
        shader = new __WEBPACK_IMPORTED_MODULE_0__webgl__["VertexShader"](gl, source);
        this.vertexShaders[source] = shader;
      }
      return shader;
    }

    /**
     * Returns a compiled `VertexShader` object corresponding to the supplied
     * GLSL source code string, if possible from cache.
     *
     * @param {WebGLRenderingContext} gl - gl context
     * @param {String} source - Source code for shader
     * @return {FragmentShader} - a compiled fragment shader, possibly from chache
     */

  }, {
    key: 'getFragmentShader',
    value: function getFragmentShader(gl, source) {
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(typeof source === 'string', ERR_SOURCE);

      var shader = this.fragmentShaders[source];
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(!shader || shader.gl === gl, ERR_CONTEXT);

      if (!shader) {
        shader = new __WEBPACK_IMPORTED_MODULE_0__webgl__["FragmentShader"](gl, source);
        this.fragmentShaders[source] = shader;
      }
      return shader;
    }
  }]);

  return ShaderCache;
}();

/* harmony default export */ __webpack_exports__["a"] = (ShaderCache);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvc2hhZGVyLXRvb2xzL3NoYWRlci1jYWNoZS5qcyJdLCJuYW1lcyI6WyJWZXJ0ZXhTaGFkZXIiLCJGcmFnbWVudFNoYWRlciIsImFzc2VydCIsIkVSUl9TT1VSQ0UiLCJFUlJfQ09OVEVYVCIsIlNoYWRlckNhY2hlIiwiZ2wiLCJ2ZXJ0ZXhTaGFkZXJzIiwiZnJhZ21lbnRTaGFkZXJzIiwic291cmNlIiwic2hhZGVyIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBUUEsWUFBUixFQUFzQkMsY0FBdEIsUUFBMkMsYUFBM0M7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGFBQWEsb0NBQW5CO0FBQ0EsSUFBTUMsY0FBYywrREFBcEI7O0lBRXFCQyxXOztBQUVuQjs7Ozs7O0FBTUEseUJBQXVCO0FBQUEsbUZBQUosRUFBSTtBQUFBLFFBQVZDLEVBQVUsUUFBVkEsRUFBVTs7QUFBQTs7QUFDckIsU0FBS0EsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixFQUFyQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsRUFBdkI7QUFDRDs7QUFFRDs7Ozs7Ozs7OEJBSVM7QUFDUDtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7OztvQ0FRZ0JGLEUsRUFBSUcsTSxFQUFRO0FBQzFCUCxhQUFPLE9BQU9PLE1BQVAsS0FBa0IsUUFBekIsRUFBbUNOLFVBQW5DOztBQUVBLFVBQUlPLFNBQVMsS0FBS0gsYUFBTCxDQUFtQkUsTUFBbkIsQ0FBYjtBQUNBUCxhQUFPLENBQUNRLE1BQUQsSUFBV0EsT0FBT0osRUFBUCxLQUFjQSxFQUFoQyxFQUFvQ0YsV0FBcEM7O0FBRUEsVUFBSSxDQUFDTSxNQUFMLEVBQWE7QUFDWEEsaUJBQVMsSUFBSVYsWUFBSixDQUFpQk0sRUFBakIsRUFBcUJHLE1BQXJCLENBQVQ7QUFDQSxhQUFLRixhQUFMLENBQW1CRSxNQUFuQixJQUE2QkMsTUFBN0I7QUFDRDtBQUNELGFBQU9BLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7c0NBUWtCSixFLEVBQUlHLE0sRUFBUTtBQUM1QlAsYUFBTyxPQUFPTyxNQUFQLEtBQWtCLFFBQXpCLEVBQW1DTixVQUFuQzs7QUFFQSxVQUFJTyxTQUFTLEtBQUtGLGVBQUwsQ0FBcUJDLE1BQXJCLENBQWI7QUFDQVAsYUFBTyxDQUFDUSxNQUFELElBQVdBLE9BQU9KLEVBQVAsS0FBY0EsRUFBaEMsRUFBb0NGLFdBQXBDOztBQUVBLFVBQUksQ0FBQ00sTUFBTCxFQUFhO0FBQ1hBLGlCQUFTLElBQUlULGNBQUosQ0FBbUJLLEVBQW5CLEVBQXVCRyxNQUF2QixDQUFUO0FBQ0EsYUFBS0QsZUFBTCxDQUFxQkMsTUFBckIsSUFBK0JDLE1BQS9CO0FBQ0Q7QUFDRCxhQUFPQSxNQUFQO0FBQ0Q7Ozs7OztlQS9Ea0JMLFciLCJmaWxlIjoic2hhZGVyLWNhY2hlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtWZXJ0ZXhTaGFkZXIsIEZyYWdtZW50U2hhZGVyfSBmcm9tICcuLi8uLi93ZWJnbCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IEVSUl9TT1VSQ0UgPSAnU2hhZGVyQ2FjaGUgZXhwZWN0cyBzb3VyY2Ugc3RyaW5ncyc7XG5jb25zdCBFUlJfQ09OVEVYVCA9ICdTaGFkZXJDYWNoZSBkb2VzIG5vdCBzdXBwb3J0IGNhY2hpbmcgYWNyb3NzIG11bHRpcGxlIGNvbnRleHRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyQ2FjaGUge1xuXG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIGNvbXBpbGVkIHNoYWRlcnMsIGtleWVkIGJ5IHNoYWRlciBzb3VyY2Ugc3RyaW5ncy5cbiAgICogQ29tcGlsYXRpb24gb2YgbG9uZyBzaGFkZXJzIGNhbiBiZSB0aW1lIGNvbnN1bWluZy5cbiAgICogQnkgdXNpbmcgdGhpcyBjbGFzcywgdGhlIGFwcGxpY2F0aW9uIGNhbiBlbnN1cmUgdGhhdCBlYWNoIHNoYWRlclxuICAgKiBpcyBvbmx5IGNvbXBpbGVkIG9uY2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7Z2x9ID0ge30pIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXJzID0ge307XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHNoYWRlciByZWZlcmVuY2VzXG4gICAqIEByZXR1cm4ge1NoYWRlckNhY2hlfSAtIHJldHVybnMgdGhpcyBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGRlbGV0ZSgpIHtcbiAgICAvLyBUT0RPIC0gcmVxdWlyZXMgcmVmZXJlbmNlIGNvdW50aW5nIHRvIGF2b2lkIGRlbGV0aW5nIHNoYWRlcnMgaW4gdXNlXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbXBpbGVkIGBWZXJ0ZXhTaGFkZXJgIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdXBwbGllZFxuICAgKiBHTFNMIHNvdXJjZSBjb2RlIHN0cmluZywgaWYgcG9zc2libGUgZnJvbSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gZ2wgY29udGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gU291cmNlIGNvZGUgZm9yIHNoYWRlclxuICAgKiBAcmV0dXJuIHtWZXJ0ZXhTaGFkZXJ9IC0gYSBjb21waWxlZCB2ZXJ0ZXggc2hhZGVyXG4gICAqL1xuICBnZXRWZXJ0ZXhTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICAgIGFzc2VydCh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJywgRVJSX1NPVVJDRSk7XG5cbiAgICBsZXQgc2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXJzW3NvdXJjZV07XG4gICAgYXNzZXJ0KCFzaGFkZXIgfHwgc2hhZGVyLmdsID09PSBnbCwgRVJSX0NPTlRFWFQpO1xuXG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHNoYWRlciA9IG5ldyBWZXJ0ZXhTaGFkZXIoZ2wsIHNvdXJjZSk7XG4gICAgICB0aGlzLnZlcnRleFNoYWRlcnNbc291cmNlXSA9IHNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29tcGlsZWQgYFZlcnRleFNoYWRlcmAgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN1cHBsaWVkXG4gICAqIEdMU0wgc291cmNlIGNvZGUgc3RyaW5nLCBpZiBwb3NzaWJsZSBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBnbCBjb250ZXh0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgY29kZSBmb3Igc2hhZGVyXG4gICAqIEByZXR1cm4ge0ZyYWdtZW50U2hhZGVyfSAtIGEgY29tcGlsZWQgZnJhZ21lbnQgc2hhZGVyLCBwb3NzaWJseSBmcm9tIGNoYWNoZVxuICAgKi9cbiAgZ2V0RnJhZ21lbnRTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICAgIGFzc2VydCh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJywgRVJSX1NPVVJDRSk7XG5cbiAgICBsZXQgc2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcnNbc291cmNlXTtcbiAgICBhc3NlcnQoIXNoYWRlciB8fCBzaGFkZXIuZ2wgPT09IGdsLCBFUlJfQ09OVEVYVCk7XG5cbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgc2hhZGVyID0gbmV3IEZyYWdtZW50U2hhZGVyKGdsLCBzb3VyY2UpO1xuICAgICAgdGhpcy5mcmFnbWVudFNoYWRlcnNbc291cmNlXSA9IHNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxufVxuIl19

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.requestFile = requestFile;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Supports loading (requesting) assets with XHR (XmlHttpRequest)
/* eslint-disable guard-for-in, complexity, no-try-catch */

/* global XMLHttpRequest */
function noop() {}

var XHR_STATES = {
  UNINITIALIZED: 0,
  LOADING: 1,
  LOADED: 2,
  INTERACTIVE: 3,
  COMPLETED: 4
};

var XHR = function () {
  function XHR(_ref) {
    var url = _ref.url,
        _ref$path = _ref.path,
        path = _ref$path === undefined ? null : _ref$path,
        _ref$method = _ref.method,
        method = _ref$method === undefined ? 'GET' : _ref$method,
        _ref$asynchronous = _ref.asynchronous,
        asynchronous = _ref$asynchronous === undefined ? true : _ref$asynchronous,
        _ref$noCache = _ref.noCache,
        noCache = _ref$noCache === undefined ? false : _ref$noCache,
        _ref$sendAsBinary = _ref.sendAsBinary,
        sendAsBinary = _ref$sendAsBinary === undefined ? false : _ref$sendAsBinary,
        _ref$responseType = _ref.responseType,
        responseType = _ref$responseType === undefined ? false : _ref$responseType,
        _ref$onProgress = _ref.onProgress,
        onProgress = _ref$onProgress === undefined ? noop : _ref$onProgress,
        _ref$onError = _ref.onError,
        onError = _ref$onError === undefined ? noop : _ref$onError,
        _ref$onAbort = _ref.onAbort,
        onAbort = _ref$onAbort === undefined ? noop : _ref$onAbort,
        _ref$onComplete = _ref.onComplete,
        onComplete = _ref$onComplete === undefined ? noop : _ref$onComplete;

    _classCallCheck(this, XHR);

    this.url = path ? path.join(path, url) : url;
    this.method = method;
    this.async = asynchronous;
    this.noCache = noCache;
    this.sendAsBinary = sendAsBinary;
    this.responseType = responseType;

    this.req = new XMLHttpRequest();

    this.req.onload = function (e) {
      return onComplete(e);
    };
    this.req.onerror = function (e) {
      return onError(e);
    };
    this.req.onabort = function (e) {
      return onAbort(e);
    };
    this.req.onprogress = function (e) {
      if (e.lengthComputable) {
        onProgress(e, Math.round(e.loaded / e.total * 100));
      } else {
        onProgress(e, -1);
      }
    };
  }

  _createClass(XHR, [{
    key: 'setRequestHeader',
    value: function setRequestHeader(header, value) {
      this.req.setRequestHeader(header, value);
      return this;
    }

    // /* eslint-disable max-statements */

  }, {
    key: 'sendAsync',
    value: function sendAsync() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.body || null;

      return new Promise(function (resolve, reject) {
        try {
          var req = _this.req,
              method = _this.method,
              noCache = _this.noCache,
              sendAsBinary = _this.sendAsBinary,
              responseType = _this.responseType;


          var url = noCache ? _this.url + (_this.url.indexOf('?') >= 0 ? '&' : '?') + Date.now() : _this.url;

          req.open(method, url, _this.async);

          if (responseType) {
            req.responseType = responseType;
          }

          if (_this.async) {
            req.onreadystatechange = function (e) {
              if (req.readyState === XHR_STATES.COMPLETED) {
                if (req.status === 200) {
                  resolve(req.responseType ? req.response : req.responseText);
                } else {
                  reject(new Error(req.status + ': ' + url));
                }
              }
            };
          }

          if (sendAsBinary) {
            req.sendAsBinary(body);
          } else {
            req.send(body);
          }

          if (!_this.async) {
            if (req.status === 200) {
              resolve(req.responseType ? req.response : req.responseText);
            } else {
              reject(new Error(req.status + ': ' + url));
            }
          }
        } catch (error) {
          reject(error);
        }
      });
    }
    /* eslint-enable max-statements */

  }]);

  return XHR;
}();

function requestFile(opts) {
  var xhr = new XHR(opts);
  return xhr.sendAsync();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pby9icm93c2VyLXJlcXVlc3QtZmlsZS5qcyJdLCJuYW1lcyI6WyJyZXF1ZXN0RmlsZSIsIm5vb3AiLCJYSFJfU1RBVEVTIiwiVU5JTklUSUFMSVpFRCIsIkxPQURJTkciLCJMT0FERUQiLCJJTlRFUkFDVElWRSIsIkNPTVBMRVRFRCIsIlhIUiIsInVybCIsInBhdGgiLCJtZXRob2QiLCJhc3luY2hyb25vdXMiLCJub0NhY2hlIiwic2VuZEFzQmluYXJ5IiwicmVzcG9uc2VUeXBlIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkFib3J0Iiwib25Db21wbGV0ZSIsImpvaW4iLCJhc3luYyIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0Iiwib25sb2FkIiwiZSIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib25wcm9ncmVzcyIsImxlbmd0aENvbXB1dGFibGUiLCJNYXRoIiwicm91bmQiLCJsb2FkZWQiLCJ0b3RhbCIsImhlYWRlciIsInZhbHVlIiwic2V0UmVxdWVzdEhlYWRlciIsImJvZHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImluZGV4T2YiLCJEYXRlIiwibm93Iiwib3BlbiIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsIkVycm9yIiwic2VuZCIsImVycm9yIiwib3B0cyIsInhociIsInNlbmRBc3luYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUF3R2dCQSxXLEdBQUFBLFc7Ozs7QUF4R2hCO0FBQ0E7O0FBRUE7QUFDQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLElBQU1DLGFBQWE7QUFDakJDLGlCQUFlLENBREU7QUFFakJDLFdBQVMsQ0FGUTtBQUdqQkMsVUFBUSxDQUhTO0FBSWpCQyxlQUFhLENBSkk7QUFLakJDLGFBQVc7QUFMTSxDQUFuQjs7SUFRTUMsRztBQUNKLHFCQWFHO0FBQUEsUUFaREMsR0FZQyxRQVpEQSxHQVlDO0FBQUEs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cyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFN1cHBvcnRzIGxvYWRpbmcgKHJlcXVlc3RpbmcpIGFzc2V0cyB3aXRoIFhIUiAoWG1sSHR0cFJlcXVlc3QpXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4sIGNvbXBsZXhpdHksIG5vLXRyeS1jYXRjaCAqL1xuXG4vKiBnbG9iYWwgWE1MSHR0cFJlcXVlc3QgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBYSFJfU1RBVEVTID0ge1xuICBVTklOSVRJQUxJWkVEOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIElOVEVSQUNUSVZFOiAzLFxuICBDT01QTEVURUQ6IDRcbn07XG5cbmNsYXNzIFhIUiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgcGF0aCA9IG51bGwsXG4gICAgbWV0aG9kID0gJ0dFVCcsXG4gICAgYXN5bmNocm9ub3VzID0gdHJ1ZSxcbiAgICBub0NhY2hlID0gZmFsc2UsXG4gICAgLy8gYm9keSA9IG51bGwsXG4gICAgc2VuZEFzQmluYXJ5ID0gZmFsc2UsXG4gICAgcmVzcG9uc2VUeXBlID0gZmFsc2UsXG4gICAgb25Qcm9ncmVzcyA9IG5vb3AsXG4gICAgb25FcnJvciA9IG5vb3AsXG4gICAgb25BYm9ydCA9IG5vb3AsXG4gICAgb25Db21wbGV0ZSA9IG5vb3BcbiAgfSkge1xuICAgIHRoaXMudXJsID0gcGF0aCA/IHBhdGguam9pbihwYXRoLCB1cmwpIDogdXJsO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMuYXN5bmMgPSBhc3luY2hyb25vdXM7XG4gICAgdGhpcy5ub0NhY2hlID0gbm9DYWNoZTtcbiAgICB0aGlzLnNlbmRBc0JpbmFyeSA9IHNlbmRBc0JpbmFyeTtcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcblxuICAgIHRoaXMucmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLnJlcS5vbmxvYWQgPSBlID0+IG9uQ29tcGxldGUoZSk7XG4gICAgdGhpcy5yZXEub25lcnJvciA9IGUgPT4gb25FcnJvcihlKTtcbiAgICB0aGlzLnJlcS5vbmFib3J0ID0gZSA9PiBvbkFib3J0KGUpO1xuICAgIHRoaXMucmVxLm9ucHJvZ3Jlc3MgPSBlID0+IHtcbiAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhlLCBNYXRoLnJvdW5kKGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Qcm9ncmVzcyhlLCAtMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuICAgIHRoaXMucmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBzZW5kQXN5bmMoYm9keSA9IHRoaXMuYm9keSB8fCBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtyZXEsIG1ldGhvZCwgbm9DYWNoZSwgc2VuZEFzQmluYXJ5LCByZXNwb25zZVR5cGV9ID0gdGhpcztcblxuICAgICAgICBjb25zdCB1cmwgPSBub0NhY2hlID9cbiAgICAgICAgICB0aGlzLnVybCArICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBEYXRlLm5vdygpIDpcbiAgICAgICAgICB0aGlzLnVybDtcblxuICAgICAgICByZXEub3BlbihtZXRob2QsIHVybCwgdGhpcy5hc3luYyk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlID0+IHtcbiAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5DT01QTEVURUQpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVHlwZSA/IHJlcS5yZXNwb25zZSA6IHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYCR7cmVxLnN0YXR1c306ICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VuZEFzQmluYXJ5KSB7XG4gICAgICAgICAgcmVxLnNlbmRBc0JpbmFyeShib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXEuc2VuZChib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hc3luYykge1xuICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVHlwZSA/IHJlcS5yZXNwb25zZSA6IHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGAke3JlcS5zdGF0dXN9OiAke3VybH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RGaWxlKG9wdHMpIHtcbiAgY29uc3QgeGhyID0gbmV3IFhIUihvcHRzKTtcbiAgcmV0dXJuIHhoci5zZW5kQXN5bmMoKTtcbn1cbiJdfQ==

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browserLoad = __webpack_require__(103);

Object.defineProperty(exports, 'loadFile', {
  enumerable: true,
  get: function get() {
    return _browserLoad.loadFile;
  }
});
Object.defineProperty(exports, 'loadImage', {
  enumerable: true,
  get: function get() {
    return _browserLoad.loadImage;
  }
});

var _loadFiles = __webpack_require__(238);

Object.defineProperty(exports, 'loadFiles', {
  enumerable: true,
  get: function get() {
    return _loadFiles.loadFiles;
  }
});
Object.defineProperty(exports, 'loadImages', {
  enumerable: true,
  get: function get() {
    return _loadFiles.loadImages;
  }
});
Object.defineProperty(exports, 'loadTextures', {
  enumerable: true,
  get: function get() {
    return _loadFiles.loadTextures;
  }
});
Object.defineProperty(exports, 'setPathPrefix', {
  enumerable: true,
  get: function get() {
    return _loadFiles.setPathPrefix;
  }
});
Object.defineProperty(exports, 'loadProgram', {
  enumerable: true,
  get: function get() {
    return _loadFiles.loadProgram;
  }
});
Object.defineProperty(exports, 'loadModel', {
  enumerable: true,
  get: function get() {
    return _loadFiles.loadModel;
  }
});
Object.defineProperty(exports, 'parseModel', {
  enumerable: true,
  get: function get() {
    return _loadFiles.parseModel;
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pby9pbmRleC5qcyJdLCJuYW1lcyI6WyJsb2FkRmlsZSIsImxvYWRJbWFnZSIsImxvYWRGaWxlcyIsImxvYWRJbWFnZXMiLCJsb2FkVGV4dHVyZXMiLCJzZXRQYXRoUHJlZml4IiwibG9hZFByb2dyYW0iLCJsb2FkTW9kZWwiLCJwYXJzZU1vZGVsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt3QkFDUUEsUTs7Ozs7O3dCQUFVQyxTOzs7Ozs7Ozs7c0JBQ1ZDLFM7Ozs7OztzQkFBV0MsVTs7Ozs7O3NCQUFZQyxZOzs7Ozs7c0JBQ3ZCQyxhOzs7Ozs7c0JBQWVDLFc7Ozs7OztzQkFBYUMsUzs7Ozs7O3NCQUFXQyxVIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsbCBhIHJlcXVpcmUgYmFzZWQgaGVscGVyIHRvIHNlbGVjdCBwbGF0Zm9ybSB0byBleHBvcnRcbmV4cG9ydCB7bG9hZEZpbGUsIGxvYWRJbWFnZX0gZnJvbSAnLi9icm93c2VyLWxvYWQnO1xuZXhwb3J0IHtsb2FkRmlsZXMsIGxvYWRJbWFnZXMsIGxvYWRUZXh0dXJlc30gZnJvbSAnLi9sb2FkLWZpbGVzJztcbmV4cG9ydCB7c2V0UGF0aFByZWZpeCwgbG9hZFByb2dyYW0sIGxvYWRNb2RlbCwgcGFyc2VNb2RlbH0gZnJvbSAnLi9sb2FkLWZpbGVzJztcbiJdfQ==

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* eslint-disable guard-for-in, complexity, no-try-catch */


exports.setPathPrefix = setPathPrefix;
exports.loadFiles = loadFiles;
exports.loadImages = loadImages;
exports.loadTextures = loadTextures;
exports.loadProgram = loadProgram;
exports.loadModel = loadModel;
exports.parseModel = parseModel;

var _assert = __webpack_require__(0);

var _assert2 = _interopRequireDefault(_assert);

var _browserLoad = __webpack_require__(103);

var _webgl = __webpack_require__(20);

var _core = __webpack_require__(18);

var _geometry = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}

var pathPrefix = '';

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

/*
 * Loads (Requests) multiple files asynchronously
 */
function loadFiles() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var urls = opts.urls,
      _opts$onProgress = opts.onProgress,
      onProgress = _opts$onProgress === undefined ? noop : _opts$onProgress;

  (0, _assert2.default)(urls.every(function (url) {
    return typeof url === 'string';
  }), 'loadImages: {urls} must be array of strings');
  var count = 0;
  return Promise.all(urls.map(function (url) {
    url = pathPrefix + url;
    var promise = (0, _browserLoad.loadFile)(Object.assign({ url: url }, opts));
    promise.then(function (file) {
      return onProgress({
        progress: ++count / urls.length,
        count: count,
        total: urls.length,
        url: url
      });
    });
    return promise;
  }));
}

/*
 * Loads (requests) multiple images asynchronously
 */
function loadImages() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var urls = opts.urls,
      _opts$onProgress2 = opts.onProgress,
      onProgress = _opts$onProgress2 === undefined ? noop : _opts$onProgress2;

  (0, _assert2.default)(urls.every(function (url) {
    return typeof url === 'string';
  }), 'loadImages: {urls} must be array of strings');
  var count = 0;
  return Promise.all(urls.map(function (url) {
    url = pathPrefix + url;
    var promise = (0, _browserLoad.loadImage)(url);
    promise.then(function (file) {
      return onProgress({
        progress: ++count / urls.length,
        count: count,
        total: urls.length,
        url: url
      });
    });
    return promise;
  }));
}

function loadTextures(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var urls = opts.urls,
      _opts$onProgress3 = opts.onProgress,
      onProgress = _opts$onProgress3 === undefined ? noop : _opts$onProgress3;

  (0, _assert2.default)(urls.every(function (url) {
    return typeof url === 'string';
  }), 'loadTextures: {urls} must be array of strings');

  return loadImages(Object.assign({ urls: urls, onProgress: onProgress }, opts)).then(function (images) {
    return images.map(function (img, i) {
      var params = Array.isArray(opts.parameters) ? opts.parameters[i] : opts.parameters;
      params = params === undefined ? {} : params;
      return new _webgl.Texture2D(gl, Object.assign({ id: urls[i] }, params, { data: img }));
    });
  });
}

function loadProgram(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var vs = opts.vs,
      fs = opts.fs,
      _opts$onProgress4 = opts.onProgress,
      onProgress = _opts$onProgress4 === undefined ? noop : _opts$onProgress4;

  return loadFiles(Object.assign({ urls: [vs, fs], onProgress: onProgress }, opts)).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        vsText = _ref2[0],
        fsText = _ref2[1];

    return new _webgl.Program(gl, Object.assign({ vs: vsText, fs: fsText }, opts));
  });
}

// Loads a simple JSON format
function loadModel(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var url = opts.url,
      _opts$onProgress5 = opts.onProgress,
      onProgress = _opts$onProgress5 === undefined ? noop : _opts$onProgress5;

  return loadFiles(Object.assign({ urls: [url], onProgress: onProgress }, opts)).then(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        file = _ref4[0];

    return parseModel(gl, Object.assign({ file: file }, opts));
  });
}

function parseModel(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var file = opts.file,
      _opts$program = opts.program,
      program = _opts$program === undefined ? new _webgl.Program(gl) : _opts$program;

  var json = typeof file === 'string' ? parseJSON(file) : file;
  // Remove any attributes so that we can create a geometry
  // TODO - change format to put these in geometry sub object?
  var attributes = {};
  var modelOptions = {};
  for (var key in json) {
    var value = json[key];
    if (Array.isArray(value)) {
      attributes[key] = key === 'indices' ? new Uint16Array(value) : new Float32Array(value);
    } else {
      modelOptions[key] = value;
    }
  }

  return new _core.Model(Object.assign({ program: program, geometry: new _geometry.Geometry({ attributes: attributes }) }, modelOptions, opts));
}

function parseJSON(file) {
  try {
    return JSON.parse(file);
  } catch (error) {
    throw new Error('Failed to parse JSON: ' + error);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pby9sb2FkLWZpbGVzLmpzIl0sIm5hbWVzIjpbInNldFBhdGhQcmVmaXgiLCJsb2FkRmlsZXMiLCJsb2FkSW1hZ2VzIiwibG9hZFRleHR1cmVzIiwibG9hZFByb2dyYW0iLCJsb2FkTW9kZWwiLCJwYXJzZU1vZGVsIiwibm9vcCIsInBhdGhQcmVmaXgiLCJwcmVmaXgiLCJvcHRzIiwidXJscyIsIm9uUHJvZ3Jlc3MiLCJldmVyeSIsInVybCIsImNvdW50IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInByb21pc2UiLCJPYmplY3QiLCJhc3NpZ24iLCJ0aGVuIiwicHJvZ3Jlc3MiLCJsZW5ndGgiLCJ0b3RhbCIsImdsIiwiaW1hZ2VzIiwiaW1nIiwiaSIsInBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsInBhcmFtZXRlcnMiLCJ1bmRlZmluZWQiLCJpZCIsImRhdGEiLCJ2cyIsImZzIiwidnNUZXh0IiwiZnNUZXh0IiwiZmlsZSIsInByb2dyYW0iLCJqc29uIiwicGFyc2VKU09OIiwiYXR0cmlidXRlcyIsIm1vZGVsT3B0aW9ucyIsImtleSIsInZhbHVlIiwiVWludDE2QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJnZW9tZXRyeSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozt5cEJBQUE7OztRQWNnQkEsYSxHQUFBQSxhO1FBT0FDLFMsR0FBQUEsUztRQXNCQUMsVSxHQUFBQSxVO1FBbUJBQyxZLEdBQUFBLFk7UUFhQUMsVyxHQUFBQSxXO1FBU0FDLFMsR0FBQUEsUztRQU1BQyxVLEdBQUFBLFU7O0FBekZoQjs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQixJQUFJQyxhQUFhLEVBQWpCOztBQUVBOzs7QUFHTyxTQUFTUixhQUFULENBQXVCUyxNQUF2QixFQUErQjtBQUNwQ0QsZUFBYUMsTUFBYjtBQUNEOztBQUVEOzs7QUFHTyxTQUFT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bkIsRUFBeUI7QUFDdkIsTUFBSTtBQUNGLFdBQU9XLEtBQUtDLEtBQUwsQ0FBV1osSUFBWCxDQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU9hLEtBQVAsRUFBYztBQUNkLFVBQU0sSUFBSUMsS0FBSiw0QkFBbUNELEtBQW5DLENBQU47QUFDRDtBQUNGIiwiZmlsZSI6ImxvYWQtZmlsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4sIGNvbXBsZXhpdHksIG5vLXRyeS1jYXRjaCAqL1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtsb2FkRmlsZSwgbG9hZEltYWdlfSBmcm9tICcuL2Jyb3dzZXItbG9hZCc7XG5pbXBvcnQge1Byb2dyYW0sIFRleHR1cmUyRH0gZnJvbSAnLi4vd2ViZ2wnO1xuaW1wb3J0IHtNb2RlbH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQge0dlb21ldHJ5fSBmcm9tICcuLi9nZW9tZXRyeSc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5sZXQgcGF0aFByZWZpeCA9ICcnO1xuXG4vKlxuICogU2V0IGEgcmVsYXRpdmUgcGF0aCBwcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBhdGhQcmVmaXgocHJlZml4KSB7XG4gIHBhdGhQcmVmaXggPSBwcmVmaXg7XG59XG5cbi8qXG4gKiBMb2FkcyAoUmVxdWVzdHMpIG11bHRpcGxlIGZpbGVzIGFzeW5jaHJvbm91c2x5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmlsZXMob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHt1cmxzLCBvblByb2dyZXNzID0gbm9vcH0gPSBvcHRzO1xuICBhc3NlcnQodXJscy5ldmVyeSh1cmwgPT4gdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpLCAnbG9hZEltYWdlczoge3VybHN9IG11c3QgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gUHJvbWlzZS5hbGwodXJscy5tYXAoXG4gICAgdXJsID0+IHtcbiAgICAgIHVybCA9IHBhdGhQcmVmaXggKyB1cmw7XG4gICAgICBjb25zdCBwcm9taXNlID0gbG9hZEZpbGUoT2JqZWN0LmFzc2lnbih7dXJsfSwgb3B0cykpO1xuICAgICAgcHJvbWlzZS50aGVuKGZpbGUgPT4gb25Qcm9ncmVzcyh7XG4gICAgICAgIHByb2dyZXNzOiArK2NvdW50IC8gdXJscy5sZW5ndGgsXG4gICAgICAgIGNvdW50LFxuICAgICAgICB0b3RhbDogdXJscy5sZW5ndGgsXG4gICAgICAgIHVybFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICApKTtcbn1cblxuLypcbiAqIExvYWRzIChyZXF1ZXN0cykgbXVsdGlwbGUgaW1hZ2VzIGFzeW5jaHJvbm91c2x5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VzKG9wdHMgPSB7fSkge1xuICBjb25zdCB7dXJscywgb25Qcm9ncmVzcyA9IG5vb3B9ID0gb3B0cztcbiAgYXNzZXJ0KHVybHMuZXZlcnkodXJsID0+IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSwgJ2xvYWRJbWFnZXM6IHt1cmxzfSBtdXN0IGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHVybHMubWFwKFxuICAgIHVybCA9PiB7XG4gICAgICB1cmwgPSBwYXRoUHJlZml4ICsgdXJsO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGxvYWRJbWFnZSh1cmwpO1xuICAgICAgcHJvbWlzZS50aGVuKGZpbGUgPT4gb25Qcm9ncmVzcyh7XG4gICAgICAgIHByb2dyZXNzOiArK2NvdW50IC8gdXJscy5sZW5ndGgsXG4gICAgICAgIGNvdW50LFxuICAgICAgICB0b3RhbDogdXJscy5sZW5ndGgsXG4gICAgICAgIHVybFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRUZXh0dXJlcyhnbCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHt1cmxzLCBvblByb2dyZXNzID0gbm9vcH0gPSBvcHRzO1xuICBhc3NlcnQodXJscy5ldmVyeSh1cmwgPT4gdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpLFxuICAgICdsb2FkVGV4dHVyZXM6IHt1cmxzfSBtdXN0IGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcblxuICByZXR1cm4gbG9hZEltYWdlcyhPYmplY3QuYXNzaWduKHt1cmxzLCBvblByb2dyZXNzfSwgb3B0cykpXG4gIC50aGVuKGltYWdlcyA9PiBpbWFnZXMubWFwKChpbWcsIGkpID0+IHtcbiAgICBsZXQgcGFyYW1zID0gQXJyYXkuaXNBcnJheShvcHRzLnBhcmFtZXRlcnMpID8gb3B0cy5wYXJhbWV0ZXJzW2ldIDogb3B0cy5wYXJhbWV0ZXJzO1xuICAgIHBhcmFtcyA9IHBhcmFtcyA9PT0gdW5kZWZpbmVkID8ge30gOiBwYXJhbXM7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIE9iamVjdC5hc3NpZ24oe2lkOiB1cmxzW2ldfSwgcGFyYW1zLCB7ZGF0YTogaW1nfSkpO1xuICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUHJvZ3JhbShnbCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHt2cywgZnMsIG9uUHJvZ3Jlc3MgPSBub29wfSA9IG9wdHM7XG4gIHJldHVybiBsb2FkRmlsZXMoT2JqZWN0LmFzc2lnbih7dXJsczogW3ZzLCBmc10sIG9uUHJvZ3Jlc3N9LCBvcHRzKSlcbiAgLnRoZW4oXG4gICAgKFt2c1RleHQsIGZzVGV4dF0pID0+IG5ldyBQcm9ncmFtKGdsLCBPYmplY3QuYXNzaWduKHt2czogdnNUZXh0LCBmczogZnNUZXh0fSwgb3B0cykpXG4gICk7XG59XG5cbi8vIExvYWRzIGEgc2ltcGxlIEpTT04gZm9ybWF0XG5leHBvcnQgZnVuY3Rpb24gbG9hZE1vZGVsKGdsLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge3VybCwgb25Qcm9ncmVzcyA9IG5vb3B9ID0gb3B0cztcbiAgcmV0dXJuIGxvYWRGaWxlcyhPYmplY3QuYXNzaWduKHt1cmxzOiBbdXJsXSwgb25Qcm9ncmVzc30sIG9wdHMpKVxuICAudGhlbigoW2ZpbGVdKSA9PiBwYXJzZU1vZGVsKGdsLCBPYmplY3QuYXNzaWduKHtmaWxlfSwgb3B0cykpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTW9kZWwoZ2wsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7ZmlsZSwgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsKX0gPSBvcHRzO1xuICBjb25zdCBqc29uID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gcGFyc2VKU09OKGZpbGUpIDogZmlsZTtcbiAgLy8gUmVtb3ZlIGFueSBhdHRyaWJ1dGVzIHNvIHRoYXQgd2UgY2FuIGNyZWF0ZSBhIGdlb21ldHJ5XG4gIC8vIFRPRE8gLSBjaGFuZ2UgZm9ybWF0IHRvIHB1dCB0aGVzZSBpbiBnZW9tZXRyeSBzdWIgb2JqZWN0P1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vZGVsT3B0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBqc29uKSB7XG4gICAgY29uc3QgdmFsdWUgPSBqc29uW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBrZXkgPT09ICdpbmRpY2VzJyA/IG5ldyBVaW50MTZBcnJheSh2YWx1ZSkgOiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IE1vZGVsKE9iamVjdC5hc3NpZ24oXG4gICAge3Byb2dyYW0sIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe2F0dHJpYnV0ZXN9KX0sXG4gICAgbW9kZWxPcHRpb25zLFxuICAgIG9wdHNcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTihmaWxlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZmlsZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgSlNPTjogJHtlcnJvcn1gKTtcbiAgfVxufVxuIl19

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl__ = __webpack_require__(20);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// ClipSpaceQuad




var CLIPSPACE_QUAD_VERTEX_SHADER = 'attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n';

/* eslint-disable indent, no-multi-spaces */
var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1
// -1, -1,
//  1, -1,
//  1,  1,
// -1, -1,
//  1,  1,
// -1,  1
];

var TEX_COORDS = POSITIONS.map(function (coord) {
  return coord === -1 ? 0 : coord;
});
/* eslint-enable indent, no-multi-spaces */

var ClipSpaceQuad = function (_Model) {
  _inherits(ClipSpaceQuad, _Model);

  function ClipSpaceQuad(opts) {
    _classCallCheck(this, ClipSpaceQuad);

    var _this = _possibleConstructorReturn(this, (ClipSpaceQuad.__proto__ || Object.getPrototypeOf(ClipSpaceQuad)).call(this, Object.assign({}, opts, {
      vs: CLIPSPACE_QUAD_VERTEX_SHADER,
      geometry: new __WEBPACK_IMPORTED_MODULE_1__geometry__["Geometry"]({
        drawMode: __WEBPACK_IMPORTED_MODULE_2__webgl__["GL"].TRIANGLE_STRIP,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: { size: 2, value: new Float32Array(POSITIONS) },
          aTexCoord: { size: 2, value: new Float32Array(TEX_COORDS) },
          aCoordinate: { size: 2, value: new Float32Array(TEX_COORDS) }
        }
      })
    })));

    _this.setVertexCount(4);
    return _this;
  }

  return ClipSpaceQuad;
}(__WEBPACK_IMPORTED_MODULE_0__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (ClipSpaceQuad);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY2xpcC1zcGFjZS1xdWFkLmpzIl0sIm5hbWVzIjpbIk1vZGVsIiwiR2VvbWV0cnkiLCJHTCIsIkNMSVBTUEFDRV9RVUFEX1ZFUlRFWF9TSEFERVIiLCJQT1NJVElPTlMiLCJURVhfQ09PUkRTIiwibWFwIiwiY29vcmQiLCJDbGlwU3BhY2VRdWFkIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsInZzIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIlRSSUFOR0xFX1NUUklQIiwidmVydGV4Q291bnQiLCJhdHRyaWJ1dGVzIiwiYUNsaXBTcGFjZVBvc2l0aW9uIiwic2l6ZSIsInZhbHVlIiwiRmxvYXQzMkFycmF5IiwiYVRleENvb3JkIiwiYUNvb3JkaW5hdGUiLCJzZXRWZXJ0ZXhDb3VudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxTQUFRQSxLQUFSLFFBQW9CLFNBQXBCO0FBQ0EsU0FBUUMsUUFBUixRQUF1QixhQUF2QjtBQUNBLFNBQVFDLEVBQVIsUUFBaUIsVUFBakI7O0FBRUEsSUFBTUMsZ1dBQU47O0FBaUJBO0FBQ0EsSUFBTUMsWUFBWSxDQUNoQixDQUFDLENBRGUsRUFDWixDQUFDLENBRFcsRUFFZixDQUZlLEVBRVosQ0FBQyxDQUZXLEVBR2hCLENBQUMsQ0FIZSxFQUdYLENBSFcsRUFJZixDQUplLEVBSVg7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWZ0IsQ0FBbEI7O0FBYUEsSUFBTUMsYUFBYUQsVUFBVUUsR0FBVixDQUFjO0FBQUEsU0FBU0MsVUFBVSxDQUFDLENBQVgsR0FBZSxDQUFmLEdBQW1CQSxLQUE1QjtBQUFBLENBQWQsQ0FBbkI7QUFDQTs7SUFFcUJDLGE7OztBQUNuQix5QkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDhIQUVWQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkYsSUFBbEIsRUFBd0I7QUFDNUJHLFVBQUlULDRCQUR3QjtBQUU1QlUsZ0JBQVUsSUFBSVosUUFBSixDQUFhO0FBQ3JCYSxrQkFBVVosR0FBR2EsY0FEUTtBQUVyQkMscUJBQWEsQ0FGUTtBQUdyQkMsb0JBQVk7QUFDVkMsOEJBQW9CLEVBQUNDLE1BQU0sQ0FBUCxFQUFVQyxPQUFPLElBQUlDLFlBQUosQ0FBaUJqQixTQUFqQixDQUFqQixFQURWO0FBRVZrQixxQkFBVyxFQUFDSCxNQUFNLENBQVAsRUFBVUMsT0FBTyxJQUFJQyxZQUFKLENBQWlCaEIsVUFBakIsQ0FBakIsRUFGRDtBQUdWa0IsdUJBQWEsRUFBQ0osTUFBTSxDQUFQLEVBQVVDLE9BQU8sSUFBSUMsWUFBSixDQUFpQmhCLFVBQWpCLENBQWpCO0FBSEg7QUFIUyxPQUFiO0FBRmtCLEtBQXhCLENBRlU7O0FBY2hCLFVBQUttQixjQUFMLENBQW9CLENBQXBCO0FBZGdCO0FBZWpCOzs7RUFoQndDeEIsSzs7ZUFBdEJRLGEiLCJmaWxlIjoiY2xpcC1zcGFjZS1xdWFkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2xpcFNwYWNlUXVhZFxuaW1wb3J0IHtNb2RlbH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQge0dlb21ldHJ5fSBmcm9tICcuLi9nZW9tZXRyeSc7XG5pbXBvcnQge0dMfSBmcm9tICcuLi93ZWJnbCc7XG5cbmNvbnN0IENMSVBTUEFDRV9RVUFEX1ZFUlRFWF9TSEFERVIgPSBgXFxcbmF0dHJpYnV0ZSB2ZWMyIGFDbGlwU3BhY2VQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXhDb29yZDtcbmF0dHJpYnV0ZSB2ZWMyIGFDb29yZGluYXRlO1xuXG52YXJ5aW5nIHZlYzIgcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgY29vcmRpbmF0ZTtcbnZhcnlpbmcgdmVjMiB1djtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDbGlwU3BhY2VQb3NpdGlvbiwgMC4sIDEuKTtcbiAgcG9zaXRpb24gPSBhQ2xpcFNwYWNlUG9zaXRpb247XG4gIGNvb3JkaW5hdGUgPSBhQ29vcmRpbmF0ZTtcbiAgdXYgPSBhVGV4Q29vcmQ7XG59XG5gO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQsIG5vLW11bHRpLXNwYWNlcyAqL1xuY29uc3QgUE9TSVRJT05TID0gW1xuICAtMSwgLTEsXG4gICAxLCAtMSxcbiAgLTEsICAxLFxuICAgMSwgIDFcbiAgLy8gLTEsIC0xLFxuICAvLyAgMSwgLTEsXG4gIC8vICAxLCAgMSxcbiAgLy8gLTEsIC0xLFxuICAvLyAgMSwgIDEsXG4gIC8vIC0xLCAgMVxuXTtcblxuY29uc3QgVEVYX0NPT1JEUyA9IFBPU0lUSU9OUy5tYXAoY29vcmQgPT4gY29vcmQgPT09IC0xID8gMCA6IGNvb3JkKTtcbi8qIGVzbGludC1lbmFibGUgaW5kZW50LCBuby1tdWx0aS1zcGFjZXMgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpcFNwYWNlUXVhZCBleHRlbmRzIE1vZGVsIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgdnM6IENMSVBTUEFDRV9RVUFEX1ZFUlRFWF9TSEFERVIsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX1NUUklQLFxuICAgICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGFDbGlwU3BhY2VQb3NpdGlvbjoge3NpemU6IDIsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFBPU0lUSU9OUyl9LFxuICAgICAgICAgIGFUZXhDb29yZDoge3NpemU6IDIsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFRFWF9DT09SRFMpfSxcbiAgICAgICAgICBhQ29vcmRpbmF0ZToge3NpemU6IDIsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFRFWF9DT09SRFMpfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pKTtcbiAgICB0aGlzLnNldFZlcnRleENvdW50KDQpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core__ = __webpack_require__(18);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Cone = function (_Model) {
  _inherits(Cone, _Model);

  function Cone() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Cone);

    return _possibleConstructorReturn(this, (Cone.__proto__ || Object.getPrototypeOf(Cone)).call(this, Object.assign({}, opts, { geometry: new __WEBPACK_IMPORTED_MODULE_0__geometry__["ConeGeometry"](opts) })));
  }

  return Cone;
}(__WEBPACK_IMPORTED_MODULE_1__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (Cone);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY29uZS5qcyJdLCJuYW1lcyI6WyJDb25lR2VvbWV0cnkiLCJNb2RlbCIsIkNvbmUiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2VvbWV0cnkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLFNBQVFBLFlBQVIsUUFBMkIsYUFBM0I7QUFDQSxTQUFRQyxLQUFSLFFBQW9CLFNBQXBCOztJQUVxQkMsSTs7O0FBQ25CLGtCQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSx1R0FDZkMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JGLElBQWxCLEVBQXdCLEVBQUNHLFVBQVUsSUFBSU4sWUFBSixDQUFpQkcsSUFBakIsQ0FBWCxFQUF4QixDQURlO0FBRXRCOzs7RUFIK0JGLEs7O2VBQWJDLEkiLCJmaWxlIjoiY29uZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29uZUdlb21ldHJ5fSBmcm9tICcuLi9nZW9tZXRyeSc7XG5pbXBvcnQge01vZGVsfSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZSBleHRlbmRzIE1vZGVsIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge2dlb21ldHJ5OiBuZXcgQ29uZUdlb21ldHJ5KG9wdHMpfSkpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Cube = function (_Model) {
  _inherits(Cube, _Model);

  function Cube() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Cube);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["uid"])('cube') : _opts$id;
    return _possibleConstructorReturn(this, (Cube.__proto__ || Object.getPrototypeOf(Cube)).call(this, Object.assign({}, opts, { id: id, geometry: new __WEBPACK_IMPORTED_MODULE_0__geometry__["CubeGeometry"](opts) })));
  }

  return Cube;
}(__WEBPACK_IMPORTED_MODULE_1__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (Cube);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY3ViZS5qcyJdLCJuYW1lcyI6WyJDdWJlR2VvbWV0cnkiLCJNb2RlbCIsInVpZCIsIkN1YmUiLCJvcHRzIiwiaWQiLCJPYmplY3QiLCJhc3NpZ24iLCJnZW9tZXRyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBUUEsWUFBUixRQUEyQixhQUEzQjtBQUNBLFNBQVFDLEtBQVIsUUFBb0IsU0FBcEI7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCOztJQUVxQkMsSTs7O0FBQ25CLGtCQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxtQkFDTUEsSUFETixDQUNkQyxFQURjO0FBQUEsUUFDZEEsRUFEYyw0QkFDVEgsSUFBSSxNQUFKLENBRFM7QUFBQSx1R0FFZkksT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILElBQWxCLEVBQXdCLEVBQUNDLE1BQUQsRUFBS0csVUFBVSxJQUFJUixZQUFKLENBQWlCSSxJQUFqQixDQUFmLEVBQXhCLENBRmU7QUFHdEI7OztFQUorQkgsSzs7ZUFBYkUsSSIsImZpbGUiOiJjdWJlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDdWJlR2VvbWV0cnl9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7TW9kZWx9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHt1aWR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ViZSBleHRlbmRzIE1vZGVsIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge2lkID0gdWlkKCdjdWJlJyl9ID0gb3B0cztcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7aWQsIGdlb21ldHJ5OiBuZXcgQ3ViZUdlb21ldHJ5KG9wdHMpfSkpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_model__ = __webpack_require__(31);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Cylinder = function (_Model) {
  _inherits(Cylinder, _Model);

  function Cylinder() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Cylinder);

    return _possibleConstructorReturn(this, (Cylinder.__proto__ || Object.getPrototypeOf(Cylinder)).call(this, Object.assign({}, opts, { geometry: new __WEBPACK_IMPORTED_MODULE_0__geometry__["CylinderGeometry"](opts) })));
  }

  return Cylinder;
}(__WEBPACK_IMPORTED_MODULE_1__core_model__["a" /* default */]);

/* unused harmony default export */ var _unused_webpack_default_export = (Cylinder);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY3lsaW5kZXIuanMiXSwibmFtZXMiOlsiQ3lsaW5kZXJHZW9tZXRyeSIsIk1vZGVsIiwiQ3lsaW5kZXIiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2VvbWV0cnkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLFNBQVFBLGdCQUFSLFFBQStCLGFBQS9CO0FBQ0EsT0FBT0MsS0FBUCxNQUFrQixlQUFsQjs7SUFFcUJDLFE7OztBQUNuQixzQkFBdUI7QUFBQSxRQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsK0dBQ2ZDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCRixJQUFsQixFQUF3QixFQUFDRyxVQUFVLElBQUlOLGdCQUFKLENBQXFCRyxJQUFyQixDQUFYLEVBQXhCLENBRGU7QUFFdEI7OztFQUhtQ0YsSzs7ZUFBakJDLFEiLCJmaWxlIjoiY3lsaW5kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0N5bGluZGVyR2VvbWV0cnl9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi9jb3JlL21vZGVsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3lsaW5kZXIgZXh0ZW5kcyBNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtnZW9tZXRyeTogbmV3IEN5bGluZGVyR2VvbWV0cnkob3B0cyl9KSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry__ = __webpack_require__(16);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var IcoSphere = function (_Model) {
  _inherits(IcoSphere, _Model);

  function IcoSphere() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, IcoSphere);

    return _possibleConstructorReturn(this, (IcoSphere.__proto__ || Object.getPrototypeOf(IcoSphere)).call(this, Object.assign({}, opts, { geometry: new __WEBPACK_IMPORTED_MODULE_1__geometry__["IcoSphereGeometry"](opts) })));
  }

  return IcoSphere;
}(__WEBPACK_IMPORTED_MODULE_0__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (IcoSphere);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvaWNvLXNwaGVyZS5qcyJdLCJuYW1lcyI6WyJNb2RlbCIsIkljb1NwaGVyZUdlb21ldHJ5IiwiSWNvU3BoZXJlIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImdlb21ldHJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFRQSxLQUFSLFFBQW9CLFNBQXBCO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0MsYUFBaEM7O0lBRXFCQyxTOzs7QUFDbkIsdUJBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLGlIQUNmQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkYsSUFBbEIsRUFBd0IsRUFBQ0csVUFBVSxJQUFJTCxpQkFBSixDQUFzQkUsSUFBdEIsQ0FBWCxFQUF4QixDQURlO0FBRXRCOzs7RUFIb0NILEs7O2VBQWxCRSxTIiwiZmlsZSI6Imljby1zcGhlcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01vZGVsfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7SWNvU3BoZXJlR2VvbWV0cnl9IGZyb20gJy4uL2dlb21ldHJ5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvU3BoZXJlIGV4dGVuZHMgTW9kZWwge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7Z2VvbWV0cnk6IG5ldyBJY29TcGhlcmVHZW9tZXRyeShvcHRzKX0pKTtcbiAgfVxufVxuIl19

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_model__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Plane = function (_Model) {
  _inherits(Plane, _Model);

  function Plane() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Plane);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["uid"])('plane') : _opts$id;
    return _possibleConstructorReturn(this, (Plane.__proto__ || Object.getPrototypeOf(Plane)).call(this, Object.assign({}, opts, { id: id, geometry: new __WEBPACK_IMPORTED_MODULE_0__geometry__["PlaneGeometry"](opts) })));
  }

  return Plane;
}(__WEBPACK_IMPORTED_MODULE_1__core_model__["a" /* default */]);

/* unused harmony default export */ var _unused_webpack_default_export = (Plane);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvcGxhbmUuanMiXSwibmFtZXMiOlsiUGxhbmVHZW9tZXRyeSIsIk1vZGVsIiwidWlkIiwiUGxhbmUiLCJvcHRzIiwiaWQiLCJPYmplY3QiLCJhc3NpZ24iLCJnZW9tZXRyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBUUEsYUFBUixRQUE0QixhQUE1QjtBQUNBLE9BQU9DLEtBQVAsTUFBa0IsZUFBbEI7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCOztJQUVxQkMsSzs7O0FBQ25CLG1CQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxtQkFDT0EsSUFEUCxDQUNkQyxFQURjO0FBQUEsUUFDZEEsRUFEYyw0QkFDVEgsSUFBSSxPQUFKLENBRFM7QUFBQSx5R0FFZkksT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILElBQWxCLEVBQXdCLEVBQUNDLE1BQUQsRUFBS0csVUFBVSxJQUFJUixhQUFKLENBQWtCSSxJQUFsQixDQUFmLEVBQXhCLENBRmU7QUFHdEI7OztFQUpnQ0gsSzs7ZUFBZEUsSyIsImZpbGUiOiJwbGFuZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UGxhbmVHZW9tZXRyeX0gZnJvbSAnLi4vZ2VvbWV0cnknO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uL2NvcmUvbW9kZWwnO1xuaW1wb3J0IHt1aWR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxhbmUgZXh0ZW5kcyBNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtpZCA9IHVpZCgncGxhbmUnKX0gPSBvcHRzO1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtpZCwgZ2VvbWV0cnk6IG5ldyBQbGFuZUdlb21ldHJ5KG9wdHMpfSkpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(4);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Sphere = function (_Model) {
  _inherits(Sphere, _Model);

  function Sphere() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Sphere);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["uid"])('sphere') : _opts$id;
    return _possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, Object.assign({}, opts, { id: id, geometry: new __WEBPACK_IMPORTED_MODULE_1__geometry__["SphereGeometry"](opts) })));
  }

  return Sphere;
}(__WEBPACK_IMPORTED_MODULE_0__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (Sphere);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvc3BoZXJlLmpzIl0sIm5hbWVzIjpbIk1vZGVsIiwiU3BoZXJlR2VvbWV0cnkiLCJ1aWQiLCJTcGhlcmUiLCJvcHRzIiwiaWQiLCJPYmplY3QiLCJhc3NpZ24iLCJnZW9tZXRyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBUUEsS0FBUixRQUFvQixTQUFwQjtBQUNBLFNBQVFDLGNBQVIsUUFBNkIsYUFBN0I7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFVBQWxCOztJQUVxQkMsTTs7O0FBQ25CLG9CQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxtQkFDUUEsSUFEUixDQUNkQyxFQURjO0FBQUEsUUFDZEEsRUFEYyw0QkFDVEgsSUFBSSxRQUFKLENBRFM7QUFBQSwyR0FFZkksT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILElBQWxCLEVBQXdCLEVBQUNDLE1BQUQsRUFBS0csVUFBVSxJQUFJUCxjQUFKLENBQW1CRyxJQUFuQixDQUFmLEVBQXhCLENBRmU7QUFHdEI7OztFQUppQ0osSzs7ZUFBZkcsTSIsImZpbGUiOiJzcGhlcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01vZGVsfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7U3BoZXJlR2VvbWV0cnl9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7dWlkfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaGVyZSBleHRlbmRzIE1vZGVsIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge2lkID0gdWlkKCdzcGhlcmUnKX0gPSBvcHRzO1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtpZCwgZ2VvbWV0cnk6IG5ldyBTcGhlcmVHZW9tZXRyeShvcHRzKX0pKTtcbiAgfVxufVxuIl19

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core__ = __webpack_require__(18);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var TruncatedCone = function (_Model) {
  _inherits(TruncatedCone, _Model);

  function TruncatedCone() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TruncatedCone);

    return _possibleConstructorReturn(this, (TruncatedCone.__proto__ || Object.getPrototypeOf(TruncatedCone)).call(this, Object.assign({}, opts, { geometry: new __WEBPACK_IMPORTED_MODULE_0__geometry__["TruncatedConeGeometry"](opts) })));
  }

  return TruncatedCone;
}(__WEBPACK_IMPORTED_MODULE_1__core__["Model"]);

/* unused harmony default export */ var _unused_webpack_default_export = (TruncatedCone);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvdHJ1bmNhdGVkLWNvbmUuanMiXSwibmFtZXMiOlsiVHJ1bmNhdGVkQ29uZUdlb21ldHJ5IiwiTW9kZWwiLCJUcnVuY2F0ZWRDb25lIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImdlb21ldHJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFRQSxxQkFBUixRQUFvQyxhQUFwQztBQUNBLFNBQVFDLEtBQVIsUUFBb0IsU0FBcEI7O0lBRXFCQyxhOzs7QUFDbkIsMkJBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLHlIQUNmQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkYsSUFBbEIsRUFBd0IsRUFBQ0csVUFBVSxJQUFJTixxQkFBSixDQUEwQkcsSUFBMUIsQ0FBWCxFQUF4QixDQURlO0FBRXRCOzs7RUFId0NGLEs7O2VBQXRCQyxhIiwiZmlsZSI6InRydW5jYXRlZC1jb25lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUcnVuY2F0ZWRDb25lR2VvbWV0cnl9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7TW9kZWx9IGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcnVuY2F0ZWRDb25lIGV4dGVuZHMgTW9kZWwge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7Z2VvbWV0cnk6IG5ldyBUcnVuY2F0ZWRDb25lR2VvbWV0cnkob3B0cyl9KSk7XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export stop */
/* unused harmony export get */
/* unused harmony export getWheel */
/* unused harmony export getKey */
/* unused harmony export isRightClick */
/* unused harmony export getPos */
/* unused harmony export EventsProxy */
/* unused harmony export Keys */
/* unused harmony export addEvents */


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// event.js
// Handle keyboard/mouse/touch events in the Canvas
// TODO - this will not work under node

/* eslint-disable dot-notation, max-statements, no-loop-func */
/* global window, document */
function noop() {}

var KEYS = {
  enter: 13,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  esc: 27,
  space: 32,
  backspace: 8,
  tab: 9,
  delete: 46
};

// returns an O3D object or false otherwise.
function toO3D(n) {
  return n !== true ? n : false;
}

// Returns an element position
function _getPos(elem) {
  var bbox = elem.getBoundingClientRect();
  return {
    x: bbox.left,
    y: bbox.top,
    bbox: bbox
  };
}

// event object wrapper
function get(e, win) {
  win = win || window;
  return e || win.event;
}

function getWheel(e) {
  return e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
}

function getKey(e) {
  var code = e.which || e.keyCode;
  var key = keyOf(code);
  // onkeydown
  var fKey = code - 111;
  if (fKey > 0 && fKey < 13) {
    key = 'f' + fKey;
  }
  key = key || String.fromCharCode(code).toLowerCase();

  return {
    code: code,
    key: key,
    shift: e.shiftKey,
    control: e.ctrlKey,
    alt: e.altKey,
    meta: e.metaKey
  };
}

function isRightClick(e) {
  return e.which === 3 || e.button === 2;
}

function getPos(e, win) {
  // get mouse position
  win = win || window;
  e = e || win.event;
  var doc = win.document;
  doc = doc.documentElement || doc.body;
  // TODO(nico): make touch event handling better
  if (e.touches && e.touches.length) {
    var touchesPos = [];
    var l = e.touches.length;
    var evt = void 0;
    for (var i = 0; i < l; ++i) {
      evt = e.touches[i];
      touchesPos.push({
        x: evt.pageX || evt.clientX + doc.scrollLeft,
        y: evt.pageY || evt.clientY + doc.scrollTop
      });
    }
    return touchesPos;
  }
  var page = {
    x: e.pageX || e.clientX + doc.scrollLeft,
    y: e.pageY || e.clientY + doc.scrollTop
  };
  return [page];
}

function _stop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  e.cancelBubble = true;
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
}

var EventsProxy = function () {
  function EventsProxy(domElem, opt) {
    _classCallCheck(this, EventsProxy);

    this.scene = opt.scene;
    this.domElem = domElem;
    this.pos = _getPos(domElem);
    this.opt = this.callbacks = opt;

    this.size = {
      width: domElem.width || domElem.offsetWidth,
      height: domElem.height || domElem.offsetHeight
    };

    this.attachEvents();
  }

  _createClass(EventsProxy, [{
    key: 'attachEvents',
    value: function attachEvents() {
      var _this = this;

      var domElem = this.domElem;
      var opt = this.opt;

      if (opt.disableContextMenu) {
        domElem.oncontextmenu = function () {
          return false;
        };
      }

      if (opt.enableMouse) {
        ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout'].forEach(function (action) {
          domElem.addEventListener(action, function (e, win) {
            _this[action](_this.eventInfo(action, e, win));
          }, false);
        });

        // "well, this is embarrassing..."
        var type = '';
        if (!document.getBoxObjectFor && window.mozInnerScreenX === null) {
          type = 'mousewheel';
        } else {
          type = 'DOMMouseScroll';
        }
        domElem.addEventListener(type, function (e, win) {
          _this['mousewheel'](_this.eventInfo('mousewheel', e, win));
        }, false);
      }

      if (opt.enableTouch) {
        ['touchstart', 'touchmove', 'touchend'].forEach(function (action) {
          domElem.addEventListener(action, function (e, win) {
            _this[action](_this.eventInfo(action, e, win));
          }, false);
        });
      }

      if (opt.enableKeyboard) {
        ['keydown', 'keyup'].forEach(function (action) {
          document.addEventListener(action, function (e, win) {
            _this[action](_this.eventInfo(action, e, win));
          }, false);
        });
      }
    }
  }, {
    key: 'eventInfo',
    value: function eventInfo(type, e, win) {
      var domElem = this.domElem;
      var scene = this.scene;
      var opt = this.opt;
      var size = this.getSize();
      var relative = opt.relative;
      var centerOrigin = opt.centerOrigin;
      var pos = opt.cachePosition && this.pos || _getPos(domElem);
      var ge = get(e, win);
      var epos = getPos(e, win);
      var origPos = { x: epos[0].x, y: epos[0].y };
      var evt = {};
      var x = void 0;
      var y = void 0;

      // get Position
      for (var i = 0, l = epos.length; i < l; ++i) {
        x = epos[i].x;
        y = epos[i].y;
        if (relative) {
          x -= pos.x;y -= pos.y;
          if (centerOrigin) {
            x -= size.width / 2;
            y -= size.height / 2;
            // y axis now points to the top of the screen
            y *= -1;
          }
        }
        epos[i].x = x;
        epos[i].y = y;
      }

      switch (type) {
        case 'mousewheel':
          evt.wheel = getWheel(ge);
          break;
        case 'keydown':
        case 'keyup':
          Object.assign(evt, getKey(ge));
          break;
        case 'mouseup':
          evt.isRightClick = isRightClick(ge);
          break;
        default:
          break;
      }

      var cacheTarget = void 0;

      Object.assign(evt, {
        x: epos[0].x,
        y: epos[0].y,
        posArray: epos,

        cache: false,
        // stop event propagation
        stop: function stop() {
          _stop(ge);
        },

        // get the target element of the event
        getTarget: function getTarget() {
          if (cacheTarget) {
            return cacheTarget;
          }
          return cacheTarget = opt.picking && scene.pick(origPos.x - pos.x, origPos.y - pos.y) || true;
        }
      });
      // wrap native event
      evt.event = ge;

      return evt;
    }
  }, {
    key: 'getSize',
    value: function getSize() {
      if (this.cacheSize) {
        return this.size;
      }
      var domElem = this.domElem;
      return {
        width: domElem.width || domElem.offsetWidth,
        height: domElem.height || domElem.offsetHeight
      };
    }
  }, {
    key: 'mouseup',
    value: function mouseup(e) {
      if (!this.moved) {
        if (e.isRightClick) {
          this.callbacks.onRightClick(e, this.hovered);
        } else {
          this.callbacks.onClick(e, toO3D(this.pressed));
        }
      }
      if (this.pressed) {
        if (this.moved) {
          this.callbacks.onDragEnd(e, toO3D(this.pressed));
        } else {
          this.callbacks.onDragCancel(e, toO3D(this.pressed));
        }
        this.pressed = this.moved = false;
      }
    }
  }, {
    key: 'mouseout',
    value: function mouseout(e) {
      // mouseout canvas
      var rt = e.relatedTarget;
      var domElem = this.domElem;
      while (rt && rt.parentNode) {
        if (domElem === rt.parentNode) {
          return;
        }
        rt = rt.parentNode;
      }
      if (this.hovered) {
        this.callbacks.onMouseLeave(e, this.hovered);
        this.hovered = false;
      }
      if (this.pressed && this.moved) {
        this.callbacks.onDragEnd(e);
        this.pressed = this.moved = false;
      }
    }
  }, {
    key: 'mouseover',
    value: function mouseover(e) {}
  }, {
    key: 'mousemove',
    value: function mousemove(e) {
      if (this.pressed) {
        this.moved = true;
        this.callbacks.onDragMove(e, toO3D(this.pressed));
        return;
      }
      if (this.hovered) {
        var target = toO3D(e.getTarget());
        if (!target || target.hash !== this.hash) {
          this.callbacks.onMouseLeave(e, this.hovered);
          this.hovered = target;
          this.hash = target;
          if (target) {
            this.hash = target.hash;
            this.callbacks.onMouseEnter(e, this.hovered);
          }
        } else {
          this.callbacks.onMouseMove(e, this.hovered);
        }
      } else {
        this.hovered = toO3D(e.getTarget());
        this.hash = this.hovered;
        if (this.hovered) {
          this.hash = this.hovered.hash;
          this.callbacks.onMouseEnter(e, this.hovered);
        }
      }
      if (!this.opt.picking) {
        this.callbacks.onMouseMove(e);
      }
    }
  }, {
    key: 'mousewheel',
    value: function mousewheel(e) {
      this.callbacks.onMouseWheel(e);
    }
  }, {
    key: 'mousedown',
    value: function mousedown(e) {
      this.pressed = e.getTarget();
      this.callbacks.onDragStart(e, toO3D(this.pressed));
    }
  }, {
    key: 'touchstart',
    value: function touchstart(e) {
      this.touched = e.getTarget();
      this.touchedLastPosition = { x: e.x, y: e.y };
      this.callbacks.onTouchStart(e, toO3D(this.touched));
    }
  }, {
    key: 'touchmove',
    value: function touchmove(e) {
      if (this.touched) {
        this.touchMoved = true;
        this.callbacks.onTouchMove(e, toO3D(this.touched));
      }
    }
  }, {
    key: 'touchend',
    value: function touchend(e) {
      if (this.touched) {
        if (this.touchMoved) {
          this.callbacks.onTouchEnd(e, toO3D(this.touched));
        } else {
          e.x = isNaN(e.x) ? this.touchedLastPosition.x : e.x;
          e.y = isNaN(e.y) ? this.touchedLastPosition.y : e.y;
          this.callbacks.onTap(e, toO3D(this.touched));
          this.callbacks.onTouchCancel(e, toO3D(this.touched));
        }
        this.touched = this.touchMoved = false;
      }
    }
  }, {
    key: 'keydown',
    value: function keydown(e) {
      this.callbacks.onKeyDown(e);
    }
  }, {
    key: 'keyup',
    value: function keyup(e) {
      this.callbacks.onKeyUp(e);
    }
  }]);

  return EventsProxy;
}();

Object.assign(EventsProxy.prototype, {
  hovered: false,
  pressed: false,
  touched: false,
  touchedLastPosition: { x: 0, y: 0 },
  touchMoved: false,
  moved: false
});

var DEFAULT_OPTS = {
  cachePosition: true,
  cacheSize: true,
  relative: true,
  centerOrigin: true,
  disableContextMenu: true,
  bind: false,
  picking: false,

  enableTouch: true,
  enableMouse: true,
  enableKeyboard: true,

  onClick: noop,
  onRightClick: noop,
  onDragStart: noop,
  onDragMove: noop,
  onDragEnd: noop,
  onDragCancel: noop,
  onTouchStart: noop,
  onTouchMove: noop,
  onTouchEnd: noop,
  onTouchCancel: noop,
  onTap: noop,
  onMouseMove: noop,
  onMouseEnter: noop,
  onMouseLeave: noop,
  onMouseWheel: noop,
  onKeyDown: noop,
  onKeyUp: noop
};

var Keys = KEYS;

function keyOf(code) {
  var keyMap = Keys;
  for (var name in keyMap) {
    if (keyMap[name] === code) {
      return name;
    }
  }
  return null;
}

function addEvents(domElement) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  opt = Object.assign({}, DEFAULT_OPTS, opt);

  var bind = opt.bind;
  if (bind) {
    for (var name in opt) {
      if (name.match(/^on[a-zA-Z0-9]+$/)) {
        (function (fname, fn) {
          opt[fname] = function f() {
            fn.apply(bind, Array.prototype.slice.call(arguments));
          };
        })(name, opt[name]);
      }
    }
  }

  return new EventsProxy(domElement, opt);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWNrYWdlcy9ldmVudHMvYWRkLWV2ZW50cy5qcyJdLCJuYW1lcyI6WyJub29wIiwiS0VZUyIsImVudGVyIiwidXAiLCJkb3duIiwibGVmdCIsInJpZ2h0IiwiZXNjIiwic3BhY2UiLCJiYWNrc3BhY2UiLCJ0YWIiLCJkZWxldGUiLCJ0b08zRCIsIm4iLCJfZ2V0UG9zIiwiZWxlbSIsImJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsInRvcCIsImdldCIsImUiLCJ3aW4iLCJ3aW5kb3ciLCJldmVudCIsImdldFdoZWVsIiwid2hlZWxEZWx0YSIsImRldGFpbCIsImdldEtleSIsImNvZGUiLCJ3aGljaCIsImtleUNvZGUiLCJrZXkiLCJrZXlPZiIsImZLZXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0xvd2VyQ2FzZSIsInNoaWZ0Iiwic2hpZnRLZXkiLCJjb250cm9sIiwiY3RybEtleSIsImFsdCIsImFsdEtleSIsIm1ldGEiLCJtZXRhS2V5IiwiaXNSaWdodENsaWNrIiwiYnV0dG9uIiwiZ2V0UG9zIiwiZG9jIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwidG91Y2hlcyIsImxlbmd0aCIsInRvdWNoZXNQb3MiLCJsIiwiZXZ0IiwiaSIsInB1c2giLCJwYWdlWCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwicGFnZVkiLCJjbGllbnRZIiwic2Nyb2xsVG9wIiwicGFnZSIsInN0b3AiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwiRXZlbnRzUHJveHkiLCJkb21FbGVtIiwib3B0Iiwic2NlbmUiLCJwb3MiLCJjYWxsYmFja3MiLCJzaXplIiwid2lkdGgiLCJvZmZzZXRXaWR0aCIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImF0dGFjaEV2ZW50cyIsImRpc2FibGVDb250ZXh0TWVudSIsIm9uY29udGV4dG1lbnUiLCJlbmFibGVNb3VzZSIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwiYWN0aW9uIiwiZXZlbnRJbmZvIiwidHlwZSIsImdldEJveE9iamVjdEZvciIsIm1veklubmVyU2NyZWVuWCIsImVuYWJsZVRvdWNoIiwiZW5hYmxlS2V5Ym9hcmQiLCJnZXRTaXplIiwicmVsYXRpdmUiLCJjZW50ZXJPcmlnaW4iLCJjYWNoZVBvc2l0aW9uIiwiZ2UiLCJlcG9zIiwib3JpZ1BvcyIsIndoZWVsIiwiT2JqZWN0IiwiYXNzaWduIiwiY2FjaGVUYXJnZXQiLCJwb3NBcnJheSIsImNhY2hlIiwiZ2V0VGFyZ2V0IiwicGlja2luZyIsInBpY2siLCJjYWNoZVNpemUiLCJtb3ZlZCIsIm9uUmlnaHRDbGljayIsImhvdmVyZWQiLCJvbkNsaWNrIiwicHJlc3NlZCIsIm9uRHJhZ0VuZCIsIm9uRHJhZ0NhbmNlbCIsInJ0IiwicmVsYXRlZFRhcmdldCIsInBhcmVudE5vZGUiLCJvbk1vdXNlTGVhdmUiLCJvbkRyYWdNb3ZlIiwidGFyZ2V0IiwiaGFzaCIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVdoZWVsIiwib25EcmFnU3RhcnQiLCJ0b3VjaGVkIiwidG91Y2hlZExhc3RQb3NpdGlvbiIsIm9uVG91Y2hTdGFydCIsInRvdWNoTW92ZWQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJpc05hTiIsIm9uVGFwIiwib25Ub3VjaENhbmNlbCIsIm9uS2V5RG93biIsIm9uS2V5VXAiLCJwcm90b3R5cGUiLCJERUZBVUxUX09QVFMiLCJiaW5kIiwiS2V5cyIsImtleU1hcCIsIm5hbWUiLCJhZGRFdmVudHMiLCJkb21FbGVtZW50IiwibWF0Y2giLCJmbmFtZSIsImZuIiwiZiIsImFwcGx5IiwiQXJyYXkiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBU0EsSUFBVCxHQUFnQixDQUFFOztBQUVsQixJ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QTNCLENBQWY7QUFDRCxXQUZEO0FBR0QsU0FKRCxFQUlHWCxJQUpILEVBSVN6RSxJQUFJeUUsSUFBSixDQUpUO0FBS0Q7QUFDRjtBQUNGOztBQUVELFNBQU8sSUFBSTNFLFdBQUosQ0FBZ0I2RSxVQUFoQixFQUE0QjNFLEdBQTVCLENBQVA7QUFDRCIsImZpbGUiOiJhZGQtZXZlbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXZlbnQuanNcbi8vIEhhbmRsZSBrZXlib2FyZC9tb3VzZS90b3VjaCBldmVudHMgaW4gdGhlIENhbnZhc1xuLy8gVE9ETyAtIHRoaXMgd2lsbCBub3Qgd29yayB1bmRlciBub2RlXG5cbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiwgbWF4LXN0YXRlbWVudHMsIG5vLWxvb3AtZnVuYyAqL1xuLyogZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBLRVlTID0ge1xuICBlbnRlcjogMTMsXG4gIHVwOiAzOCxcbiAgZG93bjogNDAsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGVzYzogMjcsXG4gIHNwYWNlOiAzMixcbiAgYmFja3NwYWNlOiA4LFxuICB0YWI6IDksXG4gIGRlbGV0ZTogNDZcbn07XG5cbi8vIHJldHVybnMgYW4gTzNEIG9iamVjdCBvciBmYWxzZSBvdGhlcndpc2UuXG5mdW5jdGlvbiB0b08zRChuKSB7XG4gIHJldHVybiBuICE9PSB0cnVlID8gbiA6IGZhbHNlO1xufVxuXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgcG9zaXRpb25cbmZ1bmN0aW9uIF9nZXRQb3MoZWxlbSkge1xuICBjb25zdCBiYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBiYm94LmxlZnQsXG4gICAgeTogYmJveC50b3AsXG4gICAgYmJveFxuICB9O1xufVxuXG4vLyBldmVudCBvYmplY3Qgd3JhcHBlclxuZXhwb3J0IGZ1bmN0aW9uIGdldChlLCB3aW4pIHtcbiAgd2luID0gd2luIHx8IHdpbmRvdztcbiAgcmV0dXJuIGUgfHwgd2luLmV2ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWwoZSkge1xuICByZXR1cm4gZS53aGVlbERlbHRhID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoZSkge1xuICBjb25zdCBjb2RlID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gIGxldCBrZXkgPSBrZXlPZihjb2RlKTtcbiAgLy8gb25rZXlkb3duXG4gIGNvbnN0IGZLZXkgPSBjb2RlIC0gMTExO1xuICBpZiAoZktleSA+IDAgJiYgZktleSA8IDEzKSB7XG4gICAga2V5ID0gYGYke2ZLZXl9YDtcbiAgfVxuICBrZXkgPSBrZXkgfHwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBrZXksXG4gICAgc2hpZnQ6IGUuc2hpZnRLZXksXG4gICAgY29udHJvbDogZS5jdHJsS2V5LFxuICAgIGFsdDogZS5hbHRLZXksXG4gICAgbWV0YTogZS5tZXRhS2V5XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JpZ2h0Q2xpY2soZSkge1xuICByZXR1cm4gZS53aGljaCA9PT0gMyB8fCBlLmJ1dHRvbiA9PT0gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvcyhlLCB3aW4pIHtcbiAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uXG4gIHdpbiA9IHdpbiB8fCB3aW5kb3c7XG4gIGUgPSBlIHx8IHdpbi5ldmVudDtcbiAgbGV0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgZG9jID0gZG9jLmRvY3VtZW50RWxlbWVudCB8fCBkb2MuYm9keTtcbiAgLy8gVE9ETyhuaWNvKTogbWFrZSB0b3VjaCBldmVudCBoYW5kbGluZyBiZXR0ZXJcbiAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgdG91Y2hlc1BvcyA9IFtdO1xuICAgIGNvbnN0IGwgPSBlLnRvdWNoZXMubGVuZ3RoO1xuICAgIGxldCBldnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgIGV2dCA9IGUudG91Y2hlc1tpXTtcbiAgICAgIHRvdWNoZXNQb3MucHVzaCh7XG4gICAgICAgIHg6IGV2dC5wYWdlWCB8fCAoZXZ0LmNsaWVudFggKyBkb2Muc2Nyb2xsTGVmdCksXG4gICAgICAgIHk6IGV2dC5wYWdlWSB8fCAoZXZ0LmNsaWVudFkgKyBkb2Muc2Nyb2xsVG9wKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b3VjaGVzUG9zO1xuICB9XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgeDogZS5wYWdlWCB8fCAoZS5jbGllbnRYICsgZG9jLnNjcm9sbExlZnQpLFxuICAgIHk6IGUucGFnZVkgfHwgKGUuY2xpZW50WSArIGRvYy5zY3JvbGxUb3ApXG4gIH07XG4gIHJldHVybiBbcGFnZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcbiAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXZlbnRzUHJveHkge1xuXG4gIGNvbnN0cnVjdG9yKGRvbUVsZW0sIG9wdCkge1xuICAgIHRoaXMuc2NlbmUgPSBvcHQuc2NlbmU7XG4gICAgdGhpcy5kb21FbGVtID0gZG9tRWxlbTtcbiAgICB0aGlzLnBvcyA9IF9nZXRQb3MoZG9tRWxlbSk7XG4gICAgdGhpcy5vcHQgPSB0aGlzLmNhbGxiYWNrcyA9IG9wdDtcblxuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBkb21FbGVtLndpZHRoIHx8IGRvbUVsZW0ub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGRvbUVsZW0uaGVpZ2h0IHx8IGRvbUVsZW0ub2Zmc2V0SGVpZ2h0XG4gICAgfTtcblxuICAgIHRoaXMuYXR0YWNoRXZlbnRzKCk7XG4gIH1cblxuICBhdHRhY2hFdmVudHMoKSB7XG4gICAgY29uc3QgZG9tRWxlbSA9IHRoaXMuZG9tRWxlbTtcbiAgICBjb25zdCBvcHQgPSB0aGlzLm9wdDtcblxuICAgIGlmIChvcHQuZGlzYWJsZUNvbnRleHRNZW51KSB7XG4gICAgICBkb21FbGVtLm9uY29udGV4dG1lbnUgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0LmVuYWJsZU1vdXNlKSB7XG4gICAgICBbJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXVxuICAgICAgLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgZG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgKGUsIHdpbikgPT4ge1xuICAgICAgICAgIHRoaXNbYWN0aW9uXSh0aGlzLmV2ZW50SW5mbyhhY3Rpb24sIGUsIHdpbikpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gXCJ3ZWxsLCB0aGlzIGlzIGVtYmFycmFzc2luZy4uLlwiXG4gICAgICBsZXQgdHlwZSA9ICcnO1xuICAgICAgaWYgKCFkb2N1bWVudC5nZXRCb3hPYmplY3RGb3IgJiYgd2luZG93Lm1veklubmVyU2NyZWVuWCA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gJ21vdXNld2hlZWwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdET01Nb3VzZVNjcm9sbCc7XG4gICAgICB9XG4gICAgICBkb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGUsIHdpbikgPT4ge1xuICAgICAgICB0aGlzWydtb3VzZXdoZWVsJ10odGhpcy5ldmVudEluZm8oJ21vdXNld2hlZWwnLCBlLCB3aW4pKTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0LmVuYWJsZVRvdWNoKSB7XG4gICAgICBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10uZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICBkb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCAoZSwgd2luKSA9PiB7XG4gICAgICAgICAgdGhpc1thY3Rpb25dKHRoaXMuZXZlbnRJbmZvKGFjdGlvbiwgZSwgd2luKSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHQuZW5hYmxlS2V5Ym9hcmQpIHtcbiAgICAgIFsna2V5ZG93bicsICdrZXl1cCddLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIChlLCB3aW4pID0+IHtcbiAgICAgICAgICB0aGlzW2FjdGlvbl0odGhpcy5ldmVudEluZm8oYWN0aW9uLCBlLCB3aW4pKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnRJbmZvKHR5cGUsIGUsIHdpbikge1xuICAgIGNvbnN0IGRvbUVsZW0gPSB0aGlzLmRvbUVsZW07XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IG9wdCA9IHRoaXMub3B0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IG9wdC5yZWxhdGl2ZTtcbiAgICBjb25zdCBjZW50ZXJPcmlnaW4gPSBvcHQuY2VudGVyT3JpZ2luO1xuICAgIGNvbnN0IHBvcyA9IG9wdC5jYWNoZVBvc2l0aW9uICYmIHRoaXMucG9zIHx8IF9nZXRQb3MoZG9tRWxlbSk7XG4gICAgY29uc3QgZ2UgPSBnZXQoZSwgd2luKTtcbiAgICBjb25zdCBlcG9zID0gZ2V0UG9zKGUsIHdpbik7XG4gICAgY29uc3Qgb3JpZ1BvcyA9IHt4OiBlcG9zWzBdLngsIHk6IGVwb3NbMF0ueX07XG4gICAgY29uc3QgZXZ0ID0ge307XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG5cbiAgICAvLyBnZXQgUG9zaXRpb25cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVwb3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICB4ID0gZXBvc1tpXS54O1xuICAgICAgeSA9IGVwb3NbaV0ueTtcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICB4IC09IHBvcy54OyB5IC09IHBvcy55O1xuICAgICAgICBpZiAoY2VudGVyT3JpZ2luKSB7XG4gICAgICAgICAgeCAtPSBzaXplLndpZHRoIC8gMjtcbiAgICAgICAgICB5IC09IHNpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAvLyB5IGF4aXMgbm93IHBvaW50cyB0byB0aGUgdG9wIG9mIHRoZSBzY3JlZW5cbiAgICAgICAgICB5ICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlcG9zW2ldLnggPSB4O1xuICAgICAgZXBvc1tpXS55ID0geTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdtb3VzZXdoZWVsJzpcbiAgICAgIGV2dC53aGVlbCA9IGdldFdoZWVsKGdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIE9iamVjdC5hc3NpZ24oZXZ0LCBnZXRLZXkoZ2UpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgZXZ0LmlzUmlnaHRDbGljayA9IGlzUmlnaHRDbGljayhnZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlVGFyZ2V0O1xuXG4gICAgT2JqZWN0LmFzc2lnbihldnQsIHtcbiAgICAgIHg6IGVwb3NbMF0ueCxcbiAgICAgIHk6IGVwb3NbMF0ueSxcbiAgICAgIHBvc0FycmF5OiBlcG9zLFxuXG4gICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAvLyBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICBzdG9wKCkge1xuICAgICAgICBzdG9wKGdlKTtcbiAgICAgIH0sXG4gICAgICAvLyBnZXQgdGhlIHRhcmdldCBlbGVtZW50IG9mIHRoZSBldmVudFxuICAgICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICBpZiAoY2FjaGVUYXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjYWNoZVRhcmdldCA9IG9wdC5waWNraW5nICYmXG4gICAgICAgICAgc2NlbmUucGljayhvcmlnUG9zLnggLSBwb3MueCwgb3JpZ1Bvcy55IC0gcG9zLnkpIHx8IHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHdyYXAgbmF0aXZlIGV2ZW50XG4gICAgZXZ0LmV2ZW50ID0gZ2U7XG5cbiAgICByZXR1cm4gZXZ0O1xuICB9XG5cbiAgZ2V0U2l6ZSgpIHtcbiAgICBpZiAodGhpcy5jYWNoZVNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuICAgIGNvbnN0IGRvbUVsZW0gPSB0aGlzLmRvbUVsZW07XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBkb21FbGVtLndpZHRoIHx8IGRvbUVsZW0ub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGRvbUVsZW0uaGVpZ2h0IHx8IGRvbUVsZW0ub2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIG1vdXNldXAoZSkge1xuICAgIGlmICghdGhpcy5tb3ZlZCkge1xuICAgICAgaWYgKGUuaXNSaWdodENsaWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uUmlnaHRDbGljayhlLCB0aGlzLmhvdmVyZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25DbGljayhlLCB0b08zRCh0aGlzLnByZXNzZWQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgaWYgKHRoaXMubW92ZWQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25EcmFnRW5kKGUsIHRvTzNEKHRoaXMucHJlc3NlZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25EcmFnQ2FuY2VsKGUsIHRvTzNEKHRoaXMucHJlc3NlZCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVzc2VkID0gdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG1vdXNlb3V0KGUpIHtcbiAgICAvLyBtb3VzZW91dCBjYW52YXNcbiAgICBsZXQgcnQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgY29uc3QgZG9tRWxlbSA9IHRoaXMuZG9tRWxlbTtcbiAgICB3aGlsZSAocnQgJiYgcnQucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGRvbUVsZW0gPT09IHJ0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcnQgPSBydC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAodGhpcy5ob3ZlcmVkKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlTGVhdmUoZSwgdGhpcy5ob3ZlcmVkKTtcbiAgICAgIHRoaXMuaG92ZXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVzc2VkICYmIHRoaXMubW92ZWQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRHJhZ0VuZChlKTtcbiAgICAgIHRoaXMucHJlc3NlZCA9IHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBtb3VzZW92ZXIoZSkge1xuICB9XG5cbiAgbW91c2Vtb3ZlKGUpIHtcbiAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRHJhZ01vdmUoZSwgdG9PM0QodGhpcy5wcmVzc2VkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmhvdmVyZWQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRvTzNEKGUuZ2V0VGFyZ2V0KCkpO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0Lmhhc2ggIT09IHRoaXMuaGFzaCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlTGVhdmUoZSwgdGhpcy5ob3ZlcmVkKTtcbiAgICAgICAgdGhpcy5ob3ZlcmVkID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmhhc2ggPSB0YXJnZXQuaGFzaDtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlRW50ZXIoZSwgdGhpcy5ob3ZlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25Nb3VzZU1vdmUoZSwgdGhpcy5ob3ZlcmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ob3ZlcmVkID0gdG9PM0QoZS5nZXRUYXJnZXQoKSk7XG4gICAgICB0aGlzLmhhc2ggPSB0aGlzLmhvdmVyZWQ7XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRoaXMuaG92ZXJlZC5oYXNoO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlRW50ZXIoZSwgdGhpcy5ob3ZlcmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdC5waWNraW5nKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlTW92ZShlKTtcbiAgICB9XG4gIH1cblxuICBtb3VzZXdoZWVsKGUpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbk1vdXNlV2hlZWwoZSk7XG4gIH1cblxuICBtb3VzZWRvd24oZSkge1xuICAgIHRoaXMucHJlc3NlZCA9IGUuZ2V0VGFyZ2V0KCk7XG4gICAgdGhpcy5jYWxsYmFja3Mub25EcmFnU3RhcnQoZSwgdG9PM0QodGhpcy5wcmVzc2VkKSk7XG4gIH1cblxuICB0b3VjaHN0YXJ0KGUpIHtcbiAgICB0aGlzLnRvdWNoZWQgPSBlLmdldFRhcmdldCgpO1xuICAgIHRoaXMudG91Y2hlZExhc3RQb3NpdGlvbiA9IHt4OiBlLngsIHk6IGUueX07XG4gICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaFN0YXJ0KGUsIHRvTzNEKHRoaXMudG91Y2hlZCkpO1xuICB9XG5cbiAgdG91Y2htb3ZlKGUpIHtcbiAgICBpZiAodGhpcy50b3VjaGVkKSB7XG4gICAgICB0aGlzLnRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaE1vdmUoZSwgdG9PM0QodGhpcy50b3VjaGVkKSk7XG4gICAgfVxuICB9XG5cbiAgdG91Y2hlbmQoZSkge1xuICAgIGlmICh0aGlzLnRvdWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLnRvdWNoTW92ZWQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaEVuZChlLCB0b08zRCh0aGlzLnRvdWNoZWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUueCA9IGlzTmFOKGUueCkgPyB0aGlzLnRvdWNoZWRMYXN0UG9zaXRpb24ueCA6IGUueDtcbiAgICAgICAgZS55ID0gaXNOYU4oZS55KSA/IHRoaXMudG91Y2hlZExhc3RQb3NpdGlvbi55IDogZS55O1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblRhcChlLCB0b08zRCh0aGlzLnRvdWNoZWQpKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25Ub3VjaENhbmNlbChlLCB0b08zRCh0aGlzLnRvdWNoZWQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG91Y2hlZCA9IHRoaXMudG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGtleWRvd24oZSkge1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uS2V5RG93bihlKTtcbiAgfVxuXG4gIGtleXVwKGUpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5vbktleVVwKGUpO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oRXZlbnRzUHJveHkucHJvdG90eXBlLCB7XG4gIGhvdmVyZWQ6IGZhbHNlLFxuICBwcmVzc2VkOiBmYWxzZSxcbiAgdG91Y2hlZDogZmFsc2UsXG4gIHRvdWNoZWRMYXN0UG9zaXRpb246IHt4OiAwLCB5OiAwfSxcbiAgdG91Y2hNb3ZlZDogZmFsc2UsXG4gIG1vdmVkOiBmYWxzZVxufSk7XG5cbmNvbnN0IERFRkFVTFRfT1BUUyA9IHtcbiAgY2FjaGVQb3NpdGlvbjogdHJ1ZSxcbiAgY2FjaGVTaXplOiB0cnVlLFxuICByZWxhdGl2ZTogdHJ1ZSxcbiAgY2VudGVyT3JpZ2luOiB0cnVlLFxuICBkaXNhYmxlQ29udGV4dE1lbnU6IHRydWUsXG4gIGJpbmQ6IGZhbHNlLFxuICBwaWNraW5nOiBmYWxzZSxcblxuICBlbmFibGVUb3VjaDogdHJ1ZSxcbiAgZW5hYmxlTW91c2U6IHRydWUsXG4gIGVuYWJsZUtleWJvYXJkOiB0cnVlLFxuXG4gIG9uQ2xpY2s6IG5vb3AsXG4gIG9uUmlnaHRDbGljazogbm9vcCxcbiAgb25EcmFnU3RhcnQ6IG5vb3AsXG4gIG9uRHJhZ01vdmU6IG5vb3AsXG4gIG9uRHJhZ0VuZDogbm9vcCxcbiAgb25EcmFnQ2FuY2VsOiBub29wLFxuICBvblRvdWNoU3RhcnQ6IG5vb3AsXG4gIG9uVG91Y2hNb3ZlOiBub29wLFxuICBvblRvdWNoRW5kOiBub29wLFxuICBvblRvdWNoQ2FuY2VsOiBub29wLFxuICBvblRhcDogbm9vcCxcbiAgb25Nb3VzZU1vdmU6IG5vb3AsXG4gIG9uTW91c2VFbnRlcjogbm9vcCxcbiAgb25Nb3VzZUxlYXZlOiBub29wLFxuICBvbk1vdXNlV2hlZWw6IG5vb3AsXG4gIG9uS2V5RG93bjogbm9vcCxcbiAgb25LZXlVcDogbm9vcFxufTtcblxuZXhwb3J0IGNvbnN0IEtleXMgPSBLRVlTO1xuXG5mdW5jdGlvbiBrZXlPZihjb2RlKSB7XG4gIGNvbnN0IGtleU1hcCA9IEtleXM7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBrZXlNYXApIHtcbiAgICBpZiAoa2V5TWFwW25hbWVdID09PSBjb2RlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFdmVudHMoZG9tRWxlbWVudCwgb3B0ID0ge30pIHtcbiAgb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBvcHQpO1xuXG4gIGNvbnN0IGJpbmQgPSBvcHQuYmluZDtcbiAgaWYgKGJpbmQpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0KSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXm9uW2EtekEtWjAtOV0rJC8pKSB7XG4gICAgICAgICgoZm5hbWUsIGZuKSA9PiB7XG4gICAgICAgICAgb3B0W2ZuYW1lXSA9IGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShiaW5kLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShuYW1lLCBvcHRbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRXZlbnRzUHJveHkoZG9tRWxlbWVudCwgb3B0KTtcbn1cbiJdfQ==

/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__add_events__ = __webpack_require__(247);
/* unused harmony reexport addEvents */

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWNrYWdlcy9ldmVudHMvaW5kZXguanMiXSwibmFtZXMiOlsiYWRkRXZlbnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFRQSxTQUFSLFFBQXdCLGNBQXhCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHthZGRFdmVudHN9IGZyb20gJy4vYWRkLWV2ZW50cyc7XG4iXX0=

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkArguments = checkArguments;
exports.validateVector2 = validateVector2;
exports.checkVector2 = checkVector2;
exports.validateVector3 = validateVector3;
exports.checkVector3 = checkVector3;
exports.validateVector4 = validateVector4;
exports.checkVector4 = checkVector4;
exports.validateQuaternion = validateQuaternion;
exports.checkQuaternion = checkQuaternion;
exports.validateMatrix2 = validateMatrix2;
exports.checkMatrix2 = checkMatrix2;
exports.validateMatrix2d = validateMatrix2d;
exports.checkMatrix2d = checkMatrix2d;
exports.validateMatrix3 = validateMatrix3;
exports.checkMatrix3 = checkMatrix3;
exports.validateMatrix4 = validateMatrix4;
exports.checkMatrix4 = checkMatrix4;

var _glMatrix = __webpack_require__(9);

function checkArguments() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var i = 0; i < args.length; ++i) {
    if (args[i] === undefined) {
      throw new Error('Invalid math argument');
    }
  }
}

function validateVector2(v) {
  return v.length === 2 && Number.isFinite(v[0]) && Number.isFinite(v[1]);
}

function checkVector2(v) {
  if (_glMatrix.glMatrix.debug && !validateVector2(v)) {
    throw new Error('Invalid Vector2');
  }
}

function validateVector3(v) {
  return v.length === 3 && Number.isFinite(v[0]) && Number.isFinite(v[1]) && Number.isFinite(v[2]);
}

function checkVector3(v) {
  if (_glMatrix.glMatrix.debug && !validateVector3(v)) {
    throw new Error('Invalid Vector3');
  }
}

function validateVector4(v) {
  return v.length === 4 && Number.isFinite(v[0]) && Number.isFinite(v[1]) && Number.isFinite(v[2]) && Number.isFinite(v[3]);
}

function checkVector4(v) {
  if (_glMatrix.glMatrix.debug && !validateVector4(v)) {
    throw new Error('Invalid Vector4');
  }
}

function validateQuaternion(q) {
  return q.length === 4 && Number.isFinite(q[0]) && Number.isFinite(q[1]) && Number.isFinite(q[2]) && Number.isFinite(q[3]);
}

function checkQuaternion(q) {
  if (_glMatrix.glMatrix.debug && !validateQuaternion(q)) {
    throw new Error('Invalid Quaternion');
  }
}

function validateMatrix2(m) {
  return m.length === 4 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]);
}

function checkMatrix2(m) {
  if (_glMatrix.glMatrix.debug && !validateMatrix2(m)) {
    throw new Error('Invalid Matrix2');
  }
}

function validateMatrix2d(m) {
  return m.length === 6 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]);
}

function checkMatrix2d(m) {
  if (_glMatrix.glMatrix.debug && !validateMatrix2d(m)) {
    throw new Error('Invalid Matrix2d');
  }
}

function validateMatrix3(m) {
  return m.length === 9 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]);
}

function checkMatrix3(m) {
  if (_glMatrix.glMatrix.debug && !validateMatrix3(m)) {
    throw new Error('Invalid Matrix3');
  }
}

function validateMatrix4(m) {
  return m.length === 16 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]) && Number.isFinite(m[9]) && Number.isFinite(m[10]) && Number.isFinite(m[11]) && Number.isFinite(m[12]) && Number.isFinite(m[13]) && Number.isFinite(m[14]) && Number.isFinite(m[15]);
}

function checkMatrix4(m) {
  if (_glMatrix.glMatrix.debug && !validateMatrix4(m)) {
    throw new Error('Invalid Matrix4');
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9wYWNrYWdlcy9tYXRoL3NyYy91dGlscy92YWxpZGF0b3JzLmpzIl0sIm5hbWVzIjpbImNoZWNrQXJndW1lbnRzIiwidmFsaWRhdGVWZWN0b3IyIiwiY2hlY2tWZWN0b3IyIiwidmFsaWRhdGVWZWN0b3IzIiwiY2hlY2tWZWN0b3IzIiwidmFsaWRhdGVWZWN0b3I0IiwiY2hlY2tWZWN0b3I0IiwidmFsaWRhdGVRdWF0ZXJuaW9uIiwiY2hlY2tRdWF0ZXJuaW9uIiwidmFsaWRhdGVNYXRyaXgyIiwiY2hlY2tNYXRyaXgyIiwidmFsaWRhdGVNYXRyaXgyZCIsImNoZWNrTWF0cml4MmQiLCJ2YWxpZGF0ZU1hdHJpeDMiLCJjaGVja01hdHJpeDMiLCJ2YWxpZGF0ZU1hdHJpeDQiLCJjaGVja01hdHJpeDQiLCJhcmdzIiwiaSIsImxlbmd0aCIsInVuZGVmaW5lZCIsIkVycm9yIiwidiIsIk51bWJlciIsImlzRmluaXRlIiwiZGVidWciLCJxIiwibSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFFZ0JBLGMsR0FBQUEsYztRQVFBQyxlLEdBQUFBLGU7UUFLQUMsWSxHQUFBQSxZO1FBTUFDLGUsR0FBQUEsZTtRQUtBQyxZLEdBQUFBLFk7UUFNQUMsZSxHQUFBQSxlO1FBTUFDLFksR0FBQUEsWTtRQU1BQyxrQixHQUFBQSxrQjtRQU1BQyxlLEdBQUFBLGU7UUFNQUMsZSxHQUFBQSxlO1FBTUFDLFksR0FBQUEsWTtRQU1BQyxnQixHQUFBQSxnQjtRQU9BQyxhLEdBQUFBLGE7UUFNQUMsZSxHQUFBQSxlO1FBU0FDLFksR0FBQUEsWTtRQU1BQyxlLEdBQUFBLGU7UUFZQUMsWSxHQUFBQSxZOztBQTVHaEI7O0FBRU8sU0FBU2hCLGNBQVQsR0FBaUM7QUFBQSxvQ0FBTmlCLElBQU07QUFBTkEsUUFBTTtBQUFBOztBQUN0QyxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsS0FBS0UsTUFBekIsRUFBaUMsRUFBRUQsQ0FBbkMsRUFBc0M7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RixDQUFoQixDQUxLLElBS29CSixPQUFPQyxRQUFQLENBQWdCRyxFQUFFLENBQUYsQ0FBaEIsQ0FMcEIsSUFNTEosT0FBT0MsUUFBUCxDQUFnQkcsRUFBRSxFQUFGLENBQWhCLENBTkssSUFNcUJKLE9BQU9DLFFBQVAsQ0FBZ0JHLEVBQUUsRUFBRixDQUFoQixDQU5yQixJQU9MSixPQUFPQyxRQUFQLENBQWdCRyxFQUFFLEVBQUYsQ0FBaEIsQ0FQSyxJQU9xQkosT0FBT0MsUUFBUCxDQUFnQkcsRUFBRSxFQUFGLENBQWhCLENBUHJCLElBUUxKLE9BQU9DLFFBQVAsQ0FBZ0JHLEVBQUUsRUFBRixDQUFoQixDQVJLLElBUXFCSixPQUFPQyxRQUFQLENBQWdCRyxFQUFFLEVBQUYsQ0FBaEIsQ0FSNUI7QUFTRDs7QUFFTSxTQUFTWCxZQUFULENBQXNCVyxDQUF0QixFQUF5QjtBQUM5QixNQUFJLG1CQUFTRixLQUFULElBQWtCLENBQUNWLGdCQUFnQlksQ0FBaEIsQ0FBdkIsRUFBMkM7QUFDekMsVUFBTSxJQUFJTixLQUFKLENBQVUsaUJBQVYsQ0FBTjtBQUNEO0FBQ0YiLCJmaWxlIjoidmFsaWRhdG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2xNYXRyaXh9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FyZ3VtZW50cyguLi5hcmdzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcmdzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXRoIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVZlY3RvcjIodikge1xuICByZXR1cm4gdi5sZW5ndGggPT09IDIgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUodlswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZbMV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWZWN0b3IyKHYpIHtcbiAgaWYgKGdsTWF0cml4LmRlYnVnICYmICF2YWxpZGF0ZVZlY3RvcjIodikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVmVjdG9yMicpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVZlY3RvcjModikge1xuICByZXR1cm4gdi5sZW5ndGggPT09IDMgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUodlswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZbMV0pICYmIE51bWJlci5pc0Zpbml0ZSh2WzJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVmVjdG9yMyh2KSB7XG4gIGlmIChnbE1hdHJpeC5kZWJ1ZyAmJiAhdmFsaWRhdGVWZWN0b3IzKHYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFZlY3RvcjMnKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWZWN0b3I0KHYpIHtcbiAgcmV0dXJuIHYubGVuZ3RoID09PSA0ICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKHZbMF0pICYmIE51bWJlci5pc0Zpbml0ZSh2WzFdKSAmJlxuICAgIE51bWJlci5pc0Zpbml0ZSh2WzJdKSAmJiBOdW1iZXIuaXNGaW5pdGUodlszXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZlY3RvcjQodikge1xuICBpZiAoZ2xNYXRyaXguZGVidWcgJiYgIXZhbGlkYXRlVmVjdG9yNCh2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBWZWN0b3I0Jyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUXVhdGVybmlvbihxKSB7XG4gIHJldHVybiBxLmxlbmd0aCA9PT0gNCAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShxWzBdKSAmJiBOdW1iZXIuaXNGaW5pdGUocVsxXSkgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUocVsyXSkgJiYgTnVtYmVyLmlzRmluaXRlKHFbM10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tRdWF0ZXJuaW9uKHEpIHtcbiAgaWYgKGdsTWF0cml4LmRlYnVnICYmICF2YWxpZGF0ZVF1YXRlcm5pb24ocSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUXVhdGVybmlvbicpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1hdHJpeDIobSkge1xuICByZXR1cm4gbS5sZW5ndGggPT09IDQgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUobVswXSkgJiYgTnVtYmVyLmlzRmluaXRlKG1bMV0pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bMl0pICYmIE51bWJlci5pc0Zpbml0ZShtWzNdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWF0cml4MihtKSB7XG4gIGlmIChnbE1hdHJpeC5kZWJ1ZyAmJiAhdmFsaWRhdGVNYXRyaXgyKG0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1hdHJpeDInKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNYXRyaXgyZChtKSB7XG4gIHJldHVybiBtLmxlbmd0aCA9PT0gNiAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShtWzBdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVsxXSkgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUobVsyXSkgJiYgTnVtYmVyLmlzRmluaXRlKG1bM10pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bNF0pICYmIE51bWJlci5pc0Zpbml0ZShtWzVdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWF0cml4MmQobSkge1xuICBpZiAoZ2xNYXRyaXguZGVidWcgJiYgIXZhbGlkYXRlTWF0cml4MmQobSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTWF0cml4MmQnKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNYXRyaXgzKG0pIHtcbiAgcmV0dXJuIG0ubGVuZ3RoID09PSA5ICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bMF0pICYmIE51bWJlci5pc0Zpbml0ZShtWzFdKSAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShtWzJdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVszXSkgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUobVs0XSkgJiYgTnVtYmVyLmlzRmluaXRlKG1bNV0pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bNl0pICYmIE51bWJlci5pc0Zpbml0ZShtWzddKSAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShtWzhdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWF0cml4MyhtKSB7XG4gIGlmIChnbE1hdHJpeC5kZWJ1ZyAmJiAhdmFsaWRhdGVNYXRyaXgzKG0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1hdHJpeDMnKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNYXRyaXg0KG0pIHtcbiAgcmV0dXJuIG0ubGVuZ3RoID09PSAxNiAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShtWzBdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVsxXSkgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUobVsyXSkgJiYgTnVtYmVyLmlzRmluaXRlKG1bM10pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bNF0pICYmIE51bWJlci5pc0Zpbml0ZShtWzVdKSAmJlxuICAgIE51bWJlci5pc0Zpbml0ZShtWzZdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVs3XSkgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUobVs4XSkgJiYgTnVtYmVyLmlzRmluaXRlKG1bOV0pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bMTBdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVsxMV0pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bMTJdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVsxM10pICYmXG4gICAgTnVtYmVyLmlzRmluaXRlKG1bMTRdKSAmJiBOdW1iZXIuaXNGaW5pdGUobVsxNV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNYXRyaXg0KG0pIHtcbiAgaWYgKGdsTWF0cml4LmRlYnVnICYmICF2YWxpZGF0ZU1hdHJpeDQobSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTWF0cml4NCcpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPageLoaded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pageLoadPromise; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__is_browser__ = __webpack_require__(56);
/* global window, document */


var isPageLoaded = false;

var pageLoadPromise = __WEBPACK_IMPORTED_MODULE_0__is_browser__["c" /* default */] ? new Promise(function (resolve, reject) {
  window.onload = function () {
    isPageLoaded = true;
    resolve(document);
  };
}) : Promise.resolve({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9icm93c2VyLXV0aWxzLmpzIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsImlzUGFnZUxvYWRlZCIsInBhZ2VMb2FkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid2luZG93Iiwib25sb2FkIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsT0FBT0EsU0FBUCxNQUFzQixjQUF0Qjs7QUFFQSxPQUFPLElBQUlDLGVBQWUsS0FBbkI7O0FBRVAsT0FBTyxJQUFNQyxrQkFBa0JGLFlBQzdCLElBQUlHLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDL0JDLFNBQU9DLE1BQVAsR0FBZ0IsWUFBTTtBQUNwQk4sbUJBQWUsSUFBZjtBQUNBRyxZQUFRSSxRQUFSO0FBQ0QsR0FIRDtBQUlELENBTEQsQ0FENkIsR0FPN0JMLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBaEIsQ0FQSyIsImZpbGUiOiJicm93c2VyLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQgKi9cbmltcG9ydCBpc0Jyb3dzZXIgZnJvbSAnLi9pcy1icm93c2VyJztcblxuZXhwb3J0IGxldCBpc1BhZ2VMb2FkZWQgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IHBhZ2VMb2FkUHJvbWlzZSA9IGlzQnJvd3NlciA/XG4gIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3aW5kb3cub25sb2FkID0gKCkgPT4ge1xuICAgICAgaXNQYWdlTG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJlc29sdmUoZG9jdW1lbnQpO1xuICAgIH07XG4gIH0pIDpcbiAgUHJvbWlzZS5yZXNvbHZlKHt9KTtcblxuIl19

/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = promisify;
/**
 * Converts a function that accepts a node style (err, result) callback
 * as the last argument into a function that takes the same arguments
 * and returns a promise that resolves or rejects with the values provided
 * by the original callback
 * @param {Function} func - function to wrap
 * @return {Function} promisified function
 */
/* eslint-disable no-try-catch */
function promisify(func) {
  return function promisifiedFunction() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      function callback(error, data) {
        try {
          if (error) {
            reject(error);
          } else {
            resolve(data);
          }
        } catch (e) {
          reject(e);
        }
      }
      func.apply(undefined, args.concat([callback]));
    });
  };
}
/* eslint-enable no-try-catch */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wcm9taXNlLXV0aWxzLmpzIl0sIm5hbWVzIjpbInByb21pc2lmeSIsImZ1bmMiLCJwcm9taXNpZmllZEZ1bmN0aW9uIiwiYXJncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbGJhY2siLCJlcnJvciIsImRhdGEiLCJlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBLE9BQU8sU0FBU0EsU0FBVCxDQUFtQkMsSUFBbkIsRUFBeUI7QUFDOUIsU0FBTyxTQUFTQyxtQkFBVCxHQUFzQztBQUFBLHNDQUFOQyxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFDM0MsV0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDLGVBQVNDLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQXlCQyxJQUF6QixFQUErQjtBQUM3QixZQUFJO0FBQ0YsY0FBSUQsS0FBSixFQUFXO0FBQ1RGLG1CQUFPRSxLQUFQO0FBQ0QsV0FGRCxNQUVPO0FBQ0xILG9CQUFRSSxJQUFSO0FBQ0Q7QUFDRixTQU5ELENBTUUsT0FBT0MsQ0FBUCxFQUFVO0FBQ1ZKLGlCQUFPSSxDQUFQO0FBQ0Q7QUFDRjtBQUNEVCw0QkFBUUUsSUFBUixTQUFjSSxRQUFkO0FBQ0QsS0FiTSxDQUFQO0FBY0QsR0FmRDtBQWdCRDtBQUNEIiwiZmlsZSI6InByb21pc2UtdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnZlcnRzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbm9kZSBzdHlsZSAoZXJyLCByZXN1bHQpIGNhbGxiYWNrXG4gKiBhcyB0aGUgbGFzdCBhcmd1bWVudCBpbnRvIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkXG4gKiBieSB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvbWlzaWZpZWQgZnVuY3Rpb25cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdHJ5LWNhdGNoICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzaWZ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2lmaWVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmMoLi4uYXJncywgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9O1xufVxuLyogZXNsaW50LWVuYWJsZSBuby10cnktY2F0Y2ggKi9cbiJdfQ==

/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = splat;
/* harmony export (immutable) */ __webpack_exports__["b"] = noop;
/* harmony export (immutable) */ __webpack_exports__["c"] = uid;
/* harmony export (immutable) */ __webpack_exports__["d"] = merge;
/**
 * Wraps the argument in an array if it is not one.
 * @param {object} a - The object to wrap.
 * @return {Array} array
 **/
function splat(a) {
  return a ? Array.isArray(a) ? a : [a] : [];
}

/**
* Provides a standard noop function.
**/
function noop() {}

var uidCounters = {};

/**
 * Returns a UID.
 * @param {String} id= - Identifier base name
 * @return {number} uid
 **/
function uid() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';

  uidCounters[id] = uidCounters[id] || 1;
  var count = uidCounters[id]++;
  return id + '-' + count;
}

/**
 * Merge multiple objects into one.
 * @param {...object} objects - The objects to merge.
 * @return {object} object
 **/
function merge(objects) {
  var mix = {};
  for (var i = 0, l = arguments.length; i < l; i++) {
    var object = arguments[i];
    if (!object || object.constructor.name !== 'Object') {
      /* eslint-disable no-continue */
      continue;
    }
    for (var key in object) {
      var op = object[key];
      var mp = mix[key];
      if (mp && op.constructor.name === 'Object' && mp.constructor.name === 'Object') {
        mix[key] = merge(mp, op);
      } else {
        mix[key] = detach(op);
      }
    }
  }
  return mix;
}

/**
 * Internal function for duplicating an object.
 * @param {object} elem - The object to recursively duplicate.
 * @return {object} object
 **/
function detach(elem) {
  var t = elem.constructor.name;
  var ans = void 0;
  if (t === 'Object') {
    ans = {};
    for (var p in elem) {
      ans[p] = detach(elem[p]);
    }
  } else if (t === 'Array') {
    ans = [];
    for (var i = 0, l = elem.length; i < l; i++) {
      ans[i] = detach(elem[i]);
    }
  } else {
    ans = elem;
  }

  return ans;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy91dGlscy5qcyJdLCJuYW1lcyI6WyJzcGxhdCIsImEiLCJBcnJheSIsImlzQXJyYXkiLCJub29wIiwidWlkQ291bnRlcnMiLCJ1aWQiLCJpZCIsImNvdW50IiwibWVyZ2UiLCJvYmplY3RzIiwibWl4IiwiaSIsImwiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJvYmplY3QiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJrZXkiLCJvcCIsIm1wIiwiZGV0YWNoIiwiZWxlbSIsInQiLCJhbnMiLCJwIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxPQUFPLFNBQVNBLEtBQVQsQ0FBZUMsQ0FBZixFQUFrQjtBQUN2QixTQUFPQSxJQUFLQyxNQUFNQyxPQUFOLENBQWNGLENBQWQsSUFBbUJBLENBQW5CLEdBQXVCLENBQUNBLENBQUQsQ0FBNUIsR0FBbUMsRUFBMUM7QUFDRDs7QUFFRDs7O0FBR0EsT0FBTyxTQUFTRyxJQUFULEdBQWdCLENBQUU7O0FBRXpCLElBQU1DLGNBQWMsRUFBcEI7O0FBRUE7Ozs7O0FBS0EsT0FBTyxTQUFTQyxHQUFULEdBQXdCO0FBQUEsTUFBWEMsRUFBVyx1RUFBTixJQUFNOztBQUM3QkYsY0FBWUUsRUFBWixJQUFrQkYsWUFBWUUsRUFBWixLQUFtQixDQUFyQztBQUNBLE1BQU1DLFFBQVFILFlBQVlFLEVBQVosR0FBZDtBQUNBLFNBQVVBLEVBQVYsU0FBZ0JDLEtBQWhCO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsT0FBTyxTQUFTQyxLQUFULENBQWVDLE9BQWYsRUFBd0I7QUFDN0IsTUFBTUMsTUFBTSxFQUFaO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQVIsRUFBV0MsSUFBSUMsVUFBVUMsTUFBOUIsRUFBc0NILElBQUlDLENBQTFDLEVBQTZDRCxHQUE3QyxFQUFrRDtBQUNoRCxRQUFNSSxTQUFTRixVQUFVRixDQUFWLENBQWY7QUFDQSxRQUFJLENBQUNJLE1BQUQsSUFBV0EsT0FBT0MsV0FBUCxDQUFtQkMsSUFBbkIsS0FBNEIsUUFBM0MsRUFBcUQ7QUFDbkQ7QUFDQTtBQUNEO0FBQ0QsU0FBSyxJQUFNQyxHQUFYLElBQWtCSCxNQUFsQixFQUEwQjtBQUN4QixVQUFNSSxLQUFLSixPQUFPRyxHQUFQLENBQVg7QUFDQSxVQUFNRSxLQUFLVixJQUFJUSxHQUFKLENBQVg7QUFDQSxVQUFJRSxNQUFNRCxHQUFHSCxXQUFILENBQWVDLElBQWYsS0FBd0IsUUFBOUIsSUFDRkcsR0FBR0osV0FBSCxDQUFlQyxJQUFmLEtBQXdCLFFBRDFCLEVBQ29DO0FBQ2xDUCxZQUFJUSxHQUFKLElBQVdWLE1BQU1ZLEVBQU4sRUFBVUQsRUFBVixDQUFYO0FBQ0QsT0FIRCxNQUdPO0FBQ0xULFlBQUlRLEdBQUosSUFBV0csT0FBT0YsRUFBUCxDQUFYO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT1QsR0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNXLE1BQVQsQ0FBZ0JDLElBQWhCLEVBQXNCO0FBQ3BCLE1BQU1DLElBQUlELEtBQUtOLFdBQUwsQ0FBaUJDLElBQTNCO0FBQ0EsTUFBSU8sWUFBSjtBQUNBLE1BQUlELE1BQU0sUUFBVixFQUFvQjtBQUNsQkMsVUFBTSxFQUFOO0FBQ0EsU0FBSyxJQUFNQyxDQUFYLElBQWdCSCxJQUFoQixFQUFzQjtBQUNwQkUsVUFBSUMsQ0FBSixJQUFTSixPQUFPQyxLQUFLRyxDQUFMLENBQVAsQ0FBVDtBQUNEO0FBQ0YsR0FMRCxNQUtPLElBQUlGLE1BQU0sT0FBVixFQUFtQjtBQUN4QkMsVUFBTSxFQUFOO0FBQ0EsU0FBSyxJQUFJYixJQUFJLENBQVIsRUFBV0MsSUFBSVUsS0FBS1IsTUFBekIsRUFBaUNILElBQUlDLENBQXJDLEVBQXdDRCxHQUF4QyxFQUE2QztBQUMzQ2EsVUFBSWIsQ0FBSixJQUFTVSxPQUFPQyxLQUFLWCxDQUFMLENBQVAsQ0FBVDtBQUNEO0FBQ0YsR0FMTSxNQUtBO0FBQ0xhLFVBQU1GLElBQU47QUFDRDs7QUFFRCxTQUFPRSxHQUFQO0FBQ0QiLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdyYXBzIHRoZSBhcmd1bWVudCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3Qgb25lLlxuICogQHBhcmFtIHtvYmplY3R9IGEgLSBUaGUgb2JqZWN0IHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXlcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxhdChhKSB7XG4gIHJldHVybiBhID8gKEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdKSA6IFtdO1xufVxuXG4vKipcbiogUHJvdmlkZXMgYSBzdGFuZGFyZCBub29wIGZ1bmN0aW9uLlxuKiovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHVpZENvdW50ZXJzID0ge307XG5cbi8qKlxuICogUmV0dXJucyBhIFVJRC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpZD0gLSBJZGVudGlmaWVyIGJhc2UgbmFtZVxuICogQHJldHVybiB7bnVtYmVyfSB1aWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB1aWQoaWQgPSAnaWQnKSB7XG4gIHVpZENvdW50ZXJzW2lkXSA9IHVpZENvdW50ZXJzW2lkXSB8fCAxO1xuICBjb25zdCBjb3VudCA9IHVpZENvdW50ZXJzW2lkXSsrO1xuICByZXR1cm4gYCR7aWR9LSR7Y291bnR9YDtcbn1cblxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBvYmplY3RzIGludG8gb25lLlxuICogQHBhcmFtIHsuLi5vYmplY3R9IG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0cykge1xuICBjb25zdCBtaXggPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghb2JqZWN0IHx8IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnT2JqZWN0Jykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29udGludWUgKi9cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGNvbnN0IG9wID0gb2JqZWN0W2tleV07XG4gICAgICBjb25zdCBtcCA9IG1peFtrZXldO1xuICAgICAgaWYgKG1wICYmIG9wLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnICYmXG4gICAgICAgIG1wLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIG1peFtrZXldID0gbWVyZ2UobXAsIG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1peFtrZXldID0gZGV0YWNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgZHVwbGljYXRpbmcgYW4gb2JqZWN0LlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW0gLSBUaGUgb2JqZWN0IHRvIHJlY3Vyc2l2ZWx5IGR1cGxpY2F0ZS5cbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBkZXRhY2goZWxlbSkge1xuICBjb25zdCB0ID0gZWxlbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICBsZXQgYW5zO1xuICBpZiAodCA9PT0gJ09iamVjdCcpIHtcbiAgICBhbnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHAgaW4gZWxlbSkge1xuICAgICAgYW5zW3BdID0gZGV0YWNoKGVsZW1bcF0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0ID09PSAnQXJyYXknKSB7XG4gICAgYW5zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbGVtLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYW5zW2ldID0gZGV0YWNoKGVsZW1baV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbnMgPSBlbGVtO1xuICB9XG5cbiAgcmV0dXJuIGFucztcbn1cbiJdfQ==

/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getShaderName;
/* harmony export (immutable) */ __webpack_exports__["a"] = formatGLSLCompilerError;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* eslint-disable no-continue, max-statements */


// import shaderName from 'glsl-shader-name';
// replace with regexp
function getShaderName(shader) {
  return 'unnamed';
}

/**
 * Formats a GLSL shader compiler error and generates a string
 * showing the source code around the error.
 *
 * From https://github.com/wwwtyro/gl-format-compiler-error (public domain)
 *
 * @param {String} errLog - error log from gl.getShaderInfoLog
 * @param {String} src - original shader source code
 * @param {Number} shaderType - shader type (GL constant)
 * @return {String} - Formatted strings has the error marked inline with src.
 */
function formatGLSLCompilerError(errLog, src, shaderType) {
  var errorStrings = errLog.split(/\r?\n/);
  var errors = {};

  // Parse the error - note: browser and driver dependent
  for (var i = 0; i < errorStrings.length; i++) {
    var errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    var lineNo = parseInt(errorString.split(':')[2], 10);
    if (isNaN(lineNo)) {
      return 'Could not parse GLSL compiler error: ' + errLog;
    }
    errors[lineNo] = errorString;
  }

  // Format the error inline with the code
  var message = '';
  var lines = addLineNumbers(src).split(/\r?\n/);

  for (var _i = 0; _i < lines.length; _i++) {
    var line = lines[_i];
    if (!errors[_i + 3] && !errors[_i + 2] && !errors[_i + 1]) {
      continue;
    }
    message += line + '\n';
    if (errors[_i + 1]) {
      var e = errors[_i + 1];
      e = e.substr(e.split(':', 3).join(':').length + 1).trim();
      message += '^^^ ' + e + '\n\n';
    }
  }

  var name = getShaderName(src) || 'unknown name';
  var type = getShaderTypeName(shaderType);
  return 'GLSL error in ' + type + ' shader ' + name + '\n' + message;
}

/**
 * Prepends line numbers to each line of a string.
 * The line numbers will be left-padded with spaces to ensure an
 * aligned layout when rendered using monospace fonts.
 *
 * Adapted from https://github.com/Jam3/add-line-numbers, MIT license
 *
 * @param {String} string - multi-line string to add line numbers to
 * @param {Number} start=1 - number of spaces to add
 * @param {String} delim =': ' - injected between line number and original line
 * @return {String} string - The original string with line numbers added
 */
function addLineNumbers(string) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';

  var lines = string.split(/\r?\n/);
  var maxDigits = String(lines.length + start - 1).length;
  return lines.map(function (line, i) {
    var lineNumber = i + start;
    var digits = String(lineNumber).length;
    var prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  }).join('\n');
}

/**
 * Pads a string with a number of spaces (space characters) to the left
 * @param {String} string - string to pad
 * @param {Number} digits - number of spaces to add
 * @return {String} string - The padded string
 */
function padLeft(string, digits) {
  var result = '';
  for (var i = 0; i < digits; ++i) {
    result += ' ';
  }
  return '' + result + string;
}

function getShaderTypeName(type) {
  switch (type) {
    case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].FRAGMENT_SHADER:
      return 'fragment';
    case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].VERTEX_SHADER:
      return 'vertex';
    default:
      return 'unknown type';
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy93ZWJnbC9hcGkvd2ViZ2wtZm9ybWF0LXNoYWRlci1lcnJvci5qcyJdLCJuYW1lcyI6WyJHTCIsImdldFNoYWRlck5hbWUiLCJzaGFkZXIiLCJmb3JtYXRHTFNMQ29tcGlsZXJFcnJvciIsImVyckxvZyIsInNyYyIsInNoYWRlclR5cGUiLCJlcnJvclN0cmluZ3MiLCJzcGxpdCIsImVycm9ycyIsImkiLCJsZW5ndGgiLCJlcnJvclN0cmluZyIsImxpbmVObyIsInBhcnNlSW50IiwiaXNOYU4iLCJtZXNzYWdlIiwibGluZXMiLCJhZGRMaW5lTnVtYmVycyIsImxpbmUiLCJlIiwic3Vic3RyIiwiam9pbiIsInRyaW0iLCJuYW1lIiwidHlwZSIsImdldFNoYWRlclR5cGVOYW1lIiwic3RyaW5nIiwic3RhcnQiLCJkZWxpbSIsIm1heERpZ2l0cyIsIlN0cmluZyIsIm1hcCIsImxpbmVOdW1iZXIiLCJkaWdpdHMiLCJwcmVmaXgiLCJwYWRMZWZ0IiwicmVzdWx0IiwiRlJBR01FTlRfU0hBREVSIiwiVkVSVEVYX1NIQURFUiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxPQUFPQSxFQUFQLE1BQWUsUUFBZjs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxTQUFTQyxhQUFULENBQXVCQyxNQUF2QixFQUErQjtBQUNwQyxTQUFPLFNBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxPQUFPLFNBQVNDLHVCQUFULENBQWlDQyxNQUFqQyxFQUF5Q0MsR0FBekMsRUFBOENDLFVBQTlDLEVBQTBEO0FBQy9ELE1BQU1DLGVBQWVILE9BQU9JLEtBQVAsQ0FBYSxPQUFiLENBQXJCO0FBQ0EsTUFBTUMsU0FBUyxFQUFmOztBQUVBO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILGFBQWFJLE1BQWpDLEVBQXlDRCxHQUF6QyxFQUE4QztBQUM1QyxRQUFNRSxjQUFjTCxhQUFhRyxDQUFiLENBQXBCO0FBQ0EsUUFBSUUsWUFBWUQsTUFBWixJQUFz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cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY29udGludWUsIG1heC1zdGF0ZW1lbnRzICovXG5pbXBvcnQgR0wgZnJvbSAnLi4vYXBpJztcblxuLy8gaW1wb3J0IHNoYWRlck5hbWUgZnJvbSAnZ2xzbC1zaGFkZXItbmFtZSc7XG4vLyByZXBsYWNlIHdpdGggcmVnZXhwXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhZGVyTmFtZShzaGFkZXIpIHtcbiAgcmV0dXJuICd1bm5hbWVkJztcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgR0xTTCBzaGFkZXIgY29tcGlsZXIgZXJyb3IgYW5kIGdlbmVyYXRlcyBhIHN0cmluZ1xuICogc2hvd2luZyB0aGUgc291cmNlIGNvZGUgYXJvdW5kIHRoZSBlcnJvci5cbiAqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93d3d0eXJvL2dsLWZvcm1hdC1jb21waWxlci1lcnJvciAocHVibGljIGRvbWFpbilcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXJyTG9nIC0gZXJyb3IgbG9nIGZyb20gZ2wuZ2V0U2hhZGVySW5mb0xvZ1xuICogQHBhcmFtIHtTdHJpbmd9IHNyYyAtIG9yaWdpbmFsIHNoYWRlciBzb3VyY2UgY29kZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNoYWRlclR5cGUgLSBzaGFkZXIgdHlwZSAoR0wgY29uc3RhbnQpXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gRm9ybWF0dGVkIHN0cmluZ3MgaGFzIHRoZSBlcnJvciBtYXJrZWQgaW5saW5lIHdpdGggc3JjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0R0xTTENvbXBpbGVyRXJyb3IoZXJyTG9nLCBzcmMsIHNoYWRlclR5cGUpIHtcbiAgY29uc3QgZXJyb3JTdHJpbmdzID0gZXJyTG9nLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGVycm9ycyA9IHt9O1xuXG4gIC8vIFBhcnNlIHRoZSBlcnJvciAtIG5vdGU6IGJyb3dzZXIgYW5kIGRyaXZlciBkZXBlbmRlbnRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvclN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlcnJvclN0cmluZyA9IGVycm9yU3RyaW5nc1tpXTtcbiAgICBpZiAoZXJyb3JTdHJpbmcubGVuZ3RoIDw9IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lTm8gPSBwYXJzZUludChlcnJvclN0cmluZy5zcGxpdCgnOicpWzJdLCAxMCk7XG4gICAgaWYgKGlzTmFOKGxpbmVObykpIHtcbiAgICAgIHJldHVybiBgQ291bGQgbm90IHBhcnNlIEdMU0wgY29tcGlsZXIgZXJyb3I6ICR7ZXJyTG9nfWA7XG4gICAgfVxuICAgIGVycm9yc1tsaW5lTm9dID0gZXJyb3JTdHJpbmc7XG4gIH1cblxuICAvLyBGb3JtYXQgdGhlIGVycm9yIGlubGluZSB3aXRoIHRoZSBjb2RlXG4gIGxldCBtZXNzYWdlID0gJyc7XG4gIGNvbnN0IGxpbmVzID0gYWRkTGluZU51bWJlcnMoc3JjKS5zcGxpdCgvXFxyP1xcbi8pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKCFlcnJvcnNbaSArIDNdICYmICFlcnJvcnNbaSArIDJdICYmICFlcnJvcnNbaSArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBgJHtsaW5lfVxcbmA7XG4gICAgaWYgKGVycm9yc1tpICsgMV0pIHtcbiAgICAgIGxldCBlID0gZXJyb3JzW2kgKyAxXTtcbiAgICAgIGUgPSBlLnN1YnN0cihlLnNwbGl0KCc6JywgMykuam9pbignOicpLmxlbmd0aCArIDEpLnRyaW0oKTtcbiAgICAgIG1lc3NhZ2UgKz0gYF5eXiAke2V9XFxuXFxuYDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuYW1lID0gZ2V0U2hhZGVyTmFtZShzcmMpIHx8ICd1bmtub3duIG5hbWUnO1xuICBjb25zdCB0eXBlID0gZ2V0U2hhZGVyVHlwZU5hbWUoc2hhZGVyVHlwZSk7XG4gIHJldHVybiBgR0xTTCBlcnJvciBpbiAke3R5cGV9IHNoYWRlciAke25hbWV9XFxuJHttZXNzYWdlfWA7XG59XG5cbi8qKlxuICogUHJlcGVuZHMgbGluZSBudW1iZXJzIHRvIGVhY2ggbGluZSBvZiBhIHN0cmluZy5cbiAqIFRoZSBsaW5lIG51bWJlcnMgd2lsbCBiZSBsZWZ0LXBhZGRlZCB3aXRoIHNwYWNlcyB0byBlbnN1cmUgYW5cbiAqIGFsaWduZWQgbGF5b3V0IHdoZW4gcmVuZGVyZWQgdXNpbmcgbW9ub3NwYWNlIGZvbnRzLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vSmFtMy9hZGQtbGluZS1udW1iZXJzLCBNSVQgbGljZW5zZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBtdWx0aS1saW5lIHN0cmluZyB0byBhZGQgbGluZSBudW1iZXJzIHRvXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQ9MSAtIG51bWJlciBvZiBzcGFjZXMgdG8gYWRkXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gPSc6ICcgLSBpbmplY3RlZCBiZXR3ZWVuIGxpbmUgbnVtYmVyIGFuZCBvcmlnaW5hbCBsaW5lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyAtIFRoZSBvcmlnaW5hbCBzdHJpbmcgd2l0aCBsaW5lIG51bWJlcnMgYWRkZWRcbiAqL1xuZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoc3RyaW5nLCBzdGFydCA9IDEsIGRlbGltID0gJzogJykge1xuICBjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBtYXhEaWdpdHMgPSBTdHJpbmcobGluZXMubGVuZ3RoICsgc3RhcnQgLSAxKS5sZW5ndGg7XG4gIHJldHVybiBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gaSArIHN0YXJ0O1xuICAgIGNvbnN0IGRpZ2l0cyA9IFN0cmluZyhsaW5lTnVtYmVyKS5sZW5ndGg7XG4gICAgY29uc3QgcHJlZml4ID0gcGFkTGVmdChsaW5lTnVtYmVyLCBtYXhEaWdpdHMgLSBkaWdpdHMpO1xuICAgIHJldHVybiBwcmVmaXggKyBkZWxpbSArIGxpbmU7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFBhZHMgYSBzdHJpbmcgd2l0aCBhIG51bWJlciBvZiBzcGFjZXMgKHNwYWNlIGNoYXJhY3RlcnMpIHRvIHRoZSBsZWZ0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0cyAtIG51bWJlciBvZiBzcGFjZXMgdG8gYWRkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyAtIFRoZSBwYWRkZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHBhZExlZnQoc3RyaW5nLCBkaWdpdHMpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0czsgKytpKSB7XG4gICAgcmVzdWx0ICs9ICcgJztcbiAgfVxuICByZXR1cm4gYCR7cmVzdWx0fSR7c3RyaW5nfWA7XG59XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVOYW1lKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgR0wuRlJBR01FTlRfU0hBREVSOiByZXR1cm4gJ2ZyYWdtZW50JztcbiAgY2FzZSBHTC5WRVJURVhfU0hBREVSOiByZXR1cm4gJ3ZlcnRleCc7XG4gIGRlZmF1bHQ6IHJldHVybiAndW5rbm93biB0eXBlJztcbiAgfVxufVxuIl19

/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getGLParameter */
/* unused harmony export setGLParameter */
/* unused harmony export withGLState */
/* unused harmony export TEST_EXPORTS */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint-disable no-inline-comments, max-len */



// WebGL specification 'types'
var GLenum = 'GLenum';
var GLfloat = 'GLfloat';
var GLint = 'GLint';
var GLuint = 'GLint';
var GLboolean = 'GLboolean';

/*
State management
- camelCased versions of the GL constants
- except when setter function exist that are named differently
- When gl api offers <setter> and <setter>Separate, the parameter is named
  after the setter but
*/

// Map of composite parameters
var GL_STATE = {
  blend: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND, value);
    }
  },

  blendColor: {
    type: new Float32Array(4),
    value: new Float32Array([0, 0, 0, 0]),
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_COLOR,
    setter: function setter(gl, value) {
      return gl.blendColor(value);
    }
  },

  blendEquation: {
    type: [GLenum, GLenum],
    value: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FUNC_ADD, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FUNC_ADD],
    params: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_EQUATION_RGB, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_EQUATION_ALPHA],
    object: ['rgb', 'alpha'],
    setter: function setter(gl, value) {
      return gl.blendEquationSeparate.apply(gl, _toConsumableArray(value));
    },
    normalizeArgs: function normalizeArgs(args) {
      return isArray(args) ? args : [args, args];
    }
  },

  // blend func
  blendFunc: {
    type: [GLenum, GLenum, GLenum, GLenum],
    value: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ONE, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ZERO, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ONE, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ZERO],
    params: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_SRC_RGB, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_DST_RGB, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BLEND_DST_ALPHA],
    object: ['srcRgb', 'srcAlpha', 'dstRgb', 'dstAlpha'],
    setter: function setter(gl, value) {
      return gl.blendFuncSeparate.apply(gl, _toConsumableArray(value));
    },
    normalizeArgs: function normalizeArgs(args) {
      return isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;
    }
  },

  clearColor: {
    type: new Float32Array(4),
    value: new Float32Array([0, 0, 0, 0]), // TBD
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].COLOR_CLEAR_VALUE,
    setter: function setter(gl, value) {
      return gl.clearColor.apply(gl, _toConsumableArray(value));
    }
  },

  colorMask: {
    type: [GLboolean, GLboolean, GLboolean, GLboolean],
    value: [true, true, true, true],
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].COLOR_WRITEMASK,
    setter: function setter(gl, value) {
      return gl.colorMask.apply(gl, _toConsumableArray(value));
    }
  },

  cullFace: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].CULL_FACE,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].CULL_FACE, value);
    }
  },

  cullFaceMode: {
    type: GLenum,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].CULL_FACE_MODE,
    setter: function setter(gl, value) {
      return gl.cullFace(value);
    }
  },

  depthTest: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_TEST,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_TEST, value);
    }
  },

  depthClearValue: {
    type: GLfloat,
    value: true,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_CLEAR_VALUE,
    setter: function setter(gl, value) {
      return gl.clearDepth(value);
    }
  },

  depthFunc: {
    type: GLenum,
    value: null,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_FUNC,
    setter: function setter(gl, value) {
      return gl.depthFunc(value);
    }
  },

  depthRange: {
    type: new Float32Array(2),
    value: new Float32Array([0, 1]), // TBD
    object: ['min', 'max'],
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_RANGE,
    setter: function setter(gl, value) {
      return gl.depthRange.apply(gl, _toConsumableArray(value));
    }
  },

  depthWritemask: {
    type: GLboolean,
    value: null,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DEPTH_WRITEMASK,
    setter: function setter(gl, value) {
      return gl.depthMask(value);
    }
  },

  dither: {
    type: GLboolean,
    value: true,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DITHER,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DITHER, value);
    }
  },

  frontFace: {
    type: GLenum,
    value: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].CCW,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRONT_FACE,
    setter: function setter(gl, value) {
      return gl.frontFace(value);
    }
  },

  // Hint for quality of images generated with glGenerateMipmap
  generateMipmapHint: {
    type: GLenum,
    value: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].DONT_CARE,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].GENERATE_MIPMAP_HINT,
    setter: function setter(gl, value) {
      return gl.hint(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].GENERATE_MIPMAP_HINT, value);
    }
  },

  lineWidth: {
    type: GLfloat,
    value: 1,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_WIDTH,
    setter: function setter(gl, value) {
      return gl.lineWidth(value);
    }
  },

  polygonOffsetFill: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POLYGON_OFFSET_FILL,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POLYGON_OFFSET_FILL, value);
    }
  },

  // Add small offset to fragment depth values (by factor  DZ + r  units)
  // Useful for rendering hidden-line images, for applying decals to surfaces,
  // and for rendering solids with highlighted edges.
  // https://www.khronos.org/opengles/sdk/docs/man/xhtml/glPolygonOffset.xml
  polygonOffset: {
    type: [GLfloat, GLfloat],
    value: [0, 0],
    params: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POLYGON_OFFSET_FACTOR, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POLYGON_OFFSET_UNITS],
    object: ['factor', 'units'],
    setter: function setter(gl, value) {
      return gl.polygonOffset.apply(gl, _toConsumableArray(value));
    }
  },

  // TODO - enabling multisampling
  // glIsEnabled with argument GL_SAMPLE_ALPHA_TO_COVERAGE
  // glIsEnabled with argument GL_SAMPLE_COVERAGE

  // specify multisample coverage parameters
  // https://www.khronos.org/opengles/sdk/docs/man/xhtml/glSampleCoverage.xml
  sampleCoverage: {
    type: [GLfloat, GLboolean],
    value: [1.0, false],
    params: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SAMPLE_COVERAGE_VALUE, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SAMPLE_COVERAGE_INVERT],
    object: ['value', 'invert'],
    setter: function setter(gl, value) {
      return gl.sampleCoverage.apply(gl, _toConsumableArray(value));
    }
  },

  scissorTest: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SCISSOR_TEST,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SCISSOR_TEST, value);
    }
  },
  scissorBox: {
    type: new Int32Array(4),
    value: new Int32Array([null, null, null, null]), // TBD
    object: ['x', 'y', 'width', 'height'],
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].SCISSOR_BOX,
    setter: function setter(gl, value) {
      return gl.scissor.apply(gl, _toConsumableArray(value));
    }
  },

  stencilTest: {
    type: GLboolean,
    value: false,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_TEST,
    setter: function setter(gl, value) {
      return gl.enable(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_TEST, value);
    }
  },

  // Sets index used when stencil buffer is cleared.
  stencilClearValue: {
    type: GLint,
    value: 0,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_CLEAR_VALUE, // GLint
    setter: function setter(gl, value) {
      return gl.clearStencil(value);
    }
  },

  // Sets bit mask enabling writing of individual bits in the stencil planes
  // https://www.khronos.org/opengles/sdk/docs/man/xhtml/glStencilMaskSeparate.xml
  stencilMask: {
    type: [GLuint, GLuint],
    value: [0xFFFFFFFF, 0xFFFFFFFF],
    params: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_WRITEMASK, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_WRITEMASK],
    object: ['mask', 'backMask'],
    setter: function setter(gl, value) {
      value = isArray(value) ? value : [value, value];

      var _value = value,
          _value2 = _slicedToArray(_value, 2),
          mask = _value2[0],
          backMask = _value2[1];

      gl.stencilMaskSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRONT, mask);
      gl.stencilMaskSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BACK, backMask);
    }
  },

  // Set stencil testing function, reference value and mask for front and back
  // https://www.khronos.org/opengles/sdk/docs/man/xhtml/glStencilFuncSeparate.xml
  stencilFunc: {
    type: [GLenum, GLint, GLuint, GLenum, GLint, GLuint],
    value: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ALWAYS, 0, 0xFFFFFFFF, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].ALWAYS, 0, 0xFFFFFFFF],
    params: [
    // front
    __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_FUNC, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_REF, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_VALUE_MASK,
    // back
    __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_FUNC, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_REF, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_VALUE_MASK],
    object: ['func', 'ref', 'valueMask', 'backFunc', 'backRef', 'backValueMask'],
    setter: function setter(gl, value) {
      var _value3 = _slicedToArray(value, 6),
          func = _value3[0],
          ref = _value3[1],
          mask = _value3[2],
          backFunc = _value3[3],
          backRef = _value3[4],
          backMask = _value3[5];

      gl.stencilFuncSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRONT, func, ref, mask);
      gl.stencilFuncSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BACK, backFunc, backRef, backMask);
    }
  },

  // Specifies the action to take when the stencil test fails, front and back.
  // Stencil test fail action, depth test fail action, pass action
  // GL.KEEP, GL.ZERO, GL.REPLACE, GL.INCR, GL.INCR_WRAP, GL.DECR, GL.DECR_WRAP,
  // and GL.INVERT
  // https://www.khronos.org/opengles/sdk/docs/man/xhtml/glStencilOpSeparate.xml
  stencilOp: {
    type: [GLenum, GLenum, GLenum, GLenum, GLenum, GLenum],
    values: [__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].KEEP],
    params: [
    // front
    __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_FAIL, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_PASS_DEPTH_FAIL, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_PASS_DEPTH_PASS,
    // back
    __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_FAIL, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_PASS_DEPTH_FAIL, __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].STENCIL_BACK_PASS_DEPTH_PASS],
    object: ['fail', 'passDepthFail', 'passDepthPass', 'backFail', 'backPassDepthFail', 'backPassDepthPass'],
    setter: function setter(gl, value) {
      var _value4 = _slicedToArray(value, 6),
          sfail = _value4[0],
          dpfail = _value4[1],
          dppass = _value4[2],
          backSfail = _value4[3],
          backDpfail = _value4[4],
          backDppass = _value4[5];

      gl.stencilOpSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].FRONT, sfail, dpfail, dppass);
      gl.stencilOpSeparate(__WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].BACK, backSfail, backDpfail, backDppass);
    }
  },

  viewport: {
    type: new Int32Array(4),
    value: new Int32Array([]),
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].VIEWPORT,
    object: ['x', 'y', 'width', 'height'],
    setter: function setter(gl, value) {
      return gl.viewport.apply(gl, _toConsumableArray(value));
    }
  },

  // WEBGL1 PIXEL PACK/UNPACK MODES

  // Packing of pixel data in memory (1,2,4,8)
  packAlignment: {
    type: GLint,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].PACK_ALIGNMENT,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    }
  },
  // Unpacking pixel data from memory(1,2,4,8)
  unpackAlignment: {
    type: GLint,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_ALIGNMENT,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    }
  },
  // Flip source data along its vertical axis
  unpackFlipY: {
    type: GLboolean,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_FLIP_Y_WEBGL,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    }
  },
  // Multiplies the alpha channel into the other color channels
  unpackPremultiplyAlpha: {
    type: GLboolean,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_PREMULTIPLY_ALPHA_WEBGL,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    }
  },
  // Default color space conversion or no color space conversion.
  unpackColorspaceConversion: {
    type: GLenum,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_COLORSPACE_CONVERSION_WEBGL,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    }
  },

  // WEBGL2 PIXEL PACK/UNPACK MODES

  // Number of pixels in a row.
  packRowLength: {
    type: GLint,
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].PACK_ROW_LENGTH,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of pixels skipped before the first pixel is written into memory.
  packSkipPixels: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].PACK_SKIP_PIXELS,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of rows of pixels skipped before first pixel is written to memory.
  packSkipRows: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].PACK_SKIP_ROWS,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of pixels in a row.
  unpackRowLength: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_ROW_LENGTH,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Image height used for reading pixel data from memory
  unpackImageHeight: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_IMAGE_HEIGHT,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of pixel images skipped before first pixel is read from memory
  unpackSkipPixels: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_SKIP_PIXELS,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of rows of pixels skipped before first pixel is read from memory
  unpackSkipRows: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_SKIP_ROWS,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  },
  //  Number of pixel images skipped before first pixel is read from memory
  unpackSkipImages: {
    params: __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].UNPACK_SKIP_IMAGES,
    setter: function setter(gl, value) {
      return gl.pixelStorei(value);
    },
    webgl2: true
  }
};

// Map from GL parameter constants to composite paramters
var GL_PARAMS = {};

function unpackStateParams() {
  for (var key in GL_STATE) {
    var parameterDef = GL_STATE[key];
    var params = parameterDef.params;

    var paramsArray = isArray(params) ? params : [params];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = paramsArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var param = _step.value;

        GL_PARAMS[param] = key;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
}

unpackStateParams();

// GETTERS AND SETTERS

/**
 * Sets value with key to context.
 * Value may be "normalized" (in case a short form is supported). In that case
 * the normalized value is retured.
 *
 * @param {WebGLRenderingContext} gl - context
 * @param {String} key - parameter name
 * @param {*} value - parameter value
 * @return {*} - "normalized" parameter value after assignment
 */
function getGLParameter(gl, key) {
  var parameterDefinition = GL_STATE[key];
  if (!parameterDefinition) {
    throw new Error('Unknown GL state parameter ' + key);
  }
  // Get the parameter value(s) from the context
  var params = parameterDefinition.params;

  var value = isArray(params) ? params.map(function (param) {
    return gl.getParameter(param);
  }) : gl.getParameter(params);
  return value;
}

/**
 * Sets value with key to context.
 * Value may be "normalized" (in case a short form is supported). In that case
 * the normalized value is retured.
 *
 * @param {WebGLRenderingContext} gl - context
 * @param {String} key - parameter name
 * @param {*} value - parameter value
 * @return {*} - "normalized" parameter value after assignment
 */
function setGLParameter(gl, key, value) {
  var parameterDefinition = GL_STATE[key];
  if (!parameterDefinition) {
    throw new Error('Unknown GL state parameter ' + key);
  }
  var setter = parameterDefinition.setter,
      normalizeValue = parameterDefinition.normalizeValue;

  var adjustedValue = normalizeValue ? normalizeValue(value) : value;
  setter(gl, adjustedValue);
  return adjustedValue;
}

// HELPERS

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

// GLState

var GLState = function () {
  // Note: does not maintain a gl reference
  function GLState(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$copyState = _ref.copyState,
        copyState = _ref$copyState === undefined ? false : _ref$copyState;

    _classCallCheck(this, GLState);

    this.state = {};
    if (copyState) {
      this._copyWebGLState(gl);
    } else {
      this._getInitialState();
    }
    this.stateStack = [];
  }

  _createClass(GLState, [{
    key: 'pushValues',
    value: function pushValues(gl, values) {
      var oldValues = {};
      for (var key in values) {
        // Get current value being shadowed
        oldValues[key] = this.state[key];
        // Set the new value
        this.setValue(gl, key, values[key]);
      }
      this.stateStack.push({ oldValues: oldValues });
    }
  }, {
    key: 'popValues',
    value: function popValues(gl) {
      __WEBPACK_IMPORTED_MODULE_1_assert___default()(this.stateStack.length > 0);

      var _stateStack$pop = this.stateStack.pop(),
          oldValues = _stateStack$pop.oldValues;

      for (var key in oldValues) {
        // Set the old value
        this.setValue(gl, key, oldValues[key]);
      }
    }
  }, {
    key: 'getValue',
    value: function getValue(gl, key) {
      return this.state[key];
    }
  }, {
    key: 'setValue',
    value: function setValue(gl, key, value) {
      var actualValue = setGLParameter(gl, key, value);
      this.state[key] = actualValue;
    }

    // Copies entire WebGL state to an object.
    // This generates a huge amount of asynchronous requests and should be
    // considered a very slow operation, to be done once at program startup.

  }, {
    key: '_copyWebGLState',
    value: function _copyWebGLState(gl) {
      for (var parameterKey in GL_STATE) {
        this.state[parameterKey] = getGLParameter(gl, parameterKey);
      }
    }
  }, {
    key: '_getInitialState',
    value: function _getInitialState() {
      for (var parameterKey in GL_STATE) {
        this.state[parameterKey] = GL_STATE[parameterKey].value;
      }
    }
  }]);

  return GLState;
}();

function getGLState(gl) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$copyState = _ref2.copyState,
      copyState = _ref2$copyState === undefined ? false : _ref2$copyState;

  gl.luma = gl.luma || {};
  gl.luma.state = gl.luma.state || new GLState(gl, { copyState: copyState });
  return gl.luma.state;
}

/*
 * Executes a function with gl states temporarily set
 * Exception safe
 */
function withGLState(gl, params, func) {
  // assertWebGLContext(gl);
  var state = getGLState(gl);

  var frameBuffer = params.frameBuffer;
  // TODO - was there any previously set frame buffer we need to remember?

  if (frameBuffer) {
    frameBuffer.bind();
  }

  state.pushValues(gl, params);

  try {
    func(gl);
  } finally {
    state.popValues(gl);

    if (params.frameBuffer) {
      // TODO - was there any previously set frame buffer?
      // TODO - delegate "unbind" to Framebuffer object?
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
  }
}

var TEST_EXPORTS = {
  GL_STATE: GL_STATE
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9jb250ZXh0LXN0YXRlLmpzIl0sIm5hbWVzIjpbIkdMIiwiYXNzZXJ0IiwiR0xlbnVtIiwiR0xmbG9hdCIsIkdMaW50IiwiR0x1aW50IiwiR0xib29sZWFuIiwiR0xfU1RBVEUiLCJibGVuZCIsInR5cGUiLCJ2YWx1ZSIsInBhcmFtcyIsIkJMRU5EIiwic2V0dGVyIiwiZ2wiLCJlbmFibGUiLCJibGVuZENvbG9yIiwiRmxvYXQzMkFycmF5IiwiQkxFTkRfQ09MT1IiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJCTEVORF9FUVVBVElPTl9SR0IiLCJCTEVORF9FUVVBVElPTl9BTFBIQSIsIm9iamVjdCIsImJsZW5kRXF1YXRpb25TZXBhcmF0ZSIsIm5vcm1hbGl6ZUFyZ3MiLCJpc0FycmF5IiwiYXJncyIsImJsZW5kRnVuYyIsIk9ORSIsIlpFUk8iLCJCTEVORF9TUkNfUkdCIiwiQkxFTkRfU1JDX0FMUEhBIiwiQkxFTkRfRFNUX1JHQiIsIkJMRU5EX0RTVF9BTFBIQSIsImJsZW5kRnVuY1NlcGFyYXRlIiwibGVuZ3RoIiwiY2xlYXJDb2xvciIsIkNPTE9SX0NMRUFSX1ZBTFVFIiwiY29sb3JNYXNrIiwiQ09MT1JfV1JJVEVNQVNLIiwiY3VsbEZhY2UiLCJDVUxMX0ZBQ0UiLCJjdWxsRmFjZU1vZGUiLCJDVUxMX0ZBQ0VfTU9ERSIsImRlcHRoVGVzdCIsIkRFUFRIX1RFU1QiLCJkZXB0aENsZWFyVmFsdWUiLCJERVBUSF9DTEVBUl9WQUxVRSIsImNsZWFyRGVwdGgiLCJkZXB0aEZ1bmMiLCJERVBUSF9GVU5DIiwiZGVwdGhSYW5nZSIsIkRFUFRIX1JBTkdFIiwiZGVwdGhXcml0ZW1hc2siLCJERVBUSF9XUklURU1BU0siLCJkZXB0aE1hc2siLCJkaXRoZXIiLCJESVRIRVIiLCJmcm9udEZhY2UiLCJDQ1ciLCJGUk9OVF9GQUNFIiwiZ2VuZXJhdGVNaXBtYXBIaW50IiwiRE9OVF9DQVJFIiwiR0VORVJBVEVfTUlQTUFQX0hJTlQiLCJoaW50IiwibGluZVdpZHRoIiwiTElORV9XSURUSCIsInBvbHlnb25PZmZzZXRGaWxsIiwiUE9MWUdPTl9PRkZTRVRfRklMTCIsInBvbHlnb25PZmZzZXQiLCJQT0xZR09OX09GRlNFVF9GQUNUT1IiLCJQT0xZR09OX09GRlNFVF9VTklUUyIsInNhbXBsZUNvdmVyYWdlIiwiU0FNUExFX0NPVkVSQUdFX1ZBTFVFIiwiU0FNUExFX0NPVkVSQUdFX0lOVkVSVCIsInNjaXNzb3JUZXN0IiwiU0NJU1NPUl9URVNUIiwic2Npc3NvckJveCIsIkludDMyQXJyYXkiLCJTQ0lTU09SX0JPWCIsInNjaXNzb3IiLCJzdGVuY2lsVGVzdCIsIlNURU5DSUxfVEVTVCIsInN0ZW5jaWxDbGVhclZhbHVlIiwiU1RFTkNJTF9DTEVBUl9WQUxVRSIsImNsZWFyU3RlbmNpbCIsInN0ZW5jaWxNYXNrIiwiU1RFTkNJTF9XUklURU1BU0siLCJTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLIiwibWFzayIsImJhY2tNYXNrIiwic3RlbmNpbE1hc2tTZXBhcmF0ZSIsIkZST05UIiwiQkFDSyIsInN0ZW5jaWxGdW5jIiwiQUxXQVlTIiwiU1RFTkNJTF9GVU5DIiwiU1RFTkNJTF9SRUYiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX0JBQ0tfRlVOQyIsIlNURU5DSUxfQkFDS19SRUYiLCJTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSyIsImZ1bmMiLCJyZWYiLCJiYWNrRnVuYyIsImJhY2tSZWYiLCJzdGVuY2lsRnVuY1NlcGFyYXRlIiwic3RlbmNpbE9wIiwidmFsdWVzIiwiS0VFUCIsIlNURU5DSUxfRkFJTCIsIlNURU5DSUxfUEFTU19ERVBUSF9GQUlMIiwiU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1MiLCJTVEVOQ0lMX0JBQ0tfRkFJTCIsIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTIiwic2ZhaWwiLCJkcGZhaWwiLCJkcHBhc3MiLCJiYWNrU2ZhaWwiLCJiYWNrRHBmYWlsIiwiYmFja0RwcGFzcyIsInN0ZW5jaWxPcFNlcGFyYXRlIiwidmlld3BvcnQiLCJWSUVXUE9SVCIsInBhY2tBbGlnbm1lbnQiLCJQQUNLX0FMSUdOTUVOVCIsInBpeGVsU3RvcmVpIiwidW5wYWNrQWxpZ25tZW50IiwiVU5QQUNLX0FMSUdOTUVOVCIsInVucGFja0ZsaXBZIiwiVU5QQUNLX0ZMSVBfWV9XRUJHTCIsInVucGFja1ByZW11bHRpcGx5QWxwaGEiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJ1bnBhY2tDb2xvcnNwYWNlQ29udmVyc2lvbiIsIlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wiLCJwYWNrUm93TGVuZ3RoIiwiUEFDS19ST1dfTEVOR1RIIiwid2ViZ2wyIiwicGFja1NraXBQaXhlbHMiLCJQQUNLX1NLSVBfUElYRUxTIiwicGFja1NraXBSb3dzIiwiUEFDS19TS0lQX1JPV1MiLCJ1bnBhY2tSb3dMZW5ndGgiLCJVTlBBQ0tfUk9XX0xFTkdUSCIsInVucGFja0ltYWdlSGVpZ2h0IiwiVU5QQUNLX0lNQUdFX0hFSUdIVCIsInVucGFja1NraXBQaXhlbHMiLCJVTlBBQ0tfU0tJUF9QSVhFTFMiLCJ1bnBhY2tTa2lwUm93cyIsIlVOUEFDS19TS0lQX1JPV1MiLCJ1bnBhY2tTa2lwSW1hZ2VzIiwiVU5QQUNLX1NLSVBfSU1BR0VTIiwiR0xfUEFSQU1TIiwidW5wYWNrU3RhdGVQYXJhbXMiLCJrZXkiLCJwYXJhbWV0ZXJEZWYiLCJwYXJhbXNBcnJheSIsInBhcmFtIiwiZ2V0R0xQYXJhbWV0ZXIiLCJwYXJhbWV0ZXJEZWZpbml0aW9uIiwiRXJyb3IiLCJtYXAiLCJnZXRQYXJhbWV0ZXIiLCJzZXRHTFBhcmFtZXRlciIsIm5vcm1hbGl6ZVZhbHVlIiwiYWRqdXN0ZWRWYWx1ZSIsImFycmF5IiwiQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIkdMU3RhdGUiLCJjb3B5U3RhdGUiLCJzdGF0ZSIsIl9jb3B5V2ViR0xTdGF0ZSIsIl9nZXRJbml0aWFsU3RhdGUiLCJzdGF0ZVN0YWNrIiwib2xkVmFsdWVzIiwic2V0VmFsdWUiLCJwdXNoIiwicG9wIiwiYWN0dWFsVmFsdWUiLCJwYXJhbWV0ZXJLZXkiLCJnZXRHTFN0YXRlIiwibHVtYSIsIndpdGhHTFN0YXRlIiwiZnJhbWVCdWZmZXIiLCJiaW5kIiwicHVzaFZhbHVlcyIsInBvcFZhbHVlcyIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiVEVTVF9FWFBPUlRTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsT0FBT0EsRUFBUCxNQUFlLGdCQUFmO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTtBQUNBLElBQU1DLFNBQVMsUUFBZjtBQUNBLElBQU1DLFVBQVUsU0FBaEI7QUFDQSxJQUFNQyxRQUFRLE9BQWQ7QUFDQSxJQUFNQyxTQUFTLE9BQWY7QUFDQSxJQUFNQyxZQUFZLFdBQWxCOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0EsSUFBTUMsV0FBVztBQUNmQyxTQUFPO0FBQ0xDLFVBQU1ILFNBREQ7QUFFTEksV0FBTyxLQUZGO0FBR0xDLFlBQVFYLEdBQUdZLEtBSE47QUFJTEMsWUFBUSxnQkFBQ0MsRUFBRCxFQUFLSixLQUFMO0FBQUEsYUFBZUksR0FBR0MsTUFBSCxDQUFVZixHQUFHWSxLQUFiLEVBQW9CRixLQUFwQixDQUFmO0FBQUE7QUFKSCxHQURROztBQVFmTSxjQUFZO0FBQ1ZQLFVBQU0sSUFBSVEsWUFBSixDQUFpQixDQUFqQixDQURJO0FBRVZQLFdBQU8sSUFBSU8sWUFBSixDQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBakIsQ0FGRztBQUdWTixZQUFRWCxHQUFHa0IsV0FIRDtBQUlWTCxZQUFRLGdCQUFDQyxFQUFELEVBQUtKLEtBQUw7QUFBQSxhQUFlSSxHQUFHRSxVQUFILENBQWNOLEtBQWQsQ0FBZjtBQUFBO0FBSkUsR0FSRzs7QUFlZlMsaUJBQWU7QUFDYlYsVUFBTSxDQUFDUCxNQUFELEVBQVNB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QUY0QyxNQUlyQzZLLFdBSnFDLEdBSXRCaEwsTUFKc0IsQ0FJckNnTCxXQUpxQztBQUs1Qzs7QUFDQSxNQUFJQSxXQUFKLEVBQWlCO0FBQ2ZBLGdCQUFZQyxJQUFaO0FBQ0Q7O0FBRURkLFFBQU1lLFVBQU4sQ0FBaUIvSyxFQUFqQixFQUFxQkgsTUFBckI7O0FBRUEsTUFBSTtBQUNGNEYsU0FBS3pGLEVBQUw7QUFDRCxHQUZELFNBRVU7QUFDUmdLLFVBQU1nQixTQUFOLENBQWdCaEwsRUFBaEI7O0FBRUEsUUFBSUgsT0FBT2dMLFdBQVgsRUFBd0I7QUFDdEI7QUFDQTtBQUNBN0ssU0FBR2lMLGVBQUgsQ0FBbUJqTCxHQUFHa0wsV0FBdEIsRUFBbUMsSUFBbkM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsT0FBTyxJQUFNQyxlQUFlO0FBQzFCMUw7QUFEMEIsQ0FBckIiLCJmaWxlIjoiY29udGV4dC1zdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWlubGluZS1jb21tZW50cywgbWF4LWxlbiAqL1xuaW1wb3J0IEdMIGZyb20gJy4vZ2wtY29uc3RhbnRzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gV2ViR0wgc3BlY2lmaWNhdGlvbiAndHlwZXMnXG5jb25zdCBHTGVudW0gPSAnR0xlbnVtJztcbmNvbnN0IEdMZmxvYXQgPSAnR0xmbG9hdCc7XG5jb25zdCBHTGludCA9ICdHTGludCc7XG5jb25zdCBHTHVpbnQgPSAnR0xpbnQnO1xuY29uc3QgR0xib29sZWFuID0gJ0dMYm9vbGVhbic7XG5cbi8qXG5TdGF0ZSBtYW5hZ2VtZW50XG4tIGNhbWVsQ2FzZWQgdmVyc2lvbnMgb2YgdGhlIEdMIGNvbnN0YW50c1xuLSBleGNlcHQgd2hlbiBzZXR0ZXIgZnVuY3Rpb24gZXhpc3QgdGhhdCBhcmUgbmFtZWQgZGlmZmVyZW50bHlcbi0gV2hlbiBnbCBhcGkgb2ZmZXJzIDxzZXR0ZXI+IGFuZCA8c2V0dGVyPlNlcGFyYXRlLCB0aGUgcGFyYW1ldGVyIGlzIG5hbWVkXG4gIGFmdGVyIHRoZSBzZXR0ZXIgYnV0XG4qL1xuXG4vLyBNYXAgb2YgY29tcG9zaXRlIHBhcmFtZXRlcnNcbmNvbnN0IEdMX1NUQVRFID0ge1xuICBibGVuZDoge1xuICAgIHR5cGU6IEdMYm9vbGVhbixcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgcGFyYW1zOiBHTC5CTEVORCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmVuYWJsZShHTC5CTEVORCwgdmFsdWUpXG4gIH0sXG5cbiAgYmxlbmRDb2xvcjoge1xuICAgIHR5cGU6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSxcbiAgICBwYXJhbXM6IEdMLkJMRU5EX0NPTE9SLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuYmxlbmRDb2xvcih2YWx1ZSlcbiAgfSxcblxuICBibGVuZEVxdWF0aW9uOiB7XG4gICAgdHlwZTogW0dMZW51bSwgR0xlbnVtXSxcbiAgICB2YWx1ZTogW0dMLkZVTkNfQURELCBHTC5GVU5DX0FERF0sXG4gICAgcGFyYW1zOiBbR0wuQkxFTkRfRVFVQVRJT05fUkdCLCBHTC5CTEVORF9FUVVBVElPTl9BTFBIQV0sXG4gICAgb2JqZWN0OiBbJ3JnYicsICdhbHBoYSddLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKC4uLnZhbHVlKSxcbiAgICBub3JtYWxpemVBcmdzOlxuICAgICAgYXJncyA9PiBpc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzLCBhcmdzXVxuICB9LFxuXG4gIC8vIGJsZW5kIGZ1bmNcbiAgYmxlbmRGdW5jOiB7XG4gICAgdHlwZTogW0dMZW51bSwgR0xlbnVtLCBHTGVudW0sIEdMZW51bV0sXG4gICAgdmFsdWU6IFtHTC5PTkUsIEdMLlpFUk8sIEdMLk9ORSwgR0wuWkVST10sXG4gICAgcGFyYW1zOiBbXG4gICAgICBHTC5CTEVORF9TUkNfUkdCLCBHTC5CTEVORF9TUkNfQUxQSEEsIEdMLkJMRU5EX0RTVF9SR0IsIEdMLkJMRU5EX0RTVF9BTFBIQVxuICAgIF0sXG4gICAgb2JqZWN0OiBbJ3NyY1JnYicsICdzcmNBbHBoYScsICdkc3RSZ2InLCAnZHN0QWxwaGEnXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmJsZW5kRnVuY1NlcGFyYXRlKC4uLnZhbHVlKSxcbiAgICBub3JtYWxpemVBcmdzOlxuICAgICAgYXJncyA9PiBpc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAzID8gWy4uLmFyZ3MsIC4uLmFyZ3NdIDogYXJnc1xuICB9LFxuXG4gIGNsZWFyQ29sb3I6IHtcbiAgICB0eXBlOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwXSksIC8vIFRCRFxuICAgIHBhcmFtczogR0wuQ09MT1JfQ0xFQVJfVkFMVUUsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5jbGVhckNvbG9yKC4uLnZhbHVlKVxuICB9LFxuXG4gIGNvbG9yTWFzazoge1xuICAgIHR5cGU6IFtHTGJvb2xlYW4sIEdMYm9vbGVhbiwgR0xib29sZWFuLCBHTGJvb2xlYW5dLFxuICAgIHZhbHVlOiBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0sXG4gICAgcGFyYW1zOiBHTC5DT0xPUl9XUklURU1BU0ssXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5jb2xvck1hc2soLi4udmFsdWUpXG4gIH0sXG5cbiAgY3VsbEZhY2U6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIHBhcmFtczogR0wuQ1VMTF9GQUNFLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuZW5hYmxlKEdMLkNVTExfRkFDRSwgdmFsdWUpXG4gIH0sXG5cbiAgY3VsbEZhY2VNb2RlOiB7XG4gICAgdHlwZTogR0xlbnVtLFxuICAgIHBhcmFtczogR0wuQ1VMTF9GQUNFX01PREUsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5jdWxsRmFjZSh2YWx1ZSlcbiAgfSxcblxuICBkZXB0aFRlc3Q6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIHBhcmFtczogR0wuREVQVEhfVEVTVCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmVuYWJsZShHTC5ERVBUSF9URVNULCB2YWx1ZSlcbiAgfSxcblxuICBkZXB0aENsZWFyVmFsdWU6IHtcbiAgICB0eXBlOiBHTGZsb2F0LFxuICAgIHZhbHVlOiB0cnVlLFxuICAgIHBhcmFtczogR0wuREVQVEhfQ0xFQVJfVkFMVUUsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5jbGVhckRlcHRoKHZhbHVlKVxuICB9LFxuXG4gIGRlcHRoRnVuYzoge1xuICAgIHR5cGU6IEdMZW51bSxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBwYXJhbXM6IEdMLkRFUFRIX0ZVTkMsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5kZXB0aEZ1bmModmFsdWUpXG4gIH0sXG5cbiAgZGVwdGhSYW5nZToge1xuICAgIHR5cGU6IG5ldyBGbG9hdDMyQXJyYXkoMiksXG4gICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDFdKSwgLy8gVEJEXG4gICAgb2JqZWN0OiBbJ21pbicsICdtYXgnXSxcbiAgICBwYXJhbXM6IEdMLkRFUFRIX1JBTkdFLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuZGVwdGhSYW5nZSguLi52YWx1ZSlcbiAgfSxcblxuICBkZXB0aFdyaXRlbWFzazoge1xuICAgIHR5cGU6IEdMYm9vbGVhbixcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBwYXJhbXM6IEdMLkRFUFRIX1dSSVRFTUFTSyxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmRlcHRoTWFzayh2YWx1ZSlcbiAgfSxcblxuICBkaXRoZXI6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgdmFsdWU6IHRydWUsXG4gICAgcGFyYW1zOiBHTC5ESVRIRVIsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5lbmFibGUoR0wuRElUSEVSLCB2YWx1ZSlcbiAgfSxcblxuICBmcm9udEZhY2U6IHtcbiAgICB0eXBlOiBHTGVudW0sXG4gICAgdmFsdWU6IEdMLkNDVyxcbiAgICBwYXJhbXM6IEdMLkZST05UX0ZBQ0UsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5mcm9udEZhY2UodmFsdWUpXG4gIH0sXG5cbiAgLy8gSGludCBmb3IgcXVhbGl0eSBvZiBpbWFnZXMgZ2VuZXJhdGVkIHdpdGggZ2xHZW5lcmF0ZU1pcG1hcFxuICBnZW5lcmF0ZU1pcG1hcEhpbnQ6IHtcbiAgICB0eXBlOiBHTGVudW0sXG4gICAgdmFsdWU6IEdMLkRPTlRfQ0FSRSxcbiAgICBwYXJhbXM6IEdMLkdFTkVSQVRFX01JUE1BUF9ISU5ULFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuaGludChHTC5HRU5FUkFURV9NSVBNQVBfSElOVCwgdmFsdWUpXG4gIH0sXG5cbiAgbGluZVdpZHRoOiB7XG4gICAgdHlwZTogR0xmbG9hdCxcbiAgICB2YWx1ZTogMSxcbiAgICBwYXJhbXM6IEdMLkxJTkVfV0lEVEgsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5saW5lV2lkdGgodmFsdWUpXG4gIH0sXG5cbiAgcG9seWdvbk9mZnNldEZpbGw6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIHBhcmFtczogR0wuUE9MWUdPTl9PRkZTRVRfRklMTCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmVuYWJsZShHTC5QT0xZR09OX09GRlNFVF9GSUxMLCB2YWx1ZSlcbiAgfSxcblxuICAvLyBBZGQgc21hbGwgb2Zmc2V0IHRvIGZyYWdtZW50IGRlcHRoIHZhbHVlcyAoYnkgZmFjdG9yIMOXIERaICsgciDDlyB1bml0cylcbiAgLy8gVXNlZnVsIGZvciByZW5kZXJpbmcgaGlkZGVuLWxpbmUgaW1hZ2VzLCBmb3IgYXBwbHlpbmcgZGVjYWxzIHRvIHN1cmZhY2VzLFxuICAvLyBhbmQgZm9yIHJlbmRlcmluZyBzb2xpZHMgd2l0aCBoaWdobGlnaHRlZCBlZGdlcy5cbiAgLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUG9seWdvbk9mZnNldC54bWxcbiAgcG9seWdvbk9mZnNldDoge1xuICAgIHR5cGU6IFtHTGZsb2F0LCBHTGZsb2F0XSxcbiAgICB2YWx1ZTogWzAsIDBdLFxuICAgIHBhcmFtczogW0dMLlBPTFlHT05fT0ZGU0VUX0ZBQ1RPUiwgR0wuUE9MWUdPTl9PRkZTRVRfVU5JVFNdLFxuICAgIG9iamVjdDogWydmYWN0b3InLCAndW5pdHMnXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBvbHlnb25PZmZzZXQoLi4udmFsdWUpXG4gIH0sXG5cbiAgLy8gVE9ETyAtIGVuYWJsaW5nIG11bHRpc2FtcGxpbmdcbiAgLy8gZ2xJc0VuYWJsZWQgd2l0aCBhcmd1bWVudCBHTF9TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0VcbiAgLy8gZ2xJc0VuYWJsZWQgd2l0aCBhcmd1bWVudCBHTF9TQU1QTEVfQ09WRVJBR0VcblxuICAvLyBzcGVjaWZ5IG11bHRpc2FtcGxlIGNvdmVyYWdlIHBhcmFtZXRlcnNcbiAgLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsU2FtcGxlQ292ZXJhZ2UueG1sXG4gIHNhbXBsZUNvdmVyYWdlOiB7XG4gICAgdHlwZTogW0dMZmxvYXQsIEdMYm9vbGVhbl0sXG4gICAgdmFsdWU6IFsxLjAsIGZhbHNlXSxcbiAgICBwYXJhbXM6IFtHTC5TQU1QTEVfQ09WRVJBR0VfVkFMVUUsIEdMLlNBTVBMRV9DT1ZFUkFHRV9JTlZFUlRdLFxuICAgIG9iamVjdDogWyd2YWx1ZScsICdpbnZlcnQnXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnNhbXBsZUNvdmVyYWdlKC4uLnZhbHVlKVxuICB9LFxuXG4gIHNjaXNzb3JUZXN0OiB7XG4gICAgdHlwZTogR0xib29sZWFuLFxuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBwYXJhbXM6IEdMLlNDSVNTT1JfVEVTVCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLmVuYWJsZShHTC5TQ0lTU09SX1RFU1QsIHZhbHVlKVxuICB9LFxuICBzY2lzc29yQm94OiB7XG4gICAgdHlwZTogbmV3IEludDMyQXJyYXkoNCksXG4gICAgdmFsdWU6IG5ldyBJbnQzMkFycmF5KFtudWxsLCBudWxsLCBudWxsLCBudWxsXSksIC8vIFRCRFxuICAgIG9iamVjdDogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgcGFyYW1zOiBHTC5TQ0lTU09SX0JPWCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnNjaXNzb3IoLi4udmFsdWUpXG4gIH0sXG5cbiAgc3RlbmNpbFRlc3Q6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIHBhcmFtczogR0wuU1RFTkNJTF9URVNULFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wuZW5hYmxlKEdMLlNURU5DSUxfVEVTVCwgdmFsdWUpXG4gIH0sXG5cbiAgLy8gU2V0cyBpbmRleCB1c2VkIHdoZW4gc3RlbmNpbCBidWZmZXIgaXMgY2xlYXJlZC5cbiAgc3RlbmNpbENsZWFyVmFsdWU6IHtcbiAgICB0eXBlOiBHTGludCxcbiAgICB2YWx1ZTogMCxcbiAgICBwYXJhbXM6IEdMLlNURU5DSUxfQ0xFQVJfVkFMVUUsIC8vIEdMaW50XG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5jbGVhclN0ZW5jaWwodmFsdWUpXG4gIH0sXG5cbiAgLy8gU2V0cyBiaXQgbWFzayBlbmFibGluZyB3cml0aW5nIG9mIGluZGl2aWR1YWwgYml0cyBpbiB0aGUgc3RlbmNpbCBwbGFuZXNcbiAgLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsU3RlbmNpbE1hc2tTZXBhcmF0ZS54bWxcbiAgc3RlbmNpbE1hc2s6IHtcbiAgICB0eXBlOiBbR0x1aW50LCBHTHVpbnRdLFxuICAgIHZhbHVlOiBbMHhGRkZGRkZGRiwgMHhGRkZGRkZGRl0sXG4gICAgcGFyYW1zOiBbR0wuU1RFTkNJTF9XUklURU1BU0ssIEdMLlNURU5DSUxfQkFDS19XUklURU1BU0tdLFxuICAgIG9iamVjdDogWydtYXNrJywgJ2JhY2tNYXNrJ10sXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWUsIHZhbHVlXTtcbiAgICAgIGNvbnN0IFttYXNrLCBiYWNrTWFza10gPSB2YWx1ZTtcbiAgICAgIGdsLnN0ZW5jaWxNYXNrU2VwYXJhdGUoR0wuRlJPTlQsIG1hc2spO1xuICAgICAgZ2wuc3RlbmNpbE1hc2tTZXBhcmF0ZShHTC5CQUNLLCBiYWNrTWFzayk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNldCBzdGVuY2lsIHRlc3RpbmcgZnVuY3Rpb24sIHJlZmVyZW5jZSB2YWx1ZSBhbmQgbWFzayBmb3IgZnJvbnQgYW5kIGJhY2tcbiAgLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsU3RlbmNpbEZ1bmNTZXBhcmF0ZS54bWxcbiAgc3RlbmNpbEZ1bmM6IHtcbiAgICB0eXBlOiBbR0xlbnVtLCBHTGludCwgR0x1aW50LCBHTGVudW0sIEdMaW50LCBHTHVpbnRdLFxuICAgIHZhbHVlOiBbR0wuQUxXQVlTLCAwLCAweEZGRkZGRkZGLCBHTC5BTFdBWVMsIDAsIDB4RkZGRkZGRkZdLFxuICAgIHBhcmFtczogW1xuICAgICAgLy8gZnJvbnRcbiAgICAgIEdMLlNURU5DSUxfRlVOQyxcbiAgICAgIEdMLlNURU5DSUxfUkVGLFxuICAgICAgR0wuU1RFTkNJTF9WQUxVRV9NQVNLLFxuICAgICAgLy8gYmFja1xuICAgICAgR0wuU1RFTkNJTF9CQUNLX0ZVTkMsXG4gICAgICBHTC5TVEVOQ0lMX0JBQ0tfUkVGLFxuICAgICAgR0wuU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0tcbiAgICBdLFxuICAgIG9iamVjdDogW1xuICAgICAgJ2Z1bmMnLCAncmVmJywgJ3ZhbHVlTWFzaycsICdiYWNrRnVuYycsICdiYWNrUmVmJywgJ2JhY2tWYWx1ZU1hc2snXG4gICAgXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IFtmdW5jLCByZWYsIG1hc2ssIGJhY2tGdW5jLCBiYWNrUmVmLCBiYWNrTWFza10gPSB2YWx1ZTtcbiAgICAgIGdsLnN0ZW5jaWxGdW5jU2VwYXJhdGUoR0wuRlJPTlQsIGZ1bmMsIHJlZiwgbWFzayk7XG4gICAgICBnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKEdMLkJBQ0ssIGJhY2tGdW5jLCBiYWNrUmVmLCBiYWNrTWFzayk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNwZWNpZmllcyB0aGUgYWN0aW9uIHRvIHRha2Ugd2hlbiB0aGUgc3RlbmNpbCB0ZXN0IGZhaWxzLCBmcm9udCBhbmQgYmFjay5cbiAgLy8gU3RlbmNpbCB0ZXN0IGZhaWwgYWN0aW9uLCBkZXB0aCB0ZXN0IGZhaWwgYWN0aW9uLCBwYXNzIGFjdGlvblxuICAvLyBHTC5LRUVQLCBHTC5aRVJPLCBHTC5SRVBMQUNFLCBHTC5JTkNSLCBHTC5JTkNSX1dSQVAsIEdMLkRFQ1IsIEdMLkRFQ1JfV1JBUCxcbiAgLy8gYW5kIEdMLklOVkVSVFxuICAvLyBodHRwczovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xTdGVuY2lsT3BTZXBhcmF0ZS54bWxcbiAgc3RlbmNpbE9wOiB7XG4gICAgdHlwZTogW0dMZW51bSwgR0xlbnVtLCBHTGVudW0sIEdMZW51bSwgR0xlbnVtLCBHTGVudW1dLFxuICAgIHZhbHVlczogW0dMLktFRVAsIEdMLktFRVAsIEdMLktFRVAsIEdMLktFRVAsIEdMLktFRVAsIEdMLktFRVBdLFxuICAgIHBhcmFtczogW1xuICAgICAgLy8gZnJvbnRcbiAgICAgIEdMLlNURU5DSUxfRkFJTCxcbiAgICAgIEdMLlNURU5DSUxfUEFTU19ERVBUSF9GQUlMLFxuICAgICAgR0wuU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1MsXG4gICAgICAvLyBiYWNrXG4gICAgICBHTC5TVEVOQ0lMX0JBQ0tfRkFJTCxcbiAgICAgIEdMLlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwsXG4gICAgICBHTC5TVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTXG4gICAgXSxcbiAgICBvYmplY3Q6IFtcbiAgICAgICdmYWlsJywgJ3Bhc3NEZXB0aEZhaWwnLCAncGFzc0RlcHRoUGFzcycsXG4gICAgICAnYmFja0ZhaWwnLCAnYmFja1Bhc3NEZXB0aEZhaWwnLCAnYmFja1Bhc3NEZXB0aFBhc3MnXG4gICAgXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IFtzZmFpbCwgZHBmYWlsLCBkcHBhc3MsIGJhY2tTZmFpbCwgYmFja0RwZmFpbCwgYmFja0RwcGFzc10gPSB2YWx1ZTtcbiAgICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKEdMLkZST05ULCBzZmFpbCwgZHBmYWlsLCBkcHBhc3MpO1xuICAgICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoR0wuQkFDSywgYmFja1NmYWlsLCBiYWNrRHBmYWlsLCBiYWNrRHBwYXNzKTtcbiAgICB9XG4gIH0sXG5cbiAgdmlld3BvcnQ6IHtcbiAgICB0eXBlOiBuZXcgSW50MzJBcnJheSg0KSxcbiAgICB2YWx1ZTogbmV3IEludDMyQXJyYXkoW10pLFxuICAgIHBhcmFtczogR0wuVklFV1BPUlQsXG4gICAgb2JqZWN0OiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnZpZXdwb3J0KC4uLnZhbHVlKVxuICB9LFxuXG4gIC8vIFdFQkdMMSBQSVhFTCBQQUNLL1VOUEFDSyBNT0RFU1xuXG4gIC8vIFBhY2tpbmcgb2YgcGl4ZWwgZGF0YSBpbiBtZW1vcnkgKDEsMiw0LDgpXG4gIHBhY2tBbGlnbm1lbnQ6IHtcbiAgICB0eXBlOiBHTGludCxcbiAgICBwYXJhbXM6IEdMLlBBQ0tfQUxJR05NRU5ULFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wucGl4ZWxTdG9yZWkodmFsdWUpXG4gIH0sXG4gIC8vIFVucGFja2luZyBwaXhlbCBkYXRhIGZyb20gbWVtb3J5KDEsMiw0LDgpXG4gIHVucGFja0FsaWdubWVudDoge1xuICAgIHR5cGU6IEdMaW50LFxuICAgIHBhcmFtczogR0wuVU5QQUNLX0FMSUdOTUVOVCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBpeGVsU3RvcmVpKHZhbHVlKVxuICB9LFxuICAvLyBGbGlwIHNvdXJjZSBkYXRhIGFsb25nIGl0cyB2ZXJ0aWNhbCBheGlzXG4gIHVucGFja0ZsaXBZOiB7XG4gICAgdHlwZTogR0xib29sZWFuLFxuICAgIHBhcmFtczogR0wuVU5QQUNLX0ZMSVBfWV9XRUJHTCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBpeGVsU3RvcmVpKHZhbHVlKVxuICB9LFxuICAvLyBNdWx0aXBsaWVzIHRoZSBhbHBoYSBjaGFubmVsIGludG8gdGhlIG90aGVyIGNvbG9yIGNoYW5uZWxzXG4gIHVucGFja1ByZW11bHRpcGx5QWxwaGE6IHtcbiAgICB0eXBlOiBHTGJvb2xlYW4sXG4gICAgcGFyYW1zOiBHTC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5waXhlbFN0b3JlaSh2YWx1ZSlcbiAgfSxcbiAgLy8gRGVmYXVsdCBjb2xvciBzcGFjZSBjb252ZXJzaW9uIG9yIG5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24uXG4gIHVucGFja0NvbG9yc3BhY2VDb252ZXJzaW9uOiB7XG4gICAgdHlwZTogR0xlbnVtLFxuICAgIHBhcmFtczogR0wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBpeGVsU3RvcmVpKHZhbHVlKVxuICB9LFxuXG4gIC8vIFdFQkdMMiBQSVhFTCBQQUNLL1VOUEFDSyBNT0RFU1xuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgaW4gYSByb3cuXG4gIHBhY2tSb3dMZW5ndGg6IHtcbiAgICB0eXBlOiBHTGludCxcbiAgICBwYXJhbXM6IEdMLlBBQ0tfUk9XX0xFTkdUSCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBpeGVsU3RvcmVpKHZhbHVlKSxcbiAgICB3ZWJnbDI6IHRydWVcbiAgfSxcbiAgLy8gIE51bWJlciBvZiBwaXhlbHMgc2tpcHBlZCBiZWZvcmUgdGhlIGZpcnN0IHBpeGVsIGlzIHdyaXR0ZW4gaW50byBtZW1vcnkuXG4gIHBhY2tTa2lwUGl4ZWxzOiB7XG4gICAgcGFyYW1zOiBHTC5QQUNLX1NLSVBfUElYRUxTLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wucGl4ZWxTdG9yZWkodmFsdWUpLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICAvLyAgTnVtYmVyIG9mIHJvd3Mgb2YgcGl4ZWxzIHNraXBwZWQgYmVmb3JlIGZpcnN0IHBpeGVsIGlzIHdyaXR0ZW4gdG8gbWVtb3J5LlxuICBwYWNrU2tpcFJvd3M6IHtcbiAgICBwYXJhbXM6IEdMLlBBQ0tfU0tJUF9ST1dTLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wucGl4ZWxTdG9yZWkodmFsdWUpLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICAvLyAgTnVtYmVyIG9mIHBpeGVscyBpbiBhIHJvdy5cbiAgdW5wYWNrUm93TGVuZ3RoOiB7XG4gICAgcGFyYW1zOiBHTC5VTlBBQ0tfUk9XX0xFTkdUSCxcbiAgICBzZXR0ZXI6IChnbCwgdmFsdWUpID0+IGdsLnBpeGVsU3RvcmVpKHZhbHVlKSxcbiAgICB3ZWJnbDI6IHRydWVcbiAgfSxcbiAgLy8gIEltYWdlIGhlaWdodCB1c2VkIGZvciByZWFkaW5nIHBpeGVsIGRhdGEgZnJvbSBtZW1vcnlcbiAgdW5wYWNrSW1hZ2VIZWlnaHQ6IHtcbiAgICBwYXJhbXM6IEdMLlVOUEFDS19JTUFHRV9IRUlHSFQsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5waXhlbFN0b3JlaSh2YWx1ZSksXG4gICAgd2ViZ2wyOiB0cnVlXG4gIH0sXG4gIC8vICBOdW1iZXIgb2YgcGl4ZWwgaW1hZ2VzIHNraXBwZWQgYmVmb3JlIGZpcnN0IHBpeGVsIGlzIHJlYWQgZnJvbSBtZW1vcnlcbiAgdW5wYWNrU2tpcFBpeGVsczoge1xuICAgIHBhcmFtczogR0wuVU5QQUNLX1NLSVBfUElYRUxTLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wucGl4ZWxTdG9yZWkodmFsdWUpLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9LFxuICAvLyAgTnVtYmVyIG9mIHJvd3Mgb2YgcGl4ZWxzIHNraXBwZWQgYmVmb3JlIGZpcnN0IHBpeGVsIGlzIHJlYWQgZnJvbSBtZW1vcnlcbiAgdW5wYWNrU2tpcFJvd3M6IHtcbiAgICBwYXJhbXM6IEdMLlVOUEFDS19TS0lQX1JPV1MsXG4gICAgc2V0dGVyOiAoZ2wsIHZhbHVlKSA9PiBnbC5waXhlbFN0b3JlaSh2YWx1ZSksXG4gICAgd2ViZ2wyOiB0cnVlXG4gIH0sXG4gIC8vICBOdW1iZXIgb2YgcGl4ZWwgaW1hZ2VzIHNraXBwZWQgYmVmb3JlIGZpcnN0IHBpeGVsIGlzIHJlYWQgZnJvbSBtZW1vcnlcbiAgdW5wYWNrU2tpcEltYWdlczoge1xuICAgIHBhcmFtczogR0wuVU5QQUNLX1NLSVBfSU1BR0VTLFxuICAgIHNldHRlcjogKGdsLCB2YWx1ZSkgPT4gZ2wucGl4ZWxTdG9yZWkodmFsdWUpLFxuICAgIHdlYmdsMjogdHJ1ZVxuICB9XG59O1xuXG4vLyBNYXAgZnJvbSBHTCBwYXJhbWV0ZXIgY29uc3RhbnRzIHRvIGNvbXBvc2l0ZSBwYXJhbXRlcnNcbmNvbnN0IEdMX1BBUkFNUyA9IHt9O1xuXG5mdW5jdGlvbiB1bnBhY2tTdGF0ZVBhcmFtcygpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gR0xfU1RBVEUpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJEZWYgPSBHTF9TVEFURVtrZXldO1xuICAgIGNvbnN0IHtwYXJhbXN9ID0gcGFyYW1ldGVyRGVmO1xuICAgIGNvbnN0IHBhcmFtc0FycmF5ID0gaXNBcnJheShwYXJhbXMpID8gcGFyYW1zIDogW3BhcmFtc107XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXNBcnJheSkge1xuICAgICAgR0xfUEFSQU1TW3BhcmFtXSA9IGtleTtcbiAgICB9XG4gIH1cbn1cblxudW5wYWNrU3RhdGVQYXJhbXMoKTtcblxuLy8gR0VUVEVSUyBBTkQgU0VUVEVSU1xuXG4vKipcbiAqIFNldHMgdmFsdWUgd2l0aCBrZXkgdG8gY29udGV4dC5cbiAqIFZhbHVlIG1heSBiZSBcIm5vcm1hbGl6ZWRcIiAoaW4gY2FzZSBhIHNob3J0IGZvcm0gaXMgc3VwcG9ydGVkKS4gSW4gdGhhdCBjYXNlXG4gKiB0aGUgbm9ybWFsaXplZCB2YWx1ZSBpcyByZXR1cmVkLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIGNvbnRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHBhcmFtZXRlciB2YWx1ZVxuICogQHJldHVybiB7Kn0gLSBcIm5vcm1hbGl6ZWRcIiBwYXJhbWV0ZXIgdmFsdWUgYWZ0ZXIgYXNzaWdubWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R0xQYXJhbWV0ZXIoZ2wsIGtleSkge1xuICBjb25zdCBwYXJhbWV0ZXJEZWZpbml0aW9uID0gR0xfU1RBVEVba2V5XTtcbiAgaWYgKCFwYXJhbWV0ZXJEZWZpbml0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEdMIHN0YXRlIHBhcmFtZXRlciAke2tleX1gKTtcbiAgfVxuICAvLyBHZXQgdGhlIHBhcmFtZXRlciB2YWx1ZShzKSBmcm9tIHRoZSBjb250ZXh0XG4gIGNvbnN0IHtwYXJhbXN9ID0gcGFyYW1ldGVyRGVmaW5pdGlvbjtcbiAgY29uc3QgdmFsdWUgPSBpc0FycmF5KHBhcmFtcykgP1xuICAgIHBhcmFtcy5tYXAocGFyYW0gPT4gZ2wuZ2V0UGFyYW1ldGVyKHBhcmFtKSkgOlxuICAgIGdsLmdldFBhcmFtZXRlcihwYXJhbXMpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogU2V0cyB2YWx1ZSB3aXRoIGtleSB0byBjb250ZXh0LlxuICogVmFsdWUgbWF5IGJlIFwibm9ybWFsaXplZFwiIChpbiBjYXNlIGEgc2hvcnQgZm9ybSBpcyBzdXBwb3J0ZWQpLiBJbiB0aGF0IGNhc2VcbiAqIHRoZSBub3JtYWxpemVkIHZhbHVlIGlzIHJldHVyZWQuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gY29udGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHBhcmFtZXRlciBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gcGFyYW1ldGVyIHZhbHVlXG4gKiBAcmV0dXJuIHsqfSAtIFwibm9ybWFsaXplZFwiIHBhcmFtZXRlciB2YWx1ZSBhZnRlciBhc3NpZ25tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRHTFBhcmFtZXRlcihnbCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBwYXJhbWV0ZXJEZWZpbml0aW9uID0gR0xfU1RBVEVba2V5XTtcbiAgaWYgKCFwYXJhbWV0ZXJEZWZpbml0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEdMIHN0YXRlIHBhcmFtZXRlciAke2tleX1gKTtcbiAgfVxuICBjb25zdCB7c2V0dGVyLCBub3JtYWxpemVWYWx1ZX0gPSBwYXJhbWV0ZXJEZWZpbml0aW9uO1xuICBjb25zdCBhZGp1c3RlZFZhbHVlID0gbm9ybWFsaXplVmFsdWUgPyBub3JtYWxpemVWYWx1ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgc2V0dGVyKGdsLCBhZGp1c3RlZFZhbHVlKTtcbiAgcmV0dXJuIGFkanVzdGVkVmFsdWU7XG59XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnJheSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFycmF5KTtcbn1cblxuLy8gR0xTdGF0ZVxuXG5jbGFzcyBHTFN0YXRlIHtcbiAgLy8gTm90ZTogZG9lcyBub3QgbWFpbnRhaW4gYSBnbCByZWZlcmVuY2VcbiAgY29uc3RydWN0b3IoZ2wsIHtjb3B5U3RhdGUgPSBmYWxzZX0gPSB7fSkge1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICBpZiAoY29weVN0YXRlKSB7XG4gICAgICB0aGlzLl9jb3B5V2ViR0xTdGF0ZShnbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgfVxuXG4gIHB1c2hWYWx1ZXMoZ2wsIHZhbHVlcykge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgdmFsdWUgYmVpbmcgc2hhZG93ZWRcbiAgICAgIG9sZFZhbHVlc1trZXldID0gdGhpcy5zdGF0ZVtrZXldO1xuICAgICAgLy8gU2V0IHRoZSBuZXcgdmFsdWVcbiAgICAgIHRoaXMuc2V0VmFsdWUoZ2wsIGtleSwgdmFsdWVzW2tleV0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaCh7b2xkVmFsdWVzfSk7XG4gIH1cblxuICBwb3BWYWx1ZXMoZ2wpIHtcbiAgICBhc3NlcnQodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA+IDApO1xuICAgIGNvbnN0IHtvbGRWYWx1ZXN9ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFZhbHVlcykge1xuICAgICAgLy8gU2V0IHRoZSBvbGQgdmFsdWVcbiAgICAgIHRoaXMuc2V0VmFsdWUoZ2wsIGtleSwgb2xkVmFsdWVzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIGdldFZhbHVlKGdsLCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtrZXldO1xuICB9XG5cbiAgc2V0VmFsdWUoZ2wsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IHNldEdMUGFyYW1ldGVyKGdsLCBrZXksIHZhbHVlKTtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSBhY3R1YWxWYWx1ZTtcbiAgfVxuXG4gIC8vIENvcGllcyBlbnRpcmUgV2ViR0wgc3RhdGUgdG8gYW4gb2JqZWN0LlxuICAvLyBUaGlzIGdlbmVyYXRlcyBhIGh1Z2UgYW1vdW50IG9mIGFzeW5jaHJvbm91cyByZXF1ZXN0cyBhbmQgc2hvdWxkIGJlXG4gIC8vIGNvbnNpZGVyZWQgYSB2ZXJ5IHNsb3cgb3BlcmF0aW9uLCB0byBiZSBkb25lIG9uY2UgYXQgcHJvZ3JhbSBzdGFydHVwLlxuICBfY29weVdlYkdMU3RhdGUoZ2wpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlcktleSBpbiBHTF9TVEFURSkge1xuICAgICAgdGhpcy5zdGF0ZVtwYXJhbWV0ZXJLZXldID0gZ2V0R0xQYXJhbWV0ZXIoZ2wsIHBhcmFtZXRlcktleSk7XG4gICAgfVxuICB9XG5cbiAgX2dldEluaXRpYWxTdGF0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlcktleSBpbiBHTF9TVEFURSkge1xuICAgICAgdGhpcy5zdGF0ZVtwYXJhbWV0ZXJLZXldID0gR0xfU1RBVEVbcGFyYW1ldGVyS2V5XS52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0R0xTdGF0ZShnbCwge2NvcHlTdGF0ZSA9IGZhbHNlfSA9IHt9KSB7XG4gIGdsLmx1bWEgPSBnbC5sdW1hIHx8IHt9O1xuICBnbC5sdW1hLnN0YXRlID0gZ2wubHVtYS5zdGF0ZSB8fCBuZXcgR0xTdGF0ZShnbCwge2NvcHlTdGF0ZX0pO1xuICByZXR1cm4gZ2wubHVtYS5zdGF0ZTtcbn1cblxuLypcbiAqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gd2l0aCBnbCBzdGF0ZXMgdGVtcG9yYXJpbHkgc2V0XG4gKiBFeGNlcHRpb24gc2FmZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEdMU3RhdGUoZ2wsIHBhcmFtcywgZnVuYykge1xuICAvLyBhc3NlcnRXZWJHTENvbnRleHQoZ2wpO1xuICBjb25zdCBzdGF0ZSA9IGdldEdMU3RhdGUoZ2wpO1xuXG4gIGNvbnN0IHtmcmFtZUJ1ZmZlcn0gPSBwYXJhbXM7XG4gIC8vIFRPRE8gLSB3YXMgdGhlcmUgYW55IHByZXZpb3VzbHkgc2V0IGZyYW1lIGJ1ZmZlciB3ZSBuZWVkIHRvIHJlbWVtYmVyP1xuICBpZiAoZnJhbWVCdWZmZXIpIHtcbiAgICBmcmFtZUJ1ZmZlci5iaW5kKCk7XG4gIH1cblxuICBzdGF0ZS5wdXNoVmFsdWVzKGdsLCBwYXJhbXMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYyhnbCk7XG4gIH0gZmluYWxseSB7XG4gICAgc3RhdGUucG9wVmFsdWVzKGdsKTtcblxuICAgIGlmIChwYXJhbXMuZnJhbWVCdWZmZXIpIHtcbiAgICAgIC8vIFRPRE8gLSB3YXMgdGhlcmUgYW55IHByZXZpb3VzbHkgc2V0IGZyYW1lIGJ1ZmZlcj9cbiAgICAgIC8vIFRPRE8gLSBkZWxlZ2F0ZSBcInVuYmluZFwiIHRvIEZyYW1lYnVmZmVyIG9iamVjdD9cbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBURVNUX0VYUE9SVFMgPSB7XG4gIEdMX1NUQVRFXG59O1xuIl19

/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__ = __webpack_require__(58);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// WebGL2 Query Helper
// https://developer.mozilla.org/en-US/docs/Web/API/WebGLQuery





// WebGL2 VertexArray Objects Helper

var noop = function noop(x) {
  return x;
};

var ERR_GPU_DISJOINT = 'Disjoint GPU operation invalidated timer queries';
var ERR_TIMER_QUERY_NOT_SUPPORTED = 'Timer queries require "EXT_disjoint_timer_query" extension';

var EMPTY_EXTENSION = {
  createQueryEXT: function createQueryEXT() {
    return null;
  },
  getQueryEXT: function getQueryEXT() {
    return 0;
  }
};

function getTimerQueryExtension(gl) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["c" /* assertWebGLContext */])(gl);
  var extension = void 0;
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl)) {
    extension = gl.getExtension('EXT_disjoint_timer_query_webgl2');
  } else {
    extension = gl.getExtension('EXT_disjoint_timer_query');
  }
  return extension || EMPTY_EXTENSION;
}

function deleteQuery(handle) {}
// if (this.handle) {
//   if (this.webgl2) {
//     this.gl.deleteQuery(this.handle);
//   } else {
//     this.ext.deleteQueryEXT(this.handle);
//   }
// }
// this.handle = null;
// return this;


/* eslint-disable max-len */
// gl.ANY_SAMPLES_PASSED // Specifies an occlusion query: these queries detect whether an object is visible (whether the scoped drawing commands pass the depth test and if so, how many samples pass).
// gl.ANY_SAMPLES_PASSED_CONSERVATIVE // Same as above above, but less accurate and faster version.
// gl.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN // Number of primitives that are written to transform feedback buffers.

// gl.QUERY_RESULT: Returns a GLuint containing the query result.
// gl.QUERY_RESULT_AVAILABLE: Returns a GLboolean indicating whether or not a query result is available.

var Query = function (_Resource) {
  _inherits(Query, _Resource);

  _createClass(Query, null, [{
    key: 'isSupported',

    /**
     * Returns true if Query is supported by the WebGL implementation
     * (depends on the EXT_disjoint_timer_query extension)/
     * Can also check whether timestamp queries are available.
     *
     * @param {WebGLRenderingContext} gl - gl context
     * @param {Object} opts= - options
     * @param {Object} opts.requireTimestamps=false -
     *   If true, checks if timestamps are supported
     * @return {Boolean} - TimerQueries are supported with specified configuration
     */
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$queries = _ref.queries,
          queries = _ref$queries === undefined ? false : _ref$queries,
          _ref$timers = _ref.timers,
          timers = _ref$timers === undefined ? false : _ref$timers,
          _ref$timestamps = _ref.timestamps,
          timestamps = _ref$timestamps === undefined ? false : _ref$timestamps;

      var ext = getTimerQueryExtension(gl);

      var supported = true;
      if (queries) {
        supported = supported && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl);
      }

      if (timestamps) {
        var queryCounterBits = ext.getQueryEXT(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIMESTAMP_EXT, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].QUERY_COUNTER_BITS_EXT);
        supported = supported && queryCounterBits > 0;
      }

      return supported;
    }

    /**
     * @classdesc
     * Provides a way to measure the duration of a set of GL commands,
     * without stalling the rendering pipeline.
     *
     * Exposes a `promise` member that tracks the state of the query
     * when `poll` is used to update queries.
     *
     * @example
        const timerQuery = new Query({
          onComplete: timestamp => console.log(timestamp)
          onError: error => console.warn(error)
        });
         timerQuery.begin();
         // Issue GPU calls
         timerQuery.end();
         // Poll for resolved queries
        requestAnimationFrame(() => Query.poll(gl))
     *
     * Remarks:
     * - On Chrome, go to chrome:flags and enable "WebGL Draft Extensions"
     *
     * - For full functionality, Query depends on a `poll` function being
     *   called regularly. When this is done, completed queries will be
     *   automatically detected and any callbacks called.
     *
     * - Query instance creation will always succeed, even when the required
     *   extension is not supported. Instead any issued queries will fail
     *   immediately. This allows applications to unconditionally use TimerQueries
     *   without adding logic to check whether they are supported; the
     *   difference being that the `onComplete` callback never gets called,
     *   (the `onError` callback, if supplied, will be called instead).
     *
     * - Even when supported, timer queries can fail whenever a change in the
     *   GPU occurs that will make the values returned by this extension unusable
     *   for performance metrics. Power conservation might cause the GPU to go to
     *   sleep at the lower levers. Query will detect this condition and
     *   fail any outstanding queries (which calls the `onError` function,
     *   if supplied).
     *
     * @class
     * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - gl context
     * @param {Object} opts - options
     * @param {Function} opts.onComplete - called with a timestamp.
     *   Specifying this parameter causes a timestamp query to be initiated
     * @param {Function} opts.onComplete - called with a timestamp.
     *   Specifying this parameter causes a timestamp query to be initiated
     */

  }]);

  function Query(gl) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$onComplete = _ref2.onComplete,
        onComplete = _ref2$onComplete === undefined ? noop : _ref2$onComplete,
        _ref2$onError = _ref2.onError,
        onError = _ref2$onError === undefined ? noop : _ref2$onError;

    _classCallCheck(this, Query);

    var _this = _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).call(this));

    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl)) {
      _this.ext = _this.gl.getExtension('EXT_disjoint_timer_query_webgl2');
      _this.webgl2 = true;
    } else {
      _this.ext = _this.gl.getExtension('EXT_disjoint_timer_query');
      _this.handle = _this.ext ? _this.ext.createQueryEXT() : null;
      _this.webgl2 = false;
    }

    _this.target = null;
    _this.onComplete = onComplete;
    _this.onError = onError;

    // query manager needs a promise field
    _this.promise = null;

    Object.seal(_this);
    return _this;
  }

  _createClass(Query, [{
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createQuery();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].deleteQuery(this);
      deleteQuery(this.gl, this.handle);
    }

    // Shortcut for timer query (dependent on extension in both WebGL1 and 2)

  }, {
    key: 'beginTimeElapsedQuery',
    value: function beginTimeElapsedQuery() {
      return this.begin(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIME_ELAPSED_EXT);
    }

    // Shortcut for timer query (dependent on extension in both WebGL1 and 2)

  }, {
    key: 'beginOcclusionQuery',
    value: function beginOcclusionQuery() {
      var conservative = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return this.begin(conservative ? this.gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this.gl.ANY_SAMPLES_PASSED);
    }

    // Shortcut for timer query (dependent on extension in both WebGL1 and 2)

  }, {
    key: 'beginTransformFeedbackQuery',
    value: function beginTransformFeedbackQuery() {
      return this.begin(this.gl.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }

    /**
     * Measures GPU time delta between this call and a matching `end` call in the
     * GPU instruction stream.
     *
     * Remarks:
     * - Due to OpenGL API limitations, after calling `begin()` on one Query
     *   instance, `end()` must be called on that same instance before
     *   calling `begin()` on another query. While there can be multiple
     *   outstanding queries representing disjoint `begin()`/`end()` intervals.
     *   It is not possible to interleave or overlap `begin` and `end` calls.
     *
     * - Triggering a new query when a Query is already tracking an
     *   unresolved query causes that query to be cancelled.
     *
     * @param {GLenum} target - target to query
     * @return {Query} - returns itself, to enable chaining of calls.
     */

  }, {
    key: 'begin',
    value: function begin(target) {
      __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].beginQuery(this, this.onComplete, this.onError);
      this.target = target;

      // WebGL2
      if (this.webgl2) {
        this.gl.beginQuery(target, this.handle);
        return this;
      }

      // WebGL1
      switch (target) {
        case __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIME_ELAPSED_EXT:
          if (this.ext) {
            this.ext.beginQueryEXT(this.target, this.handle);
          } else {
            __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].rejectQuery(this, ERR_TIMER_QUERY_NOT_SUPPORTED);
          }
          break;
        default:
          __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].rejectQuery(this, 'Query not supported');
          throw new Error('Query not supported');
      }

      return this;
    }

    /**
     * Inserts a query end marker into the GPU instruction stream.
     * Can be called multiple times.
     *
     * @return {Query} - returns itself, to enable chaining of calls.
     */

  }, {
    key: 'end',
    value: function end() {
      // Note: calling end does not affect the pending promise
      if (this.target) {
        if (this.webgl2) {
          this.gl.endQuery(this.target);
        } else if (this.ext) {
          this.ext.endQueryEXT(this.target);
        }
      }
      this.target = null;
      return this;
    }

    /**
     * Generates a GPU time stamp when the GPU instruction stream reaches
     * this instruction.
     * To measure time deltas, two timestamp queries are needed.
     *
     * Remarks:
     * - timestamp() queries may not be available even when the timer query
     *   extension is. See TimeQuery.isSupported() flags.
     *
     * - Triggering a new query when a Query is already tracking an
     *   unresolved query causes that query to be cancelled.
     *
     * @return {Query} - returns itself, to enable chaining of calls.
     */

  }, {
    key: 'getTimestamp',
    value: function getTimestamp() {
      __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].beginQuery(this, this.onComplete, this.onError);
      if (this.ext) {
        // Note: Same function signature for both WebGL1 and WebGL2 extensions
        this.ext.queryCounterEXT(this.handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TIMESTAMP_EXT);
      } else {
        __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].rejectQuery(this, ERR_TIMER_QUERY_NOT_SUPPORTED);
      }
      return this;
    }

    /**
     * Cancels a pending query
     * Note - Cancel's the promise and calls end on the current query if needed.
     *
     * @return {Query} - returns itself, to enable chaining of calls.
     */

  }, {
    key: 'cancel',
    value: function cancel() {
      this.end();
      __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].cancelQuery(this);
      return this;
    }

    /**
     * @return {Boolean} - true if query result is available
     */

  }, {
    key: 'isResultAvailable',
    value: function isResultAvailable() {
      var webgl2 = this.webgl2,
          gl = this.gl,
          handle = this.handle,
          ext = this.ext;

      return webgl2 ? gl.getQueryParameter(handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].QUERY_RESULT_AVAILABLE_EXT) : ext && ext.getQueryObjectEXT(handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].QUERY_RESULT_AVAILABLE_EXT);
    }

    /**
     * Returns the query result, converted to milliseconds to match
     * JavaScript conventions.
     *
     * @return {Number} - measured time or timestamp, in milliseconds
     */

  }, {
    key: 'getResult',
    value: function getResult() {
      var webgl2 = this.webgl2,
          gl = this.gl,
          handle = this.handle,
          ext = this.ext;

      var result = webgl2 ? gl.getQueryParameter(handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].QUERY_RESULT_EXT) : ext && ext.getQueryObjectEXT(handle, __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].QUERY_RESULT_EXT);
      return Number.isFinite(result) ? result / 1e6 : 0;
    }
  }], [{
    key: 'poll',
    value: function poll(gl) {
      __WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].poll(gl);
    }
  }]);

  return Query;
}(__WEBPACK_IMPORTED_MODULE_2__webgl_resource__["a" /* default */]);

// NOTE: This call lets the queryManager know how to detect disjoint GPU state
// It will check dsjoint state on polls and before adding a new query
// and reject any outstanding TimerQueries with our supplied error message.


/* unused harmony default export */ var _unused_webpack_default_export = (Query);
__WEBPACK_IMPORTED_MODULE_3__webgl_helpers_query_manager__["a" /* default */].setInvalidator({
  queryType: Query,
  errorMessage: ERR_GPU_DISJOINT,
  // Note: Querying the disjoint state resets it
  checkInvalid: function checkInvalid(gl) {
    return gl.getParameter(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].GPU_DISJOINT_EXT);
  }
});

/* TODO - remove code below
/* eslint-disable max-len *
// gl.ANY_SAMPLES_PASSED // Specifies an occlusion query: these queries detect whether an object is visible (whether the scoped drawing commands pass the depth test and if so, how many samples pass).
// gl.ANY_SAMPLES_PASSED_CONSERVATIVE // Same as above above, but less accurate and faster version.
// gl.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN // Number of primitives that are written to transform feedback buffers.

// gl.QUERY_RESULT: Returns a GLuint containing the query result.
// gl.QUERY_RESULT_AVAILABLE: Returns a GLboolean indicating whether or not a query result is available.

export default class Query {

  static isSupported(gl) {
    return isWebGL2Context(gl);
  }

  /**
   * @class
   * @param {WebGL2Context} gl
   *
  constructor(gl) {
    assertWebGL2Context(gl);
    const handle = gl.createQuery();
    glCheckError(gl);

    this.gl = gl;
    this.handle = handle;
    this.target = null;
    this.userData = {};

    // query manager needs a promise field
    this.promise = null;

    Object.seal(this);
  }

  /*
   * @return {Query} returns self to enable chaining
   *
  delete() {
    queryManager.deleteQuery(this);
    if (this.handle) {
      this.gl.deleteQuery(this.handle);
      this.handle = null;
      glCheckError(this.gl);
    }
    return this;
  }

  /*
   * @return {Query} returns self to enable chaining
   *
  begin(target) {
    queryManager.beginQuery(this);
    this.target = target;
    this.gl.beginQuery(target, this.handle);
    glCheckError(this.gl);
    return this;
  }

  /*
   * @return {Query} returns self to enable chaining
   *
  end() {
    if (this.target) {
      this.target = null;
      this.gl.endQuery(this.target);
      glCheckError(this.gl);
    }
    return this;
  }

  cancel() {
    this.end();
    queryManager.cancelQuery(this);
    return this;
  }

  isResultAvailable() {
    return this.gl.getQueryParameter(this.handle,
      this.gl.QUERY_RESULT_AVAILBLE);
  }

  getResult() {
    return this.gl.getQueryParameter(this.handle, this.gl.QUERY_RESULT);
  }

  static poll(gl) {
    queryManager.poll(gl);
  }
}
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC9xdWVyeS5qcyJdLCJuYW1lcyI6WyJHTCIsImFzc2VydFdlYkdMQ29udGV4dCIsImlzV2ViR0wyQ29udGV4dCIsIlJlc291cmNlIiwicXVlcnlNYW5hZ2VyIiwibm9vcCIsIngiLCJFUlJfR1BVX0RJU0pPSU5UIiwiRVJSX1RJTUVSX1FVRVJZX05PVF9TVVBQT1JURUQiLCJFTVBUWV9FWFRFTlNJT04iLCJjcmVhdGVRdWVyeUVYVCIsImdldFF1ZXJ5RVhUIiwiZ2V0VGltZXJRdWVyeUV4dGVuc2lvbiIsImdsIiwiZXh0ZW5zaW9uIiwiZ2V0RXh0ZW5zaW9uIiwiZGVsZXRlUXVlcnkiLCJoYW5kbGUiLCJRdWVyeSIsInF1ZXJpZXMiLCJ0aW1lcnMiLCJ0aW1lc3RhbXBzIiwiZXh0Iiwic3VwcG9ydGVkIiwicXVlcnlDb3VudGVyQml0cyIsIlRJTUVTVEFNUF9FWFQiLCJRVUVSWV9DT1VOVEVSX0JJVFNfRVhUIiwib25Db21wbGV0ZSIsIm9uRXJyb3IiLCJ3ZWJnbDIiLCJ0YXJnZXQiLCJwcm9taXNlIiwiT2JqZWN0Iiwic2VhbCIsImNyZWF0ZVF1ZXJ5IiwiYmVnaW4iLCJUSU1FX0VMQVBTRURfRVhUIiwiY29uc2VydmF0aXZlIiwiQU5ZX1NBTVBMRVNfUEFTU0VEX0NPTlNFUlZBVElWRSIsIkFOWV9TQU1QTEVTX1BBU1NFRCIsIlRSQU5TRk9STV9GRUVEQkFDS19QUklNSVRJVkVTX1dSSVRURU4iLCJiZWdpblF1ZXJ5IiwiYmVnaW5RdWVyeUVYVCIsInJlamVjdFF1ZXJ5IiwiRXJyb3IiLCJlbmRRdWVyeSIsImVuZFF1ZXJ5RVhUIiwicXVlcnlDb3VudGVyRVhUIiwiZW5kIiwiY2FuY2VsUXVlcnkiLCJnZXRRdWVyeVBhcmFtZXRlciIsIlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUIiwiZ2V0UXVlcnlPYmplY3RFWFQiLCJyZXN1bHQiLCJRVUVSWV9SRVNVTFRfRVhUIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwb2xsIiwic2V0SW52YWxpZGF0b3IiLCJxdWVyeVR5cGUiLCJlcnJvck1lc3NhZ2UiLCJjaGVja0ludmFsaWQiLCJnZXRQYXJhbWV0ZXIiLCJHUFVfRElTSk9JTlRfRVhUIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxPQUFPQSxFQUFQLE1BQWUsT0FBZjtBQUNBLFNBQVFDLGtCQUFSLEVBQTRCQyxlQUE1QixRQUFrRCxXQUFsRDtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsbUJBQXJCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5QixnQ0FBekI7O0FBRUE7O0FBRUEsSUFBTUMsT0FBTyxTQUFQQSxJQUFPO0FBQUEsU0FBS0MsQ0FBTDtBQUFBLENBQWI7O0FBRUEsSUFBTUMsbUJBQW1CLGtEQUF6QjtBQUNBLElBQU1DLGdDQUFnQyw0REFBdEM7O0FBRUEsSUFBTUMsa0JBQWtCO0FBQ3RCQyxnQkFEc0IsNEJBQ0w7QUFDZixXQUFPLElBQVA7QUFDRCxHQUhxQjtBQUl0QkMsYUFKc0IseUJBSVI7QUFDWixXQUFPLENBQVA7QUFDRDtBQU5xQixDQUF4Qjs7QUFTQSxTQUFTQyxzQkFBVCxDQUFnQ0MsRUFBaEMsRUFBb0M7QUFDbENaLHFCQUFtQlksRUFBbkI7QUFDQSxNQUFJQyxrQkFBSjtBQUNBLE1BQUlaLGdCQUFnQlcsRUFBaEIsQ0FBSixFQUF5QjtBQUN2QkMsZ0JBQVlELEdBQUdFLFlBQUgsQ0FBZ0IsaUNBQWhCLENBQVo7QUFDRCxHQUZELE1BRU87QUFDTEQsZ0JBQVlELEdBQUdFLFlBQUgsQ0FBZ0IsMEJBQWhCLENBQVo7QUFDRDtBQUNELFNBQU9ELGFBQWFMLGVBQXBCO0FBQ0Q7O0FBRUQsU0FBU08sV0FBVCxDQUFxQkMsTUFBckIsRUFBNkIsQ0FVNUI7QUFUQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0lBRXFCQyxLOzs7Ozs7QUFDbkI7Ozs7Ozs7Ozs7O2dDQVdtQkwsRSxFQUlYO0FBQUEscUZBQUosRUFBSTtB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QjtBQUNBc0QsZ0JBQWM7QUFBQSxXQUFNaEQsR0FBR2lELFlBQUgsQ0FBZ0I5RCxHQUFHK0QsZ0JBQW5CLENBQU47QUFBQTtBQUpZLENBQTVCOztBQU9BIiwiZmlsZSI6InF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV2ViR0wyIFF1ZXJ5IEhlbHBlclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUXVlcnlcbmltcG9ydCBHTCBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2Fzc2VydFdlYkdMQ29udGV4dCwgaXNXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4uL3dlYmdsL3Jlc291cmNlJztcbmltcG9ydCBxdWVyeU1hbmFnZXIgZnJvbSAnLi4vd2ViZ2wvaGVscGVycy9xdWVyeS1tYW5hZ2VyJztcblxuLy8gV2ViR0wyIFZlcnRleEFycmF5IE9iamVjdHMgSGVscGVyXG5cbmNvbnN0IG5vb3AgPSB4ID0+IHg7XG5cbmNvbnN0IEVSUl9HUFVfRElTSk9JTlQgPSAnRGlzam9pbnQgR1BVIG9wZXJhdGlvbiBpbnZhbGlkYXRlZCB0aW1lciBxdWVyaWVzJztcbmNvbnN0IEVSUl9USU1FUl9RVUVSWV9OT1RfU1VQUE9SVEVEID0gJ1RpbWVyIHF1ZXJpZXMgcmVxdWlyZSBcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiIGV4dGVuc2lvbic7XG5cbmNvbnN0IEVNUFRZX0VYVEVOU0lPTiA9IHtcbiAgY3JlYXRlUXVlcnlFWFQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGdldFF1ZXJ5RVhUKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRUaW1lclF1ZXJ5RXh0ZW5zaW9uKGdsKSB7XG4gIGFzc2VydFdlYkdMQ29udGV4dChnbCk7XG4gIGxldCBleHRlbnNpb247XG4gIGlmIChpc1dlYkdMMkNvbnRleHQoZ2wpKSB7XG4gICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKTtcbiAgfVxuICByZXR1cm4gZXh0ZW5zaW9uIHx8IEVNUFRZX0VYVEVOU0lPTjtcbn1cblxuZnVuY3Rpb24gZGVsZXRlUXVlcnkoaGFuZGxlKSB7XG4gIC8vIGlmICh0aGlzLmhhbmRsZSkge1xuICAvLyAgIGlmICh0aGlzLndlYmdsMikge1xuICAvLyAgICAgdGhpcy5nbC5kZWxldGVRdWVyeSh0aGlzLmhhbmRsZSk7XG4gIC8vICAgfSBlbHNlIHtcbiAgLy8gICAgIHRoaXMuZXh0LmRlbGV0ZVF1ZXJ5RVhUKHRoaXMuaGFuZGxlKTtcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gdGhpcy5oYW5kbGUgPSBudWxsO1xuICAvLyByZXR1cm4gdGhpcztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLy8gZ2wuQU5ZX1NBTVBMRVNfUEFTU0VEIC8vIFNwZWNpZmllcyBhbiBvY2NsdXNpb24gcXVlcnk6IHRoZXNlIHF1ZXJpZXMgZGV0ZWN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHZpc2libGUgKHdoZXRoZXIgdGhlIHNjb3BlZCBkcmF3aW5nIGNvbW1hbmRzIHBhc3MgdGhlIGRlcHRoIHRlc3QgYW5kIGlmIHNvLCBob3cgbWFueSBzYW1wbGVzIHBhc3MpLlxuLy8gZ2wuQU5ZX1NBTVBMRVNfUEFTU0VEX0NPTlNFUlZBVElWRSAvLyBTYW1lIGFzIGFib3ZlIGFib3ZlLCBidXQgbGVzcyBhY2N1cmF0ZSBhbmQgZmFzdGVyIHZlcnNpb24uXG4vLyBnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOIC8vIE51bWJlciBvZiBwcmltaXRpdmVzIHRoYXQgYXJlIHdyaXR0ZW4gdG8gdHJhbnNmb3JtIGZlZWRiYWNrIGJ1ZmZlcnMuXG5cbi8vIGdsLlFVRVJZX1JFU1VMVDogUmV0dXJucyBhIEdMdWludCBjb250YWluaW5nIHRoZSBxdWVyeSByZXN1bHQuXG4vLyBnbC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFOiBSZXR1cm5zIGEgR0xib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYSBxdWVyeSByZXN1bHQgaXMgYXZhaWxhYmxlLlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSBleHRlbmRzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBRdWVyeSBpcyBzdXBwb3J0ZWQgYnkgdGhlIFdlYkdMIGltcGxlbWVudGF0aW9uXG4gICAqIChkZXBlbmRzIG9uIHRoZSBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnkgZXh0ZW5zaW9uKS9cbiAgICogQ2FuIGFsc28gY2hlY2sgd2hldGhlciB0aW1lc3RhbXAgcXVlcmllcyBhcmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBnbCBjb250ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzPSAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucmVxdWlyZVRpbWVzdGFtcHM9ZmFsc2UgLVxuICAgKiAgIElmIHRydWUsIGNoZWNrcyBpZiB0aW1lc3RhbXBzIGFyZSBzdXBwb3J0ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBUaW1lclF1ZXJpZXMgYXJlIHN1cHBvcnRlZCB3aXRoIHNwZWNpZmllZCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoZ2wsIHtcbiAgICBxdWVyaWVzID0gZmFsc2UsXG4gICAgdGltZXJzID0gZmFsc2UsXG4gICAgdGltZXN0YW1wcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGV4dCA9IGdldFRpbWVyUXVlcnlFeHRlbnNpb24oZ2wpO1xuXG4gICAgbGV0IHN1cHBvcnRlZCA9IHRydWU7XG4gICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHN1cHBvcnRlZCAmJiBpc1dlYkdMMkNvbnRleHQoZ2wpO1xuICAgIH1cblxuICAgIGlmICh0aW1lc3RhbXBzKSB7XG4gICAgICBjb25zdCBxdWVyeUNvdW50ZXJCaXRzID1cbiAgICAgICAgZXh0LmdldFF1ZXJ5RVhUKEdMLlRJTUVTVEFNUF9FWFQsIEdMLlFVRVJZX0NPVU5URVJfQklUU19FWFQpO1xuICAgICAgc3VwcG9ydGVkID0gc3VwcG9ydGVkICYmIChxdWVyeUNvdW50ZXJCaXRzID4gMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByb3ZpZGVzIGEgd2F5IHRvIG1lYXN1cmUgdGhlIGR1cmF0aW9uIG9mIGEgc2V0IG9mIEdMIGNvbW1hbmRzLFxuICAgKiB3aXRob3V0IHN0YWxsaW5nIHRoZSByZW5kZXJpbmcgcGlwZWxpbmUuXG4gICAqXG4gICAqIEV4cG9zZXMgYSBgcHJvbWlzZWAgbWVtYmVyIHRoYXQgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgcXVlcnlcbiAgICogd2hlbiBgcG9sbGAgaXMgdXNlZCB0byB1cGRhdGUgcXVlcmllcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICAgIGNvbnN0IHRpbWVyUXVlcnkgPSBuZXcgUXVlcnkoe1xuICAgICAgICBvbkNvbXBsZXRlOiB0aW1lc3RhbXAgPT4gY29uc29sZS5sb2codGltZXN0YW1wKVxuICAgICAgICBvbkVycm9yOiBlcnJvciA9PiBjb25zb2xlLndhcm4oZXJyb3IpXG4gICAgICB9KTtcblxuICAgICAgdGltZXJRdWVyeS5iZWdpbigpO1xuXG4gICAgICAvLyBJc3N1ZSBHUFUgY2FsbHNcblxuICAgICAgdGltZXJRdWVyeS5lbmQoKTtcblxuICAgICAgLy8gUG9sbCBmb3IgcmVzb2x2ZWQgcXVlcmllc1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IFF1ZXJ5LnBvbGwoZ2wpKVxuICAgKlxuICAgKiBSZW1hcmtzOlxuICAgKiAtIE9uIENocm9tZSwgZ28gdG8gY2hyb21lOmZsYWdzIGFuZCBlbmFibGUgXCJXZWJHTCBEcmFmdCBFeHRlbnNpb25zXCJcbiAgICpcbiAgICogLSBGb3IgZnVsbCBmdW5jdGlvbmFsaXR5LCBRdWVyeSBkZXBlbmRzIG9uIGEgYHBvbGxgIGZ1bmN0aW9uIGJlaW5nXG4gICAqICAgY2FsbGVkIHJlZ3VsYXJseS4gV2hlbiB0aGlzIGlzIGRvbmUsIGNvbXBsZXRlZCBxdWVyaWVzIHdpbGwgYmVcbiAgICogICBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIGFuZCBhbnkgY2FsbGJhY2tzIGNhbGxlZC5cbiAgICpcbiAgICogLSBRdWVyeSBpbnN0YW5jZSBjcmVhdGlvbiB3aWxsIGFsd2F5cyBzdWNjZWVkLCBldmVuIHdoZW4gdGhlIHJlcXVpcmVkXG4gICAqICAgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQgYW55IGlzc3VlZCBxdWVyaWVzIHdpbGwgZmFpbFxuICAgKiAgIGltbWVkaWF0ZWx5LiBUaGlzIGFsbG93cyBhcHBsaWNhdGlvbnMgdG8gdW5jb25kaXRpb25hbGx5IHVzZSBUaW1lclF1ZXJpZXNcbiAgICogICB3aXRob3V0IGFkZGluZyBsb2dpYyB0byBjaGVjayB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvcnRlZDsgdGhlXG4gICAqICAgZGlmZmVyZW5jZSBiZWluZyB0aGF0IHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2sgbmV2ZXIgZ2V0cyBjYWxsZWQsXG4gICAqICAgKHRoZSBgb25FcnJvcmAgY2FsbGJhY2ssIGlmIHN1cHBsaWVkLCB3aWxsIGJlIGNhbGxlZCBpbnN0ZWFkKS5cbiAgICpcbiAgICogLSBFdmVuIHdoZW4gc3VwcG9ydGVkLCB0aW1lciBxdWVyaWVzIGNhbiBmYWlsIHdoZW5ldmVyIGEgY2hhbmdlIGluIHRoZVxuICAgKiAgIEdQVSBvY2N1cnMgdGhhdCB3aWxsIG1ha2UgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGlzIGV4dGVuc2lvbiB1bnVzYWJsZVxuICAgKiAgIGZvciBwZXJmb3JtYW5jZSBtZXRyaWNzLiBQb3dlciBjb25zZXJ2YXRpb24gbWlnaHQgY2F1c2UgdGhlIEdQVSB0byBnbyB0b1xuICAgKiAgIHNsZWVwIGF0IHRoZSBsb3dlciBsZXZlcnMuIFF1ZXJ5IHdpbGwgZGV0ZWN0IHRoaXMgY29uZGl0aW9uIGFuZFxuICAgKiAgIGZhaWwgYW55IG91dHN0YW5kaW5nIHF1ZXJpZXMgKHdoaWNoIGNhbGxzIHRoZSBgb25FcnJvcmAgZnVuY3Rpb24sXG4gICAqICAgaWYgc3VwcGxpZWQpLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCAtIGdsIGNvbnRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMub25Db21wbGV0ZSAtIGNhbGxlZCB3aXRoIGEgdGltZXN0YW1wLlxuICAgKiAgIFNwZWNpZnlpbmcgdGhpcyBwYXJhbWV0ZXIgY2F1c2VzIGEgdGltZXN0YW1wIHF1ZXJ5IHRvIGJlIGluaXRpYXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLm9uQ29tcGxldGUgLSBjYWxsZWQgd2l0aCBhIHRpbWVzdGFtcC5cbiAgICogICBTcGVjaWZ5aW5nIHRoaXMgcGFyYW1ldGVyIGNhdXNlcyBhIHRpbWVzdGFtcCBxdWVyeSB0byBiZSBpbml0aWF0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgb25Db21wbGV0ZSA9IG5vb3AsXG4gICAgb25FcnJvciA9IG5vb3BcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChpc1dlYkdMMkNvbnRleHQoZ2wpKSB7XG4gICAgICB0aGlzLmV4dCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyk7XG4gICAgICB0aGlzLndlYmdsMiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScpO1xuICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLmV4dCA/IHRoaXMuZXh0LmNyZWF0ZVF1ZXJ5RVhUKCkgOiBudWxsO1xuICAgICAgdGhpcy53ZWJnbDIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG4gICAgLy8gcXVlcnkgbWFuYWdlciBuZWVkcyBhIHByb21pc2UgZmllbGRcbiAgICB0aGlzLnByb21pc2UgPSBudWxsO1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZVF1ZXJ5KCk7XG4gIH1cblxuICBfZGVsZXRlSGFuZGxlKCkge1xuICAgIHF1ZXJ5TWFuYWdlci5kZWxldGVRdWVyeSh0aGlzKTtcbiAgICBkZWxldGVRdWVyeSh0aGlzLmdsLCB0aGlzLmhhbmRsZSk7XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgdGltZXIgcXVlcnkgKGRlcGVuZGVudCBvbiBleHRlbnNpb24gaW4gYm90aCBXZWJHTDEgYW5kIDIpXG4gIGJlZ2luVGltZUVsYXBzZWRRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpbihHTC5USU1FX0VMQVBTRURfRVhUKTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciB0aW1lciBxdWVyeSAoZGVwZW5kZW50IG9uIGV4dGVuc2lvbiBpbiBib3RoIFdlYkdMMSBhbmQgMilcbiAgYmVnaW5PY2NsdXNpb25RdWVyeShjb25zZXJ2YXRpdmUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmJlZ2luKGNvbnNlcnZhdGl2ZSA/XG4gICAgICB0aGlzLmdsLkFOWV9TQU1QTEVTX1BBU1NFRF9DT05TRVJWQVRJVkUgOlxuICAgICAgdGhpcy5nbC5BTllfU0FNUExFU19QQVNTRURcbiAgICApO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIHRpbWVyIHF1ZXJ5IChkZXBlbmRlbnQgb24gZXh0ZW5zaW9uIGluIGJvdGggV2ViR0wxIGFuZCAyKVxuICBiZWdpblRyYW5zZm9ybUZlZWRiYWNrUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVnaW4odGhpcy5nbC5UUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyBHUFUgdGltZSBkZWx0YSBiZXR3ZWVuIHRoaXMgY2FsbCBhbmQgYSBtYXRjaGluZyBgZW5kYCBjYWxsIGluIHRoZVxuICAgKiBHUFUgaW5zdHJ1Y3Rpb24gc3RyZWFtLlxuICAgKlxuICAgKiBSZW1hcmtzOlxuICAgKiAtIER1ZSB0byBPcGVuR0wgQVBJIGxpbWl0YXRpb25zLCBhZnRlciBjYWxsaW5nIGBiZWdpbigpYCBvbiBvbmUgUXVlcnlcbiAgICogICBpbnN0YW5jZSwgYGVuZCgpYCBtdXN0IGJlIGNhbGxlZCBvbiB0aGF0IHNhbWUgaW5zdGFuY2UgYmVmb3JlXG4gICAqICAgY2FsbGluZyBgYmVnaW4oKWAgb24gYW5vdGhlciBxdWVyeS4gV2hpbGUgdGhlcmUgY2FuIGJlIG11bHRpcGxlXG4gICAqICAgb3V0c3RhbmRpbmcgcXVlcmllcyByZXByZXNlbnRpbmcgZGlzam9pbnQgYGJlZ2luKClgL2BlbmQoKWAgaW50ZXJ2YWxzLlxuICAgKiAgIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBpbnRlcmxlYXZlIG9yIG92ZXJsYXAgYGJlZ2luYCBhbmQgYGVuZGAgY2FsbHMuXG4gICAqXG4gICAqIC0gVHJpZ2dlcmluZyBhIG5ldyBxdWVyeSB3aGVuIGEgUXVlcnkgaXMgYWxyZWFkeSB0cmFja2luZyBhblxuICAgKiAgIHVucmVzb2x2ZWQgcXVlcnkgY2F1c2VzIHRoYXQgcXVlcnkgdG8gYmUgY2FuY2VsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0dMZW51bX0gdGFyZ2V0IC0gdGFyZ2V0IHRvIHF1ZXJ5XG4gICAqIEByZXR1cm4ge1F1ZXJ5fSAtIHJldHVybnMgaXRzZWxmLCB0byBlbmFibGUgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBiZWdpbih0YXJnZXQpIHtcbiAgICBxdWVyeU1hbmFnZXIuYmVnaW5RdWVyeSh0aGlzLCB0aGlzLm9uQ29tcGxldGUsIHRoaXMub25FcnJvcik7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAvLyBXZWJHTDJcbiAgICBpZiAodGhpcy53ZWJnbDIpIHtcbiAgICAgIHRoaXMuZ2wuYmVnaW5RdWVyeSh0YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFdlYkdMMVxuICAgIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgY2FzZSBHTC5USU1FX0VMQVBTRURfRVhUOlxuICAgICAgaWYgKHRoaXMuZXh0KSB7XG4gICAgICAgIHRoaXMuZXh0LmJlZ2luUXVlcnlFWFQodGhpcy50YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5TWFuYWdlci5yZWplY3RRdWVyeSh0aGlzLCBFUlJfVElNRVJfUVVFUllfTk9UX1NVUFBPUlRFRCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcXVlcnlNYW5hZ2VyLnJlamVjdFF1ZXJ5KHRoaXMsICdRdWVyeSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgcXVlcnkgZW5kIG1hcmtlciBpbnRvIHRoZSBHUFUgaW5zdHJ1Y3Rpb24gc3RyZWFtLlxuICAgKiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtRdWVyeX0gLSByZXR1cm5zIGl0c2VsZiwgdG8gZW5hYmxlIGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgZW5kKCkge1xuICAgIC8vIE5vdGU6IGNhbGxpbmcgZW5kIGRvZXMgbm90IGFmZmVjdCB0aGUgcGVuZGluZyBwcm9taXNlXG4gICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy53ZWJnbDIpIHtcbiAgICAgICAgdGhpcy5nbC5lbmRRdWVyeSh0aGlzLnRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZXh0KSB7XG4gICAgICAgIHRoaXMuZXh0LmVuZFF1ZXJ5RVhUKHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIEdQVSB0aW1lIHN0YW1wIHdoZW4gdGhlIEdQVSBpbnN0cnVjdGlvbiBzdHJlYW0gcmVhY2hlc1xuICAgKiB0aGlzIGluc3RydWN0aW9uLlxuICAgKiBUbyBtZWFzdXJlIHRpbWUgZGVsdGFzLCB0d28gdGltZXN0YW1wIHF1ZXJpZXMgYXJlIG5lZWRlZC5cbiAgICpcbiAgICogUmVtYXJrczpcbiAgICogLSB0aW1lc3RhbXAoKSBxdWVyaWVzIG1heSBub3QgYmUgYXZhaWxhYmxlIGV2ZW4gd2hlbiB0aGUgdGltZXIgcXVlcnlcbiAgICogICBleHRlbnNpb24gaXMuIFNlZSBUaW1lUXVlcnkuaXNTdXBwb3J0ZWQoKSBmbGFncy5cbiAgICpcbiAgICogLSBUcmlnZ2VyaW5nIGEgbmV3IHF1ZXJ5IHdoZW4gYSBRdWVyeSBpcyBhbHJlYWR5IHRyYWNraW5nIGFuXG4gICAqICAgdW5yZXNvbHZlZCBxdWVyeSBjYXVzZXMgdGhhdCBxdWVyeSB0byBiZSBjYW5jZWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1F1ZXJ5fSAtIHJldHVybnMgaXRzZWxmLCB0byBlbmFibGUgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBnZXRUaW1lc3RhbXAoKSB7XG4gICAgcXVlcnlNYW5hZ2VyLmJlZ2luUXVlcnkodGhpcywgdGhpcy5vbkNvbXBsZXRlLCB0aGlzLm9uRXJyb3IpO1xuICAgIGlmICh0aGlzLmV4dCkge1xuICAgICAgLy8gTm90ZTogU2FtZSBmdW5jdGlvbiBzaWduYXR1cmUgZm9yIGJvdGggV2ViR0wxIGFuZCBXZWJHTDIgZXh0ZW5zaW9uc1xuICAgICAgdGhpcy5leHQucXVlcnlDb3VudGVyRVhUKHRoaXMuaGFuZGxlLCBHTC5USU1FU1RBTVBfRVhUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlNYW5hZ2VyLnJlamVjdFF1ZXJ5KHRoaXMsIEVSUl9USU1FUl9RVUVSWV9OT1RfU1VQUE9SVEVEKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhIHBlbmRpbmcgcXVlcnlcbiAgICogTm90ZSAtIENhbmNlbCdzIHRoZSBwcm9taXNlIGFuZCBjYWxscyBlbmQgb24gdGhlIGN1cnJlbnQgcXVlcnkgaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtRdWVyeX0gLSByZXR1cm5zIGl0c2VsZiwgdG8gZW5hYmxlIGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuZW5kKCk7XG4gICAgcXVlcnlNYW5hZ2VyLmNhbmNlbFF1ZXJ5KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBxdWVyeSByZXN1bHQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBpc1Jlc3VsdEF2YWlsYWJsZSgpIHtcbiAgICBjb25zdCB7d2ViZ2wyLCBnbCwgaGFuZGxlLCBleHR9ID0gdGhpcztcbiAgICByZXR1cm4gd2ViZ2wyID9cbiAgICAgIGdsLmdldFF1ZXJ5UGFyYW1ldGVyKGhhbmRsZSwgR0wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpIDpcbiAgICAgIGV4dCAmJiBleHQuZ2V0UXVlcnlPYmplY3RFWFQoaGFuZGxlLCBHTC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcXVlcnkgcmVzdWx0LCBjb252ZXJ0ZWQgdG8gbWlsbGlzZWNvbmRzIHRvIG1hdGNoXG4gICAqIEphdmFTY3JpcHQgY29udmVudGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBtZWFzdXJlZCB0aW1lIG9yIHRpbWVzdGFtcCwgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBnZXRSZXN1bHQoKSB7XG4gICAgY29uc3Qge3dlYmdsMiwgZ2wsIGhhbmRsZSwgZXh0fSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0gd2ViZ2wyID9cbiAgICAgIGdsLmdldFF1ZXJ5UGFyYW1ldGVyKGhhbmRsZSwgR0wuUVVFUllfUkVTVUxUX0VYVCkgOlxuICAgICAgZXh0ICYmIGV4dC5nZXRRdWVyeU9iamVjdEVYVChoYW5kbGUsIEdMLlFVRVJZX1JFU1VMVF9FWFQpO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCAvIDFlNiA6IDA7XG4gIH1cblxuICBzdGF0aWMgcG9sbChnbCkge1xuICAgIHF1ZXJ5TWFuYWdlci5wb2xsKGdsKTtcbiAgfVxufVxuXG4vLyBOT1RFOiBUaGlzIGNhbGwgbGV0cyB0aGUgcXVlcnlNYW5hZ2VyIGtub3cgaG93IHRvIGRldGVjdCBkaXNqb2ludCBHUFUgc3RhdGVcbi8vIEl0IHdpbGwgY2hlY2sgZHNqb2ludCBzdGF0ZSBvbiBwb2xscyBhbmQgYmVmb3JlIGFkZGluZyBhIG5ldyBxdWVyeVxuLy8gYW5kIHJlamVjdCBhbnkgb3V0c3RhbmRpbmcgVGltZXJRdWVyaWVzIHdpdGggb3VyIHN1cHBsaWVkIGVycm9yIG1lc3NhZ2UuXG5xdWVyeU1hbmFnZXIuc2V0SW52YWxpZGF0b3Ioe1xuICBxdWVyeVR5cGU6IFF1ZXJ5LFxuICBlcnJvck1lc3NhZ2U6IEVSUl9HUFVfRElTSk9JTlQsXG4gIC8vIE5vdGU6IFF1ZXJ5aW5nIHRoZSBkaXNqb2ludCBzdGF0ZSByZXNldHMgaXRcbiAgY2hlY2tJbnZhbGlkOiBnbCA9PiBnbC5nZXRQYXJhbWV0ZXIoR0wuR1BVX0RJU0pPSU5UX0VYVClcbn0pO1xuXG4vKiBUT0RPIC0gcmVtb3ZlIGNvZGUgYmVsb3dcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKlxuLy8gZ2wuQU5ZX1NBTVBMRVNfUEFTU0VEIC8vIFNwZWNpZmllcyBhbiBvY2NsdXNpb24gcXVlcnk6IHRoZXNlIHF1ZXJpZXMgZGV0ZWN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHZpc2libGUgKHdoZXRoZXIgdGhlIHNjb3BlZCBkcmF3aW5nIGNvbW1hbmRzIHBhc3MgdGhlIGRlcHRoIHRlc3QgYW5kIGlmIHNvLCBob3cgbWFueSBzYW1wbGVzIHBhc3MpLlxuLy8gZ2wuQU5ZX1NBTVBMRVNfUEFTU0VEX0NPTlNFUlZBVElWRSAvLyBTYW1lIGFzIGFib3ZlIGFib3ZlLCBidXQgbGVzcyBhY2N1cmF0ZSBhbmQgZmFzdGVyIHZlcnNpb24uXG4vLyBnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfUFJJTUlUSVZFU19XUklUVEVOIC8vIE51bWJlciBvZiBwcmltaXRpdmVzIHRoYXQgYXJlIHdyaXR0ZW4gdG8gdHJhbnNmb3JtIGZlZWRiYWNrIGJ1ZmZlcnMuXG5cbi8vIGdsLlFVRVJZX1JFU1VMVDogUmV0dXJucyBhIEdMdWludCBjb250YWluaW5nIHRoZSBxdWVyeSByZXN1bHQuXG4vLyBnbC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFOiBSZXR1cm5zIGEgR0xib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYSBxdWVyeSByZXN1bHQgaXMgYXZhaWxhYmxlLlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSB7XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKGdsKSB7XG4gICAgcmV0dXJuIGlzV2ViR0wyQ29udGV4dChnbCk7XG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7V2ViR0wyQ29udGV4dH0gZ2xcbiAgICpcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICBhc3NlcnRXZWJHTDJDb250ZXh0KGdsKTtcbiAgICBjb25zdCBoYW5kbGUgPSBnbC5jcmVhdGVRdWVyeSgpO1xuICAgIGdsQ2hlY2tFcnJvcihnbCk7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcblxuICAgIC8vIHF1ZXJ5IG1hbmFnZXIgbmVlZHMgYSBwcm9taXNlIGZpZWxkXG4gICAgdGhpcy5wcm9taXNlID0gbnVsbDtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLypcbiAgICogQHJldHVybiB7UXVlcnl9IHJldHVybnMgc2VsZiB0byBlbmFibGUgY2hhaW5pbmdcbiAgICpcbiAgZGVsZXRlKCkge1xuICAgIHF1ZXJ5TWFuYWdlci5kZWxldGVRdWVyeSh0aGlzKTtcbiAgICBpZiAodGhpcy5oYW5kbGUpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUXVlcnkodGhpcy5oYW5kbGUpO1xuICAgICAgdGhpcy5oYW5kbGUgPSBudWxsO1xuICAgICAgZ2xDaGVja0Vycm9yKHRoaXMuZ2wpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qXG4gICAqIEByZXR1cm4ge1F1ZXJ5fSByZXR1cm5zIHNlbGYgdG8gZW5hYmxlIGNoYWluaW5nXG4gICAqXG4gIGJlZ2luKHRhcmdldCkge1xuICAgIHF1ZXJ5TWFuYWdlci5iZWdpblF1ZXJ5KHRoaXMpO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuZ2wuYmVnaW5RdWVyeSh0YXJnZXQsIHRoaXMuaGFuZGxlKTtcbiAgICBnbENoZWNrRXJyb3IodGhpcy5nbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKlxuICAgKiBAcmV0dXJuIHtRdWVyeX0gcmV0dXJucyBzZWxmIHRvIGVuYWJsZSBjaGFpbmluZ1xuICAgKlxuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmdsLmVuZFF1ZXJ5KHRoaXMudGFyZ2V0KTtcbiAgICAgIGdsQ2hlY2tFcnJvcih0aGlzLmdsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5lbmQoKTtcbiAgICBxdWVyeU1hbmFnZXIuY2FuY2VsUXVlcnkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpc1Jlc3VsdEF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRRdWVyeVBhcmFtZXRlcih0aGlzLmhhbmRsZSxcbiAgICAgIHRoaXMuZ2wuUVVFUllfUkVTVUxUX0FWQUlMQkxFKTtcbiAgfVxuXG4gIGdldFJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRRdWVyeVBhcmFtZXRlcih0aGlzLmhhbmRsZSwgdGhpcy5nbC5RVUVSWV9SRVNVTFQpO1xuICB9XG5cbiAgc3RhdGljIHBvbGwoZ2wpIHtcbiAgICBxdWVyeU1hbmFnZXIucG9sbChnbCk7XG4gIH1cbn1cbiovXG4iXX0=

/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl_texture__ = __webpack_require__(21);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// import GL from './api';

// import {isWebGl2Context, assertWebGL2Context, withParameters} from './context';

// import Buffer from './buffer';

var Texture2DArray = function (_Texture) {
  _inherits(Texture2DArray, _Texture);

  _createClass(Texture2DArray, null, [{
    key: 'isSupported',
    value: function isSupported(gl) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__context__["b" /* isWebGL2Context */])(gl) || gl.getExtension('OES_vertex_array_object');
    }
  }]);

  function Texture2DArray(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Texture2DArray);

    var _this = _possibleConstructorReturn(this, (Texture2DArray.__proto__ || Object.getPrototypeOf(Texture2DArray)).call(this, gl, opts));

    throw new Error('Texture2DArray not yet implemented');
    return _this;
  }

  return Texture2DArray;
}(__WEBPACK_IMPORTED_MODULE_1__webgl_texture__["a" /* default */]);

/* unused harmony default export */ var _unused_webpack_default_export = (Texture2DArray);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90ZXh0dXJlLTJkLWFycmF5LmpzIl0sIm5hbWVzIjpbImlzV2ViR0wyQ29udGV4dCIsIlRleHR1cmUiLCJUZXh0dXJlMkRBcnJheSIsImdsIiwiZ2V0RXh0ZW5zaW9uIiwib3B0cyIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsU0FBUUEsZUFBUixRQUE4QixXQUE5QjtBQUNBO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixrQkFBcEI7QUFDQTs7SUFFcUJDLGM7Ozs7O2dDQUNBQyxFLEVBQUk7QUFDckIsYUFBT0gsZ0JBQWdCRyxFQUFoQixLQUF1QkEsR0FBR0MsWUFBSCxDQUFnQix5QkFBaEIsQ0FBOUI7QUFDRDs7O0FBRUQsMEJBQVlELEVBQVosRUFBMkI7QUFBQSxRQUFYRSxJQUFXLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsZ0lBQ25CRixFQURtQixFQUNmRSxJQURlOztBQUV6QixVQUFNLElBQUlDLEtBQUosQ0FBVSxvQ0FBVixDQUFOO0FBRnlCO0FBRzFCOzs7RUFSeUNMLE87O2VBQXZCQyxjIiwiZmlsZSI6InRleHR1cmUtMmQtYXJyYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgR0wgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHtpc1dlYkdMMkNvbnRleHR9IGZyb20gJy4vY29udGV4dCc7XG4vLyBpbXBvcnQge2lzV2ViR2wyQ29udGV4dCwgYXNzZXJ0V2ViR0wyQ29udGV4dCwgd2l0aFBhcmFtZXRlcnN9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuLi93ZWJnbC90ZXh0dXJlJztcbi8vIGltcG9ydCBCdWZmZXIgZnJvbSAnLi9idWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlMkRBcnJheSBleHRlbmRzIFRleHR1cmUge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoZ2wpIHtcbiAgICByZXR1cm4gaXNXZWJHTDJDb250ZXh0KGdsKSB8fCBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihnbCwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoZ2wsIG9wdHMpO1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZTJEQXJyYXkgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_texture__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__buffer__ = __webpack_require__(28);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Texture3D = function (_Texture) {
  _inherits(Texture3D, _Texture);

  _createClass(Texture3D, null, [{
    key: 'isSupported',
    value: function isSupported(gl) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["b" /* isWebGL2Context */])(gl) || gl.getExtension('OES_vertex_array_object');
    }

    /**
     * @classdesc
     * 3D WebGL Texture
     * Note: Constructor will initialize your texture.
     *
     * @class
     * @param {WebGLRenderingContext} gl - gl context
     * @param {Image|ArrayBuffer|null} opts= - named options
     * @param {Image|ArrayBuffer|null} opts.data= - buffer
     * @param {GLint} width - width of texture
     * @param {GLint} height - height of texture
     */

  }]);

  function Texture3D(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Texture3D);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["d" /* assertWebGL2Context */])(gl);

    var _this = _possibleConstructorReturn(this, (Texture3D.__proto__ || Object.getPrototypeOf(Texture3D)).call(this, gl, Object.assign({}, opts, { target: opts.target || __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].TEXTURE_3D })));

    _this.width = null;
    _this.height = null;
    _this.depth = null;
    Object.seal(_this);

    _this.setImageData(opts);
    if (opts.generateMipmap) {
      _this.generateMipmap();
    }
    return _this;
  }

  _createClass(Texture3D, [{
    key: 'initialize',
    value: function initialize() {
      var _this2 = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.opts = Object.assign({}, this.opts, opts);
      var _opts = this.opts,
          pixels = _opts.pixels,
          settings = _opts.settings;

      if (settings) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__context__["j" /* withParameters */])(settings, function () {
          if (pixels) {
            _this2.setImage3D(_this2.opts);
          }
        });
        this.setParameters(opts);
      }
    }

    // WebGL2

    // Image 3D copies from Typed Array or WebGLBuffer

  }, {
    key: 'setImage3D',
    value: function setImage3D(_ref) {
      var _ref$level = _ref.level,
          level = _ref$level === undefined ? 0 : _ref$level,
          _ref$internalformat = _ref.internalformat,
          internalformat = _ref$internalformat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref$internalformat,
          width = _ref.width,
          height = _ref.height,
          _ref$depth = _ref.depth,
          depth = _ref$depth === undefined ? 1 : _ref$depth,
          _ref$border = _ref.border,
          border = _ref$border === undefined ? 0 : _ref$border,
          format = _ref.format,
          _ref$type = _ref.type,
          type = _ref$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref$type,
          _ref$offset = _ref.offset,
          offset = _ref$offset === undefined ? 0 : _ref$offset,
          pixels = _ref.pixels;

      if (ArrayBuffer.isView(pixels)) {
        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, pixels);
        return;
      }
      if (pixels instanceof __WEBPACK_IMPORTED_MODULE_3__buffer__["a" /* default */]) {
        this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, pixels.handle);
        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, offset);
        this.gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, pixels.handle);
      }
    }
  }, {
    key: '_setImage2DFromBuffer',
    value: function _setImage2DFromBuffer(_ref2) {
      var buffer = _ref2.buffer,
          _ref2$offset = _ref2.offset,
          offset = _ref2$offset === undefined ? 0 : _ref2$offset,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? null : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? null : _ref2$height,
          _ref2$mipmapLevel = _ref2.mipmapLevel,
          mipmapLevel = _ref2$mipmapLevel === undefined ? 0 : _ref2$mipmapLevel,
          _ref2$internalFormat = _ref2.internalFormat,
          internalFormat = _ref2$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref2$internalFormat,
          _ref2$format = _ref2.format,
          format = _ref2$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref2$format,
          _ref2$type = _ref2.type,
          type = _ref2$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref2$type,
          _ref2$border = _ref2.border,
          border = _ref2$border === undefined ? 0 : _ref2$border;
      var gl = this.gl;

      // This signature of texImage2D uses currently bound GL_PIXEL_UNPACK_BUFFER

      gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].PIXEL_UNPACK_BUFFER, buffer.target);
      // And as always, we must also bind the texture itself
      this.bind();

      gl.texImage2D(gl.TEXTURE_2D, mipmapLevel, format, width, height, border, format, type, buffer.target);

      this.unbind();
      gl.bindBuffer(__WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].GL_PIXEL_UNPACK_BUFFER, null);
      return this;
    }
  }, {
    key: 'setImageDataFromCompressedBuffer',
    value: function setImageDataFromCompressedBuffer(_ref3) {
      var buffer = _ref3.buffer,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === undefined ? 0 : _ref3$offset,
          _ref3$width = _ref3.width,
          width = _ref3$width === undefined ? null : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === undefined ? null : _ref3$height,
          _ref3$mipmapLevel = _ref3.mipmapLevel,
          mipmapLevel = _ref3$mipmapLevel === undefined ? 0 : _ref3$mipmapLevel,
          _ref3$internalFormat = _ref3.internalFormat,
          internalFormat = _ref3$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref3$internalFormat,
          _ref3$format = _ref3.format,
          format = _ref3$format === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref3$format,
          _ref3$type = _ref3.type,
          type = _ref3$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref3$type,
          _ref3$border = _ref3.border,
          border = _ref3$border === undefined ? 0 : _ref3$border;
      var gl = this.gl;

      gl.compressedTexImage2D(this.target, mipmapLevel, internalFormat, width, height, border, buffer);
      // gl.compressedTexSubImage2D(target,
      //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);
      return this;
    }

    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     */
    // TODO - include loop, move to framebuffer?

  }, {
    key: 'copyImageFromFramebuffer',
    value: function copyImageFromFramebuffer(_ref4) {
      var framebuffer = _ref4.framebuffer,
          _ref4$offset = _ref4.offset,
          offset = _ref4$offset === undefined ? 0 : _ref4$offset,
          x = _ref4.x,
          y = _ref4.y,
          width = _ref4.width,
          height = _ref4.height,
          _ref4$mipmapLevel = _ref4.mipmapLevel,
          mipmapLevel = _ref4$mipmapLevel === undefined ? 0 : _ref4$mipmapLevel,
          _ref4$internalFormat = _ref4.internalFormat,
          internalFormat = _ref4$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref4$internalFormat,
          _ref4$type = _ref4.type,
          type = _ref4$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref4$type,
          _ref4$border = _ref4.border,
          border = _ref4$border === undefined ? 0 : _ref4$border;
      var gl = this.gl;

      framebuffer.bind();

      // target
      this.bind();
      gl.copyTexImage2D(this.target, mipmapLevel, internalFormat, x, y, width, height, border);
      this.unbind();

      framebuffer.unbind();
    }
  }, {
    key: 'copySubImage',
    value: function copySubImage(_ref5) {
      // if (pixels instanceof ArrayBufferView) {
      //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);
      // }
      // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);
      // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);
      // // Additional signature in a WebGL 2 context:
      // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);

      var pixels = _ref5.pixels,
          _ref5$offset = _ref5.offset,
          offset = _ref5$offset === undefined ? 0 : _ref5$offset,
          x = _ref5.x,
          y = _ref5.y,
          width = _ref5.width,
          height = _ref5.height,
          _ref5$mipmapLevel = _ref5.mipmapLevel,
          mipmapLevel = _ref5$mipmapLevel === undefined ? 0 : _ref5$mipmapLevel,
          _ref5$internalFormat = _ref5.internalFormat,
          internalFormat = _ref5$internalFormat === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].RGBA : _ref5$internalFormat,
          _ref5$type = _ref5.type,
          type = _ref5$type === undefined ? __WEBPACK_IMPORTED_MODULE_0__api__["a" /* default */].UNSIGNED_BYTE : _ref5$type,
          _ref5$border = _ref5.border,
          border = _ref5$border === undefined ? 0 : _ref5$border;
    }
  }]);

  return Texture3D;
}(__WEBPACK_IMPORTED_MODULE_2__webgl_texture__["a" /* default */]);

/* unused harmony default export */ var _unused_webpack_default_export = (Texture3D);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90ZXh0dXJlLTNkLmpzIl0sIm5hbWVzIjpbIkdMIiwiaXNXZWJHTDJDb250ZXh0IiwiYXNzZXJ0V2ViR0wyQ29udGV4dCIsIndpdGhQYXJhbWV0ZXJzIiwiVGV4dHVyZSIsIkJ1ZmZlciIsIlRleHR1cmUzRCIsImdsIiwiZ2V0RXh0ZW5zaW9uIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsIlRFWFRVUkVfM0QiLCJ3aWR0aCIsImhlaWdodCIsImRlcHRoIiwic2VhbCIsInNldEltYWdlRGF0YSIsImdlbmVyYXRlTWlwbWFwIiwicGl4ZWxzIiwic2V0dGluZ3MiLCJzZXRJbWFnZTNEIiwic2V0UGFyYW1ldGVycyIsImxldmVsIiwiaW50ZXJuYWxmb3JtYXQiLCJSR0JBIiwiYm9yZGVyIiwiZm9ybWF0IiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJvZmZzZXQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInRleEltYWdlM0QiLCJiaW5kQnVmZmVyIiwiUElYRUxfVU5QQUNLX0JVRkZFUiIsImhhbmRsZSIsImJ1ZmZlciIsIm1pcG1hcExldmVsIiwiaW50ZXJuYWxGb3JtYXQiLCJiaW5kIiwidGV4SW1hZ2UyRCIsIlRFWFRVUkVfMkQiLCJ1bmJpbmQiLCJHTF9QSVhFTF9VTlBBQ0tfQlVGRkVSIiwiY29tcHJlc3NlZFRleEltYWdlMkQiLCJmcmFtZWJ1ZmZlciIsIngiLCJ5IiwiY29weVRleEltYWdlMkQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsT0FBT0EsRUFBUCxNQUFlLE9BQWY7QUFDQSxTQUFRQyxlQUFSLEVBQXlCQyxtQkFBekIsRUFBOENDLGNBQTlDLFFBQW1FLFdBQW5FO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixrQkFBcEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFVBQW5COztJQUVxQkMsUzs7Ozs7Z0NBRUFDLEUsRUFBSTtBQUNyQixhQUFPTixnQkFBZ0JNLEVBQWhCLEtBQXVCQSxHQUFHQyxZQUFI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SUFBWjs7QUFFQTtBQUNBLFdBQUtBLElBQUw7QUFDQWxDLFNBQUcyQyxjQUFILENBQ0UsS0FBS3RDLE1BRFAsRUFDZTJCLFdBRGYsRUFDNEJDLGNBRDVCLEVBQzRDUSxDQUQ1QyxFQUMrQ0MsQ0FEL0MsRUFDa0RuQyxLQURsRCxFQUN5REMsTUFEekQsRUFDaUVZLE1BRGpFO0FBRUEsV0FBS2lCLE1BQUw7O0FBRUFHLGtCQUFZSCxNQUFaO0FBQ0Q7Ozt3Q0FhRTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQyxVQVZEeEIsTUFVQyxTQVZEQSxNQVVDO0FBQUEsK0JBVERXLE1BU0M7QUFBQSxVQVREQSxNQVNDLGdDQVRRLENBU1I7QUFBQSxVQVJEaUIsQ0FRQyxTQVJEQSxDQVFDO0FBQUEsVUFQREMsQ0FPQyxTQVBEQSxDQU9DO0FBQUEsVUFORG5DLEtBTUMsU0FOREEsS0FNQztBQUFBLFVBTERDLE1BS0MsU0FMREEsTUFLQztBQUFBLG9DQUpEd0IsV0FJQztBQUFBLFVBSkRBLFdBSUMscUNBSmEsQ0FJYjtBQUFBLHVDQUhEQyxjQUdDO0FBQUEsVUFIREEsY0FHQyx3Q0FIZ0J4QyxHQUFHMEIsSUFHbkI7QUFBQSw2QkFGREcsSUFFQztBQUFBLFVBRkRBLElBRUMsOEJBRk03QixHQUFHOEIsYUFFVDtBQUFBLCtCQURESCxNQUNDO0FBQUEsVUFEREEsTUFDQyxnQ0FEUSxDQUNSO0FBVUY7Ozs7RUE5S29DdkIsTzs7ZUFBbEJFLFMiLCJmaWxlIjoidGV4dHVyZS0zZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHTCBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2lzV2ViR0wyQ29udGV4dCwgYXNzZXJ0V2ViR0wyQ29udGV4dCwgd2l0aFBhcmFtZXRlcnN9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuLi93ZWJnbC90ZXh0dXJlJztcbmltcG9ydCBCdWZmZXIgZnJvbSAnLi9idWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlM0QgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICBzdGF0aWMgaXNTdXBwb3J0ZWQoZ2wpIHtcbiAgICByZXR1cm4gaXNXZWJHTDJDb250ZXh0KGdsKSB8fCBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiAzRCBXZWJHTCBUZXh0dXJlXG4gICAqIE5vdGU6IENvbnN0cnVjdG9yIHdpbGwgaW5pdGlhbGl6ZSB5b3VyIHRleHR1cmUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBnbCBjb250ZXh0XG4gICAqIEBwYXJhbSB7SW1hZ2V8QXJyYXlCdWZmZXJ8bnVsbH0gb3B0cz0gLSBuYW1lZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7SW1hZ2V8QXJyYXlCdWZmZXJ8bnVsbH0gb3B0cy5kYXRhPSAtIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMaW50fSB3aWR0aCAtIHdpZHRoIG9mIHRleHR1cmVcbiAgICogQHBhcmFtIHtHTGludH0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRleHR1cmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzID0ge30pIHtcbiAgICBhc3NlcnRXZWJHTDJDb250ZXh0KGdsKTtcbiAgICBzdXBlcihnbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge3RhcmdldDogb3B0cy50YXJnZXQgfHwgR0wuVEVYVFVSRV8zRH0pKTtcblxuICAgIHRoaXMud2lkdGggPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLmRlcHRoID0gbnVsbDtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcblxuICAgIHRoaXMuc2V0SW1hZ2VEYXRhKG9wdHMpO1xuICAgIGlmIChvcHRzLmdlbmVyYXRlTWlwbWFwKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwKCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpO1xuICAgIGNvbnN0IHtwaXhlbHMsIHNldHRpbmdzfSA9IHRoaXMub3B0cztcbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIHdpdGhQYXJhbWV0ZXJzKHNldHRpbmdzLCAoKSA9PiB7XG4gICAgICAgIGlmIChwaXhlbHMpIHtcbiAgICAgICAgICB0aGlzLnNldEltYWdlM0QodGhpcy5vcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFBhcmFtZXRlcnMob3B0cyk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2ViR0wyXG5cbiAgLy8gSW1hZ2UgM0QgY29waWVzIGZyb20gVHlwZWQgQXJyYXkgb3IgV2ViR0xCdWZmZXJcbiAgc2V0SW1hZ2UzRCh7XG4gICAgbGV2ZWwgPSAwLFxuICAgIGludGVybmFsZm9ybWF0ID0gR0wuUkdCQSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZGVwdGggPSAxLFxuICAgIGJvcmRlciA9IDAsXG4gICAgZm9ybWF0LFxuICAgIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFLFxuICAgIG9mZnNldCA9IDAsXG4gICAgcGl4ZWxzXG4gIH0pIHtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBpeGVscykpIHtcbiAgICAgIHRoaXMuZ2wudGV4SW1hZ2UzRChcbiAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgIGxldmVsLCBpbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGJvcmRlciwgZm9ybWF0LCB0eXBlLCBwaXhlbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGl4ZWxzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIoR0wuUElYRUxfVU5QQUNLX0JVRkZFUiwgcGl4ZWxzLmhhbmRsZSk7XG4gICAgICB0aGlzLmdsLnRleEltYWdlM0QoXG4gICAgICAgIHRoaXMudGFyZ2V0LFxuICAgICAgICBsZXZlbCwgaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcihHTC5QSVhFTF9VTlBBQ0tfQlVGRkVSLCBwaXhlbHMuaGFuZGxlKTtcbiAgICB9XG4gIH1cblxuICBfc2V0SW1hZ2UyREZyb21CdWZmZXIoe1xuICAgIGJ1ZmZlcixcbiAgICBvZmZzZXQgPSAwLFxuICAgIHdpZHRoID0gbnVsbCxcbiAgICBoZWlnaHQgPSBudWxsLFxuICAgIG1pcG1hcExldmVsID0gMCxcbiAgICBpbnRlcm5hbEZvcm1hdCA9IEdMLlJHQkEsXG4gICAgZm9ybWF0ID0gR0wuUkdCQSxcbiAgICB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICBib3JkZXIgPSAwXG4gIH0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcblxuICAgIC8vIFRoaXMgc2lnbmF0dXJlIG9mIHRleEltYWdlMkQgdXNlcyBjdXJyZW50bHkgYm91bmQgR0xfUElYRUxfVU5QQUNLX0JVRkZFUlxuICAgIGdsLmJpbmRCdWZmZXIoR0wuUElYRUxfVU5QQUNLX0JVRkZFUiwgYnVmZmVyLnRhcmdldCk7XG4gICAgLy8gQW5kIGFzIGFsd2F5cywgd2UgbXVzdCBhbHNvIGJpbmQgdGhlIHRleHR1cmUgaXRzZWxmXG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsXG4gICAgICBtaXBtYXBMZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgYnVmZmVyLnRhcmdldCk7XG5cbiAgICB0aGlzLnVuYmluZCgpO1xuICAgIGdsLmJpbmRCdWZmZXIoR0wuR0xfUElYRUxfVU5QQUNLX0JVRkZFUiwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbWFnZURhdGFGcm9tQ29tcHJlc3NlZEJ1ZmZlcih7XG4gICAgYnVmZmVyLFxuICAgIG9mZnNldCA9IDAsXG4gICAgd2lkdGggPSBudWxsLFxuICAgIGhlaWdodCA9IG51bGwsXG4gICAgbWlwbWFwTGV2ZWwgPSAwLFxuICAgIGludGVybmFsRm9ybWF0ID0gR0wuUkdCQSxcbiAgICBmb3JtYXQgPSBHTC5SR0JBLFxuICAgIHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFLFxuICAgIGJvcmRlciA9IDBcbiAgfSkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzO1xuICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRoaXMudGFyZ2V0LFxuICAgICAgbWlwbWFwTGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGJ1ZmZlcik7XG4gICAgLy8gZ2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQodGFyZ2V0LFxuICAgIC8vICAgbGV2ZWwsIHhvZmZzZXQsIHlvZmZzZXQsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgQXJyYXlCdWZmZXJWaWV3PyBwaXhlbHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSB0d28tZGltZW5zaW9uYWwgdGV4dHVyZSBpbWFnZSBvciBjdWJlLW1hcCB0ZXh0dXJlIGltYWdlIHdpdGhcbiAgICogcGl4ZWxzIGZyb20gdGhlIGN1cnJlbnQgZnJhbWVidWZmZXIgKHJhdGhlciB0aGFuIGZyb20gY2xpZW50IG1lbW9yeSkuXG4gICAqIChnbC5jb3B5VGV4SW1hZ2UyRCB3cmFwcGVyKVxuICAgKi9cbiAgLy8gVE9ETyAtIGluY2x1ZGUgbG9vcCwgbW92ZSB0byBmcmFtZWJ1ZmZlcj9cbiAgY29weUltYWdlRnJvbUZyYW1lYnVmZmVyKHtcbiAgICBmcmFtZWJ1ZmZlcixcbiAgICBvZmZzZXQgPSAwLFxuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWlwbWFwTGV2ZWwgPSAwLFxuICAgIGludGVybmFsRm9ybWF0ID0gR0wuUkdCQSxcbiAgICB0eXBlID0gR0wuVU5TSUdORURfQllURSxcbiAgICBib3JkZXIgPSAwXG4gIH0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcbiAgICBmcmFtZWJ1ZmZlci5iaW5kKCk7XG5cbiAgICAvLyB0YXJnZXRcbiAgICB0aGlzLmJpbmQoKTtcbiAgICBnbC5jb3B5VGV4SW1hZ2UyRChcbiAgICAgIHRoaXMudGFyZ2V0LCBtaXBtYXBMZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJvcmRlcik7XG4gICAgdGhpcy51bmJpbmQoKTtcblxuICAgIGZyYW1lYnVmZmVyLnVuYmluZCgpO1xuICB9XG5cbiAgY29weVN1YkltYWdlKHtcbiAgICBwaXhlbHMsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1pcG1hcExldmVsID0gMCxcbiAgICBpbnRlcm5hbEZvcm1hdCA9IEdMLlJHQkEsXG4gICAgdHlwZSA9IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgYm9yZGVyID0gMFxuICB9KSB7XG4gICAgLy8gaWYgKHBpeGVscyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldykge1xuICAgIC8vICAgZ2wudGV4U3ViSW1hZ2UyRCh0YXJnZXQsIGxldmVsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHBpeGVscyk7XG4gICAgLy8gfVxuICAgIC8vIGdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeCwgeSwgZm9ybWF0LCB0eXBlLCA/IHBpeGVscyk7XG4gICAgLy8gZ2wudGV4U3ViSW1hZ2UyRCh0YXJnZXQsIGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIEhUTUxJbWFnZUVsZW1lbnQgcGl4ZWxzKTtcbiAgICAvLyBnbC50ZXhTdWJJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgSFRNTENhbnZhc0VsZW1lbnQgcGl4ZWxzKTtcbiAgICAvLyBnbC50ZXhTdWJJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgSFRNTFZpZGVvRWxlbWVudCBwaXhlbHMpO1xuICAgIC8vIC8vIEFkZGl0aW9uYWwgc2lnbmF0dXJlIGluIGEgV2ViR0wgMiBjb250ZXh0OlxuICAgIC8vIGdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeCwgeSwgZm9ybWF0LCB0eXBlLCBHTGludHB0ciBvZmZzZXQpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getPrimitiveCount */
/* unused harmony export getVertexCount */
/* unused harmony export getTransformFeedbackMode */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_constants__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resource__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__context__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assert__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var GL_TRANSFORM_FEEDBACK_BUFFER = 0;
var GL_TRANSFORM_FEEDBACK = 0;

var TranformFeedback = function (_Resource) {
  _inherits(TranformFeedback, _Resource);

  _createClass(TranformFeedback, null, [{
    key: 'isSupported',
    value: function isSupported(gl) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__context__["b" /* isWebGL2Context */])(gl) || gl.getExtension('OES_vertex_array_object');
    }
  }, {
    key: 'isHandle',
    value: function isHandle(handle) {
      return this.gl.isTransformFeedback(this.handle);
    }

    /**
     * @class
     * @param {WebGL2RenderingContext} gl - context
     * @param {Object} opts - options
     */

  }]);

  function TranformFeedback(gl, opts) {
    _classCallCheck(this, TranformFeedback);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__context__["d" /* assertWebGL2Context */])(gl);

    var _this = _possibleConstructorReturn(this, (TranformFeedback.__proto__ || Object.getPrototypeOf(TranformFeedback)).call(this, gl, opts));

    Object.seal(_this);
    return _this;
  }

  // bindBuffers(varyingMap = {}, buffers = {}, bufferOffsets = {}) {
  //   for (const bufferName in buffers) {
  //     const buffer = buffers[bufferName];
  //     const varying = varyingMap[bufferName];
  //     const bufferOffset = bufferOffsets[];
  //     assert(varying);
  //     this.bindBuffer(Object.assign({buffer}, varying));
  //   }
  // }

  _createClass(TranformFeedback, [{
    key: 'bindBuffer',
    value: function bindBuffer(_ref) {
      var index = _ref.index,
          buffer = _ref.buffer,
          _ref$offset = _ref.offset,
          offset = _ref$offset === undefined ? 0 : _ref$offset,
          size = _ref.size;

      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      if (size === undefined) {
        this.gl.bindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, index, buffer.handle);
      } else {
        this.gl.bindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER, index, buffer.handle, offset, size);
      }
    }
  }, {
    key: 'unbindBuffer',
    value: function unbindBuffer(_ref2) {
      var index = _ref2.index;

      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      this.gl.bindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, index, null);
    }
  }, {
    key: 'begin',
    value: function begin(primitiveMode) {
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      this.gl.pauseTransformFeedback();
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, null);
      return this;
    }
  }, {
    key: 'resume',
    value: function resume() {
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      this.gl.resumeTransformFeedback();
      return this;
    }
  }, {
    key: 'end',
    value: function end() {
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
      this.gl.endTransformFeedback();
      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, null);
      return this;
    }

    // PRIVATE METHODS

  }, {
    key: '_createHandle',
    value: function _createHandle() {
      return this.gl.createTransformFeedback();
    }
  }, {
    key: '_deleteHandle',
    value: function _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
  }]);

  return TranformFeedback;
}(__WEBPACK_IMPORTED_MODULE_1__resource__["a" /* default */]);

// Counts the number of complete "primitives" given a number of vertices and a drawMode


/* unused harmony default export */ var _unused_webpack_default_export = (TranformFeedback);
function getPrimitiveCount(_ref3) {
  var drawMode = _ref3.drawMode,
      vertexCount = _ref3.vertexCount,
      countVertices = _ref3.countVertices;

  switch (drawMode) {
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POINTS:
      return vertexCount;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES:
      return vertexCount / 2;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_STRIP:
      return vertexCount - 1;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_LOOP:
      return vertexCount;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES:
      return vertexCount / 3;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_STRIP:
      return vertexCount - 2;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_FAN:
      return vertexCount - 2;
    default:
      __WEBPACK_IMPORTED_MODULE_3_assert___default()(false);return 0;
  }
}

// Counts the number of vertices after splitting the vertex stream into separate "primitives"
function getVertexCount(_ref4) {
  var drawMode = _ref4.drawMode,
      vertexCount = _ref4.vertexCount;

  var primitiveCount = getPrimitiveCount({ drawMode: drawMode, vertexCount: vertexCount });
  switch (drawMode) {
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POINTS:
      return primitiveCount;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES:
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_STRIP:
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_LOOP:
      return vertexCount * 2;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES:
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_STRIP:
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_FAN:
      return vertexCount * 3;
    default:
      __WEBPACK_IMPORTED_MODULE_3_assert___default()(false);return 0;
  }
}

// Counts the number of complete primitives given a number of vertices and a drawMode
function getTransformFeedbackMode(_ref5) {
  var drawMode = _ref5.drawMode;

  switch (drawMode) {
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POINTS:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].POINTS;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_STRIP:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINE_LOOP:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].LINES;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_STRIP:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES;
    case __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLE_FAN:
      return __WEBPACK_IMPORTED_MODULE_0__gl_constants__["a" /* default */].TRIANGLES;
    default:
      __WEBPACK_IMPORTED_MODULE_3_assert___default()(false);return 0;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC90cmFuc2Zvcm0tZmVlZGJhY2suanMiXSwibmFtZXMiOlsiR0wiLCJSZXNvdXJjZSIsImlzV2ViR0wyQ29udGV4dCIsImFzc2VydFdlYkdMMkNvbnRleHQiLCJhc3NlcnQiLCJHTF9UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIiwiR0xfVFJBTlNGT1JNX0ZFRURCQUNLIiwiVHJhbmZvcm1GZWVkYmFjayIsImdsIiwiZ2V0RXh0ZW5zaW9uIiwiaGFuZGxlIiwiaXNUcmFuc2Zvcm1GZWVkYmFjayIsIm9wdHMiLCJPYmplY3QiLCJzZWFsIiwiaW5kZXgiLCJidWZmZXIiLCJvZmZzZXQiLCJzaXplIiwiYmluZFRyYW5zZm9ybUZlZWRiYWNrIiwidW5kZWZpbmVkIiwiYmluZEJ1ZmZlckJhc2UiLCJiaW5kQnVmZmVyUmFuZ2UiLCJwcmltaXRpdmVNb2RlIiwiYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayIsInBhdXNlVHJhbnNmb3JtRmVlZGJhY2siLCJyZXN1bWVUcmFuc2Zvcm1GZWVkYmFjayIsImVuZFRyYW5zZm9ybUZlZWRiYWNrIiwiY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2siLCJkZWxldGVUcmFuc2Zvcm1GZWVkYmFjayIsImdldFByaW1pdGl2ZUNvdW50IiwiZHJhd01vZGUiLCJ2ZXJ0ZXhDb3VudCIsImNvdW50VmVydGljZXMiLCJQT0lOVFMiLCJMSU5FUyIsIkxJTkVfU1RSSVAiLCJMSU5FX0xPT1AiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsImdldFZlcnRleENvdW50IiwicHJpbWl0aXZlQ291bnQiLCJnZXRUcmFuc2Zvcm1GZWVkYmFja01vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsT0FBT0EsRUFBUCxNQUFlLGdCQUFmO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixZQUFyQjtBQUNBLFNBQVFDLGVBQVIsRUFBeUJDLG1CQUF6QixRQUFtRCxXQUFuRDtBQUNBLE9BQU9DLE1BQVAs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QUFBUzVCLGFBQU8sS0FBUCxFQUFlLE9BQU8sQ0FBUDtBQVh4QjtBQWFEOztBQUVEO0FBQ0EsT0FBTyxTQUFTdUMsd0JBQVQsUUFBOEM7QUFBQSxNQUFYWixRQUFXLFNBQVhBLFFBQVc7O0FBQ25ELFVBQVFBLFFBQVI7QUFDQSxTQUFLL0IsR0FBR2tDLE1BQVI7QUFBZ0IsYUFBT2xDLEdBQUdrQyxNQUFWO0FBQ2hCLFNBQUtsQyxHQUFHbUMsS0FBUjtBQUFlLGFBQU9uQyxHQUFHbUMsS0FBVjtBQUNmLFNBQUtuQyxHQUFHb0MsVUFBUjtBQUFvQixhQUFPcEMsR0FBR21DLEtBQVY7QUFDcEIsU0FBS25DLEdBQUdxQyxTQUFSO0FBQW1CLGFBQU9yQyxHQUFHbUMsS0FBVjtBQUNuQixTQUFLbkMsR0FBR3NDLFNBQVI7QUFBbUIsYUFBT3RDLEdBQUdzQyxTQUFWO0FBQ25CLFNBQUt0QyxHQUFHdUMsY0FBUjtBQUF3QixhQUFPdkMsR0FBR3NDLFNBQVY7QUFDeEIsU0FBS3RDLEdBQUd3QyxZQUFSO0FBQXNCLGFBQU94QyxHQUFHc0MsU0FBVjtBQUN0QjtBQUFTbEMsYUFBTyxLQUFQLEVBQWUsT0FBTyxDQUFQO0FBUnhCO0FBVUQiLCJmaWxlIjoidHJhbnNmb3JtLWZlZWRiYWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdMIGZyb20gJy4vZ2wtY29uc3RhbnRzJztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL3Jlc291cmNlJztcbmltcG9ydCB7aXNXZWJHTDJDb250ZXh0LCBhc3NlcnRXZWJHTDJDb250ZXh0fSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBHTF9UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSID0gMDtcbmNvbnN0IEdMX1RSQU5TRk9STV9GRUVEQkFDSyA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5mb3JtRmVlZGJhY2sgZXh0ZW5kcyBSZXNvdXJjZSB7XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKGdsKSB7XG4gICAgcmV0dXJuIGlzV2ViR0wyQ29udGV4dChnbCkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuICB9XG5cbiAgc3RhdGljIGlzSGFuZGxlKGhhbmRsZSkge1xuICAgIHJldHVybiB0aGlzLmdsLmlzVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5oYW5kbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIC0gY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzKSB7XG4gICAgYXNzZXJ0V2ViR0wyQ29udGV4dChnbCk7XG4gICAgc3VwZXIoZ2wsIG9wdHMpO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLy8gYmluZEJ1ZmZlcnModmFyeWluZ01hcCA9IHt9LCBidWZmZXJzID0ge30sIGJ1ZmZlck9mZnNldHMgPSB7fSkge1xuICAvLyAgIGZvciAoY29uc3QgYnVmZmVyTmFtZSBpbiBidWZmZXJzKSB7XG4gIC8vICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2J1ZmZlck5hbWVdO1xuICAvLyAgICAgY29uc3QgdmFyeWluZyA9IHZhcnlpbmdNYXBbYnVmZmVyTmFtZV07XG4gIC8vICAgICBjb25zdCBidWZmZXJPZmZzZXQgPSBidWZmZXJPZmZzZXRzW107XG4gIC8vICAgICBhc3NlcnQodmFyeWluZyk7XG4gIC8vICAgICB0aGlzLmJpbmRCdWZmZXIoT2JqZWN0LmFzc2lnbih7YnVmZmVyfSwgdmFyeWluZykpO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIGJpbmRCdWZmZXIoe2luZGV4LCBidWZmZXIsIG9mZnNldCA9IDAsIHNpemV9KSB7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLmhhbmRsZSk7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyQmFzZShHTF9UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpbmRleCwgYnVmZmVyLmhhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlclJhbmdlKEdMX1RSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIGluZGV4LCBidWZmZXIuaGFuZGxlLCBvZmZzZXQsIHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHVuYmluZEJ1ZmZlcih7aW5kZXh9KSB7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyQmFzZShHTF9UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpbmRleCwgbnVsbCk7XG4gIH1cblxuICBiZWdpbihwcmltaXRpdmVNb2RlKSB7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5iZWdpblRyYW5zZm9ybUZlZWRiYWNrKHByaW1pdGl2ZU1vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5wYXVzZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICB0aGlzLmdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhHTF9UUkFOU0ZPUk1fRkVFREJBQ0ssIHRoaXMuaGFuZGxlKTtcbiAgICB0aGlzLmdsLnJlc3VtZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlbmQoKSB7XG4gICAgdGhpcy5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soR0xfVFJBTlNGT1JNX0ZFRURCQUNLLCB0aGlzLmhhbmRsZSk7XG4gICAgdGhpcy5nbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICAgIHRoaXMuZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKEdMX1RSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICBfY3JlYXRlSGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gIH1cblxuICBfZGVsZXRlSGFuZGxlKCkge1xuICAgIHRoaXMuZ2wuZGVsZXRlVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5oYW5kbGUpO1xuICB9XG59XG5cbi8vIENvdW50cyB0aGUgbnVtYmVyIG9mIGNvbXBsZXRlIFwicHJpbWl0aXZlc1wiIGdpdmVuIGEgbnVtYmVyIG9mIHZlcnRpY2VzIGFuZCBhIGRyYXdNb2RlXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJpbWl0aXZlQ291bnQoe2RyYXdNb2RlLCB2ZXJ0ZXhDb3VudCwgY291bnRWZXJ0aWNlc30pIHtcbiAgc3dpdGNoIChkcmF3TW9kZSkge1xuICBjYXNlIEdMLlBPSU5UUzogcmV0dXJuIHZlcnRleENvdW50O1xuICBjYXNlIEdMLkxJTkVTOiByZXR1cm4gdmVydGV4Q291bnQgLyAyO1xuICBjYXNlIEdMLkxJTkVfU1RSSVA6IHJldHVybiB2ZXJ0ZXhDb3VudCAtIDE7XG4gIGNhc2UgR0wuTElORV9MT09QOiByZXR1cm4gdmVydGV4Q291bnQ7XG4gIGNhc2UgR0wuVFJJQU5HTEVTOiByZXR1cm4gdmVydGV4Q291bnQgLyAzO1xuICBjYXNlIEdMLlRSSUFOR0xFX1NUUklQOiByZXR1cm4gdmVydGV4Q291bnQgLSAyO1xuICBjYXNlIEdMLlRSSUFOR0xFX0ZBTjogcmV0dXJuIHZlcnRleENvdW50IC0gMjtcbiAgZGVmYXVsdDogYXNzZXJ0KGZhbHNlKTsgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgYWZ0ZXIgc3BsaXR0aW5nIHRoZSB2ZXJ0ZXggc3RyZWFtIGludG8gc2VwYXJhdGUgXCJwcmltaXRpdmVzXCJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0ZXhDb3VudCh7ZHJhd01vZGUsIHZlcnRleENvdW50fSkge1xuICBjb25zdCBwcmltaXRpdmVDb3VudCA9IGdldFByaW1pdGl2ZUNvdW50KHtkcmF3TW9kZSwgdmVydGV4Q291bnR9KTtcbiAgc3dpdGNoIChkcmF3TW9kZSkge1xuICBjYXNlIEdMLlBPSU5UUzpcbiAgICByZXR1cm4gcHJpbWl0aXZlQ291bnQ7XG4gIGNhc2UgR0wuTElORVM6XG4gIGNhc2UgR0wuTElORV9TVFJJUDpcbiAgY2FzZSBHTC5MSU5FX0xPT1A6XG4gICAgcmV0dXJuIHZlcnRleENvdW50ICogMjtcbiAgY2FzZSBHTC5UUklBTkdMRVM6XG4gIGNhc2UgR0wuVFJJQU5HTEVfU1RSSVA6XG4gIGNhc2UgR0wuVFJJQU5HTEVfRkFOOlxuICAgIHJldHVybiB2ZXJ0ZXhDb3VudCAqIDM7XG4gIGRlZmF1bHQ6IGFzc2VydChmYWxzZSk7IHJldHVybiAwO1xuICB9XG59XG5cbi8vIENvdW50cyB0aGUgbnVtYmVyIG9mIGNvbXBsZXRlIHByaW1pdGl2ZXMgZ2l2ZW4gYSBudW1iZXIgb2YgdmVydGljZXMgYW5kIGEgZHJhd01vZGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1GZWVkYmFja01vZGUoe2RyYXdNb2RlfSkge1xuICBzd2l0Y2ggKGRyYXdNb2RlKSB7XG4gIGNhc2UgR0wuUE9JTlRTOiByZXR1cm4gR0wuUE9JTlRTO1xuICBjYXNlIEdMLkxJTkVTOiByZXR1cm4gR0wuTElORVM7XG4gIGNhc2UgR0wuTElORV9TVFJJUDogcmV0dXJuIEdMLkxJTkVTO1xuICBjYXNlIEdMLkxJTkVfTE9PUDogcmV0dXJuIEdMLkxJTkVTO1xuICBjYXNlIEdMLlRSSUFOR0xFUzogcmV0dXJuIEdMLlRSSUFOR0xFUztcbiAgY2FzZSBHTC5UUklBTkdMRV9TVFJJUDogcmV0dXJuIEdMLlRSSUFOR0xFUztcbiAgY2FzZSBHTC5UUklBTkdMRV9GQU46IHJldHVybiBHTC5UUklBTkdMRVM7XG4gIGRlZmF1bHQ6IGFzc2VydChmYWxzZSk7IHJldHVybiAwO1xuICB9XG59XG4iXX0=

/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _UNIFORM_TYPES;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable camelcase */


var ERR_ARGUMENT = 'UniformBufferLayout illegal argument';

// Local constants - these will "collapse" during minification
var GL_INT = 0x1404;
var GL_UNSIGNED_INT = 0x1405;
var GL_FLOAT = 0x1406;

var GL_FLOAT_VEC2 = 0x8B50;
var GL_FLOAT_VEC3 = 0x8B51;
var GL_FLOAT_VEC4 = 0x8B52;
var GL_INT_VEC2 = 0x8B53;
var GL_INT_VEC3 = 0x8B54;
var GL_INT_VEC4 = 0x8B55;

var GL_BOOL = 0x8B56;
var GL_BOOL_VEC2 = 0x8B57;
var GL_BOOL_VEC3 = 0x8B58;
var GL_BOOL_VEC4 = 0x8B59;

var GL_FLOAT_MAT2 = 0x8B5A;
var GL_FLOAT_MAT3 = 0x8B5B;
var GL_FLOAT_MAT4 = 0x8B5C;

var GL_UNSIGNED_INT_VEC2 = 0x8DC6;
var GL_UNSIGNED_INT_VEC3 = 0x8DC7;
var GL_UNSIGNED_INT_VEC4 = 0x8DC8;

var GL_FLOAT_MAT2x3 = 0x8B65;
var GL_FLOAT_MAT2x4 = 0x8B66;
var GL_FLOAT_MAT3x2 = 0x8B67;
var GL_FLOAT_MAT3x4 = 0x8B68;
var GL_FLOAT_MAT4x2 = 0x8B69;
var GL_FLOAT_MAT4x3 = 0x8B6A;

// Uniform table for std140
var UNIFORM_TYPES = (_UNIFORM_TYPES = {}, _defineProperty(_UNIFORM_TYPES, GL_FLOAT, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_INT, [GL_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC2, [GL_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC3, [GL_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC4, [GL_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_BOOL, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16]), _UNIFORM_TYPES);

// Std140 layout for uniforms

var UniformBufferLayout = function () {
  function UniformBufferLayout(layout) {
    var _typedArray;

    _classCallCheck(this, UniformBufferLayout);

    this.layout = {};
    this.size = 0;

    // Add layout (type, size and offset) definitions for each uniform in the layout
    for (var key in layout) {
      this._addUniform(key, layout[key]);
    }

    // Allocate three typed arrays pointing at same memory
    var data = new Float32Array(this.size);
    this.typedArray = (_typedArray = {}, _defineProperty(_typedArray, GL_FLOAT, data), _defineProperty(_typedArray, GL_INT, new Int32Array(data.buffer)), _defineProperty(_typedArray, GL_UNSIGNED_INT, new Uint32Array(data.buffer)), _typedArray);
  }

  // Get number of bytes needed for buffer allocation


  _createClass(UniformBufferLayout, [{
    key: 'getBytes',
    value: function getBytes() {
      return this.size * 4;
    }

    // Get the current data as Float32Array, for bufferSubData

  }, {
    key: 'getData',
    value: function getData() {
      return this.typedArray[GL_FLOAT];
    }

    // Get offset and data for one object (for bufferSubData)

  }, {
    key: 'getSubData',
    value: function getSubData(index) {
      var data = void 0;
      var offset = void 0;
      if (index === undefined) {
        data = this.data;
        offset = 0;
      } else {
        var begin = this.offsets[index];
        var end = begin + this.sizes[index];
        data = this.data.subarray(begin, end);
        offset = begin * 4;
      }
      return { data: data, offset: offset };
    }

    // Set a map of values

  }, {
    key: 'setUniforms',
    value: function setUniforms(values) {
      for (var key in values) {
        this._setValue(key, values[key]);
      }
      return this;
    }
  }, {
    key: '_setValue',
    value: function _setValue(key, value) {
      var layout = this.layout[key];
      __WEBPACK_IMPORTED_MODULE_0_assert___default()(layout, 'UniformLayoutStd140 illegal argument');
      var typedArray = this.typedArray[layout.type];
      if (layout.size === 1) {
        // single value -> just set it
        typedArray[layout.offset] = value;
      } else {
        // vector/matrix -> copy the supplied (typed) array, starting from offset
        typedArray.set(value, layout.offset);
      }
    }
  }, {
    key: '_addUniform',
    value: function _addUniform(key, uniformType) {
      var definition = UNIFORM_TYPES[uniformType];
      __WEBPACK_IMPORTED_MODULE_0_assert___default()(definition, ERR_ARGUMENT);

      var _definition = _slicedToArray(definition, 2),
          type = _definition[0],
          count = _definition[1];

      // Get the current offset and calculate the next offset based on aligned size of this element


      var offset = this.size;
      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)
      this.size = this._alignTo(this.size, count);
      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset
      this.size += count;

      this.layout[key] = { type: type, size: count, offset: offset };
    }

    // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)

  }, {
    key: '_alignTo',
    value: function _alignTo(size, count) {
      switch (count) {
        case 1:
          return size; // Pad upwards to even multiple of 2
        case 2:
          return size + size % 2; // Pad upwards to even multiple of 2
        default:
          return size + (4 - size % 4) % 4; // Pad upwards to even multiple of 4
      }
    }
  }]);

  return UniformBufferLayout;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (UniformBufferLayout);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJnbC91bmlmb3JtLWJ1ZmZlci1sYXlvdXQuanMiXSwibmFtZXMiOlsiYXNzZXJ0IiwiRVJSX0FSR1VNRU5UIiwiR0xfSU5UIiwiR0xfVU5TSUdORURfSU5UIiwiR0xfRkxPQVQiLCJHTF9GTE9BVF9WRUMyIiwiR0xfRkxPQVRfVkVDMyIsIkdMX0ZMT0FUX1ZFQzQiLCJHTF9JTlRfVkVDMiIsIkdMX0lOVF9WRUMzIiwiR0xfSU5UX1ZFQzQiLCJHTF9CT09MIiwiR0xfQk9PTF9WRUMyIiwiR0xfQk9PTF9WRUMzIiwiR0xfQk9PTF9WRUM0IiwiR0xfRkxPQVRfTUFUMiIsIkdMX0ZMT0FUX01BVDMiLCJHTF9GTE9BVF9NQVQ0IiwiR0xfVU5TSUdORURfSU5UX1ZFQzIiLCJHTF9VTlNJR05FRF9JTlRfVkVDMyIsIkdMX1VOU0lHTkVEX0lOVF9WRUM0IiwiR0xfRkxPQVRfTUFUMngzIiwiR0xfRkxPQVRfTUFUMng0IiwiR0xfRkxPQVRfTUFUM3gyIiwiR0xfRkxPQVRfTUFUM3g0IiwiR0xfRkxPQVRfTUFUNHgyIiwiR0xfRkxPQVRfTUFUNHgzIiwiVU5JRk9STV9UWVBFUyIsIlVuaWZvcm1CdWZmZXJMYXlvdXQiLCJsYXlvdXQiLCJzaXplIiwia2V5IiwiX2FkZFVuaWZvcm0iLCJkYXRhIiwiRmxvYXQzMkFycmF5IiwidHlwZWRBcnJheSIsIkludDMyQXJyYXkiLCJidWZmZXIiLCJVaW50MzJBcnJheSIsImluZGV4Iiwib2Zmc2V0IiwidW5kZWZpbmVkIiwiYmVnaW4iLCJvZmZzZXRzIiwiZW5kIiwic2l6ZXMiLCJzdWJhcnJheSIsInZhbHVlcyIsIl9zZXRWYWx1ZSIsInZhbHVlIiwidHlwZSIsInNldCIsInVuaWZvcm1UeXBlIiwiZGVmaW5pdGlvbiIsImNvdW50IiwiX2FsaWduVG8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsSUFBTUMsZUFBZSxzQ0FBckI7O0FBRUE7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QU94QixJQUFQLENBRFIsQ0FDcUI7QUFDckIsYUFBSyxDQUFMO0FBQVEsaUJBQU9BLE9BQU9BLE9BQU8sQ0FBckIsQ0FGUixDQUVnQztBQUNoQztBQUFTLGlCQUFPQSxPQUFPLENBQUMsSUFBSUEsT0FBTyxDQUFaLElBQWlCLENBQS9CLENBSFQsQ0FHMkM7QUFIM0M7QUFLRDs7Ozs7O2VBeEZrQkYsbUIiLCJmaWxlIjoidW5pZm9ybS1idWZmZXItbGF5b3V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdVbmlmb3JtQnVmZmVyTGF5b3V0IGlsbGVnYWwgYXJndW1lbnQnO1xuXG4vLyBMb2NhbCBjb25zdGFudHMgLSB0aGVzZSB3aWxsIFwiY29sbGFwc2VcIiBkdXJpbmcgbWluaWZpY2F0aW9uXG5jb25zdCBHTF9JTlQgPSAweDE0MDQ7XG5jb25zdCBHTF9VTlNJR05FRF9JTlQgPSAweDE0MDU7XG5jb25zdCBHTF9GTE9BVCA9IDB4MTQwNjtcblxuY29uc3QgR0xfRkxPQVRfVkVDMiA9IDB4OEI1MDtcbmNvbnN0IEdMX0ZMT0FUX1ZFQzMgPSAweDhCNTE7XG5jb25zdCBHTF9GTE9BVF9WRUM0ID0gMHg4QjUyO1xuY29uc3QgR0xfSU5UX1ZFQzIgPSAweDhCNTM7XG5jb25zdCBHTF9JTlRfVkVDMyA9IDB4OEI1NDtcbmNvbnN0IEdMX0lOVF9WRUM0ID0gMHg4QjU1O1xuXG5jb25zdCBHTF9CT09MID0gMHg4QjU2O1xuY29uc3QgR0xfQk9PTF9WRUMyID0gMHg4QjU3O1xuY29uc3QgR0xfQk9PTF9WRUMzID0gMHg4QjU4O1xuY29uc3QgR0xfQk9PTF9WRUM0ID0gMHg4QjU5O1xuXG5jb25zdCBHTF9GTE9BVF9NQVQyID0gMHg4QjVBO1xuY29uc3QgR0xfRkxPQVRfTUFUMyA9IDB4OEI1QjtcbmNvbnN0IEdMX0ZMT0FUX01BVDQgPSAweDhCNUM7XG5cbmNvbnN0IEdMX1VOU0lHTkVEX0lOVF9WRUMyID0gMHg4REM2O1xuY29uc3QgR0xfVU5TSUdORURfSU5UX1ZFQzMgPSAweDhEQzc7XG5jb25zdCBHTF9VTlNJR05FRF9JTlRfVkVDNCA9IDB4OERDODtcblxuY29uc3QgR0xfRkxPQVRfTUFUMngzID0gMHg4QjY1O1xuY29uc3QgR0xfRkxPQVRfTUFUMng0ID0gMHg4QjY2O1xuY29uc3QgR0xfRkxPQVRfTUFUM3gyID0gMHg4QjY3O1xuY29uc3QgR0xfRkxPQVRfTUFUM3g0ID0gMHg4QjY4O1xuY29uc3QgR0xfRkxPQVRfTUFUNHgyID0gMHg4QjY5O1xuY29uc3QgR0xfRkxPQVRfTUFUNHgzID0gMHg4QjZBO1xuXG4vLyBVbmlmb3JtIHRhYmxlIGZvciBzdGQxNDBcbmNvbnN0IFVOSUZPUk1fVFlQRVMgPSB7XG4gIC8vIE5vIHNhbXBsZXJzIGluIHVuaWZvcm0gYmxvY2tzXG5cbiAgW0dMX0ZMT0FUXTogW0dMX0ZMT0FULCAxXSxcbiAgW0dMX0ZMT0FUX1ZFQzJdOiBbR0xfRkxPQVQsIDJdLFxuICBbR0xfRkxPQVRfVkVDM106IFtHTF9GTE9BVCwgM10sXG4gIFtHTF9GTE9BVF9WRUM0XTogW0dMX0ZMT0FULCA0XSxcblxuICBbR0xfSU5UXTogW0dMX0lOVCwgMV0sXG4gIFtHTF9JTlRfVkVDMl06IFtHTF9JTlQsIDJdLFxuICBbR0xfSU5UX1ZFQzNdOiBbR0xfSU5ULCAzXSxcbiAgW0dMX0lOVF9WRUM0XTogW0dMX0lOVCwgNF0sXG5cbiAgW0dMX1VOU0lHTkVEX0lOVF06IFtHTF9VTlNJR05FRF9JTlQsIDFdLFxuICBbR0xfVU5TSUdORURfSU5UX1ZFQzJdOiBbR0xfVU5TSUdORURfSU5ULCAyXSxcbiAgW0dMX1VOU0lHTkVEX0lOVF9WRUMzXTogW0dMX1VOU0lHTkVEX0lOVCwgM10sXG4gIFtHTF9VTlNJR05FRF9JTlRfVkVDNF06IFtHTF9VTlNJR05FRF9JTlQsIDRdLFxuXG4gIFtHTF9CT09MXTogW0dMX0ZMT0FULCAxXSxcbiAgW0dMX0JPT0xfVkVDMl06IFtHTF9GTE9BVCwgMl0sXG4gIFtHTF9CT09MX1ZFQzNdOiBbR0xfRkxPQVQsIDNdLFxuICBbR0xfQk9PTF9WRUM0XTogW0dMX0ZMT0FULCA0XSxcblxuICBbR0xfRkxPQVRfTUFUMl06IFtHTF9GTE9BVCwgOF0sIC8vIDRcbiAgW0dMX0ZMT0FUX01BVDJ4M106IFtHTF9GTE9BVCwgOF0sIC8vIDZcbiAgW0dMX0ZMT0FUX01BVDJ4NF06IFtHTF9GTE9BVCwgOF0sIC8vIDhcblxuICBbR0xfRkxPQVRfTUFUM106IFtHTF9GTE9BVCwgMTJdLCAvLyA5XG4gIFtHTF9GTE9BVF9NQVQzeDJdOiBbR0xfRkxPQVQsIDEyXSwgLy8gNlxuICBbR0xfRkxPQVRfTUFUM3g0XTogW0dMX0ZMT0FULCAxMl0sIC8vIDEyXG5cbiAgW0dMX0ZMT0FUX01BVDRdOiBbR0xfRkxPQVQsIDE2XSwgLy8gMTZcbiAgW0dMX0ZMT0FUX01BVDR4Ml06IFtHTF9GTE9BVCwgMTZdLCAvLyA4XG4gIFtHTF9GTE9BVF9NQVQ0eDNdOiBbR0xfRkxPQVQsIDE2XSAvLyAxMlxufTtcblxuLy8gU3RkMTQwIGxheW91dCBmb3IgdW5pZm9ybXNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaWZvcm1CdWZmZXJMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICB0aGlzLmxheW91dCA9IHt9O1xuICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICAvLyBBZGQgbGF5b3V0ICh0eXBlLCBzaXplIGFuZCBvZmZzZXQpIGRlZmluaXRpb25zIGZvciBlYWNoIHVuaWZvcm0gaW4gdGhlIGxheW91dFxuICAgIGZvciAoY29uc3Qga2V5IGluIGxheW91dCkge1xuICAgICAgdGhpcy5fYWRkVW5pZm9ybShrZXksIGxheW91dFtrZXldKTtcbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSB0aHJlZSB0eXBlZCBhcnJheXMgcG9pbnRpbmcgYXQgc2FtZSBtZW1vcnlcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnNpemUpO1xuICAgIHRoaXMudHlwZWRBcnJheSA9IHtcbiAgICAgIFtHTF9GTE9BVF06IGRhdGEsXG4gICAgICBbR0xfSU5UXTogbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIpLFxuICAgICAgW0dMX1VOU0lHTkVEX0lOVF06IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlcilcbiAgICB9O1xuICB9XG5cbiAgLy8gR2V0IG51bWJlciBvZiBieXRlcyBuZWVkZWQgZm9yIGJ1ZmZlciBhbGxvY2F0aW9uXG4gIGdldEJ5dGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgKiA0O1xuICB9XG5cbiAgLy8gR2V0IHRoZSBjdXJyZW50IGRhdGEgYXMgRmxvYXQzMkFycmF5LCBmb3IgYnVmZmVyU3ViRGF0YVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVkQXJyYXlbR0xfRkxPQVRdO1xuICB9XG5cbiAgLy8gR2V0IG9mZnNldCBhbmQgZGF0YSBmb3Igb25lIG9iamVjdCAoZm9yIGJ1ZmZlclN1YkRhdGEpXG4gIGdldFN1YkRhdGEoaW5kZXgpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLm9mZnNldHNbaW5kZXhdO1xuICAgICAgY29uc3QgZW5kID0gYmVnaW4gKyB0aGlzLnNpemVzW2luZGV4XTtcbiAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gICAgICBvZmZzZXQgPSBiZWdpbiAqIDQ7XG4gICAgfVxuICAgIHJldHVybiB7ZGF0YSwgb2Zmc2V0fTtcbiAgfVxuXG4gIC8vIFNldCBhIG1hcCBvZiB2YWx1ZXNcbiAgc2V0VW5pZm9ybXModmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICB0aGlzLl9zZXRWYWx1ZShrZXksIHZhbHVlc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0W2tleV07XG4gICAgYXNzZXJ0KGxheW91dCwgJ1VuaWZvcm1MYXlvdXRTdGQxNDAgaWxsZWdhbCBhcmd1bWVudCcpO1xuICAgIGNvbnN0IHR5cGVkQXJyYXkgPSB0aGlzLnR5cGVkQXJyYXlbbGF5b3V0LnR5cGVdO1xuICAgIGlmIChsYXlvdXQuc2l6ZSA9PT0gMSkge1xuICAgICAgLy8gc2luZ2xlIHZhbHVlIC0+IGp1c3Qgc2V0IGl0XG4gICAgICB0eXBlZEFycmF5W2xheW91dC5vZmZzZXRdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHZlY3Rvci9tYXRyaXggLT4gY29weSB0aGUgc3VwcGxpZWQgKHR5cGVkKSBhcnJheSwgc3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgICAgIHR5cGVkQXJyYXkuc2V0KHZhbHVlLCBsYXlvdXQub2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBfYWRkVW5pZm9ybShrZXksIHVuaWZvcm1UeXBlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IFVOSUZPUk1fVFlQRVNbdW5pZm9ybVR5cGVdO1xuICAgIGFzc2VydChkZWZpbml0aW9uLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IFt0eXBlLCBjb3VudF0gPSBkZWZpbml0aW9uO1xuXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IG9mZnNldCBhbmQgY2FsY3VsYXRlIHRoZSBuZXh0IG9mZnNldCBiYXNlZCBvbiBhbGlnbmVkIHNpemUgb2YgdGhpcyBlbGVtZW50XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5zaXplO1xuICAgIC8vIEZpcnN0LCBhbGlnbiAoYnVtcCkgY3VycmVudCBvZmZzZXQgdG8gYW4gZXZlbiBtdWx0aXBsZSBvZiBjdXJyZW50IG9iamVjdCAoMSwgMiwgNClcbiAgICB0aGlzLnNpemUgPSB0aGlzLl9hbGlnblRvKHRoaXMuc2l6ZSwgY291bnQpO1xuICAgIC8vIFRoZW4sIGFkZCBvdXIgb2JqZWN0J3MgcGFkZGVkIHNpemUgKCgxLCAyLCBtdWx0aXBsZSBvZiA0KSB0byB0aGUgY3VycmVudCBvZmZzZXRcbiAgICB0aGlzLnNpemUgKz0gY291bnQ7XG5cbiAgICB0aGlzLmxheW91dFtrZXldID0ge3R5cGUsIHNpemU6IGNvdW50LCBvZmZzZXR9O1xuICB9XG5cbiAgLy8gQWxpZ24gb2Zmc2V0IHRvIDEsIDIgb3IgNCBlbGVtZW50cyAoNCwgOCBvciAxNiBieXRlcylcbiAgX2FsaWduVG8oc2l6ZSwgY291bnQpIHtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gc2l6ZTsgLy8gUGFkIHVwd2FyZHMgdG8gZXZlbiBtdWx0aXBsZSBvZiAyXG4gICAgY2FzZSAyOiByZXR1cm4gc2l6ZSArIHNpemUgJSAyOyAvLyBQYWQgdXB3YXJkcyB0byBldmVuIG11bHRpcGxlIG9mIDJcbiAgICBkZWZhdWx0OiByZXR1cm4gc2l6ZSArICg0IC0gc2l6ZSAlIDQpICUgNDsgLy8gUGFkIHVwd2FyZHMgdG8gZXZlbiBtdWx0aXBsZSBvZiA0XG4gICAgfVxuICB9XG59XG4iXX0=

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = {
	"_args": [
		[
			{
				"raw": "luma.gl",
				"scope": null,
				"escapedName": "luma.gl",
				"name": "luma.gl",
				"rawSpec": "",
				"spec": "latest",
				"type": "tag"
			},
			"D:\\tomcat7\\webapps\\echartsMapbox"
		]
	],
	"_from": "luma.gl@latest",
	"_id": "luma.gl@4.0.0-alpha.5",
	"_inCache": true,
	"_location": "/luma.gl",
	"_nodeVersion": "7.10.0",
	"_npmOperationalInternal": {
		"host": "s3://npm-registry-packages",
		"tmp": "tmp/luma.gl-4.0.0-alpha.5.tgz_1495661813835_0.7454762586858124"
	},
	"_npmUser": {
		"name": "apercu",
		"email": "bgronon@gmail.com"
	},
	"_npmVersion": "4.2.0",
	"_phantomChildren": {},
	"_requested": {
		"raw": "luma.gl",
		"scope": null,
		"escapedName": "luma.gl",
		"name": "luma.gl",
		"rawSpec": "",
		"spec": "latest",
		"type": "tag"
	},
	"_requiredBy": [
		"#USER",
		"/"
	],
	"_resolved": "https://registry.npmjs.org/luma.gl/-/luma.gl-4.0.0-alpha.5.tgz",
	"_shasum": "7bbc81b6e1d89256622d0316bef7d2fcc77cdac7",
	"_shrinkwrap": null,
	"_spec": "luma.gl",
	"_where": "D:\\tomcat7\\webapps\\echartsMapbox",
	"babel": {
		"presets": [
			[
				"es2015",
				{
					"modules": false
				}
			]
		],
		"env": {
			"test": {
				"plugins": [
					"istanbul"
				]
			}
		}
	},
	"bugs": {
		"url": "https://github.com/uber/luma.gl/issues"
	},
	"contributors": [
		{
			"name": "Ib Green",
			"email": "ib@uber.com"
		},
		{
			"name": "Nicolas Belmonte",
			"email": "nico@uber.com"
		},
		{
			"name": "Rye Terrell"
		},
		{
			"name": "Shan He",
			"email": "shan@uber.com"
		},
		{
			"name": "Mikola Lysenko"
		},
		{
			"name": "Wesam Manassra",
			"email": "manassra@uber.com"
		}
	],
	"dependencies": {
		"gl-constants": "^1.0.0",
		"gl-matrix": "^2.3.2",
		"seer": "^0.1.0",
		"webgl-debug": "^1.0.2"
	},
	"description": "A WebGL JavaScript visualization library.",
	"devDependencies": {
		"babel-cli": "^6.18",
		"babel-core": "^6.18",
		"babel-eslint": "^6.0.0",
		"babel-plugin-istanbul": "^4.1.1",
		"babel-plugin-transform-builtin-extend": "^1.1.0",
		"babel-preset-es2015": "^6.18",
		"babelify": "^7.2.0",
		"benchmark": "^2.1.4",
		"brfs-babel": "^1.0.0",
		"browserify": "^13.0.0",
		"buble": "^0.15.1",
		"buble-loader": "^0.4.0",
		"coveralls": "^2.13.0",
		"disc": "^1.3.2",
		"electron-prebuilt": "^0.37.2",
		"eslint": "^3.0",
		"eslint-config-uber-es2015": "^3.0.0",
		"eslint-config-uber-jsx": "^3.0.0",
		"eslint-plugin-babel": "^4.0.0",
		"eslint-plugin-react": "~6.7.0",
		"faucet": "0.0.1",
		"gl": "^4.0.2",
		"mkdirp": "^0.5.1",
		"module-alias": "^2.0.0",
		"nyc": "^10.2.0",
		"pre-commit": "^1.2.2",
		"raw-loader": "^0.5.1",
		"reify": "^0.4.4",
		"source-map-support": "^0.4.2",
		"tap-browser-color": "^0.1.2",
		"tape": "^4.6.3",
		"tape-catch": "^1.0.4",
		"tape-promise": "^1.1.0",
		"testron": "^1.2.0",
		"webpack-dev-server": "^2.4.4"
	},
	"directories": {},
	"dist": {
		"shasum": "7bbc81b6e1d89256622d0316bef7d2fcc77cdac7",
		"tarball": "https://registry.npmjs.org/luma.gl/-/luma.gl-4.0.0-alpha.5.tgz"
	},
	"files": [
		"src",
		"dist",
		"dist-es6",
		"headless.js"
	],
	"gitHead": "92e55d505b09b9bd17508f1066d13c806810838b",
	"homepage": "https://github.com/uber/luma.gl#readme",
	"keywords": [
		"webgl",
		"visualization",
		"animation",
		"3d"
	],
	"license": "MIT",
	"main": "dist/index.js",
	"maintainers": [
		{
			"name": "apercu",
			"email": "bgronon@gmail.com"
		},
		{
			"name": "gnavvy",
			"email": "gnavvy@gmail.com"
		},
		{
			"name": "heshan0131",
			"email": "heshan0131@gmail.com"
		},
		{
			"name": "ibgreen",
			"email": "ib.green.home@gmail.com"
		},
		{
			"name": "pessimistress",
			"email": "cxiaoji@gmail.com"
		},
		{
			"name": "shaojingli",
			"email": "lishaojing@gmail.com"
		}
	],
	"module": "dist-es6/index.js",
	"name": "luma.gl",
	"nyc": {
		"sourceMap": false,
		"instrument": false,
		"include": [
			"src/**/*.js"
		],
		"exclude": [
			"test/**/*.js"
		]
	},
	"optionalDependencies": {},
	"readme": "ERROR: No README data found!",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/uber/luma.gl.git"
	},
	"scripts": {
		"bench": "node test/bench/node.js",
		"bench-browser": "webpack-dev-server --config webpack.config.bench-browser.js --progress --hot --open --port 3011",
		"build": "npm run build-es6 && npm run build-es5",
		"build-buble": "rm -fr dist-buble && mkdir -p dist-buble && buble src -o dist-buble --no modules --y dangerousForOf --objectAssign",
		"build-clean": "rm -fr dist dist-es6 && mkdir -p dist dist-es6 ",
		"build-es5": "rm -fr dist && babel src --out-dir dist --plugins=transform-es2015-modules-commonjs --source-maps inline",
		"build-es6": "rm -fr dist-es6 && babel src --out-dir dist-es6 --source-maps inline",
		"cover": "NODE_ENV=test nyc --reporter html --reporter cobertura --reporter=lcov npm run test-cover",
		"docs": "npm run docs-build && open ./_docs/docs/index.html",
		"docs-build": "rm -fr _docs/* && jekyll build --config=docs/_config.yml --layouts docs/_layouts",
		"docs-gh-pages": "git subtree push --prefix _docs origin gh-pages",
		"docs-gh-pages-force": "git push origin `git subtree split --prefix _docs dev`:gh-pages --force",
		"docs-publish": "npm run docs-build && git add _docs -f && git commit -m 'UPDATE DOCS' --no-verify && npm run docs-gh-pages",
		"lint": "eslint src test && npm run lint-yarn",
		"lint-examples": "eslint examples",
		"lint-yarn": "!(find . -name yarn.lock -exec grep -l unpm.u {} \\; | egrep '.*')",
		"publish-beta": "npm run build && npm run test-fast && npm publish --tag beta",
		"publish-prod": "npm run build && npm run test-fast && npm publish",
		"start": "cat < docs/get-started/examples.md",
		"test": "npm run lint && npm run build && npm run test-node",
		"test-browser": "webpack-dev-server --config webpack.config.test-browser.js --progress --hot --open",
		"test-cover": "NODE_ENV=test tape -r babel-register test/node.js && nyc report",
		"test-fast": "npm run lint && node test/node.js | faucet",
		"test-node": "node test/node.js",
		"test-shader": "npm run build-dist && budo src/test/fp64-shader.spec.js:build/test-bundle.js --dir test --live --open --port 3001 --watch-glob '**/*.{html,css,scss,js,glsl}' -- -t babelify -t brfs-babel"
	},
	"version": "4.0.0-alpha.5"
};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(14);
  var warning = __webpack_require__(11);
  var ReactPropTypesSecret = __webpack_require__(63);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.
var factory = __webpack_require__(118);
module.exports = function(isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(30);
var invariant = __webpack_require__(14);
var ReactPropTypesSecret = __webpack_require__(63);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(23);

var invariant = __webpack_require__(14);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(37);

var ReactChildren = __webpack_require__(267);
var ReactComponent = __webpack_require__(64);
var ReactPureComponent = __webpack_require__(272);
var ReactClass = __webpack_require__(268);
var ReactDOMFactories = __webpack_require__(269);
var ReactElement = __webpack_require__(22);
var ReactPropTypes = __webpack_require__(270);
var ReactVersion = __webpack_require__(273);

var onlyChild = __webpack_require__(275);
var warning = __webpack_require__(11);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var canDefineProperty = __webpack_require__(39);
  var ReactElementValidator = __webpack_require__(121);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function () {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

// TODO: Fix tests so that this deprecation warning doesn't cause failures.
if (process.env.NODE_ENV !== 'production') {
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function () {
        process.env.NODE_ENV !== 'production' ? warning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated. Use ' + 'the prop-types package from npm instead.') : void 0;
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });
  }
}

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(265);
var ReactElement = __webpack_require__(22);

var emptyFunction = __webpack_require__(30);
var traverseAllChildren = __webpack_require__(276);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(23),
    _assign = __webpack_require__(37);

var ReactComponent = __webpack_require__(64);
var ReactElement = __webpack_require__(22);
var ReactPropTypeLocationNames = __webpack_require__(122);
var ReactNoopUpdateQueue = __webpack_require__(66);

var emptyObject = __webpack_require__(48);
var invariant = __webpack_require__(14);
var warning = __webpack_require__(11);

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (process.env.NODE_ENV !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

var didWarnDeprecated = false;

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(didWarnDeprecated, '%s: React.createClass is deprecated and will be removed in version 16. ' + 'Use plain JavaScript classes instead. If you\'re not yet ready to ' + 'migrate, create-react-class is available on npm as a ' + 'drop-in replacement.', spec && spec.displayName || 'A Component') : void 0;
      didWarnDeprecated = true;
    }

    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(22);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(121);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(22),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(262);

module.exports = factory(isValidElement);

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(37);

var ReactComponent = __webpack_require__(64);
var ReactNoopUpdateQueue = __webpack_require__(66);

var emptyObject = __webpack_require__(48);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.5.4';

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(23);

var ReactPropTypeLocationNames = __webpack_require__(122);
var ReactPropTypesSecret = __webpack_require__(271);

var invariant = __webpack_require__(14);
var warning = __webpack_require__(11);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(65);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(65);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(23);

var ReactElement = __webpack_require__(22);

var invariant = __webpack_require__(14);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(23);

var ReactCurrentOwner = __webpack_require__(38);
var REACT_ELEMENT_TYPE = __webpack_require__(120);

var getIteratorFn = __webpack_require__(123);
var invariant = __webpack_require__(14);
var KeyEscapeUtils = __webpack_require__(264);
var warning = __webpack_require__(11);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 277 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 278 */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(278);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(277);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24), __webpack_require__(3)))

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

//Ported to node by Marcin Ignac on 2016-05-20

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {

//polyfill window in node
if (typeof(window) == 'undefined') {
    window = global;
}

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};


/**
 * Which arguments are enums based on the number of arguments to the function.
 * So
 *    'texImage2D': {
 *       9: { 0:true, 2:true, 6:true, 7:true },
 *       6: { 0:true, 2:true, 3:true, 4:true },
 *    },
 *
 * means if there are 9 arguments then 6 and 7 are enums, if there are 6
 * arguments 3 and 4 are enums
 *
 * @type {!Object.<number, !Object.<number, string>}
 */
var glValidEnumContexts = {
  // Generic setters and getters

  'enable': {1: { 0:true }},
  'disable': {1: { 0:true }},
  'getParameter': {1: { 0:true }},

  // Rendering

  'drawArrays': {3:{ 0:true }},
  'drawElements': {4:{ 0:true, 2:true }},

  // Shaders

  'createShader': {1: { 0:true }},
  'getShaderParameter': {2: { 1:true }},
  'getProgramParameter': {2: { 1:true }},
  'getShaderPrecisionFormat': {2: { 0: true, 1:true }},

  // Vertex attributes

  'getVertexAttrib': {2: { 1:true }},
  'vertexAttribPointer': {6: { 2:true }},

  // Textures

  'bindTexture': {2: { 0:true }},
  'activeTexture': {1: { 0:true }},
  'getTexParameter': {2: { 0:true, 1:true }},
  'texParameterf': {3: { 0:true, 1:true }},
  'texParameteri': {3: { 0:true, 1:true, 2:true }},
  'texImage2D': {
     9: { 0:true, 2:true, 6:true, 7:true },
     6: { 0:true, 2:true, 3:true, 4:true }
  },
  'texSubImage2D': {
    9: { 0:true, 6:true, 7:true },
    7: { 0:true, 4:true, 5:true }
  },
  'copyTexImage2D': {8: { 0:true, 2:true }},
  'copyTexSubImage2D': {8: { 0:true }},
  'generateMipmap': {1: { 0:true }},
  'compressedTexImage2D': {7: { 0: true, 2:true }},
  'compressedTexSubImage2D': {8: { 0: true, 6:true }},

  // Buffer objects

  'bindBuffer': {2: { 0:true }},
  'bufferData': {3: { 0:true, 2:true }},
  'bufferSubData': {3: { 0:true }},
  'getBufferParameter': {2: { 0:true, 1:true }},

  // Renderbuffers and framebuffers

  'pixelStorei': {2: { 0:true, 1:true }},
  'readPixels': {7: { 4:true, 5:true }},
  'bindRenderbuffer': {2: { 0:true }},
  'bindFramebuffer': {2: { 0:true }},
  'checkFramebufferStatus': {1: { 0:true }},
  'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},
  'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},
  'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},
  'getRenderbufferParameter': {2: { 0:true, 1:true }},
  'renderbufferStorage': {4: { 0:true, 1:true }},

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},
  'depthFunc': {1: { 0:true }},
  'blendFunc': {2: { 0:true, 1:true }},
  'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},
  'blendEquation': {1: { 0:true }},
  'blendEquationSeparate': {2: { 0:true, 1:true }},
  'stencilFunc': {3: { 0:true }},
  'stencilFuncSeparate': {4: { 0:true, 1:true }},
  'stencilMaskSeparate': {2: { 0:true }},
  'stencilOp': {3: { 0:true, 1:true, 2:true }},
  'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},

  // Culling

  'cullFace': {1: { 0:true }},
  'frontFace': {1: { 0:true }},

  // ANGLE_instanced_arrays extension

  'drawArraysInstancedANGLE': {4: { 0:true }},
  'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},

  // EXT_blend_minmax extension

  'blendEquationEXT': {1: { 0:true }}
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Map of names to numbers.
 * @type {Object}
 */
var enumStringToValue = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    enumStringToValue = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
        enumStringToValue[propertyName] = ctx[propertyName];
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? ("gl." + name) :
      ("/*UNKNOWN WebGL ENUM*/ 0x" + value.toString(16) + "");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} numArgs the number of arguments passed to the function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    var funcInfo = funcInfo[numArgs];
    if (funcInfo !== undefined) {
      if (funcInfo[argumentIndex]) {
        if (typeof funcInfo[argumentIndex] === 'object' &&
            funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {
          var enums = funcInfo[argumentIndex]['enumBitwiseOr'];
          var orResult = 0;
          var orEnums = [];
          for (var i = 0; i < enums.length; ++i) {
            var enumValue = enumStringToValue[enums[i]];
            if ((value & enumValue) !== 0) {
              orResult |= enumValue;
              orEnums.push(glEnumToString(enumValue));
            }
          }
          if (orResult === value) {
            return orEnums.join(' | ');
          } else {
            return glEnumToString(value);
          }
        } else {
          return glEnumToString(value);
        }
      }
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  var numArgs = args.length;
  for (var ii = 0; ii < numArgs; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, numArgs, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 * @param {!WebGLRenderingContext} opt_err_ctx The webgl context
 *        to call getError on if different than ctx.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {
  opt_err_ctx = opt_err_ctx || ctx;
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        var numArgs = args.length;
        for (var ii = 0; ii < numArgs; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, numArgs, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = opt_err_ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
      if (propertyName != 'getExtension') {
        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
      } else {
        var wrapped = makeErrorWrapper(ctx, propertyName);
        wrapper[propertyName] = function () {
          var result = wrapped.apply(ctx, arguments);
          return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);
        };
      }
    } else {
      makePropertyWrapper(wrapper, ctx, propertyName);
    }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if (ctx instanceof WebGLRenderingContext) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    return wrappedContext_;
  }
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} numArgs The number of arguments
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

module.exports = WebGLDebugUtils;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ })
/******/ ]);